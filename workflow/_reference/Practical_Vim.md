《Practical Vim》（《Vim实用技巧》）笔记，参考了[gitig/Practical-Vim-Notes](https://github.com/gitig/Practical-Vim-Notes) 和`中文版 Practical Vim`，加入了一些我的理解和例子, 教程的[写作方式](part0/tip1.markdown)

# 技巧1:  认识`.`命令

### `.`:重复上次修改

### `x`:删除光标所在的字符

### `u`:撤销上次修改

### `dd`: 删除光标所在行

### `>G`:从当前行到最后一行，每行增加一层缩进

1. `>$`:当前行向右缩进一层
2. `><Cr>`: 当前行和其下一行向右缩进一层
> `<Cr>`:回车键
3. `>3<Cr>`: 当前行和其下3行向右缩进一层
4. `>4j`:当前行和其下4行向右缩进一层
5. `>5j`:当前行和其上5行向右缩进一层


## 上下左右移动光标

1. `h`:将光标向左移动一个字符
2. `l`:将光标向右移动一个字符
3. `j`:将光标垂直向下移动一个字符
3. `k`:将光标垂直向上移动一个字符

### 例子:  缩进代码

![tip1](./image/tip1.png)

<div></div>



<br>  

|上一篇|下一篇|
|:---|---:|
|[README](../README.md)  |[技巧2 不要自我重复](tip2.md)|


# 技巧2: 不要自我重复

1. `$`:光标移动到当前行的末尾
2. `I`:在光标所在字符所在行的开头插入内容
3. `i`:在光标所在字符的上一个字符位置插入内容
4. `a`:在光标所在字符的下一个字符位置插入内容
5. `A`:在光标所在字符所在行的结尾插入内容

### 例子:每行结尾插入`;`字符

1. `$a;<Esc>`:光标移动到改行末尾(`$`),在末尾插入(`a`), 插入字符(`;`),退回到普通模式(`<Esc>`) <br>
2. `j$a;<Esc>`:光标移动到下一行(`j`),光标移动到改行末尾(`$`),在末尾插入(`a`), 插入字符(`;`),退回到普通模式(`<Esc>`) <br>
3. `j$a;<Esc>`:光标移动到下一行(`j`),光标移动到改行末尾(`$`),在末尾插入(`a`), 插入字符(`;`),退回到普通模式(`<Esc>`) <br>
4. ...

### 减少无关操作

`A`替代了`$a`的功能，为了减少按键，应该使用`A`,上面的操作变成

> `A;<Esc>`
> `jA;<Esc>`
> `jA;<Esc>`
> ...

### 例子： 每行末尾加上`;`
![tip2](./image/tip2.png)  


<br>  

|上一篇|下一篇|
|:---|---:|
|[Tip1 认识`.`命令](tip1.md)|[Tip3 以退为进](tip3.md)|


# Tip3: 以退为进

> 合理的推出插入模式，使得插入模式操作少，可复用

## `f{char}` 光标跳到当前行当前字符后面第一个`{char}`字符所在位置
1. `f+`光标跳到当前行下一个`+`字符处
2. `F+`光标跳到当前行上一个`+`字符处

## `s`删除光标所在字符并进入插入模式，相当于`xi`

## `;`重复上次`f{char}`指令，跳到下下个`{char}`字符
## `,`反向重复上次`f{char}`指令，跳到上上个`{char}`字符


## 例子：将代码中所有的`+`字符前后加一个空格
![tip3](./image/tip3.png)  


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧2 不要自我重复](tip2.md) |  [技巧4 执行、重复、回退](tip4.md)|


# 技巧4：执行、重复、回退
> 在执行可重复工作时，我们应该让移动和修改尽可能重复，减少按键数量

1. `.`能极大减少按键数量
2. `u`撤销上次的插入操作可能会经常被使用

### 例子: 可重复的操作如何`回退`和`重复`

![tip4](./image/tip4.png)  

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧3 以退为进](tip3.md) |[技巧5 查找并手动替换](tip5.md)|


# 技巧5: 查找并手动替换

## 基本替换指令

#### `:%s/content/copy/g`将文档中所有的`content`字符串替换为`copy`

> 考虑到`content`这个单词有的时候是名词（`内容`），有点时候是（`满足的`）,我们希望有的地方替换成copy，有的地方不替换，由编辑者每次确认是否要替换，该怎么修改指令呢？

### 改进替换指令1：连续查找+有的时候使用替换操作

1. `*`：查找光标所在单词的下一次出现
2. `#`:查找光标所在单词的上一次出现
3. `cw`:删除光标开始的字符直到单词结尾

### 例子：连续查找+有的时候使用替换操作
![tip5](./image/tip5.png)  

### 改进替换指令2：加强基本替换操作

#### `:s%/content/copy/gc`:将文档中的`content`字符串替换为`copy`, 每次替换前由用户确认是否替换


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧4 执行、重复、回退](tip4.md)|[技巧6 结识`.`范式](tip6.md)|


# 技巧6: 结识`.`范式

## 最佳编辑模式: 按一键移动,按另一键执行

### 回顾

> 1. 技巧2: `j`移动到下一行,`.`执行修改(`A;<Esc>`,修改), `j.j.j.j.j.`...

> 2. 技巧3: `;`移动到下一个地方,`.`执行修改(`s + `,将`+`添加左右空格), `;.;.;.`...

> 3. 技巧5: `n.n.n.`...替换


### `.`范式

`.`范式: 用'.'修改,且只需按一次键就能把光标移动到下一个目标


<br>  

|上一篇|下一篇|
|:---|---:|
| [技巧5 查找并手动替换](tip5.md)|  [技巧7 停顿时请移开画笔](../part1_pattern/chapter2_normal_pattern/tip7.md)|


# 技巧7 停顿时请移开画笔

1. 普通模式是 vim 的放松状态
> 好比画家画画,大多数时间画笔不在画布上, vim操作的时候也应该一样: 大多数时间离开修改状态, 进行思考\阅读\在代码中穿梭

2. 普通模式可以直接进行修改,不一定需要进入插入模式

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧6 结识`.`范式](../../part0/tip6.md)| [技巧8 把撤销的单元切成块](tip8.md)|


# 技巧8： 把撤销的单元切成块

## `u`: 撤销上一次操作

> **__一次操作__**:改变文档内文本的任意操作,`i`{insert some text}`<Esc>` 是一次修改

撤销操作可能只是一个字符,可能是一段话, 控制`<Esc>`键的使用可使撤销命令重复作用于单词\句子\段落,这样最好

## `<Esc>o` 好过 `<Cr>`

插入模式中,光标位于行尾, 如果需要另起一行, 有两种方式:

> 1. 直接回车(`<Cr>`)
> 2. 跳出插入模式后在下面新开一行插入(`<Esc>o`)

第二种方法更好: 撤销下一行的时候上一行的修改还在


<br>  

|上一篇|下一篇|
|:---|---:|
|[Tip7 停顿时请移开画笔](tip7.md)| [Tip9 尽量构造可重复的修改](tip9.md)|


# 技巧9 尽量构造可重复的修改

> 1. Vim 的设计对重复操作进行了优化,我们要利用他,尽可能的构造可重复的修改
> 2. 一般认为,按键越少越好, 感兴趣的可以去 [VimGolf](http://vimgolf.com) 练习

## 比较几种删除单词的操作优劣

> 假设光标在单词的末尾(`h`)

### 1. 反向删除单词 `dbx`

![tip9_1](./image/tip9_1.png)  

`db` 删除贯标起始位置到单词开头位置的内容,但不删除光标所在单词, 补一个`x`删除光标所在字符

### 2. 正向删除 `bdw`

![tip9_2](./image/tip9_2.png)  

`b` 跳到光标所在单词开头, `dw` 删除起始位置直到单词结尾的整个单词,包括起始位置


### 3. `daw`

![tip9_3](./image/tip9_3.png)  

`aw` 指一个文本对象, `daw` 理解为 `delete a word`

###  三种删除方式比较

1. `daw` 好!
2. `daw` 可以使用`.` 重复删除单词
3.  `dbx` 之后使用 `.` 等价于 `x`,
4. `bdw` 之后使用`.` 大多数情况没问题
> 但是如果是从文件的最后一个单词删除, 相当于不断`dw`,`dw`,...而此时的word其实是倒数第二个单词的最后一个字符,所以之后按`.`只能删除一个字符,不是一个单词


<br>  

|上一篇|下一篇|
|:---|---:|
| [技巧8 把撤销的单元切换成块](tip8.md)    | [技巧10 用次数做简单的算术运算](tip10.md)|


# 技巧10 用次数做简单的算术运算

> 大多数普通模式命令可以在执行时指定执行次数,利用这个进行算术运算

#### `<C-a>` 将光标所在数字的值增加1,`<C-x>`将光标所在单词减1

> 1. **如果光标所在单词不是数字**,则在当前行向后查找数字,如果找到,则将其加一,否则,不操作
> 2. 有的时候对`007`按`<C-x>`可能得到`010`,是系统将其看成了**八进制** 的数,在vimrc文件中设置 `set nrformats=` 这一行可以让vim对所有数字按十进制考虑

`24<C-a>` 将光标所在数字的值加`24`, `28<C-x>`将光标所在数字值减28

### 例子: 修改CSS代码
> 1. 将news替换成blog
> 2. 将0px替换成-180px

![tip10](./image/tip10.png)  

#### `yyp`: 将当前行复制成两份

等价于 `yy`(先复制当前行) + `p`(再插入到当前行的下方)

#### `cw`: 删除光标所在单词,并进入插入模式

<br>  

|上一篇|下一篇|
|:---|---:|
| [Tip9 尽量构造可重复修改](tip9.md)    | [Tip11 能够重复,就别用次数](tip11.md)|


# 技巧11 能够重复,就别用次数

> 按键少不一定快,用可重复模块(比如`. 范式`)有的时候可能更快)

### 例子:删除一些单词
> 删除成: `delete two words`

![tip11_1](./image/tip11_1.png)  

#### 方法1: `d2w` 或者 `d2W`
> 删除两个单词

#### 方法2: `2dw` 或者 `2dW`
> 做两次(删除一个单词)

#### 方法3: `dw.`
> 删除一个单词,重复做一次

### 三种方法对比
1. 如果是删除6个单词,前两个方法更快: `d6w` vs `6dw` vs `dw.....`
2. 如果单词数很多(10+), 前两者虽然快,但是还要数来数去, `dw....`...所见即所得,反而更好

## 次数风格(`d8w`) vs 重复风格(`dw........`):

1. 在必要时才使用次数
> 次数好? 保证你的字数数的对！数的快! <br>
> ![tip11_2](./image/tip11_2.png)  

2. **因人而异**,选择用的顺手就行

<br>  

|上一篇|下一篇|
|:---|---:|
| [技巧10 用次数做简单的加减法](tip10.md)    | [技巧12 操作+操作符 双剑合璧](tip12.md)|


# 技巧12: 操作+操作符 双剑合璧

#### 操作=操作+操作符

> **操作符**:比如`d`(删除),`y`(复制), `c`(删除并进入插入模式) <br>
> __动作命令__: 操作符的作用范围, 比如`dl`(删除一个字符), `daw`(删除一个单词),`dap`(删除一个段落)

## 大小写转换(`g`)命令,缩进有关操作

![tip12](./image/tip12.png)  


1. `g~`大小写翻转
2. `gU`单词转大写
> 1. `gUaw` 把当前词转换成大写单词
> 2. `gUap` 把当前段落转换成大写单词段落
> 3. `gUgU`, `gUU`把当前行换成大写

3. `gu`单词转小写
4. `>` 选中的行向右缩进一层
> `>>` 或`>$`向右缩进当前行 <br>
> `><Cr>` 当前行和下一行向右缩进

5. `<` 选中的行向左缩进一层
> `<<` 或`<$`向左缩进当前行
6. `=` 选中的行自动对齐
7. `dd` 删除当前行

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧11 能够重复,就别用次数](tip11.md)|[技巧13 在插入模式中回退/撤销](../chapter3_insert_mode/tip13.md)|


# 技巧13: 在插入模式中回退/撤销


### 插入模式中回退
![tip13](./image/tip13.png)  

1. `<C-h>` 回退一个字符(等价于`Backspace`键)
2. `<C-w>` 回退一个单词
3. `<C-u>` 当前行光标前全部删除

#### 回退指令在`shell`中也可以使用


<br>  

|上一篇|下一篇|
|:---|---:|
| [技巧12 操作+操作符双剑合璧](../chapter2_normal_pattern/tip12.md)    | [技巧14 返回普通模式](tip14.md)|


# 技巧14: 返回普通模式

 > 大部分操作应该在普通模式中进行,快速的在普通模式,插入模式直接切换很重要

![tip14](./image/tip14.png)  

1. `<C-[>` == `<Esc>` ,退回到普通模式

### 插入-普通模式

> 有的时候,只想在普通模式下进行一个操作,之后立刻跳回来继续插入模式,该怎么方便的操作?<br>
> **使用插入-普通模式!**

#### `<C-o>` 进入插入普通模式

1. **`<C-o>zz`**:在插入模式中使用`zz`将当前操作行调整至屏幕中间,方便观察下面的行,继续插入操作

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧13 在插入模式中回退/撤销](tip13.md)|[技巧15 不离开插入模式, 粘贴寄存器中的文本](tip15.md)|


# 技巧15: 不离开插入模式, 粘贴寄存器中的文本


#### 建议: 将大小写锁定键(`Caps Lock`)映射成`<Esc>`键

尤其是`<Esc>` 键离的很远的时候
> 转换方法自行google

### 例子: 在插入模式中粘贴

![tip15](./image/tip15.png)  

1. `yt,` 复制光标所在字符串直到字符`,`
> `y/abc` 复制光标所在字符直到遇到字符串`abc`, 比`yt,`更强大

2. `<C-r>0` 将刚刚复制的文本粘贴到光标所在处
> **第10章** 会专门介绍寄存器和复制操作

#### 从寄存器中插入多行文本时,建议退回普通模式插入

1. `<C-r>{register}` 在只插入几个单词时效果最好.
2. 如果插入多行,而且vim设置了`textwidth`或者`autoindent`,则插入结果可能比较乱

> 这个时候可以使用`<C-r><C-p>{register}`来插入本文, 会修正不必要的缩进

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧14 返回普通模式](tip14.md)|[技巧16 随时随地做运算](tip16.md)  |


# 技巧16: 随时随地做运算
> 使用表达式寄存器做运算

1. 大部分Vim`寄存器`保存的都是**文本/字符串**
2. `表达式寄存器`可以执行一个vim脚本,并返回结果
> `=`指明使用表达式寄存器, 插入模式中`<C-r>=`表明使用表达式寄存器


### 例子: 插入模式中计算6*35

![tip16](./image/tip16.png)  


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧15 不离开插入模式, 粘贴寄存器中的文本](tip15.md)|[技巧17 用字符编码插入非常用字符](tip17.md)|


# 技巧17: 用字符编码插入非常用字符

> 1. 如果知道一些特殊字符的编码，可以直接通过输入编码从键盘敲入这些字符，不需要借助外部的输入法或者手动复制粘贴
> 2. atom 编辑器vim-mode不支持

### 例子

![tip17](./image/tip17.png)  

1. `<C-v>{123}` 按16进制插入字符,实际插入的是`{`
2. `<C-v>u{1234}` 按Unicode编码插入字符,实际插入的是`ሴ`
3. `<C-v><Cr>` 之后插入`回车键`本身表达的内容`^M`

#### `ga` 显示光标所在字符的`Ascii码,十进制编码,十六进制编码`



<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧16 随时随地做运算](tip16.md)|[技巧18 用二合字母(digraph)插入非常用字符](tip18.md)|


# 技巧18: 用二合字母(digraph)插入非常用字符
> 不知道ascii码,怎么方便插入`¿` `⅓` `⅔` `⅕` `⅙`

**二合字母**: 成对的字符

#### `<C-k>{char1}{char2}`

1. `<C-k><<` 插入的是 `«`
2. `<C-k>?I` 插入的是 `¿`
3. `<C-k>35` 插入的是 `⅗`

<br>  

|上一篇|下一篇|
|:---|---:|
| [技巧17 用字符编码插入非常用字符](tip17.md)|[技巧19 使用替换模式替换已有文本](tip19.md)|


# 技巧19: 使用替换模式替换已有文本

> 替换模式类似与插入模式,但是每次插入字符的时候覆盖后面的字符

### 例子: 替换文本

> 将 `line. But` 替换成 `line, but`

![tip19](./image/tip19.png)  

1. `R` 进入替换模式,直到`<Esc>`键按下后退出

> `gR` 进入 `虚拟替换模式`:加入`制表符`占4列宽,则在制表符开始时插入前三个不会删除原来的制表符,插入第4个字符后制表符才被替换

2. `r` 替换光标所在 **字符**

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧18 用二合字母(digraph)插入非常用字符](tip18.md)|[技巧20 深入理解可视模式](../chapter4_visual_mode/tip20.md)|


# 技巧20: 深入理解可视模式
> 可是模式允许在选中的区域内操作

### `viw` 普通模式中选中光标所在单词
> 不论此时光标在单词的首\尾\中间

### 选择模式(select mode)

1. vim中可视模式和一般的编辑器不一样:选中某个单词后按退格键不能删除单词
2. 选择模式可以!
3. 可视模式中选中后按`<C-g>`进入选中模式,再按退格键即可删除选中的文本

### `c`:删除并进入插入模式

1. `cw`:删除光标所在单词并进入插入模式
2. `c<Cr>`:删除光标所在行及下一行并进入插入模式
3. `c$`:删除光标到行末的文本并进入插入模式
4. `c^`:删除光标到行首的文本并从行首进入插入模式

<br>  

|上一篇|下一篇|
|:---|---:|
| [技巧19 使用替换模式替换已有文本](../chapter3_insert_mode/tip19.md)|[技巧21 选择高亮区域](tip21.md)|


# 技巧21: 选择高亮区域
> 介绍如果进入可视模式的三种子模式(文本选中, 行选中, 块选中)

### 激活可视模式

![tip21](./image/tip21.png)  

1. `v`进入面向字符的可视模式
> `gv` 重新选择上一次可视命令选中的位置,如果原来的单词/行被删除,显示可能有问题

2. `V`进入面向行的可视模式
3. `<C-v>`进入面向列的可视模式

### 在可是模式间切换

![tip21_1](./image/tip21_1.png)  

1. `o` 在可视模式中光标移动到选中区域的另一端点, 见下面的例子

### 切换选区的活动端

![tip21_2](./image/tip21_2.png)  


<br>  

|上一篇|下一篇|
|:---|---:|
| [技巧20 深入理解可视模式](tip20.md)|[技巧22 重复执行面向行的可视命令](tip22.md)|


# 技巧22: 重复执行面向行的可视命令
> `.`命令对于面向行的可视命令可复用

### 例子: 调整python代码的缩进

![tip22](./image/tip22.png)  

1. `Vj` 选中两行
2. `>` 将选中的行向右缩进一层
3. `.` 重复缩进操作`>`

> **Note** <br>
> 1. `>.` 也可以用 `2>`替换,但是不如`>.`的及时视觉反馈来得快

<br>  

|上一篇|下一篇|
|:---|---:|
| [技巧21 选择高亮区域](tip21.md)|[技巧23 尽可能使用操作符命令,而不是可视命令](tip23.md)|


# 技巧23: 尽可能使用操作符命令,而不是可视命令

> 可视模式比普通模式操作视觉反馈更好,但是由于对于`.`操作的支持性低,所以尽量使用操作符命令

### 例子: 修改HTML代码中的标签信息进行大写转换

![tip23_1](./image/tip23_1.png)  

1. `vit` 理解为(**visually** select **inside** the **tag**), 选中标签里的内容
> `it` 指的是文本对象(text object), 一种特殊的动作命令

2. 之后可以使用`j.j.`将下面两行内容也变为大写, 见下面的例子

![tip23_1_1](./image/tip23_1_1.png)  

![tip23_2](./image/tip23_2.png)  

### `vitU` vs `gUit`

1. `vitU` = `vit`(选中)＋`U`(变为大写), 实际是**2**个命令
2. `gUit` = `gU`(操作符) + `it`(动作命令), 实际是**1**个命令
> 可视模式下`U`等价于普通模式下`gU`

3. 两者没有优劣,但是建议需要**重复**的操作用操作符+动作命令实现


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧22 重复执行面向行的可视命令](tip22.md)|[技巧24 用面向__列块__的可视模式编辑**表格数据**](tip24.md)|


# 技巧24: 用面向__列块__的可视模式编辑**表格数据**

### 例子: 将表格的每一列之间用竖线隔开(每行添加竖线)

![tip24](./image/tip24.png)  

1. `<C-v>3j` 选中四列,每列宽1
2. `x..` 每行删3列
3. `gv` 重选上次的高亮区域
4. `r|` 将光标所在字符替换成 `|`
5. `Vr-` 选中光标所在行(`V`), 将光标所在的字符替换成`-`

<br>  

|上一篇|下一篇|
|:---|---:|
| [技巧23 尽可能使用操作符命令](tip23.md)|[技巧25 修改列文本](tip25.md)|


# 技巧25: 修改列文本

### 例子: 替换CSS中的图片路径

> 将 `/images/` 替换成 `/components/`

![tip25](./image/tip25.png)  


1. `<C-v>jje`: 进入列可视模式(`<C-v>`), 选中三行(`jj`), 每列选中到单词结尾(`e`)
2. `c`: 删除选中文本
3. `<Esc>`: 显示剩下两行的修改结果

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧24 用面向__列块__的可视模式编辑](tip24.md)|[技巧26 在长短不一的高亮块中添加文本](tip26.md)|


# 技巧26: 在长短不一的高亮块中添加文本

> **列块** 可视模式在长方形的高亮区域中很好用,在非长方形的选中区域中也可以执行

### 例子: 每行的末尾都插入`;`字符
![tip26](./image/tip26.png)  

1. 可以理解为在选中区域中进行的操作是在选中区域的第一行进行操作(比如本例的`A;`), 按下`<Esc>`键后作用到其他选中的行上
2. `$`: 动作命令, 选取扩展到行末

### 不同按键进入插入模式

|按键|操作说明｜
|---|---|
|`I`|从光标所在**行**的*__第一个__*字符进入插入模式|
|`i`|从光标所在字符的**上一个字符**进入插入模式|
|`a`|从光标所在字符的**下一个字符**进入插入模式|
|`A`|从光标所在**行**的__*最后一个*__字符进入插入模式|



<br>  

|上一篇|下一篇|
|:---|---:|
| [技巧25 修改列文本](tip25.md)|[技巧27 结识Vim的命令行模式](../chapter5_ex_mode/tip27.md)|


# 技巧27: 结识Vim的命令行模式

> 1. 命令行模式需要输入:一条Ex命令 or 一条查找模式 or 一个表达式
> 2. 本技巧介绍一些操作缓冲区文本的Ex命令

1. 普通模式中按下`:`键进入命令行模式
> 1. 这个模式和shell下的命令行有些类似:`输入一条命令,按回车键执行`
> 2. 普通模式中按`/`进入查找模式、按`<C-r>=`访问表达式寄存器时， 也进入命令行模式`

2. 由于历史原因, 在命令行模式中执行的命令被称作`Ex`命令
3. 命令行模式可以干很多事情：读写文件（`:edit` 和`：write`）、创建新标签页（`：tabnew`）、分割窗口（`：split`）、操作参数列表（`：prev`、`:next`)缓冲区列表（`:bprev`、`:bnext`)...

###  操作缓冲区文本的Ex命令介绍
![tip27](./image/tip27.png)  


1. 命令行模式和插入模式类似（大部分按键输入一个字符），不同的是：命令行模式输入的文本出现在`命令行`上，插入模式输入到`缓冲区`
2. `<C-w>`(回退一个单词),`<C-u>`(回退一个字符), `<C-r>{register}`（将寄存器内的文本插入）、`<C-v>`(按照编码来插入字符) 等指令在命令行模式仍能使用
3. Ex命令的有点在于`有能在多行上同时执行的能力`（不需要`j.j.j.`一直按）


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧26 在长短不一的高亮块中添加文本](../chapter4_visual_mode/tip26.md)|[技巧28 在一行或多个连续行上执行命令](tip28.md)|


# 技巧28： 在一行或多个连续行上执行命令

### 例子：使用命令行打印代码

![tip28_1](./image/tip28_1.png)  

### 用行号做地址
1. `:1` 跳到第一行
2. `:print` 将第一行的内容打印到命令行上显示
3. `:$` 跳到最后一行
4. `p` 等于`:print`

### 用地址指定一个范围
5. `:5p` 光标移动到第5行并打印改行
6. `:2,5p` 打印第二到第5行的内容(**含第二行和第五行**)
7. `:.,$p` 打印当前行到最后一行的内容（`.`代表当前行，`$`代表最后一行）
8. `%p` 打印所有行
9. `%s/Practical/iampkuhz/` 把所有的`Practical` 单词替换成 `iampkuhz`

### 用高亮选取指定范围

> 假设已经在可视模式下选中下面的文本

![tip28_2](./image/tip28_3.png)  

10. 在上面的可视选取选中后按`:`，则命令行会预先填充`:'<,'>`
> `'<`代表高亮选区的第一行, `'>`代表高亮选区的最后一行
11. `:/<html>/,/<\/html>/p`, 在本例中等价于`2,5p`
> `/<html>/`表示的是 `<html>` 所在地址， `/<\/html>/`表示的是 `</html>`所在地址（含有转义字符）
12. `:/<html>/+1,/<\/html>/-1p`, 在本例中等价于`2+1,5-1p`,等价于`3,4p`

### Ex命令的地址和范围符号总结

![tip28_2](./image/tip28_2.png)  


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧27 结识Vim的命令行模式](tip27.md)|[技巧29 使用`:t` `:m` 进行复制和移动行](tip29.md)|


# 技巧29： 使用`:t` `:m` 进行复制和移动行

> 1. `:t` 是 `:copy` 的缩写, 也等价于`:co`， 可以把多行复制到其他位置
> 2. `:m` 是 `:move` 的缩写，把多行移动到其他位置


### 例子： 复制/移动购物清单

![tip29_1](./image/tip29_1.png)  

### 复制行

1. `：6copy.` 等价于 `:6co.` 等价于 `:6t.`： 将第3行复制到当前行下方, 效果见下图 <br>
![tip29_2](./image/tip29_2.png)  

2. 其他复制的例子见下表 <br>
![tip29_3](./image/tip29_3.png)  


#### `:t.` vs `yyp`
 1. 两者都是把当前行复制一份放到下面一行
 2. `:t.` 不使用寄存器，`yyp`使用

#### 移动行

1. `Vjj`选中待移动区域后`:m$`将其插入到文件结尾
![tip29_4](./image/tip29_4.png)  

> 也可以`Vjj`选中后按`dGp` (`d`删除选中区域，`G`跳到最后一行，`p`粘贴内容)


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧28 在一行或多个连续行上执行命令](tip28.md)|[技巧30 在指定范围上执行普通模式命令](tip30.md)|


# 技巧30： 在指定范围上执行普通模式命令

> `:normal {oprator}`可以在一系列连续行上执行一条普通模式命令， 结合`.`或宏命令可以花费很少的按键来完成大量重复性的任务

### 例子：给文件的每一行末尾添加`;`字符

> 在`技巧2`中，如果我们想在50行的每一行的末尾加上`;`,则我们需要`A;<Esc>j.j.j.j.`...按3×+2*49=101次键盘，下面的例子只需要几次按键即可完成此任务

![tip30_1](./image/tip30_1.png)  

![tip30_2](./image/tip30_2.png)  

1. `:'<,'>normal .` ： 对高亮选取的每一行，执行`.`命令
> 1. `:%normal A;` 表示对每一行,在结尾处插入`;`
> 2. `:%normal i//` 表示对每一行，在最前面插入`//` （注释文件）

<br>  

|上一篇|下一篇|
|:---|---:|
| [技巧29 使用`:t` `:m` 进行复制和移动行](tip29.md)|[技巧31 重复上次的Ex命令](tip31.md)|


# 技巧31： 重复上次的Ex命令

1. `:@:` 重复上次的Ex命令
2. `:@@` 使用过`@@`之后再重复之前的指令，使用`：@@`
3. `:bn` 等价于 `:bnext` 在缓冲区列表中正向移动
4. `:bp` 等价于 `:bprevius` 在缓冲区列表中逆向移动
5. `<C-o>` :每次使用`:bnext` 的时候都会在跳转列表中添加一条记录，`<C-o>` 会回到跳转列表的上一条记录处 (理解为**回看**)

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧30 在指定范围上执行普通模式命令](tip30.md)|[技巧32 自动补全Ex命令](tip32.md)|


# 技巧32： 自动补全Ex命令
> `<Tab>`自动补全

1. `<C-d>` 会列出所有可用的补全列表
2. `<Tab>` 会依次补全为候选（按一次，环一个候选）

#### `wildmenu` 选项

1. 在`vimrc`中设置`set wildmenu`后，vim会提供补全导航列表
> 1. `<Tab>`, `<C-n>`, `<Right>` 正向遍历列表
> 2. `<S-Tab>`, `<C-p>`, `<Left>` 反向遍历列表

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧31 重复上次的Ex命令](tip31.md)|[技巧33 把当前单词插入到命令行](tip33.md)|


# 技巧33： 把当前单词插入到命令行

> 怎么快速的把当前光标所在的单词插入正在编辑的命令行中？`<C-r><C-w>`

### 例子：变量重命名（字符串替换）

> 将所有的`tally`替换成`counter`

![tip33](./image/tip33.png)  

1. 将光标移动到`tally`字符串上面后，用`*`相当于 `/\<C-r><C-w\><CR>`（查找光标所在单词的下一个位置）

2. 进行完上图的操作后，直接按`:%s//<C-r><C-w>/g`即可完成替换（因为此时光标在`counter`上，所所以指令等价于`:%s//counter/g`
> 因为`*`命令，使得替换命令的查找域为空（理论上是`%s/tally/counter/g`), 具体原因看[技巧90]()



<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧32 自动补全Ex命令](tip32.md)|[技巧34 回溯历史命令](tip34.md)|


# 技巧34： 回溯历史命令

> 回溯之前之执行过的命令的两种方式：
> > 1. 用光标键回滚
> > 2. 调出命令行窗口查看历史命令

1. 先按`:`，然后保持提示符为空下按`<Up>`,则刚刚执行的命令会覆盖在命令行上，`<Down>`键反向
> 1. 对于查找命令（普通模式下按`/`进入），vim也保存其历史记录，按`<Up>`,`<Down>`键切换
> 2. 命令行下历史记录的查找可以用`<C-p>`, `<C-n>`来分别替代`<Up>`,`<Down>`键，好处是手指移动距离短，坏处是没有`<Up>`,`<Down>`键对历史记录过滤的功能
> >  将两者结合：在vimrc中添加下面两行，把命令行模式下的`<C-p>`, `<C-n>`映射成`<Up>`,`<Down>`
> >  `cnoremap <C-p> <Up>`
> >  `cnoremap <C-n> <Down>`

2. 设置vimrc `set history=200`可以修改vim保存200条历史命令记录

### 命令行窗口

1. `q:`进入命令行窗口
> 1. 在命令行历史窗口中，`j`，`k`上下移动
> 2. 命令行历史窗口内支持`/`,`?`查找命令
> 3. 命令行历史窗口内按回车键执行光标所在命令
> 4. 窗口打开后拥有焦点，`:q`退出

2. 进入命令行模式的3中方法：见下图

![tip34_2](./image/tip34_2.png)  

### 例子： **利用命令行窗口合并历史命令**

![tip34_1](./image/tip34_1.png)  



<br>  

|上一篇|下一篇|
|:---|---:|
| [技巧33 把当前单词插入到命令行](tip33.md)|[技巧35 运行Shell命令](tip35.md)|


# 技巧35： 运行Shell命令

> vim 内可以调用shell命令

> **好处:**
>> 1. 可以把缓冲区的内容作为标准输入发送给标准输出发送给外部命令
>> 2. 把外部命令的标准输入放到缓冲区

1. `:ls`,`:!ls` 不同，前者是vim命令，显示缓冲区内容；后者调用shell的`ls`
2. `:!ruby %` 调用ruby执行当前文件

### `:shell` 启动一个交互式的shell会话
![tip35_1](./image/tip35_1.png)  

## 把缓冲区的内容作为标准输出或输入

1. `:read !{cmd}` 把标准输出重定向到缓冲区
2. `:write !{cmd}` 把缓冲区的内容作为shell命令的标准输入
3. `:write! sh` 把缓冲区的内容写到`sh`这个文件里面


### 例子： 使用sort排序

> 将记录按照姓氏排序

![tip35_2](./image/tip35_2.png)  

1. `2,$!sort -t',' -k2`即可按照姓氏排序上图的条目
> `2,$`表示排序候选是第二行到最后一行
> `-t','`表示按`,`分割字段
> `-k2` 表示排序字段为第二列

2. 如果排序的是当前文档且光标就在第二行，直接使用`!G` (等价于`:.,$!`)


<br>  

|上一篇|下一篇|
|:---|---:|
| [技巧34 回溯历史命令](tip34.md)|[技巧36 用缓冲区列表管理打开的文件](../../part2_file/chapter6_multi_files/tip36.md)|


# 技巧36： 用缓冲区列表管理打开的文件

> vim 的一次编辑会话可以打开多个文件，vim的缓冲区列表对文件进行管理

## 文件 vs 缓冲区

1. vim中`正在编辑一个文件` 其实是`正在编辑一个缓冲区`
2. 文件存在磁盘，缓冲区存在内存

## 查看/切换缓冲区列表

![tip36_2](./image/tip36_2.png)  

1. `vim *.txt`假设打开2个文件文件, 会默认只显示第一个文件

2. `:ls`显示缓冲区的所有文件，其中：
> 1. `%`表明当前窗口中可见的缓冲区
> 2. `#`表示轮换文件，即上一次打开的文件

3. `:bnext` 切换到下一个文件的缓冲区
> 1. `:bprev` 切换到上一次的文件缓冲区
> 2. `:bfirst` 切换到缓冲区列表中第一个文件的缓冲区
> 3. `:blast` 切换到缓冲区列表中最后一个文件的缓冲区
> 4. `<C-^>` 在当前文件和轮换文件间快速切换
> 5. `:buffer N` 跳到编号为`N`的缓冲区

4. `:bufdo` 允许在打开的所有缓冲区中执行Ex命令（作用在多个文件上）
5. `:argdo` 比`:bufdo`实用（后面讲）


## 删除缓冲区

1. `:bdelete` 删除缓冲区 <br>
> `:bdelete 1 2 4`:删除编号为1,2,4的缓冲区

**vim 内置的缓冲区管理不灵活，之后的几个技巧介绍如何将缓冲区进行自定义的组织、分割**

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧35 运行Shell命令](../../part1_pattern/chapter5_ex_mode/tip35.md)|[技巧37 用参数列表将缓冲区分组](tip37.md)|


# 技巧37： 用参数列表将缓冲区分组

> 1. 参数列表易于管理，将其分组易于访问
> 2. `:argdo` 用法

1. 假设我们已经使用`vim *.vim`打开了一些txt文件

2. `:args` 查看参数列表
>  ![tip37_1](./image/tip37_1.png) <br>
> `[]`覆盖的文件表明**活动文件** <br>
> `:args` 比 `:ls`的显示简陋 <br>

3. `:args {arglist}` 可以**指定**参数列表的内容，例子如下:
> ![tip37_2](./image/tip37_2.png)  
> `{arglist}` 也可是通配符，比如`:args *.txt`,对于打开大量文件有优势

## 用Glob模式指定文件

> 1. `*` 是一个通配符，用于匹配0个或多个字符，**不递归**
> 2. `**` 是一个通配符，用于匹配0个或多个字符，**递归**

1. **Glob模式**:使用两种通配符加上部分文件名或目录名，构造的用以匹配文件名的模式
> 几个例子: <br>
> ![tip37_3](./image/tip37_3.png)

2. `:args **/*.js **/*.css`: 构造一个只包含`.js`和`.css`的文件

## 用``` 反引号(``) ``` 来指定文件

1. 假设要打开的文件名已经存放在一个文本文件中:
>![tip37_4](./image/tip37_5.png)  

2. 使用``:args `cat .chapters` ``即可打开这4个pml文件

## 参数列表 vs 缓冲区列表

1. 参数列表更容易管理, 对于**缓冲区分组** 问题更容易管理
2. `:args {arglist}` 一下就可清空缓冲区，并设置新的缓冲区列表

3. 缓冲区列表像`桌面(desktop)`，乱七八糟；参数列表像`工作区（workspace）`, 只在需要扩展空间时用到
> [技巧69](),[技巧96]() 有参数列表的例子


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧36 用缓冲区列表管理打开的文件](tip36.md)|[技巧38 管理隐藏缓冲区](tip38.md)|


# 技巧38： 管理隐藏缓冲区

> 1. vim 对修改过的缓冲区会区别对待，放在意外退出
> 2. 本节介绍如何隐藏已修改的缓冲区
> 3. 介绍如何在退出Vim时处理隐藏缓冲区

### 例子：修改and切换缓冲区

1. 打开文件
> ![tip38_1](./image/tip38_1.png)  

2. 输入`Go`（跳到最后一行，后面插入一个空行），不保存后输入`:ls`发现第一个文件多一个`+`，说明有未保存的修改(保存后`+`消失)
> ![tip38_2](./image/tip38_2.png)  

3. 如果不保存修改就直接切换缓冲区，会报错：
> ![tip38_5](./image/tip38_5.png)  

4. 如果输入`:bn!`可以强制切换，但是显示不一样：
> ![tip38_6](./image/tip38_6.png)  
> 标记`h`表示他是`隐藏缓冲区（hidden）` <br>
> 标记`a`表示他是`活动缓冲区(active)`

## 在退出时处理隐藏缓冲区

> 下图显示所有的处理缓冲区的策略

![tip38_4](./image/tip38_4.png)  

1. 如果有隐藏缓冲区，则退出时，会提示下图，并把当前窗口切换为第一个修改的隐藏缓冲区：
> ![tip38_3](./image/tip38_3.png)  

2. 如果需要保存当前缓冲区，则执行`:write`把当前缓冲区保存到文件
> `:edit!` 则放弃更改

3. 如果有多个隐藏缓冲区被修改，则每处理一个（`:write`或`:edit!`)之后下一个自动跳到屏幕上
4. `:qall!` 放弃所有的隐藏缓冲区修改，直接退出

5. `:wall` 保存所有的缓冲区修改
> `:argdo write` 也可以保存所有的缓冲区修改


#### 运行`:argdo` 或`:bufdo`之前，最好启用`hidden`

1. 否则在执行下图的指令时，假如第二条`{cmd}`指令修改了缓冲区，则第三条指令不能切换，导致后面的指令都停止
2. `hidden`参数强制不提示


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧37 用参数列表将缓冲区分组](tip37.md)|[技巧39 将工作区切分成窗口](tip39.md)|


# 技巧39： 将工作去切分成窗口

> vim 的窗口可以并排显示多个缓冲区

## 创建切分窗口

> 效果见下图， `阴影`表示当前选中的窗口

![tip39_1](./image/tip39_1.png)  

1. `<C-w>v` 垂直(_**v**ertical_)平分当前窗口
> `:sp` 等价于 `<C-w>v`
2. `<C-w>s` 水平(_**s**tandard_)平分当前窗口
> `:vsp` 等价于 `<C-w>s`

3. 也可以指定分割窗口后缓冲区到底插入的是哪个文件的缓冲区
> `:vsp filename`, `:sp filename`

![tip39_2](./image/tip39_2.png)  

## 在窗口间切换

> 加入我们打开了多个窗口，咋么切换正在编辑的窗口？见下图：

![tip39_3](./image/tip39_3.png)  

1. `<C-w>w` 在窗口间循环切换
> `<C-w><C-w>` 等价于 `<C-w>w`,所以可以按住`Ctrl`键，之后连按2次`w`键即可切换窗口
2. `<C-w>h` 切换到左边的窗口
2. `<C-w>j` 切换到下边的窗口
2. `<C-w>k` 切换到上边的窗口
2. `<C-w>l` 切换到下边的窗口

## 关闭窗口

![tip39_4](./image/tip39_4.png)  

1. `:close` 关闭所有活动窗口
2. `:only` 关闭活动窗口以外的窗口

## 改变窗口大小和重新排列窗口

![tip39_5](./image/tip39_5.png)  

1. `<C-w>=` 是所有窗口等宽等高
2. `<C-w>_` 最大化活动窗口高度
3. `<C-w>|` 最大化活动窗口宽度

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧38 管理隐藏缓冲区](tip38.md)|[技巧40 使用标签页将窗口分组](tip40.md)|


# 技巧40： 用标签页将窗口分组

> vim里 可以用标签页把窗口组织到一系列工作区里

1. `标签页`是可以容纳多个窗口的容器
2. `标签页`和`缓冲区`不是一一对应的！
3. 可以将`标签页`理解成Linux中的`虚拟桌面`

4. 一个标签页可能包含一个或多个窗口
> 比如下图， 上面一行是标签页，灰色代表活动窗口或活动标签页
> ![tip40_1](./image/tip40_1.png)  

## 如何使用标签页

1. `:lcd {path}` 可以设置当前`窗口`的本地工作目录(非标签)
2. `:windo lcd {path}` 可以设置`所有窗口`的本地工作目录(非标签)

## 打开/关闭标签页

![tip40_2](./image/tip40_2.png)  

1. `:tabedit {filename}` 打开新的标签页
> 没有指定`{filename}`，则创建空缓冲区

2. `:tabc` 关闭当前标签页（同时关闭该标签页的所有窗口）
3. `:tabo` 关闭所有非当前标签页（同时关闭该标签页的所有窗口）

## 在标签夜间切换

![tip40_3](./image/tip40_3.png)  

1. `:tabn` 或`gt` 切换到下一个标签页
2. `:tabN` 或`gT` 切换到上一个标签页
3. `:tabn {N}` 或`{N}gt` 切换到编号为`{N}`的标签页

## 重排标签页

1. `:tabmove {N}` 将当前标签页移动到第`{N}`个位置（从`0`开始）
2. `:tabmove` 将当前标签页移动到末尾


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧39 将工作去切分成窗口](tip39.md)|[技巧41 用`:edit`命令打开文件](../chapter7_file_opr/tip41.md)|


# 技巧41： 用`:edit`命令打开文件

> 1. `:edit`命令允许通过绝对路径和相对路径打开文件

shell 命令的`pwd`显示当前的路径（`print working directory`)

## 相对于活动文件目录打开一个文件

1. `:edit %<Tab>`
> `%`表示当前工作路径，`<Tab>`将其展开

2. `:edit %:h<Tab>`
> `%:h` 表示当前工作区文件所在文件夹的完整路径

**note** <br>
> 在vimrc中添加`cnoremap <expr> $$ getcmdtype() == ':' ? expand('%:h').'/':'%%'`，则每次在命令行模式中输入`%%`，都会自动显示当前工作目录路径


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧40 用标签页将窗口分组](tip40.md)|[技巧42 使用`:find`打开文件](tip42.md)|


# 技巧42： 使用`:find`打开文件

> `:find` 允许直接输入文件名查找文件，不需要直到路径，但是需要配置`path`选项

## 配置`path`选项

#### `set path+=app/**`

该命令表示添加 app/ 目录及其所有子目录到`path`列表中

## 使用`:find` 查找

1. 配置完`path`之后可以使用`:find` 命令根据文件名查找文件路径了
2. `:find Main.js<Tab>` ，假设目标路径中有2个`Main，js`，则会显示第一个的路径，再按一次`<Tab>`会切换到第二个的路径


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧41 用`:edit`命令打开文件](tip41.md)|[技巧43 使用netrw管理文件系统](tip43.md)|


# 技巧43： 使用netrw管理文件系统

> `netrw`全称是`across NETwork Read and Write files`

vimrc 需要配置下面的内容
> set nocompatible <br>
> filetype plugin on


1. shell 命令行输入命令`vim .`，显示如下. 按`jk`移动光标，按回车键选中文件
![tip43_1](./image/tip43_1.png)  

2. `:edit .`打开文件管理器
3. `:Explore` 打开netrw的文件管理器
> `:E.` 等价`:Explore`，（但貌似不是通用的，我的不可以）

`工程目录树(project drawer)`: 一般的文本编辑软件的布局结构，左侧边是目录管理器的结构

## 与分割窗口协同工作

> `:Explore` 默认在活动窗口打开新文件

`<C-^>`打开上一次的文件（**如果上一次打开的是目录，则会报错**）

下图说明：**用工程目录树打开的新文件在原来的窗口显示**

![tip43_0](./image/tip43_0.png)  
<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧42 使用`:find`打开文件](tip42.md)|[技巧44 把文件保存到不存在的目录中](tip44.md)|


# 技巧44： 把文件保存到不存在的目录中

> **Note:** <br>
> `<C-g>`: 打印文件名和一些状态信息


1. 如果打开文件时指定的是空目录（当然打开的文件也是新文件了），则保存(`:write`)的时候会提示错误
2. 补救方法:**调用shell命令创建文件夹**
3. `:!mkdir -p %:h`
> `-p` 表示递归创建不存在的文件夹
> `%:h` 表示当前文件的完整目录路径

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧43 ](tip43.md)|[技巧45 以超级用户权限保存文件](tip45.md)|


# 技巧45： 以超级用户权限保存文件

> 我们想要修改一个文件，但是直接`vim file` 打开了一个只读文件忘记`sudo vim file`, 当我们第一次修改这个文件时，会提示`warning，XXXXX`，但结果我们连这个warning也没有看到，一直修改了好长时间，结果最后`:w`想保存的时候发现保存不了,`:w!`也不行，这时候该怎么办？

1. 对于只能读取，不能修改的文件，按`<C-g>`会提示`[readonly]`
2. 对于上面问题的解决方法：

#### `:write !sudo tee % > /dev/null`
> `%`表示编辑的文件的路径
> tee 用法：
> > 1. `tee {filepath}`，监听标准输入，把标准输入存到`{filepath}`上
> > 2. `tee -a {filepath}`,把标准输入**追加**到`{filepath}`中
> `> /dev/null` 重定向标准输出到垃圾桶（不显示标准输出），因为tee在接收标准输入的时候默认会同时打印出来，这个不必要，只要写到文件里就行
> 实际是启动`sudo tee % > /dev/null` 来写文件，然后使用`:write`来把缓冲区作为命令的标准输入


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧44 把文件保存到不存在的目录中](tip44.md)|[技巧46 用动作命令在文档中移动](../../part3_fast_move/chapter8_doc_jump/tip46.md)|


# 技巧46： 让手指保持在 `本位行（Home Row）`上

> `本位行`：键盘上`ASDFGHJKL`等字符所在的行，是盲打的停留行

#### 戒掉使用光标键的习惯

可以在vimrc中设置禁用光标键：
> noremap &lt;Up&gt; &lt;Nop&gt; <br>
> noremap &lt;Down&gt; &lt;Nop&gt; <br>
> noremap &lt;Left&gt; &lt;Nop&gt; <br>
> noremap &lt;Right&gt; &lt;Nop&gt; <br>

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧45 以超级用户权限保存文件](../../part2_file/chapter7_file_opr/tip45.md)|[技巧47 区分实际行和屏幕行](tip47.md)|


# 技巧47： 区分实际行和屏幕行

> 实际行就是文件的实际行号，如果vimrc设置`wrap`（缺省启用），则屏幕的多行是实际的一行

![tip47](./image/tip47.png)  

在`j`，`k`,`0`,`$`之前加`g`就是对屏幕行操作


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧46 让手指保持在 `本位行（Home Row）`上](tip46.md)|[技巧48 基于单词移动](tip48.md)|


# 技巧48： 基于单词移动

### 例子：单词级别的移动
> 假设当前光标所在字符为`r`，不同按键之后光标跳转情况如下图

![tip48_2](./image/tip48_2.png)  

![tip48_1](./image/tip48_1.png)  

1. `w` 移动到下一个单词（**(for)word**)的词首
2. `b` 移动到上一个单词（**back-word**)的词首
3. `e` 移动到下一个单词（**back-word**)的词尾
4. `ge` 移动到上一个单词（**back-word**)的词尾

扩展：

1. `ea`:在单词的尾部添加
2. `gea`:在上一个单词的尾部添加

### `w`,`b`,`e` vs `W`,`B`,`E`

字串（WORD）：不含空格的连续字符串
单词（word）：字母、数字、下划线组成的连续字符串

### 例子：7个单词 vs 2个字串

![tip48_3](./image/tip48_3.png)  

### 例子：根据要求选择使用字串模式还是字符模式
> 下面两个替换字符串的例子，使用不同的模式按键次数不一样，粒度较小的修改使用单词模式，粒度大的修改使用字串模式

![tip48_4](./image/tip48_4.png)  



<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧47 区分实际行和屏幕行](tip47.md)|[技巧49 对字符串进行查找](tip49.md)|


# 技巧49： 对字符串进行查找

#### `f{char}`:行内搜索字符，跳到该字符的第一次出现位置

> 没有搜到则光标不移动 <br>

![tip49_1](./image/tip49_1.png)  

> `F{char}` 和`f{char}` 搜索方向相反 <br>

![tip49_4](./image/tip49_4.png)  

> 搜索到第一个字符后按`;`继续向后查找改行的下一个字符出现位置<br>

![tip49_2](./image/tip49_2.png)  

> 按`,`向前查找改行的下一个字符出现位置

![tip49_3](./image/tip49_3.png)  


#### `t{char}`，`T{char}`

向后查找**直到**字符`{char}`,光标停在前一个字符（如果是`T{char}`，则光标停在后一个字符）

![tip49_5](./image/tip49_5.png)  



<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧48 基于单词移动](tip48.md)|[技巧50 通过查找进行移动](tip50.md)|


# 技巧50： 通过查找进行移动

> `f{char}` 的局限性：
> > 1. 只能找一个**字符**,不能找字符串
> > 2. 不能跨行找
> > 3. 普通的英文字符可能出现很多，单纯按一个字符查找可能没法快速定位到目的地



#### `/word<CR>` 查找字符串 `word`的下一个出现位置

1. 第一次查找完后，按`n`继续查找下一个出现位置，`N`反向查找(上一个出现位置)


### 例子：查找`ta`

![tip50_1](./image/tip50_1.png)  

#### 查找可以和`普通模式`，`可视模式`，`操作符待决模式`一起使用

### 例子：查找和 `可视模式` 混合使用

![tip50_2](./image/tip50_2.png)  

### 例子：查找和`操作符待决模式`一起使用
> 和上一个例子完成相同任务，但是更简单

![tip50_3](./image/tip50_3.png)  

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧49 对字符串进行查找](tip49.md)|[技巧51 用精确的文本对象选择选取](tip51.md)|


# 技巧51： 用精确的文本对象选择选取

> 怎么快速选中 _括号间的文本_,_XML标签内的文本_，_被引用的文本_ 以及其他常用文本对象？

### Vim 理解`成对出现的符号`
> vim "知道" 下图代码中的 （`{`和`}`）,(`[`和`]`), (`<`和`>`),(`<a>`和`</a>`) 是成对出现的
> 我们可以让vim**快速定位/选中/删除其文本内容**

![tip51_0](./image/tip51_0.png)  

### 例子：快速选中文本对象

![tip51_1](./image/tip51_1.png)  

1. `vi}` 快速选中`{}`之间的内容, 不包括`{`和`}` （**visual inside }**）
2. `a"` 快速选中`""`之间的内容,包括`"` (**around "**)
3. `i>` 快速选中`<>`之间的内容
4. `at` 快速选中XML标签内的内容，包括标签本身


#### Vim 的文本对象由`2`个字符组成，且第一个字符永远是`a`或`i`

`a` 包括分隔符本身(**around**)，`i` 不包括分隔符(**inside**)


#### 文本对象的例子见下表
> `a[`等价于`a]`,其他同理

![tip51_2](./image/tip51_2.png)  

注意：
> 1. 文本对象本身不是`动作命令`，但是可以在`可视模式`或`操作符待决模式`中使用
> 2. 一般可以使用`动作命令`的地方，也可以使用文本对象
> > 比如`d{motion}`, `c{motion}`, `y{motion}`.  

### 例子：替换html中链接地址

![tip51_3](./image/tip51_3.png)  

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧50 通过查找进行移动](tip50.md)|[技巧52 删除周边，修改内部](tip52.md)|


# 技巧52： 删除周边，修改内部

> vim的`文本对象`分为两类
> 1. `分隔符文本对象`：对象内部的文本, 以配对的符号作为开始和结束, 比如`vit`选中XML标签内的内容
> 2. `范围文本对象`：对象周围的文本, 像单词、句子、段落这样以文本结构的范围进行界定，比如`viw`选中光标所在单词

### 例子：选中单词、句子、段落

![tip52_1](./image/tip52_1.png)  

#### `iw` vs `aw`

1. `iw` 包含当前光标所在单词的第一个字符到最后一个字符
2. `aw` 包含`iw`的文本连同前一个 **或** 后一个空格

### 例子：删除单词
> `daw`好！

![tip52_2](./image/tip52_2.png)  

1. `daw` 符合我们想要的
2. `diw` 不好！ 因为不会删除空格，导致adjectives之前有2个空格

### 例子：删除单词并进入插入模式继续输入
> `ciw` 好！

![tip52_3](./image/tip52_3.png)  

1. `ciw` 正好！
2. `caw` 会多删一个空格，导致开始进入插入模式的时候会变成`mostadjectives`




`d{motion}`: 和`aw`, `as`, `ap`搭配好
`c{motion}`: 和`iw`, `is`, `ip`搭配好

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧51 用精确的文本对象选择选取](tip51.md)|[技巧53 设置位置标记，以便快速跳回](tip53.md)|


# 技巧53： 设置位置标记，以便快速跳回

> 可以手动设置位置标记，vim也会自动的标记位置; 标记位置方便快速跳回

#### `m{char}`:用选定的字母字符`{char}`标记光标所在位置

#### `` `{char}``:跳到字母字符`{char}`标记的位置（行+列）
> `'{char}`:跳到字母字符`{char}`标记的行 (记住`` `{char}``就行了)

**Note**
`mm`和`` `m``是一对常用的标记命令。前者标记，后者快速跳回来

### 自动位置标记

![tip53](./image/tip53.png)  

1. ``` `` ```:当前文件中上次跳转动作之前的位置
2. `` `.``:上次修改的地方
3. `` `^``:上次插入的地方
4. `` `[``:上次修改的起始位置
5. `` `]``:上次修改的结束位置
6. `` `>``:上次高亮选区的起始位置
4. `` `<``:上次高亮选区的结束位置

**Note**
> 高亮模式会默认自动标记位置标记`` `>`` `` `<``来跳转

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧52 删除周边，修改内部](tip52.md)|[技巧54 在匹配括号间跳转](tip54.md)|


# 技巧54： 在匹配括号间跳转

> vim 可以快速在开闭括号间跳转

#### `%`运行在一组开、闭括号间跳转(`()[]{}`)
> 例子见下图:

![tip54_1](./image/tip54_1.png)  

### 例子：将`{}`替换成`[]`
> 如果先替换`}`，之后按`%`是跳不回`{`所在位置的,因为已经没有匹配的`{}`对了 <br>
> 可以用``` `` ```来跳回到`上一次跳转动作之前的位置`(见[技巧53](tip53.md))

![tip54_2](./image/tip54_2.png)  


### 例子：给选中的文本对象加分隔符
> 需要 **matchit** 插件

![tip54_3](./image/tip54_3.png)  

1. `cs}]` 命令可以把 `{Donghai}`改成`[Donghai]`

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧53 设置位置标记，以便快速跳回](tip53.md)|[技巧55 遍历跳转列表](../chapter9_file_jump/tip55.md)|


# 技巧55： 遍历跳转列表
> Vim 会记录跳转的前后位置，提供命令原路返回

#### `:jumps` 列出跳转列表的内容
#### `<C-o>`,`<C-i>` 跳到跳转列表的文件中之后和之前的文件

#### 一些跳转动作：
![tip55_2](./image/tip55_2.png)  

1. `[count]G`跳转到制定行号，比如`10G`跳转到第10行
2. `/pattern<CR>`跳转到下一个`pattern`字符串出现的位置
3. `?pattern<CR>`跳转到上一个`pattern`字符串出现的位置
4. `%` 跳转到匹配的括号所在的地方
5. `(` 跳转到上一句开头
6. `)` 跳转到下一句开头
7. `{` 跳转到上一段开头
8. `}` 跳转到下一段开头
9. `H` 跳到当前屏幕最上方的行(`我自己实际尝试离屏幕顶部还有几行距离`)
10. `M` 跳到屏幕中间的行(`H`和`L`的中间行)
11. `L` 跳到当前屏幕最下方的行(`我自己实际尝试离屏幕顶部还有几行距离`)
12. `gf` 跳到光标下的文件名中去（文件需要和当前的文件在同一路径下）
13. `<C-]>` 跳到光标所在关键字的定义位置
14. `` `{mark}``跳转到一个位置标记

`<C-o>` 和`<C-i>` 搭配使用，可以在当前编辑文件和之前编辑文件之间快速切换


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧54 在匹配括号间跳转](../chapter8_doc_jump/tip54.md)|[技巧56 遍历改变列表](tip56.md)|


# 技巧56： 遍历改变列表
> 每次对文档修改后，vim都会记录当时光标所在位置，可以快速的在这些位置中跳转<br>
> `跳转列表`包含之前vim的所有文件的跳转情况，但是`改变列表`只是记录当前文件的改变情况


#### `:changes` 查看改变列表
#### `g;`,`g,`在改变列表中跳转，光标跳到之前和之后修改的位置
> 和行内搜索字符的命令`f{char}`类似，`;`,`,`分别向前和向后查找

2个特殊的跳转命令

1. `` `.`` 指向最后一次修改的地方，是不能重复使用的`g;`
2. `` `^`` 指向最后一次插入模式推出时的光标位置
3. `gi` 立刻跳转到最后一次插入模式跳出的位置，并进入插入模式，**快速的继续修改**


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧55 遍历跳转列表](tip55.md)|[技巧57 跳转到光标下的文件](tip57.md)|


# 技巧57： 跳转到光标下的文件
> vim 会把文档中的文件名当成超链接，在进行正确配置后，可以用`gf`美丽跳转到光标下的文件

#### `gf` (go to file)跳转到光标所在文件名对应的文件

**E447: Can't find file "XXXXXXX" in path** 可能的原因：
> 1. 路径中文件名缺少类型后缀：路径中是`path/file`，实际是`path/file.cpp`;<br>
> 2. 解决方法：在vimrc中设置`set suffixesadd+=.cpp`,这样会自动找文件名是`file`且文件后缀是`cpp`的文件了

如果`gf`进入新的文件后，可以按`<C-o>`(根据跳转列表)跳回来
> `gf`会在跳转列表中增加一条记录

#### 如何在指定的目录中搜索文件？
> 之前的例子都是在`相对路径`(`绝对路径`也可以跳转）中跳转, 但是有点时候引用的第三方的类库，只在特定路径中，怎么设置vim来快速跳转？<br>
> 设置 `path`！

#### `gf`命令会在`path`参数列举的所有路径中依次查找每个路径，在每个路径下查找是否有光标所在文件,有则打开，没有则继续查找`path`中的下个路径

![tip57_1](./image/tip57_1.png)  

1. `:set path?`查看当前`path`参数所含的所有路径，用`,`隔开

> 1. 由上图发现，第一个查找的路径就是`.`(当前文件所文件夹)
> 2. 如果添加一个路径`:set path+=/home/hanzhe/Documents/tmp`,则`:set path?`结果变成`path=.,/usr/include,,,~/Documents/tmp/,`

`suffixsadd`和`pth`参数既可以全局配置（在vimrc）中，也可以对每个缓冲区单独设置（敲命令`:set path+=XXX`)

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧56 遍历改变列表](tip56.md)|[技巧58 用全局位置标记在文件间快速跳转](tip58.md)


# 技巧58： 用全局位置标记在文件间快速跳转
> 1. `全局位置标记`是一种标签，可以在文件间快速跳转。
> 2. 如果我们分析完代码，想快速跳回某个文件时特别有用

#### `m{char}` 在当前光标所在位置创建一个位置标记
> `小写字母`建立缓冲区内的标记 (`局部`标记) <br>
> `大写字母`建立缓冲区内的标记 (`全局`标记)

#### `` `{char}`` 快速跳转到光标所在处

### 例子：浏览`一些/大量`文件后跳回
> 假如你需要浏览一些文件中的`foorBar()`函数，看好了之后快速跳回之前的文件继续修改，怎么操作？

1. `:vimgrep /foorBar/ **` 递归文件夹查找下一处`fooBar`的出现位置
> `vimgrep`的详细用法[技巧110]()会详细说明
2. 假如我们看了10+处`fooBar`函数，怎么快速跳回刚开始的文件位置？
3. 查找之前输入`mM`记录位置，查找结束后`` `M``快速跳回
> 也可以不断的按`<C-o>`根据跳转列表不断向前，但是如果看了很多个文件，则需要按很多次才能返回开始的文件<br>

当预计之后可能要看比较多文件才回来继续修改的时候，强烈建议使用`m{char-upper-case}`做标记来快速跳回


<br> gg

|上一篇|下一篇|
|:---|---:|
|[技巧57 跳转到光标下的文件](tip57.md)|[技巧59 用无名寄存器实现删除、复制和粘帖操作](../../part4_register/chapter10_copy_paste/tip59.md)


# 技巧59： 用无名寄存器实现删除、复制和粘帖操作
> vim 复制、剪切、粘贴的例子

### 例子：调换连续的2个字符
> 空格打的太快导致单词打错，调换' '和'l'

![tip59_1](./image/tip59_1.png)  

1. `F `从后向前查找第一个空格
2. `x` 删除光标所在字符（并把删除的字符放到`无名寄存器`）
3. `p`将无名寄存器的内容粘贴到光标后

> `xp` 是调换两个连续的字符（没必要专门记忆）

### 例子2：调换文本`行`

![tip59_2](./image/tip59_2.png)  

1. `dd`删除光标所在行（并把删除的字符放到`无名寄存器`）
2. `p`将无名寄存器的内容粘贴到光标下一行

> `ddp` 交换2个连续的行（没必要专门记忆）

### 例子3：复制文本行

![tip59_3](./image/tip59_3.png)  

1. `yy`复制光标所在行（并把复制的字符放到`无名寄存器`）
2. `p`将无名寄存器的内容粘贴到光标下一行


### 例子4：替换单词，但是失败了 (**这个例子后面几个技巧都提到，注意一下**)
> 希望将`somethingInTheWay`替换成`collection`

![tip59_4](./image/tip59_4.png)  

1. `yiw` 复制光标所在单词
2. `jww` 跳到`somethingInTheWay`
3. `diw` 删除光标所在单词
4. `P` 将未命名寄存器的内容粘贴到光标处

**粘贴失败！**

1. 失败原因: `diw`之后无名寄存器已经变成`somethingInTheWay`了
2. **解决方式**：用`"0P`替代`P`
> `"0` 是复制专用寄存器， 只有`y`操作会改变其中的值; `"0P"` 将`复制专用寄存器`的值粘贴到光标`前`

<br> gg

|上一篇|下一篇|
|:---|---:|
|[技巧58 用全局位置标记在文件间快速跳转](tip58.md)|[技巧60 深入理解vim寄存器](tip60.md)|


# 技巧60： 深入理解vim寄存器
> 使用shanchu、复制、粘贴操作时，可以指定使用哪一个寄存器

#### `"{register}` 指定使用的寄存器
> [技巧59](tip59.md) 使用`"0`来粘贴复制寄存器中的值

### 例子1：替换单词（技巧59的最后一个例子解法）
> 将`somethingInTheWay`替换成`collection`

#### 解法1：使用`复制专用寄存器("0)`来替换单词
![tip60_1](./image/tip60_1.png)  

1. 只有复制操作会改变复制专用寄存器中的值

#### 解法2：使用有名寄存器（`"a`-`"z`) 来复制和替换单词
![tip60_2](./image/tip60_2.png)  


#### 解法4：使用`黑洞寄存器`来删除单词
![tip60_3](./image/tip60_3.png)  

黑洞寄存器不会存储文本的副本

<br>

#### 系统粘贴板（`"+`） 和 选择专用寄存器(`"*`)

![tip60_4](./image/tip60_4.png)  

1. `"+p`将外部程序中复制的内容粘贴到光标后面
2. `"+yy`将光标所在行复制到系统粘贴板
3. `"*`表示主剪切板，保存上次被高亮选中的文件,使用`鼠标中键`粘贴出来
> 1. windows 和 Mac OS X没有主剪切板，`"*`和`"+`混用
> 2. `:version`查看`xterm_clipboard`是否激活，`+xterm_clipboard`表明支持主剪切板

#### 表达式寄存器(`"=`)

输入`"=`后vim会进入命令行模式，并显示提示符`=`，敲入一段vim脚本表达式并按`<CR>`执行。如果返回的是字符串或者是可以转换成字符串的数据，则Vim会使用他。

### 例子5：其他寄存器
![tip60_5](./image/tip60_5.png)  

1. `"%`当前文件名
2. `"#`轮换文件名
3. `".`上次插入的文本
4. `":`上次执行的Ex命令
5. `"/`上次查找的模式
> `:let` 可以对`"/` 寄存器进行显示的赋值, 而上面其他的寄存器都是`只读`的


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧59 用无名寄存器实现删除、复制和粘帖操作](tip59.md)|[技巧61 用寄存器中的内容替换高亮选取的文本](tip61.md)|


# 技巧61： 用寄存器中的内容替换高亮选取的文本

> 在可视模式下使用粘贴命令

### 例子：替换单词（还是[技巧59](tip59.md)的例子）

![tip61_1](./image/tip61_1.png)  

1. `ve` 选中单词
2. `p`将选中的单词替换成未命名寄存器中的文本
3. **这次命令结束后未命名寄存器中的内容会被替换成somethingInTheWay**
> 如果按`u`撤销操作后再重按`p`不会有任何效果

### 例子2：交换单词`chips`和`fish`

![tip61_3](./image/tip61_3.png)  

1. `de`删除当前单词
2. `p`把删除的单词粘贴到光标后面
3. `mm`在光标处设置标记为`m`
4. `` `m``跳到标记为`m`的位置
5. `c3w`，然后再重新输入单词也可以



<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧60 深入理解vim寄存器](tip60.md)|[技巧62 把寄存器中的内容粘贴出来](tip62.md)|


# 技巧62： 把寄存器中的内容粘贴出来
> 普通模式下的粘贴命令，待插入的文本不同，粘贴指令的执行效果也不同<br>
> 面向行和面向字符的粘贴指令效果不同

1. `xp`交换2个字符顺序
2. `ddp`交换2行顺序


1. `p`将文本粘贴到光标之前
2. `P`将文本粘贴到光标之后

> 1. `前`和`后`有两种理解：前一行/后一行，前一列/后一列
> 2. 面向`行`的删除和复制：粘贴操作粘贴到光标的`前一行和后一行`
> 3. 面向`字符`的删除和复制：粘贴操作粘贴到光标的`前一字符和后一字符`

## 粘贴面向字符的区域

### 例子：将寄存器中的单词插入光标位置

![tip62_1](./image/tip62_1.png)  

1. 上一个用`p`，下一个用`P`
2. `p`和`P`经常会用错，导致`puP`或`Pup`的按键序列出现
3. 好的方法是进入插入模式后按`<C-r>"`或`<C-r>0`来粘贴

### 例子1：使用插入模式来替换单词（还是[技巧59](tip59.md)的例子）

![tip62_2](./image/tip62_2.png)  


## 粘贴面向行的区域

比面向字符的粘贴更直观

#### `gp` 类似与`p`， 区别在于粘贴后光标位于插入的文本的末尾（`p`位于开头）
#### `gP` 类似与`P`， 区别在于粘贴后光标位于插入的文本的末尾（`P`位于开头）


### 例子：复制表格的html

![tip62_3](./image/tip62_3.png)  


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧61 用寄存器中的内容替换高亮选取的文本](tip61.md)|[技巧63 与系统粘贴板进行交互](tip63.md)|


# 技巧63: 与系统粘贴板进行交互
> 如果vim启用`autoindent`选项，则在插入命令下插入系统粘贴板的时候可能排版会混乱

### 例子：从系统粘贴板复制一段代码

1. 待插入代码如下：<br>
![tip63_0](./image/tip63_0.png)
2. 我们在别的程序中打开这个文件，并复制到系统粘贴板
3. 在vim中进入插入模式，然后使用系统的粘贴命令（`Ctrl+V`）插入这段代码，效果如下：<br>
![tip63_1](./image/tip63_1.png)

这是因为`autoindent`选项启用后每次插入一个新行（输入了一个`<CR>`），就会增加一层缩进，所以排版出错

#### 设置`paste`选项可以避免系统剪切板的粘贴操作出现意外，但是粘贴完后必须`尽快关闭paste选项`，否则插入模式下创建的自定义映射都会失效

为了解决上面切换的代价，2种方式：

1. 设置`set pastetoggle=<F5>`,按`<F5>`来启动/关闭`paste`选项
2. **推荐：** 使用家好寄存器进行粘贴`，"+p`将寄存器的内容粘贴到光标之后，不论`autoindent`是否启用，都能保证排版不会出错


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧62 把寄存器中的内容粘贴出来](tip62.md)|[技巧64 宏的读取和执行](../chapter11_macro/tip64.md)|


# 技巧64 宏的读取和执行

> 宏就是把一段修改序列录制下来，然后重复执行这段操作


### 例子：修改代码并将操作制作成宏

![tip64_1](./image/tip64_1.png)  

1. 宏以`q`开始，也已`q`结束
2. `qa`开始录制宏，并保存在寄存器`a`中
3. `:reg a`查看寄存器`a`中的内容

> 本例执行完，寄存器`a`中的内容是：<br>
> ![tip64.png](./image/tip64_0.png)

### 例子1.1： 修改代码（上个例子的继续）

![tip64_2](./image/tip64_2.png)  

1. `@{register}`执行制定寄存器的内容
> 本例中`@a`执行之前的操作，对第二行进行修改
2. `@@`执行最近刚**调用**的宏的命令


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧63 与系统粘贴板进行交互](tip63.md)|[技巧65 规范光标位置、直达目标以及终止宏](tip65.md)|


# 技巧65： 规范光标位置、直达目标以及终止宏
> 介绍执行宏时候的最佳应用方式， 能使得宏执行的时候有更好的一致性

#### 黄金法则：**录制宏时，确保每条指令都可以被重复执行**

##### rule 1: 规范光标位置

开始录制宏时，确保光标位置

1. 常见的光标位置：行首（`0`），下一处查找匹配项（`n`），当前文件的行首（`gg`）

##### rule 2: 用开始命令直达目标

1. 尽量不要使用`hhhh`，`jjj`这样的形式来达到目标位置
2. 尽量使用`w`，`b`，`e`，`ge`这样的操作


##### rule 3: 当动作命令失败时，宏终止执行

失败情况举例：光标已经位于行末，又执行了`l`命令。

1. 失败时vim会发出`哔`的声音，设置`visualbell`可以关闭提示音
2. 宏命令失败后会中止之后的指令
3. 对于查找替换类型的宏，如果不知道执行多少次，就多写一些，比如`1000@a`，执行到最后一次后会终止

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧64 宏的读取和执行](tip64.md)|[技巧66 加次数回放宏](tip66.md)|


# 技巧66： 加次数回放宏
> 点范式（`.`重复操作）快速高效，缺点是不能指定次数，我们使用宏将`.`操作封装起来，这样就可以指定次数，减小按键了


### 例子：代码美化，让`+`前后都有空格
> 对于一行代码，将其`+`附近增加空格

![tip66](./image/tip66.png)  

1. 这个例子也可以使用`f+s+<Esc>;.;.;.;.;.;.;.;.;.`完成，一个个点太麻烦
2. `22`大于实际的`+`个数：利用宏的超过范围停止之后的指令，可以在找到最后一个后停止
3. `qq;.q` 是标记为`q`的宏，其内容是`;.`
4. 使用宏的时候其实是不需要计数的（保证执行的次数大于待处理的个数即可）




<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧65 规范光标位置、直达目标以及终止宏](tip65.md)|[技巧67 在连续的文本行上重复修改](tip67.md)|


# 技巧 67： 在连续的文本行上重复修改
> 1. 对于在连续多行内进行的重复性修改，可以先录制一个宏，然后在每一行上回放
> 2. 该宏可以设计成`串行`或`并行`

### 例子：数据格式化
> 改变排序标号，首字母大写<br>
> ![tip67_1](./image/tip67_1.png)  <br>
> 变成：<br>
> ![tip67_2](./image/tip67_2.png)  

#### 步骤1. 录制宏<br>
![tip67_3](./image/tip67_3.png)  

#### 步骤2. 串行方式回放宏<br>
![tip67_4](./image/tip67_4.png)  
> `0`将光标至于行首

**Note**

假设文件内容如下：

![tip67_5](./image/tip67_5.png)  

该方法对于上面的情况会出错, 宏遇到一个执行错误后会停止执行后面的内容

![tip67_6](./image/tip67_6.png)  

### 解决方法：使用并行方式执行宏
> 好处：行与行之间互相不影响<br>
> `并行方式`实际就是选择一段文本，制定在文本区间内同时执行

![tip67_7](./image/tip67_7.png)  

1. `:normal @a` 让vim在选中的每一行都执行`@a`

`并行方式`和`串行方式`没有好坏之分,分情况使用

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧66 加次数回放宏](tip66.md)|[技巧68 给宏追加命令](tip68.md)|


# 技巧68： 给宏追加命令
> 如果我们录制完了一个宏，但是发现少加了一些命令，怎么办？
> 1. **在宏的结尾处追加**
> 2. **如果缺少的命令在宏的开始或中间，则没法解决，必须重新录制宏**


### 例子：数据格式化 (同[技巧67](tip67.md)的例子)
> 改变排序标号，首字母大写

假设我们录制完毕后如下：

![tip68_1](./image/tip68_1.png)  

发现少了一个`j`（移到下一行）,查看一下现在的宏a的内容：

![tip68_2](./image/tip68_2.png)  

则进行补救，在宏a的结尾处添加：

![tip68_3](./image/tip68_3.png)  

1. `qa` 开始录制宏a，会覆盖之前宏a的内容
2. `qA` 将命令添加到宏a的后面，不会覆盖原来的宏a内容

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧67 在连续的文本行上重复修改](tip67.md)|[技巧69 在一组文件中执行宏](tip69.md)|


# 技巧69： 在一组文件中执行宏
> 介绍如何将一个宏作用在一组文件shang<br>
> 同样可以串行或并行执行

### 例子：给每个 class 添加外部的 module
> 如下图，我们希望下图的上半部分变成下图的下半部分
> ![tip69_1](./image/tip69_1.png)  

#### 1. 建立目标文件列表/打开所有的目标文件

![tip69_2](./image/tip69_2.png)  

1. `:args *.rb` 打开目标文件
2. `:args` 显示参数列表的内容


#### 2. 录制宏

![tip69_3](./image/tip69_3.png)  
![tip69_4](./image/tip69_4.png)  

1. `:first` 先把光标移到参数列表的第一个文件
2. `gg` 移动到第一行
3. `/class<CR>` 查找class
4. `0` 移动到行的第一列
5. `j>G` 先把光标移动到下一行（`j`），然后将光标所在行到最后一行（`G`）增加一层缩进（`>`）
6. `Go` 跳到最后一行，并在下面插入一行

> 做完第一个的修改不要保存（`:w`),下面说明原因

#### 3. 方法一：并行方式执行宏

1. 撤销对第一个文件的修改`:edit!`
2. 对参数列表的所有文件执行宏`:argdo normal @a`
3. 保存`:wall`
> **之所以录制宏的时候不保存、3.1先撤销修改，是为了防止第一个文件被执行2次**


#### 3. 方法二：串行方式执行宏

1. 添加宏的内容到结尾<br>
> ![tip69_5](./image/tip69_5.png)  

2. 串行执行宏 `100@`
> 也可以是`10@a`，只要大于文件个数就行，超过的`:next`命令会失败，然后宏自动中止

3. 保存文件`:argdo write` (等价于`:wall`,保存参数列表的所有文件的修改)
> 可以将3.1添加的宏改成`:wnext`, 则3.3可以省略。`:wnext`等价于先保存当前文件修改，再移动到参数列表的下一个文件

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧68 给宏追加命令](tip68.md)|[技巧70 用迭代求值的方式给列表编号](tip70.md)|


# 技巧70： 用迭代求值的方式给列表编号
> 在使用宏的时候如何插入一个变化（递增）的数值

### 例子：给每行加上编号
> 希望把下图上面的内容变成下图下面的内容<br>
>  ![tip70_1](./image/tip70_1.png)  

解决方法：通过`:let`创建变量，每次调用宏的时候增加1,使用该变量显示行号，具体过程如下图：

1. 录制宏
> ![tip70_2](./image/tip70_2.png)  

2. 并行回放宏
>  ![tip70_3](./image/tip70_3.png)  


说明：

1. `:let i=0` 设置变量
2. `:echo i` 打印变量
3. `<C-r>=i<CR>` 在插入模式中使用表达式寄存器,并将值`i`插入

#### (思考题)解法2：使用复制、粘贴+`<C-a>`解决
> 这里我只贴代码和简要注释

1. `gg0`+`i1) <Esc>` 制作第一个
2. `qa`+`0`＋`yt `+`j0`+`i <ESC>`+`0`+`P`+`0<C-a>`+`q` 录制宏
3. `99@a` 回放宏

<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧69 在一组文件中执行宏](tip69.md)|[技巧71 编辑宏的内容](tip71.md)|


# 技巧71： 编辑宏的内容
> 1. [技巧68](tip68.md)说明在宏结尾添加 命令容易
> 2. 本技巧说明如何像编辑普通文本一样编辑宏内容

### 例子：更改排序编号的样式
> 1. 把下图的文件改成`1) One`的形式 （**注意下图有的首字母大写，有的还未大写**)<br>
> 2. 假设现在宏a的内容是`0f.r)w~j`<br>
> ![tip71_1](./image/tip71_1.png)  

#### 解法：把宏a的内容粘贴到文档中，然后修改，之后覆盖回宏a的寄存器中

#### 步骤1：将宏粘贴到 文本

`:put a`
> 1. `:put a` 把 寄存器a的内容插入到`光标所在的下一行`
> 2. 比`"ap` 好，因为如果寄存器a中的是面向字符的内容，则会插入光标后一个字符，可能会和原来的代码混在一起，`:put a`保证在独立的一行

#### 步骤2：编辑宏
![tip71_2](./image/tip71_2.png)  

1. `~`把光标所在的字符大小写取反
2. `U`把光标所在的字符变成大写

#### 步骤3：将宏从文档复制回寄存器

`0`+`"ay$`+`dd`
> `"add`也能达到类似效果，但是代码最后会多一个结尾字符`^J`,为了保险起见，使用先复制，再删除的方法


<br>  

|上一篇|下一篇|
|:---|---:|
|[技巧70 用迭代求值的方式给列表编号](tip70.md)|[技巧72 调整查找模式的大小写敏感性](../../part5_pattern/chapter12_match/tip72.md)|


# 技巧72：调整查找模式的大小写敏感性
> 可以全局设置，也可以每次查找的时候指定

### 全局设置

在`~/.vimrc` 添加 `set ignorecase` 即可不区分大小写进行查找
> 注意：设置不区分大小写查找会影响`自动补全`效果

### 单次查找设置

查找模式下输入**`\c`XXXX**忽略大小写查找`XXXX`, **`\C`XXXX** 区分查找`XXXX`

### 智能查找

在`~/.vimrc` 添加 `set smartcase` 即可智能查找：`如果输入的单词都是小写，则使用大小写不明感查找；一旦输入的单词有一个是大写，则按照大小写敏感查找`


#### 例子:不同设置下查找模式能匹配的字符串

![tip72](./image/tip72.png)


|上一篇|下一篇|
|:---|---:|
|[ 技巧71： 编辑宏的内容](../../part4_register/chapter11_macro/tip71.md)|[技巧73: 按正则表达式查找时，使用`\v`开关](tip73.md)|


# 技巧73： 使用`\v`模式进行正则表达式查找
> 1. vim的正则表达式更接近POSIX
> 1. `\v`模式使用更接近于我们日常使用的正则表达式语法风格
> 2. `\v`=`very magic`

### 例子：使用magic模式匹配css文件中的颜色代码
> 匹配`3c3c3c`, `0000EE`, `000`

![tip73_1](./image/tip73.png)

1. 满足条件的magic模式下正则表达式：`/#\([0-9a-fA-F]\{6}\|[0-9a-fA-F]\{3}\)`
> 需要非常多的转义！！
2. 使用very magic模式的正则表达式：`/\v#([0-9a-fA-F]{6}|[0-9a-fA-F]{3})`
> 基本不用写转义字符；转义字符多了肯定容易写错！
3. 优化查找(使用16进制字符类优化): `/\v#(\x{6}|\x{3})`

**very magic 模式下 `(,),|,{,}`字符变成特殊字符，表达字符凭借功能时不需要转义**

|上一篇|下一篇|
|:---|---:|
|[技巧72：调整查找模式的大小写敏感性](tip72.md)|[技巧74: 完全匹配查找时， 使用`\V`](tip74.md)|


# 技巧74: 完全匹配字符串时，使用`\V` 查找
> 1. 如果我们不想使用正则表达式查找，而是`完全匹配字符串`查找，就是用`\v`
> 2. `\V` = `very nomagic`

### 例子：在下图文本里面查找 `a.k.a`
> 假设当前光标在第一行第一个字符处

![tip74](./image/tip74.png)


1. 如果使用`/a.k.a`,则匹配到的是`backward`
  1. 因为`.`是特殊字符，能匹配任意一个字符
  2. 查找到`backward`之后按`n`建也能跳到`a.k.a`
2. 或者直接转义搜`/a\.k\.a`
3. 启用**very nomagic**模式匹配`/\Va.k.a` 可以直接搜，比上面的方便

|上一篇|下一篇|
|:---|---:|
|[技巧73： 使用`\v`模式进行正则表达式查找](tip73.md)|[技巧75: 使用`()`获取子匹配](tip75.md)|


# 技巧75: 使用圆括号`()`获取子匹配
> 如果我们需要获取查找模式匹配的部分字符串，可以使用子匹配
> 子匹配和替换模式经常搭配使用：匹配某个短语，只保留其中的某一个子匹配

### 例子：去除文本中连续出现的单词
![tip75](./image/tip75.png)

1. `/\v<(\w+)\_s+\1>`可以完成需求
  1. 上面命令中`\1`就是第一个圆括号之间匹配到的内容，表示`匹配一个单词(\w+)之后再匹配一些空格(\_s),然后再匹配前一个单词`
  2. 子匹配最多可以有9个`\1`->`\9`
  3. `\0`表示整个匹配
  4. `<`和`>`是用来匹配单词边界，可以防止**`the the`sis**被错误匹配到，`> <`本身不匹配字符，但是可以表示前、后只单词的边界（前后是空格、文章的开头、结尾什么的）

|上一篇|下一篇|
|:---|---:|
|[技巧74：完全匹配字符串时，使用`\V` 查找](tip74.md)|[技巧76: `<`,`>`界定单词边界](tip76.md)|


# 技巧76： 使用`<`,`>`界定单词边界

### 例子：查找句子中单词`the`的所有出现地方
![tip76.md](./image/tip76.png)

1. `/the` 会错误的匹配`these`, `their`
2. `/v<the>` 可以正确匹配到所有单词the
  1. 在very magic 模式下，`<`, `>`表示单词边界
  2. `<`,`>`是`零宽度元字符`, 本身不匹配字符，仅表示**单词与围绕此单词的空白字符（或者标点符号）之间的边界**
  3. **注意：** 如果在very magic 模式下面需要匹配`<`,`>`，则需要转义(`/\v\<`)


### 补充：使用圆括号`()`但是不捕获
#### 例子：讲文本中所有的（姓+名）的形式替换成(名，姓)的形式
>假设作者叫 feipi zhe, 或者 hanpi zhe, 也就是 `((fei|han)pi zhe)`能匹配所有的名字
1. 按顺序执行下面2条指令即可
  1. `/\v(%(fei|han)pi) (zhe)`
  2. `:%s//\2,\1/g`
2. 说明：`%`表示不匹配后面的括号， 所以`\1`指的是`(%(fei|han)pi)`,`\2`指的是`(zhe)`

|上一篇|下一篇|
|:---|---:|
|[技巧75：使用圆括号`()`获取子匹配](tip75.md)|[技巧77: 界定匹配的边界(`\zs`,`\ze`的使用)](tip77.md)|


# 技巧77 界定匹配的边界（使用`\zs`, `\ze`）
> 如果我们高亮所有`three apples`中的apples，不高亮three，也不高亮其他apple，怎么办？
> `\zs`,`\ze`可以帮我处理这种情况！

1. `\zs`,`\ze`和`<`,`>`类似，都是very magic模式（`\v`)下面的`零宽度元字符`

### 例子：高亮`Practical Vim`中的`vim`
1. `/Practical Vim` 能匹配并且高亮
  1. 需要在`~/.vimrc`中开启`hlsearch`选项
  2. `Practical`也会一起被高亮，虽然他不需要被高亮！
2. `/\vPractical \zsVim`能匹配并且只高亮`vim`!
  1. `\zs`表示匹配界定的开始，`\ze`表示匹配界定的结束

### 例子： 使用`\zs`,`\ze`微调匹配的结果
> 见附图

![tip77](./image/tip77.png)

|上一篇|下一篇|
|:---|---:|
|[技巧76： 使用`<`,`>`界定单词边界](tip76.md)|[技巧78: 转义字符](tip78.md)|


# 技巧78： 转移问题字符
> 1. `\V`(very nomagic)模式关闭了`.,+*`等字符的特殊含义，但是还有一些字符仍然需要转移
> 2. `/`,`\`,`?` 这几个字符永远都需要转移

1. `/`,`?`字符作为激活查找模式的保留字，如果查找这个字符，则永远都需要转移
2. 转义字符`\`本身也需要转义

### 例子：如何匹配一些奇怪的URL

#### 匹配: `http://vimdoc.net/search?q=/\\`

1. `/\Vhttp://vimdoc.net/search?q=/\\`只能匹配到`http:`
2. `/\Vhttp:\/\/vimdoc.net\/search?q=\/\\`只能匹配到`http://vimdoc.net/search?q=/\`
3. `/\Vhttp:\/\/vimdoc.net\/search?q=\/\\\\` 是正确答案

#### 逆向匹配(`?`): `http://vimdoc.net/search?q=/\\`
1. `?http://vimdoc.net/search?q=/\\` 只能匹配 `http://vimdoc.net/search`
2. `?http://vimdoc.net/search\?q=/\\` 只能匹配 `http://vimdoc.net/search?q=/\`
3. `?http://vimdoc.net/search\?q=/\\\\` 是正确答案


|上一篇|下一篇|
|:---|---:|
|[技巧77： 界定匹配的边界（使用`\zs`, `\ze`）](tip77.md)|[技巧79: 查找命令简介](../chapter13_search/tip79.md)|


# 技巧79： 查找命令入门
> 1. 如何制定查找方向？
> 2. 如何重复上一次查找？方向重复上一次查找？
> 3. 如何重复历史中的某次查找？


1. 普通模式下按`/`进入查找模式，输入完查找字符串后按回车键开始查找(中间可以按`ESC`键退出查找模式，返回普通模式)
2. `/`中输入的查找模式从上往下扫，如果稻苗到文件结尾，会提示类似`已经查找到文件结尾，再从开头继续查找`
3. 普通模式下按`?`进入反向的查找模式
4. 重复上一次查找：输入查找模式后，按`n`继续当前方向查找下一个匹配的地方，`N`反向查找下一个匹配的地方
    1. 如果是`/`的查找模式，`n`查找文本后一处匹配，`N`查找文本前一处匹配
    1. 如果是`?`的查找模式，`N`查找文本后一处匹配，`n`查找文本前一处匹配
5. 重复历史中的查找：输入`/`或`?`进入查找模式后,按`<Up>`或者`<Down>`键来查找历史查找记录，选择需要的查找历史后回车即可继续选中的历史查找



|上一篇|下一篇|
|:---|---:|
|[技巧78： 转移问题字符](../chapter12_match/tip78.md)|[技巧80: 高亮查找匹配](tip80.md)|


# 技巧80： 高亮查找匹配
> vim 可以高亮查找匹配，我们可以定制开启/关闭高亮查找结果

1. 在`~/.vimrc`中设置`set hlsearch`来开启查找模式下的高亮显示
2. 有的时候查找结果会非常多(比如查找了空格， 字母a之类的), 导致满屏全是高亮文本，根本无法继续操作了，这时候`需要临时关闭高亮选项`
    1. 输入`:noh` 或者`:nohlsearch` 来临时关闭高亮选项
    2. 当然，你也可以查找一个根本找不到的字符串来取消高亮(比如`/slfcfwaeihfcqweuif`)
    3. 按键更少的做法是制作快捷键，将`nnoremap <silent> <C-l> :<C-u>nohlsearch<CR><C-l>`加入`~/.vimrc`即可
        1. `<C-l>`在终端（linux or osx) 里面是`清除终端病重绘显示屏`的功能，和`clear`命令效果一样，设置完了只要在vim界面里面按`<C-l>`即可清除高亮
        
        
|上一篇|下一篇|
|:---|---:|
|[技巧79： 查找命令入门](tip79.md)|[技巧81: 在执行查找前预览第一处匹配](tip81.md)|


# 技巧81： 在执行查找前预览第一处匹配

1. 默认情况下我们正在输入查找模式的情况下，vim不会进行查找，只有输入`<CR>`之后才会开始查找
2. 在`~/.vimrc`中添加`set incsearch`后开启增量查找模式
    1. 该模式让vim根据已输入的文本，预览第一处匹配

### 例子：开启增量查找功能后查找`carrot`字符串

![](./image/tip81.png)


1. `增量查找功能`可以快速的查找是否存在某个字符串，对于`检查是否有匹配`的需求非常方便
2. 查找模式下的自动补全
    1. 加入我们需要查找`Antetokounmpo`(字母哥), 然后通过增量查找发现输入`Ante`之后光标已经在`Antetokounmpo`下面了，这个时候我们输入`<C-r><C-w>`可以直接把搜索框里面的内容补全为光标所在的字符串，不需要继续输入其他字符了
        1. 如果是very magic模式查找(`/v`), 则执行上面命令会变成`/vAnteAntetokounmpo`, 不可以！这时候需要先回车(确认当前查找模式),然后重新进入查找模式，直接输入`<C-r><C-w>`
        
|上一篇|下一篇|
|:---|---:|
|[技巧80： 高亮查找匹配](tip80.md)|[技巧82: 统计当前模式的匹配个数](tip82.md)|


# 技巧82： 统计当前模式的匹配个数

#### 执行完查找模式后，输入`:%s///gn`

> 说明
> 1. `g` 表明作用于全局,非当前行
> 2. `%` 表明作用于所有行，`:2,4s///gn`表示作用于2-4行
> 3. `n` 表示不改变（不替换）
> 4. 作用完后会显示类似这样的提示`32 matches on 30 lines`

|上一篇|下一篇|
|:---|---:|
|[技巧81： 在执行查找前预览第一处匹配](tip81.md)|[技巧83: 将光标偏移到查找匹配的结尾](tip83.md)|


# 技巧83： 将光标偏移到查找匹配的结尾
> 我们可以设置在查找模式中每次查找时的光标距离匹配的起始或结尾指定步长的位置

### 例子：将文中所有的`lang`文本替换为全写`language`

![](./image/tip83.png)

1. 使用替换模式可以完成效果：`:%s/lang/language/g`
2. 使用查找模式+`.`模式：
    1. `/lang` 查找第一次出现， 然后输入`e`,`a`, `uage<CR>`, 之后重复按`n.`直到重复出现
    2. 会出问题：`langs`会被替换成`langsuage`,**错误！**
3. 正确的使用查找模式+`.`模式：
    1. `/lang/e` 查找第一次出现，并且光标会移动到匹配的末尾， 之后输入`a`,`uage<CR>`,然后重复`n.`即可
    2. 如果查找的时候只输入了`/lang`,处理到`langs`之后才发现问题。没关系，回退对`langs`的操作，然后输入`//e<CR>`来匹配模式


|上一篇|下一篇|
|:---|---:|
|[技巧82： 统计当前模式的匹配个数](tip82.md)|[技巧84: 对完整的查找匹配进行操作](tip84.md)|
    

# 技巧84： 对完整的查找匹配进行操作
> 如果我们不仅要查找，还需要对匹配的内容进行替换，应该怎么操作？

### 例子： 将xml和xhtml全部变成大写

![](./image/tip84.png)

1. 方法1：每次单独操作
    1. 假设查找到了每个单词，对于XhtmlDocument, 执行`gU3l`或者`3gUl`
        1. `gU3l` 是指向右(`l`)3个字符，将其变成大写(`U`)
        2. `3gUl` 是指重复执行3次`gUl`, `gUl`是指将光标所在字符变成大写后右移光标
2. 方法2：半可重复的操作
    1. `/\vX(ht)?ml\C` 来查找xml和xhtml的所有出现， 对第一次出现，执行`gU//e`,之后重复执行`//<CR>.`
        1. `gU//e` 将光标匹配到的都变成大写，知道查找模式在当前匹配的结束(`e`)
        2. `//.` 中`//`跳到光标结束位置，`.`重复修改操作
        3. 不能用`n`跳到下次位置是因为`gU//e`修改了查找模式每次跳转之后的相对为止为文件结尾(`e`), 不能重复
3. 方法3：可重复操作
    1. `/\vX(ht)?ml\C` 来查找xml和xhtml的所有出现， 之后执行`gUfl`, 后面重复 `n.`
        1. `gUfl` 指将文本变成大写直到字符`l`
        
|上一篇|下一篇|
|:---|---:|
|[技巧83： 将光标偏移到查找匹配的结尾](tip83.md)|[技巧85: 利用查找历史，迭代完成复杂模式](tip85.md)|
    


# 技巧85： 利用查找历史， 迭代完成复杂的模式
> 写一个正则表达式匹配长字符串总是复杂的过程，我们可以利用查找历史迭代的做

### 例子： 匹配所有单引号(`''`)之间的内容，并进行替换

![](./image/tip85.png)

#### 1. 先考虑匹配
1. 错误尝试1： `/\v'.+'`
    1. 结果如下，这是因为`。+`是贪心匹配，总会匹配最长的结果
    ![](./image/tip85_1.png)
2. 错误尝试2: `/\v'[^']+'`
    1. 结果如下，`[^']+`表示匹配非`'`的任意多个字符，但是没有办法区别`doesn't`的`'`
    ![](./image/tip85_2.png)
3. 正确尝试3： `/\v'([^']|'\w)+'`
    1. 可以正确匹配到样例的所有情况
    
#### 2. 匹配+替换结合

1. 执行`/\v'(([^']|'\w)+)'`
2. 执行 `:%s//“\1”/g`
    1. `\1`在命令1中已经被赋值为第一个匹配到的括号内的内容（单引号之间的内容）

#### 3. 一条语句

`:%s/\v'(([^']|'\w)+)'/“\1”/g`

#### 迭代完成

在迭代修改正则表达式匹配的过程中，我们可以通过2种方式利用前一次的结果

1. `/<Up>` 来调用上一次的匹配模式
2. (当正则表达式变得复杂时推荐)普通模式下`q/`调出命令行窗口来显示历史语句， 这样我们可以像修改文件一样来修改上一次的命令

|上一篇|下一篇|
|:---|---:|
|[技巧84： 对完整的查找匹配进行操作](tip84.md)|[技巧86: 查找当前高亮选区中的文本](tip86.md)|
    


# 技巧86： 查找当前高亮选区中的文本
> 如果我们高亮选中了某段文本，怎么快速的在文章中查找该段文本？

1. 普通模式下`*`会查找当前光标所在的文本
2. 如果在可视模式(visual mode) 下， `*` 会增加选中区域到下一次出现
    > ![](./image/tip86.png)
3. 设置键盘映射`vmap X y/<C-R>"<CR>`可以使在可视模式下输入`X`查找被选中的区域
    1. 如果选中区域含有`.*`等特殊字符， 会有问题
    2. `y/<C-r>"<CR>` = `y`(复制选中区域(到无名寄存器)) + `/`(进入查找模式) + `<C-r>"`(将无名寄存器的内容输入进来) + `<CR>`(开始查找)
        1. `<C-r>"`取出无名寄存器的内容
        2. `<C-r>%`取出当前文件名
        3. `<C-r>/`取出上一次查找到模式串（在查找模式下等价于`<Up>`)
        4. `<C-r>+`取出系统粘贴版里面的内容
        
4. 终极版本（我只是看懂大概，语法不懂），将下面的内容复制到vim脚本就可以实现可视模式下按`*`或者`#`来正向、反向查找      

```Shell
xnoremap * :<C-u>call <SID>VSetSearch()<CR>/<C-R>=@/<CR><CR> 
xnoremap # :<C-u>call <SID>VSetSearch()<CR>?<C-R>=@/<CR><CR>
function! s:VSetSearch()
let temp = @s
norm! gv"sy
let @/ = '\V' . substitute(escape(@s, '/\'), '\n', '\\n', 'g') let @s = temp
endfunction
```


    1. `VSetSearch`函数应该是将当期寄存器的内容存放到`@/`寄存器
    2. `/<C-R>=@/<CR>` 搜索`@/`寄存器的字符串
    
    
|上一篇|下一篇|
|:---|---:|
|[技巧85： 利用查找历史， 迭代完成复杂的模式](tip85.md)|[技巧87: 认识替换命令](../chapter14_substitute/tip87.md)|
        

# 技巧87: 结识 substitute 命令
> 替换命令可以选择进行替换的范围

`：[range]s/{pattern}/{string}/[flags]`
1. `{pattern}`表示待替换的字符串的正则表达式
2. `{string}`表示替换成的字符串
3. `[flags]`（标志位）候选有：
  1. `g`表示全局范围执行替换
  2. `c`表示每查找到一处，替换前都需要确认
  3. `n`表示只统计匹配的数量，不进行替换
  4. `e`表示不显示错误提示（没有找到pattern）
  5. `&`表示使用上一次替换模式使用的标志位
4. 在替换域中有一些特殊字符，包括:

|符号|描述|
|:---|:---|
|`\r`|插入换行符|
|`\t`|插入制表符|
|`\\`|插入反斜杠|
|`\1`|插入第一个子匹配（第一个括号包住的内容）|
|`\2`|插入第二个子匹配（最多到`\9`）|
|`\0`|插入匹配模式的所有内容|
|`&`|插入匹配模式的所有内容|
|`~`|使用上一次调用`替换命令`时的{string}|
|`\={Vim Script}|执行{Vim Script}表达式：并将返回的结果作为替换{string}|


5. 更多的实例操作参考[技巧92](tip92.md)、[技巧93](tip93.md)
6. `\={Vim script}`的使用方式见[技巧94](tip94.md)、[技巧95](tip95.md)
    
    
|上一篇|下一篇|
|:---|---:|
|[技巧86：查找当前高亮选区中的文本](../chapter13_search/tip86.md)|[技巧88: 在文件范围内查找并替换每一处匹配](tip88.md)|
        


# 技巧88: 在文件范围内查找并替换每一处匹配

> 1. 不加任何标志位的substitue命令只会替换当前行、只替换第一处匹配
> 2. `g`标志位对文件的全部内容进行替换（`global`)

### 例子：将`going`替换为`rolling`
> 将下述文本中的`going`替换为`rolling`
> ![](./image/tip88-1.png)

1. 不加任何标志位，只替换第一次匹配处：
> ![](./image/tip88-2.png)

2. `g`标志位将当前行（光标所在行）所有的匹配都替换：
> ![](./image/tip88-3.png)

3. 添加`%`前缀表示在每一行都执行该替换操作：
> ![](./image/tip88-4.png)


|上一篇|下一篇|
|:---|---:|
|[技巧87：结识 substitute 命令](tip87.md)|[技巧89: 手动控制每一次替换操作](tip89.md)|


# 技巧89: 手动控制每一次替换操作
> `c`标志位表示每处替换前都需要确认

### 例子：将`content`替换成`copy`
执行：
```
:%s/content/copy/gc
```
1. 引入`c`标志位后，每次替换前会提示`替换为copy？`，然后按`y`表示替换，按`n`表示不替换/跳过，全部的选项含有：

|选项|含义|
|:---|:---|
|`y`|替换当前匹配|
|`n`|忽略当前匹配|
|`q`|退出替换过程|
|`l`|（last）替换此处匹配后退出|
|`a`|（all）替换此处与之后所有的匹配|
|`<C-e>`|向上滚动屏幕|
|`<C-y>`|向下滚动屏幕|

2. 执行`:h :s_c`可以在vim文档中查询上述信息
3. 替换-确认模式下，大部分按键都会失效，需要按`<Esc>`键退出
    1. 有的时候点模式更好用，大家依赖经验选择


|上一篇|下一篇|
|:---|---:|
|[技巧88：在文件范围内查找并替换每一处匹配](tip88.md)|[技巧90: 重用上次的查找模式](tip90.md)|


# 技巧90: 重用上次的查找模式
> 将替换命令的查找与留空，意味着使用上一次的查找模式，有时可以精简工作

1. `:%s/\v'(([^']|'\w)+)'/“\1”/g`等价于两条命令：`/\v'(([^']|'\w)+)'`和`:%s//“\1”/g`
    1. `\v`表示`<Tab>`键，`\w`表示非空字符，`[^']`表示非`'`的字符
    
2. 我们也可以在可视模式中**选中待查找文本，然后执行`*`键来激活查找部分**，之后再使用`:%s//“\1”/g`来替换

3. `:%s/\n/,/g`：该命令把所有的换行符都替换为逗号，最终形成一行。

3. `:%s/<C-r>//“\1”/g`:该命令把上次查找到的内容加上左右双引号。`<C-r>`表示复制上次的查找内容进来

|上一篇|下一篇|
|:---|---:|
|[技巧89: 手动控制每一次替换操作](tip89.md)|[技巧 91: 用寄存器的内容替换](tip91.md)|


# 技巧 91: 用寄存器的内容替换
> 输入替换命令时，可以直接复制寄存器里面的内容，省的打字了

1. `:%s//<C-r>0/g` 替换文本为`寄存器0`里面的内容
2. 替换命令里面**查找域**可以为空（使用上次查找命令的模板），但是**替换域**不能为空
3. `:%s//\=@0/g`含义：
    1. `\=`指向后面是表达式脚本，`@0`表示返回寄存器0内的内容
    2. 如果是单纯`@`（后面不接数字），表示的是无名寄存器的内容
    
    
### 例子：使用寄存器实现替换命令

`:%s/Pragmatic Vim/Practical Vim/g`等价于下面3条命令：
```angular2html
:let @/='Pragmatic Vim'
:let @a='Practical Vim'
:%s//\=@a/g
```
1. 第一条命令采用编程方式输入查找模式，等同于执行`/Pragmatic Vim<CR>`，但是不会在查找历史中留下记录
2. 第二条命令表示设置寄存器a的内容，等同于高亮选中`Practical Vim`并执行`"ay`
3. 第三条命令表示最终的替换命令
4. 2种实现方式的区别在于，过一段时间执行，前者还是能够重复，后者只是执行`:%s//\=@a/g`，寄存器a的内容可能变了，替换的结果可能很不一样



|上一篇|下一篇|
|:---|---:|
|[技巧90: 重用上次的查找模式](tip90.md)|[技巧92: 重复上一次 substitute 命令](tip92.md)|
        


# 技巧92: 重复上一次 substitute 命令
> 有时（之前执行错了、另一个缓冲区中再执行一遍）我们需要重复执行替换命令，可以使用一些快捷方式加速

### 例子：在全局范围内执行替换操作

>假设我们想把所有的`target`替换为`replacement`，但是错误执行了`:s/target/replacement/g`。

后续我们只需要执行`g&`即可达到效果。


1. `g&`等价于`:%s//~/&`，用同样的标志位、同样的替换字符串、同样的查 找模式以及新的执行范围 %，重复上一次 substitute 命令
2. 之后遇到除了没加`%`之外，其他都对的替换命令时，之后执行`g&`即可


### 例子： 对部分区域执行替换操作
> 假设我们需要下面第二个`applyName....`的子块中的`Name`字符串替换为`Number`
> ![](./image/tip92.png)

1. 如果我们执行`:%s/Name/Number/g`，会**错误的**把所有的`Name`替换成`Number`
2. 发生上述错误后，我们使用`u`回退，然后高亮选中第二个子块，最后执行`:'<,'>&&`即可
    1. `:&&`中第一个`&`是一个Ex命令，表示重复上一次替换命令；第二个`&`表示重复上一次替换命令的标志位
    2. 选中模式中已选择部分区域后，按`:`会自动进入`:'<,'>`,其中`'<`表示光标选中的第一行，`'>`表示光标选中
    3. 类似的，`:%&&`表示作用于整个文件

|上一篇|下一篇|
|:---|---:|
|[技巧91: 用寄存器的内容替换](tip91.md)|[技巧93: 使用子匹配重排CSV文件的字段](tip93.md)|
        


# 技巧93: 使用子匹配重排CSV文件的字段
> 本节介绍替换命令中：在替换域中使用查找模式的子匹配(减少替换域中的代码)

### 例子：交换csv文件的字段次序

> 交换这些字段的次序，即把电子邮箱放到首列，其次是名字，最后一列为姓氏

> ![](./image/tip93.png)

执行2条指令即可：`/\v^([^,]*),([^,]*),([^,]*)$`、`:%s//\3,\2,\1`

1. `[^,]`表示匹配除`,`外的字符
2. `([^,]*)`表示匹配连续多个非`,`外的字符，并且将捕获的结果作为子匹配（子匹配就是一对小括号包含的内容）
3. `\1`,`\2`,`\3`表示第1、2、3个子匹配，在本例中分别指姓氏、名字和邮箱


|上一篇|下一篇|
|:---|---:|
|[技巧92: 重复上一次 substitute 命令](tip92.md)|[技巧94: 在替换过程中执行算术运算](tip94.md)|


# 技巧94: 在替换过程中执行算术运算 
> 替换命令中的替换域不一定是简单的字符串，也可以是Vim脚本/表达式

### 例子: 将每一级HTML标签的层级都提升一级
> ![](./image/tip94.png)

1. 步骤1：执行`/\v\<\/?h\zs\d`查找
    1. `\zs`表示设置匹配的开始位置。也就是说，虽然是查找`<h1`,`</h2`,但是匹配的结果会抛弃`\zs`之前的内容，也就是匹配的结果只是`1`,`2`
2. 步骤2：`:%s//\=submatch(0)-1/g` 将匹配的数字都减一


|上一篇|下一篇|
|:---|---:|
|[技巧93: 使用子匹配重排CSV文件的字段](tip93.md)|[技巧95: 交换两个或更多的单词](tip95.md)|


# 技巧95: 交换两个或更多的单词
> 使用表达式寄存器+Vim脚本中的字典数据结构，对多个单词进行互换

### 例子: 交换`dog`和`man`
> ![](../../images/tip94.png)

1. 错误解决方案：执行2条指令`:%s/dog/man/g`、`:%s/man/dog/g`
    1. 第一条指令执行完后，会有2个`man`，再执行第二条会错误
2. 使用字典的解决方案：
    0. 实验vim的字典：`:let swapper={"dog":"man","man":"dog"}`
        1. 执行完后可以查询字典：`:echo swapper["dog"]`，`:echo swapper["man"]`
    1. 解决方案part1：`/\v(<man>|<dog>)`
    2. 解决方案part2：`:%s//\={"dog":"man","man":"dog"}[submatch(1)]/g`

|上一篇|下一篇|
|:---|---:|
|[技巧94: 在替换过程中执行算术运算 ](tip94.md)|[技巧96: 在多个文件中执行查找与替换](tip96.md)|


# 技巧96: 在多个文件中执行查找与替换
> vim 本身没有提供跨文件的替换命令，我们可以通过命令组合间接实现

### 例子：将每个文件中的`Pragmatic Vim`替换为`Pragmatic Practical`

解决步骤：
1. 在一个文件中执行：`/Pragmatic\ze Vim`和`:%s//Practical/g`
2. 将所有待处理文件加入到参数列表：`:args **/*.txt`
3. 执行：`:set hidden` (允许在有未保存的修改时切换缓冲区)
4. 执行：`:argdo %s//Practical/g` 对缓冲区中的每个文件执行替换操作
    1. 如果有的文件并不能找到替换的地方，则会报"找不到模式"的提示，可以使用`:argdo %s//Practical/ge`来忽略提示

另一种解决方法（假设所有待替换的文件都已经在vim的缓冲区列表中了）：
```angular2html
// 当前文件中进行查找
/Pragmatic\ze Vim
// 对缓冲区
:vimgrep /<C-r>// **/*.txt
:Qargs
:argdo %s//Practical/g
:argdo update
```

|上一篇|下一篇|
|:---|---:|
|[技巧95: 交换两个或更多的单词](tip95.md)|[技巧97: 结识 global 命令](../chapter15_global_cmd/tip97.md)|


# 技巧97: 结识 global 命令
> global命令允许在指定模式上的所有匹配运行Ex命令

`:[range] global[!] /{pattern}/ [cmd]`

1. `:global`命令的作用范围默认是整个文件（`%`）
    1. 其他Ex命令(删除、替换命令)缺省的作用范围是当前行
2. `{pattern}`域与查找历史相关联，留空则使用之前的查找模式
3. `[cmd]`可以是除`:global`命令之外的任何Ex命令
4. 将`:global`替换为`:global!`或者`:vglobal`(v表示invert)，表示在没有匹配`{pattern}`的行上执行`[cmd]`操作

|上一篇|下一篇|
|:---|---:|
|[技巧96: 在多个文件中执行查找与替换](../chapter14_substitute/tip96.md)|[技巧98: 删除所有包含模式的文本行](tip98.md)|


# 技巧98: 删除所有包含模式的文本行 
> 介绍`:global`命令和`:delete`命令复合使用

### 例子: 删除html中的标签，只保留文本
> ![](./image/tip98.png)

执行2条命令即可：`/\v\<\/?\w+>`,`:g//d`

1. 第一条命令匹配所有的html tag
2. 第二条命令对所有的匹配进行删除操作(`d`)


`:v/href/d`表示删除所有不包含`href`的文本行，其中的`:v`表示`:vglobal`

> `grep`命令的来源
>> `:g/re/p` g表示全局执行；re表示 regular expression；p表示print

|上一篇|下一篇|
|:---|---:|
|[技巧97: 结识 global 命令](tip97.md)|[技巧99: 将 TODO 项收集至寄存器](tip99.md)|


# 技巧99: 将 TODO 项收集至寄存器
> `:global`和`:yank`结合可以把匹配的文本存到寄存器中

### 例子：收集代码中的`TODO`项

> ![](./image/tip99.png)

操作步骤：
```angular2html
// 将寄存器a的内容清空
qaq
// 查看一下当前寄存器a的内容
:reg a
// 将包含 TODO 注释的行复制到此寄存器; A表示将匹配的结果附加到寄存器a后，而不是每次附加的时候清空寄存器a的内容
:g/TODO/yank A
// 查看一下当前寄存器a的内容
:reg a
// 再打开一个新的缓冲区
// 在新的缓冲区中执行下面指令，将寄存器a中的内容复制到缓冲区
"ap
```

另一种解决方式：`:g/TODO/t$`
1. `:t` 的用法见[技巧29](../../part1_pattern/chapter5_ex_mode/tip29.md),，表示**复制到**，`:t$`表示**复制到最后一行**
2. 此条命令把所有含有**TODO**的行提取出来放到文本的最后


|上一篇|下一篇|
|:---|---:|
|[技巧98: 删除所有包含模式的文本行 ](tip98.md)|[技巧100: 将 CSS 文件中所有规则的属性按照字母排序](tip100.md)|


# 技巧100: 将 CSS 文件中所有规则的属性按照字母排序

### 例子：将 CSS 文件中所有规则的属性按照字母排序

> ![](./image/tip100.png)

#### 解决方案1：每一个`{}`子块执行一次
先可视模式选中`{}`内的内容，然后调用vim内置的sort函数：
> ![](./image/tip100-1.png)
1. 对于其他的子块，重复执行即可

#### 解决方案2：使用global命令排序

执行`:g/{/ .+1,/}/-1 sort`即可

1. 该命令分为`:g`,`/{/`,` .+1,/}/-1 sort`三部分，分别表示使用global命令、查找的是`{`这个符号，以及对匹配的位置使用的Ex命令
2. `.+1,/}/-1 sort`是执行的Ex命令：
    1. `.`表示的是当前行，`.+1`表示的是下一行
    2. `/}/`表示的是后面第一个`}`所在的行, `/}/-1`表示后面第一个`}`所在的下一行
    3. 该命令表示从`.+1`行到`/}/-1`行执行`sort`命令
    
### 例子：对`{}`内包含的每一行向右缩进

执行`:g/{/ .+1,/}/—1 >`即可

> `:>`命令每次执行会有提示（`:sort`命令不会有提示），所以可以先执行`:silent`取消提示信息


|上一篇|下一篇|
|:---|---:|
|[技巧99: 将 TODO 项收集至寄存器](tip99.md)|[技巧101: 结识ctags](../../part6_tools/chapter16_ctags/tip101.md)|


# 技巧101: 结识ctags 
> 介绍安装tags、ctags生成的文件分析

### 安装 ctags

```angular2html
// ubuntu:
sudo apt-get install exuberant-ctags
// OSX:
brew install ctags
// 检查ctags是否安装完毕：
ctags --help
```

### 例子：分析ctags生成的标签的文件

1. 执行下述命令：
```angular2html
ls
ctags *
ls
```
> ![](./image/tip101.png)

2. vim查看一下生成的`tags`标签文件：
> ![](./image/tip101-1.png)

> 1. 标签文件的前几行为元数据; 后面每行为关键字、文件名、关键字在源码中的位置这3项构成
>> 1. 关键字按照字母序排列，vim可以通过二分查找定位关键字
> 2. ctags使用模式定位关键字，而不是行号
>> 1. 优点在于避免添加文本导致的关键字位置错误
> 3. 关键字`c`表示类，`f`表示函数

|上一篇|下一篇|
|:---|---:|
|[技巧100: 将 CSS 文件中所有规则的属性按照字母排序](../../part5_pattern/chapter15_global_cmd/tip100.md)|[技巧102: 配置 Vim 使用 ctags](tip102.md)|


# 技巧102: 配置 Vim 使用 ctags 
> 如何告诉vim找标签文件

#### 查看vim是从哪里找标签文件的：`:set tags?`

#### 例子：vim中生成标签文件

`:!ctags -R`
> 该命令从单曲工作目录开始，遍历所有子目录，为每个文件建立索引文件

### 例子：每次保存文件时自动更新ctags

`:autocmd BufWritePost * call system("ctags -R")`

**可以通过版本控制工具的回调机制自动执行ctags**
> Tim Pope 的《Effortless Ctags with Git》，讲解了如何为 post-commit、post-merge 以及 post-checkout等事件建立回调机制


#### ctags 更新策略
1. 手动更新：容易忘记
2. 每次保存缓冲区时通过自动命令更新：对于大工程，更新ctags的速度慢，导致卡顿
3. 每次commit代码的时候自动更新：正在修改的文件可能无法正确跳转，但是当前正在开发的代码是最不可能用于标签跳转的。对于前面2种更新策略是一种折中

|上一篇|下一篇|
|:---|---:|
|[技巧101: 结识ctags](tip101.md)|[技巧 103: 使用 Vim 的标签跳转命令，浏览关键字的定义](tip103.md)|


# 技巧 103: 使用 Vim 的标签跳转命令，浏览关键字的定义 
> ctags将代码中的关键字变成某种超链接，使用`<C-]>`和`g<C-]>`及相应的Ex命令跳转

### 例子：跳转到关键字的定义处
2个例子：
> ![](./image/tip103-1.png)
> ![](./image/tip103-2.png)

按照以上方式浏览代码库时，vim会维护一个标签历史列表，`<C-t>`充当【后退按钮】角色。
> 当例子2结束后：光标会从 Speaker 的定义处回到 Anglophone 的定义处；再按一次的话，光标会回到原位。

### 例子：从函数调用跳转到定义处
> ![](./image/tip103-3.png)
对于前面的例子，知道Speaker和Anglophone都定义了speak函数，当光标在上述位置时，调用`<C-]>`命令，光标会自动跳到Anglophone的speak函数定义，而不是Speaker的speak函数。
> 这是因为vim优先查找缓冲区的标签，而Anglophone在更近的时间点搜索过


#### `g<C-]>`与`<C-]>`的区别
1. 如果当前关键字只有一处匹配，两者一样
2. 如果有多处匹配，前者会提供候选列表让我们选择
3. 对于不能选择的后者，当我们发现跳转错误了，使用`:tselect`调出标签匹配列表进行回溯；或者使用`:tnext`直接跳转到下一处匹配（也可以使用`:tprev`,`:tfirst`,`:tlast`进行切换）

#### 使用Ex命令进行跳转
1. `:tag {keyword}`与`:tjump {keyword}`等同于`<C-]>`与`g<C-]>`
2. 当vim为标签文件提供tab补全功能的时候，只需要输入`:tag Fran<Tab>`, Vim就会把内容扩展成完整的Francophone
3. `:tjump /phone$`会列出所有以`phone`结尾的关键字：
> ![](./image/tip103-4.png)

|上一篇|下一篇|
|:---|---:|
|[技巧102: 配置Vim使用ctags](tip102.md)|[技巧 104: 不用离开 Vim 也能编译代码](../chapter17_compile/tip104.md)|


# 技巧 104: 不用离开 Vim 也能编译代码
> vim 提供了快速跳转到出错位置的方法

1. `make`命令在shell中编译
2. `:make`在vim中调用编译
> 和系统的`make`输出一样，但是vim会做一些分析，列出其中的错误信息。对于错误信息，会在 quickfix 列表中为其创建一项记录。
> 1. 使用`:cnext`跳转到quickfix列表的下一处出错位置

|上一篇|下一篇|
|:---|---:|
|[技巧 103: 使用 Vim 的标签跳转命令，浏览关键字的定义 ](../chapter16_ctags/tip103.md)|[技巧 105 浏览 Quickfix 列表](tip105.md)|


# 技巧 105 浏览 Quickfix 列表
> 介绍浏览quickfix列表的几种方式

1. `:make`命令产生的错误信息、`:grep``:vimgrep`命令的匹配结果，都会加入quickfix列表中

### 浏览quickfix列表的命令

|命令|用途|
|:---|:---|
|`:cnext`|跳转到下一项|
|`:cprev`|跳转到上一项|
|`:cfirst`|跳转到第一项|
|`:clast`|跳转到最后一项|
|`:cnfile`|跳转到下一个文件的第一项|
|`:cpfile`|跳转到上一个文件的第一项|
|`:cc N`|跳转到第n项|
|`:copen`|打开quickfix窗口|
|`:cclose`|关闭quickfix窗口|

1. 使用`:copen`打开包含quickfix列表的窗口后，可以使用`k`、`j`进行上下滚动


|上一篇|下一篇|
|:---|---:|
|[技巧 104: 不用离开 Vim 也能编译代码](tip104.md)|[技巧 106 回溯以前的 Quickfix 列表](tip106.md)|


# 技巧 106 回溯以前的 Quickfix 列表 
> 更新quickfix表不会覆盖之前的quickfix表，只是把之前的表保存起来，方便我们回溯

1. `:colder`回溯某个版本的quickfix表（vim保存最近10个quickfix表）
2. `:cnewer`回到较新的列表
3. `:colder`和`:cnewer`都支持指定次数。`:5colder`指定之前5次的quickfix列表，`:3cnewer`指定之后的3次

|上一篇|下一篇|
|:---|---:|
|[技巧 105 浏览 Quickfix 列表](tip105.md)|[技巧 107 定制外部编译器](tip107.md)|


# 技巧 107 定制外部编译器
> 介绍如何使用vim的`:make`命令调用任何安装在机器上的编译器

### 例子：在vim中调用nodelint编译js代码
> ![](./image/tip107.png)
1. 安装nodelint：`npm install nodelint -g`
2. 配置‘:make’，使其调用 Nodelint:`:setlocal makeprg=NODE_DISABLE_COLORS=1\ nodelint\ %`
> 1. `%`表示当前文件所在路径
> 2. 该命令相当于在shell中运行的2条指令：`export NODE_DISABLE_COLORS=1`和`nodelint ~/quickfix/fizzbuzz.js`
> 3. nodelint默认采用ANSI 色标编码把错误信息高亮为红色，配置信息`NODE_DISABLE_COLORS=1`将该高亮禁用，（减少特殊字符的输出），可以更容易地解析出错信息

### 例子：用nodelint的输出结果填充quickfix列表

1. `:setglobal errorformat?`查看vim解析`:make`结果的输出格式
2. `:setlocal efm=%A%f\,\ line\ %l\,\ character\ %c:%m,%Z%.%#,%-G%.%#`将输出格式进行改变

### 例子：用一条命令设置‘makeprg’与‘errorformat’
`:compiler nodelint`
相当于执行下述一系列操作：
> ![](./image/tip107.png)


#### `:args $VIMRUNTIME/compiler/*.vim`命令列出了vim自带的编译器插件


|上一篇|下一篇|
|:---|---:|
|[技巧 106 回溯以前的 Quickfix 列表 ](tip106.md)|[技巧 108 不必离开 Vim 也能调用 grep](../chapter18_grep_search/tip108.md)|


# 技巧108 不必离开 Vim 也能调用 grep 
> vim内提供了对`grep`命令的封装，在vim内也可以调用

1. 在shell中调用系统的grep：`grep -n Waldo *`
> 1. `-n`表示打印行号

2. 在vim中调用`:grep Waldo *`, 会创建一个quickfix列表；之后通过`:cnext`与`:cprev`进行切换
> grep的`-i`参数表示不区分大小写


|上一篇|下一篇|
|:---|---:|
|[技巧 107 定制外部编译器](../chapter17_compile/tip107.md)|[技巧 109 定制grep程序](tip109.md)|


# 技巧 109 定制grep程序 
> 介绍如果配置`grepprg`与`grepformat`参数

1. `grepprg`选项负责制定所调用的shell程序
2. `grepformat`选项指示vim如何解析`:grep`命令的结果
> 1. 缺省的设置为：
>> `grepprg="grep -n $* /dev/null"`
>> `grepformat="%f:%l:%m,%f:%l%m,%f %l%m"`
>> 2. `%f`表示文件名，`%l`表示行号，`%m`表示匹配行的文本
>> 3. grepformat可以包含以逗号分隔的多组格式，不过vim将采用第一种格式匹配来自`:grep`的输出结果


### 例子：通过`:grep`调用ack
1. OSX中安装ack：`brew install ack`
2. ack的默认搜索结果会按照不同文件显示在不同的区块：
> ![](./image/tip109.png)
> 使用`ack --nogroup Waldo *`参数可以得到类似grep的结果
3. `:set grepprg=ack\ --nogroup\ $*`可以把`:grep`实际使用的设置为ack
4. `set grepformat=%f:%l:%c:%m`设置打印格式
> `%c`表示列号


|上一篇|下一篇|
|:---|---:|
|[技巧108 不必离开 Vim 也能调用 grep ](tip108.md)|[技巧 110 使用 Vim 内部的 Grep](tip110.md)|


# 技巧 110 使用 Vim 内部的 Grep
> `:vimgrep`运行使用自带的正则表达式引擎，实现跨文件查找

#### `:vim[grep][!] /{pattern}/[g][j] {file} ...`

1. 当一行有多处匹配时，`g`标志位为每一处匹配创建一条记录(默认只会为整行文本创建一项记录)
2. `j`标志位只更新quickfix列表，不跳转到第一处匹配
3. `{file}`域不能为空，可以接受的参数与`:args`命令相同，包括文件名、通配符、反引号表达式以及他们的组合。
> 1. `*`匹配目录下的任意文件
> 2. `**`匹配目录及子目录下的任意文件
> 3. `##`匹配参数列表中的所有文件

### 例子：先在文件内查找，再扩大到整个工程

1. `/\v'(([^']|'\w)+)'`
2. `vim /<C-r>// **`


|上一篇|下一篇|
|:---|---:|
|[技巧 109 定制grep程序](tip109.md)|[技巧 111 结识 Vim 的关键字自动补全](../chapter19_auto_complete/tip111.md)|


# 技巧 111 结识 Vim 的关键字自动补全
> 介绍vim自动补全

#### `<C-p>`或者`<C-n>`可以在插入模式下触发自动补全
两个命令同样可以在补全列表中反向或者正向选择

### 触发Vim自动补全方法总结
除了`<C-p>`和`<C-n>`，其他的自动补全方式，都需要以`<C-x>`开始。
|命令|补全类型|
|:---|:---|
|`<C-n>`|普通关键字|
|`<C-x><C-n>`|当前缓冲区关键字|
|`<C-x><C-i>`|包含文件关键字|
|`<C-x><C-]>`|标签文件关键字|
|`<C-x><C-k>`|字典查找|
|`<C-x><C-l>`|整行补全|
|`<C-x><C-f>`|文件名补全|
|`<C-x><C-o>`|全能(omni)补全|

|上一篇|下一篇|
|:---|---:|
|[技巧 110 使用 Vim 内部的 Grep](../chapter18_grep_search/tip110.md)|[技巧 112 与自动补全的弹出式菜单进行交互](tip112.md)|


# 技巧 112 与自动补全的弹出式菜单进行交互 
> 介绍如何提升自动补全的效果：精简列表使我们快速选择、没有理想候选时快速关闭
> 具体细节查看`:h popupmenu-completion`

1. 不论哪种自动补全命令，出现弹出菜单的时候，都可以用`<C-n>`和`<C-p>`在后续中上下选择；当插入模式下使用`<C-p>`或`<C-n>`，会触发普通关键字自动补全

### 可供弹出式菜单使用的命令
|按键操作|作用|
|:---|:---|
|`<C-n>`|使用来自补全列表的下一个匹配项(next 匹配项)|
|`<C-p>`|使用来自补全列表的上一个匹配项(previous 匹配项)|
|`<Down>`|选择来自补全列表的下一个匹配项|
|`<Up>`|选择来自补全列表的上一个匹配项|
|`<C-y>`|确认使用当前选中的匹配项(yes)|
|`<C-e>`|还原最早输入的文本(从自动补全中 exit)|
|`<C-h>`|从当前匹配项中删除一个字符|
|`<C-l>`|从当前匹配项中增加一个字符|
|`{char}`|中止自动补全并插入字符 {char}|

1. `<C-n>`等价于`<Down>`;`<C-p>`等价于`<Up>`
> 两种区别在于`<Down>`和`<Up>`只会上下移动光标，不会把当前光标的候选添加到文本中；`<C-n>`和`<C-p>`不仅移动光标，还会把候选添加到文本域
> 原则上`<C-n>`与`<C-p>`更好：省的按`<CR>`或`<C-y>`进行确认了

#### 组合键`<C-n><C-p>`
1. `<C-n>`打开补全，并自动填充第一个候选；接着`<C-p>`向上选择上一个候选（相当于回到没有选择候选的状态）
2. 该条组合命令相当于打开自动补全候选，但是不选中任何候选

#### `<C-x><C-o><C-p>`对全能补全的结果进行实时性过滤

#### `<C-x><C-f><C-p>`为文件名补全进行实时性过滤


|上一篇|下一篇|
|:---|---:|
|[技巧 111 结识 Vim 的关键字自动补全](tip111.md)|[技巧 113 掌握关键字的来龙去脉](tip113.md)|


# 技巧 113 掌握关键字的来龙去脉 
> 介绍如何限制自动补全的候选来源
> 本节命令在技巧111中有介绍过

1. `<C-x><C-n>`使用缓冲区的单词做补全候选
2. `<C-x><C-i>`使用引用的其他文件的关键词做候选（`<C-i>`相当于`include`）
> 1. C语音的include、python的import、ruby的require所引用的文件都能实现
> 2. `:set include?`可以查看引用的文件
3. `<C-x><C-]>`使用ctags的索引关键字作为候选

普通补全(`<C-n>`)会把来自于缓冲区列表、包含文件以及标签文件的 单词列表组合在一起生成补全建议。


|上一篇|下一篇|
|:---|---:|
|[技巧 112 与自动补全的弹出式菜单进行交互](tip112.md)|[技巧 114 使用字典中的单词进行自动补全](tip114.md)|


# 技巧 114 使用字典中的单词进行自动补全
> 介绍如何使用字典进行自动补全

1. `<C-x><C-k>`触发基于字典的查找
2. `:set spell`来激活vim的拼写检查


[技巧121](../chapter20_spell_check/tip121.md)介绍了一种通过拼写字典实现自动补全的方式

|上一篇|下一篇|
|:---|---:|
|[技巧 113 掌握关键字的来龙去脉 ](tip113.md)|[技巧 115 自动补全整行文本](tip115.md)|


# 技巧 115 自动补全整行文本 
> 介绍对整行补全的方法

### 例子：复制第二行的内容到文件结尾
> ![](./image/tip115.png)
> ![](./image/tip115-1.png)




|上一篇|下一篇|
|:---|---:|
|[技巧 114 使用字典中的单词进行自动补全](tip114.md)|[技巧 116 自动补全文件名](tip116.md)|


# 技巧 116 自动补全文件名 
> shell中可以使用`<Tab>`来自动补全路径中的目录和文件名；Vim中也有类似的操作(`<C-x><C-f>`)

#### `<C-x><C-f>`自动补全文件名

1. 注意vim维护的是当前的工作目录，而不是当前编辑的缓冲区文件所在的目录

### 例子：自动补全引用的js文件
> 假设文件目录为：
> ![](./image/tip116.png)
> 需要对正在编辑的文件的src的属性值填充为application.js

1. 如果当前在vim中执行`:pwd`返回的结果为`webapp`，则自动补全的内容为相对于webapp文件夹的路径；进而，如果我们恰恰又需要将结果变成`src="js/application.js"`，则需要切换工作目录：
> :cd public

2. 然后执行下面操作即可：
> ![](./image/tip116-1.png)

3. 进行完操作后执行`:cd -`回到原来的工作目录


|上一篇|下一篇|
|:---|---:|
|[技巧 115 自动补全整行文本 ](tip115.md)|[技巧 117 根据上下文自动补全](tip117.md)|


# 技巧 117 根据上下文自动补全
> 介绍全能补全功能

#### `<C-x><C-o>`触发全能补全功能
1. 该功能由专用的文件类型插件实现，需要加载以下配置：
```
set nocompatible
filetype plugin on
```
2. 还需要安装为所用语音实现全能补全功能的插件


### 例子：在css文件中使用全能补全的效果图
> ![](./image/tip117.png)

0. 全能补全的效果如上图所示，当输入ba时，认为是CSS的属性的一部分；当输入完属性名之后，及时我们没有输入任何字，他也会发现是在填属性值，会提示不同于属性名的东西
1. CSS的静态语法特性决定了其非常适合全能补全


|上一篇|下一篇|
|:---|---:|
|[技巧 116 自动补全文件名 ](tip116.md)|[技巧 118 对你的工作进行拼写检查](../chapter20_spell_check/tip118.md)|


# 技巧 118 对你的工作进行拼写检查 
> 启动拼写检查后，Vim将对所有未在拼写文件中出现的单词做标记

### 例子：开启拼写检查
> vim中的文本为`Yoru mum has a moustache.`

1. 执行`:set spell`后，`Yoru`会高亮，一般为红色虚线
2. `[s`和`]s`可以在错误间进行反向和正向跳转
3. 当贯标位于拼错单词之上时，可以通过`z=`命令给出修改建议
> 1. 如果对后续特别有信心，可以直接输入`1z=`,则直接用第一个候选替换
> 2. `2z=`就是直接使用第二个候选替换

### 普通模式下，Vim拼写检查的基本命令

|命令|用途|
|:---|:---|
|`]s`|跳到下一处拼写错误|
|`[s`|跳到上一处拼写错误|
|`z=`|为当前单词提供更正建议|
|`zg`|把当前单词添加到拼写文件中|
|`zw`|把当前单词从拼写文件中删除|
|`zug`|撤销对当前单词的`zg`或`zw`命令|


|上一篇|下一篇|
|:---|---:|
|[技巧 117 根据上下文自动补全](../chapter19_auto_complete/tip117.md)|[技巧 119 使用其他拼写字典](tip119.md)|


# 技巧 119 使用其他拼写字典
> vim的拼写检查支持不同语音的拼写字典

1. `:set spelllang=en_us`设置只使用美式拼法
2. `:set spelllang=en`设置支持所有以英语为母语的地区
3. 如果设置的语言拼写文件没有时，vim会为我们提供下载和安装的方法


|上一篇|下一篇|
|:---|---:|
|[技巧 118 对你的工作进行拼写检查 ](tip118.md)|[技巧 120 将单词添加到拼写文件中](tip120.md)|


# 技巧 120 将单词添加到拼写文件中 
> 手动添加拼写文件

1. `zg`把光标下的单词加到拼写文件中
2. `zw`把光标下的单词从拼写文件中删除
3. 假设我们编辑的是utf8编码的文件，且拼写检查采用的是英语字典，则自定义的单词都被保存到名为`~/.vim/spell/en.utf- 8.add`的文件中

### 例子：为专业术语创建拼写文件
1. vim可以同时指定多个拼写文件，可以维护多份单词列表
2. 下面的例子添加了2个自定义拼写文件：
```angular2html
setlocal spelllang=en_us
setlocal spellfile=~/.vim/spell/en.utf-8.add
setlocal spellfile+=~/books/practical_vim/jargon.utf-8.add
```
3. 对于被拼写检查误判的单词，目前有2种处理方式：既可以通过`2zg`添加到vim属于列表，也可以通过`1zg`添加到缺省的


|上一篇|下一篇|
|:---|---:|
|[技巧 119 使用其他拼写字典](tip119.md)|[技巧 121 在插入模式下更正拼写错误](tip121.md)|


# 技巧 121 在插入模式下更正拼写错误
> 自动补全功能允许不离开插入模式下更正拼写错误

> 场景：刚输入完一行文本（位于行末），发现几个单词之前的地方有拼写错误

1. 解决方案1：（通常做法）切换到普通模式
> 先切换到普通模式，再执行`[s`跳回拼写错误的地方，再用`1z=`更正，最后执行`A`继续行末编辑模式
2. 解决方案2：(利用拼写自动补全)在插入模式下执行`<C-x>s`更正拼写错误


|上一篇|下一篇|
|:---|---:|
|[技巧 120 将单词添加到拼写文件中 ](tip120.md)||


