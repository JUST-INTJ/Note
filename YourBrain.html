<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.1.6/dist/style.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.6.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.6"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.1.6/dist/index.umd.min.js"></script><script>(r => {
          setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[3,4]},"v":"Java 基础","c":[{"t":"heading","d":2,"p":{"lines":[5,6],"f":true},"v":"基础 ","c":[{"t":"heading","d":3,"p":{"lines":[7,8]},"v":"基础中的基础","c":[{"t":"list_item","d":5,"p":{"lines":[9,10]},"v":"基本概念","c":[{"t":"list_item","d":7,"p":{"lines":[10,11]},"v":"JRE与JDK"},{"t":"list_item","d":7,"p":{"lines":[11,12]},"v":"Java 7 和 Java SE 7"},{"t":"list_item","d":7,"p":{"lines":[12,13]},"v":"JDK1.8和Java8"}]},{"t":"list_item","d":5,"p":{"lines":[14,15]},"v":"Object的11个方法","c":[{"t":"list_item","d":7,"p":{"lines":[15,16]},"v":"equals","c":[{"t":"list_item","d":9,"p":{"lines":[16,17]},"v":"<code>常量.equals</code>"},{"t":"list_item","d":9,"p":{"lines":[17,18]},"v":"<code>Objects.equals</code> <strong>推荐</strong>"},{"t":"list_item","d":9,"p":{"lines":[18,19]},"v":"<a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\">hashcode和equals(重要)</a>"}]}]},{"t":"list_item","d":5,"p":{"lines":[20,21]},"v":"面向对象","c":[{"t":"list_item","d":7,"p":{"lines":[21,22]},"v":"封装"},{"t":"list_item","d":7,"p":{"lines":[22,23]},"v":"继承"},{"t":"list_item","d":7,"p":{"lines":[23,24]},"v":"多态","c":[{"t":"list_item","d":9,"p":{"lines":[24,25]},"v":"上转下转"},{"t":"list_item","d":9,"p":{"lines":[25,26]},"v":"深入(JVM内容)","c":[{"t":"list_item","d":11,"p":{"lines":[26,27]},"v":"动态链接"},{"t":"list_item","d":11,"p":{"lines":[27,28]},"v":"非虚方法和虚方法"},{"t":"list_item","d":11,"p":{"lines":[28,29]},"v":"方法重写本质"},{"t":"list_item","d":11,"p":{"lines":[29,30]},"v":"虚方法表"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[31,32]},"v":"Java异常体系"},{"t":"list_item","d":5,"p":{"lines":[33,34]},"v":"常用关键字"},{"t":"list_item","d":5,"p":{"lines":[35,36]},"v":"<a href=\"https://juejin.cn/post/6844903791863529480\">静/非静态内部类</a>","c":[{"t":"list_item","d":7,"p":{"lines":[36,37]},"v":"是否懒加载"},{"t":"list_item","d":7,"p":{"lines":[37,38]},"v":"是否可以创建静态成员"},{"t":"list_item","d":7,"p":{"lines":[38,39]},"v":"能否调用调用外部类静态成员"},{"t":"list_item","d":7,"p":{"lines":[39,40]},"v":"有没有指向外部类的引用<br /><code>外部类类名.this</code>"},{"t":"list_item","d":7,"p":{"lines":[40,41]},"v":"创建方式"}]},{"t":"list_item","d":5,"p":{"lines":[42,43]},"v":"枚举","c":[{"t":"list_item","d":7,"p":{"lines":[43,44]},"v":"本质"},{"t":"list_item","d":7,"p":{"lines":[44,45]},"v":"常见用法"}]},{"t":"list_item","d":5,"p":{"lines":[46,47]},"v":"包装类","c":[{"t":"list_item","d":7,"p":{"lines":[47,48]},"v":"缓存机制","c":[{"t":"list_item","d":9,"p":{"lines":[48,49]},"v":"Integer当数值在-128 ~127时，会将创建的 Integer 对象缓存起来"},{"t":"list_item","d":9,"p":{"lines":[49,50]},"v":"Character当数值在0-~127时，会将创建的Character对象缓存起来"},{"t":"list_item","d":9,"p":{"lines":[50,51]},"v":"因此，整型包装类对象之间值的比较，全部使用 equals 方法比较"}]},{"t":"list_item","d":7,"p":{"lines":[51,52]},"v":"BigDecimal","c":[{"t":"list_item","d":9,"p":{"lines":[52,53]},"v":"浮点数之间的等值判断","c":[{"t":"list_item","d":11,"p":{"lines":[53,54]},"v":"基本数据类型不能用==来比较（精度丢失）"},{"t":"list_item","d":11,"p":{"lines":[54,55]},"v":"包装数据类型不能用 equals 来判断"},{"t":"list_item","d":11,"p":{"lines":[55,56]},"v":"<strong>使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作</strong>"}]},{"t":"list_item","d":9,"p":{"lines":[56,57]},"v":"使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。"},{"t":"list_item","d":9,"p":{"lines":[57,58]},"v":"推荐使用String作为参数传入BigDecimal构造方法"}]},{"t":"list_item","d":7,"p":{"lines":[58,59]},"v":"使用标准","c":[{"t":"list_item","d":9,"p":{"lines":[59,60]},"v":"所有的 POJO 类属性必须使用包装数据类型。"},{"t":"list_item","d":9,"p":{"lines":[60,61]},"v":"RPC 方法的返回值和参数必须使用包装数据类型。"},{"t":"list_item","d":9,"p":{"lines":[61,62]},"v":"所有的局部变量使用基本数据类型。"}]}]},{"t":"list_item","d":5,"p":{"lines":[63,64]},"v":"Arrays.asList","c":[{"t":"list_item","d":7,"p":{"lines":[64,65]},"v":"Arrays.asList()将数组转换为集合后,底层其实还是数组"},{"t":"list_item","d":7,"p":{"lines":[65,66]},"v":"传递的数组必须是对象数组，而不是基本类型。<br /><strong>当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身</strong>"},{"t":"list_item","d":7,"p":{"lines":[66,67]},"v":"使用集合的修改方法:<code>add()、remove()、clear()</code>会抛出异常。<br />Arrays.asList() 方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类,"},{"t":"list_item","d":7,"p":{"lines":[67,68]},"v":"如何正确的将数组转换为ArrayList?","c":[{"t":"list_item","d":9,"p":{"lines":[68,69]},"v":"<code>new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code>(推荐)"},{"t":"list_item","d":9,"p":{"lines":[69,70]},"v":"使用 Java8 的Stream(推荐)"},{"t":"list_item","d":9,"p":{"lines":[70,71]},"v":"使用 Guava(推荐)"},{"t":"list_item","d":9,"p":{"lines":[71,72]},"v":"使用 Apache Commons Collections"},{"t":"list_item","d":9,"p":{"lines":[72,73]},"v":"使用 Java9 的 List.of()方法"}]}]}]},{"t":"heading","d":3,"p":{"lines":[74,75]},"v":"<a href=\"https://www.cnblogs.com/yougewe/p/10125073.html\">反射</a>","c":[{"t":"list_item","d":5,"p":{"lines":[76,77]},"v":"说明"},{"t":"list_item","d":5,"p":{"lines":[77,78]},"v":"原理","c":[{"t":"list_item","d":7,"p":{"lines":[78,79]},"v":"如何获取"},{"t":"list_item","d":7,"p":{"lines":[79,80]},"v":"成员的查找"},{"t":"list_item","d":7,"p":{"lines":[80,81]},"v":"线程安全"},{"t":"list_item","d":7,"p":{"lines":[81,82]},"v":"内存使用（软指针）"},{"t":"list_item","d":7,"p":{"lines":[82,83]},"v":"数据隔离"},{"t":"list_item","d":7,"p":{"lines":[83,84]},"v":"方法执行"}]}]},{"t":"heading","d":3,"p":{"lines":[85,86]},"v":"java泛型","c":[{"t":"list_item","d":5,"p":{"lines":[87,88]},"v":"什么是泛型"},{"t":"list_item","d":5,"p":{"lines":[88,89]},"v":"原理与类型擦除"},{"t":"list_item","d":5,"p":{"lines":[89,90]},"v":"使用方式和场景"},{"t":"list_item","d":5,"p":{"lines":[90,91]},"v":"泛型通配符"},{"t":"list_item","d":5,"p":{"lines":[91,92]},"v":"泛型数组"},{"t":"list_item","d":5,"p":{"lines":[93,94]},"v":"常见问题：","c":[{"t":"list_item","d":7,"p":{"lines":[94,95]},"v":"T ,T extends xxx, ？,？extends xxx <br />和 ？super xxx 的区别？"},{"t":"list_item","d":7,"p":{"lines":[95,96]},"v":"为何不能通过直接通过<code>T[] arr=new T[10]</code>的方式来创建数组<br />如何正确创建泛型数组。"}]}]},{"t":"heading","d":3,"p":{"lines":[97,98]},"v":"String","c":[{"t":"list_item","d":5,"p":{"lines":[99,100]},"v":"String,StringBuilder,StringBuffer 使用场景"},{"t":"list_item","d":5,"p":{"lines":[100,101]},"v":"AbstractStringBilder,建造者"},{"t":"list_item","d":5,"p":{"lines":[101,102]},"v":"synchronized"},{"t":"list_item","d":5,"p":{"lines":[102,103]},"v":"字符串拼接","c":[{"t":"list_item","d":7,"p":{"lines":[103,104]},"v":"编译器优化"},{"t":"list_item","d":7,"p":{"lines":[104,105]},"v":"StringBuilder"}]},{"t":"list_item","d":5,"p":{"lines":[105,106]},"v":"字符串常量池"}]},{"t":"heading","d":3,"p":{"lines":[108,109]},"v":"SPI","c":[{"t":"list_item","d":5,"p":{"lines":[110,111]},"v":"原理","c":[{"t":"list_item","d":7,"p":{"lines":[111,112]},"v":"api"},{"t":"list_item","d":7,"p":{"lines":[112,113]},"v":"spi"}]},{"t":"list_item","d":5,"p":{"lines":[113,114]},"v":"示例","c":[{"t":"list_item","d":7,"p":{"lines":[114,115]},"v":"java spi","c":[{"t":"list_item","d":9,"p":{"lines":[115,116]},"v":"提供的api及使用"},{"t":"list_item","d":9,"p":{"lines":[116,117]},"v":"DriverManager","c":[{"t":"list_item","d":11,"p":{"lines":[117,118]},"v":"mysql自动加载"},{"t":"list_item","d":11,"p":{"lines":[118,119]},"v":"oracle必须手动加载"}]}]},{"t":"list_item","d":7,"p":{"lines":[119,120]},"v":"Spring spi思想","c":[{"t":"list_item","d":9,"p":{"lines":[120,121]},"v":"scan"},{"t":"list_item","d":9,"p":{"lines":[121,122]},"v":"自定义scope"},{"t":"list_item","d":9,"p":{"lines":[122,123]},"v":"自定义标签"}]}]}]},{"t":"heading","d":3,"p":{"lines":[125,126]},"v":"java8新特性","c":[{"t":"list_item","d":5,"p":{"lines":[127,128]},"v":"Stream"},{"t":"list_item","d":5,"p":{"lines":[128,129]},"v":"Function Interface"},{"t":"list_item","d":5,"p":{"lines":[129,130]},"v":"Lambda"},{"t":"list_item","d":5,"p":{"lines":[130,131]},"v":"Optional"},{"t":"list_item","d":5,"p":{"lines":[131,132]},"v":"Data Time-api"}]},{"t":"heading","d":3,"p":{"lines":[133,134]},"v":"语法糖","c":[{"t":"list_item","d":5,"p":{"lines":[135,136]},"v":"双大括号初始化(不推荐)"},{"t":"list_item","d":5,"p":{"lines":[136,137]},"v":"try-with-resources(针对io资源，推荐)"}]}]},{"t":"heading","d":2,"p":{"lines":[138,139],"f":true},"v":"集合 ","c":[{"t":"list_item","d":4,"p":{"lines":[140,141]},"v":"为什么要使用集合"},{"t":"list_item","d":4,"p":{"lines":[141,142]},"v":"HashMap","c":[{"t":"list_item","d":6,"p":{"lines":[142,143]},"v":"1.7","c":[{"t":"list_item","d":8,"p":{"lines":[143,144]},"v":"存储结构：数组+链表"},{"t":"list_item","d":8,"p":{"lines":[144,145]},"v":"扩容机制","c":[{"t":"list_item","d":10,"p":{"lines":[145,146]},"v":"创建新的数组"},{"t":"list_item","d":10,"p":{"lines":[146,147],"f":true},"v":"头插 ","c":[{"t":"list_item","d":12,"p":{"lines":[147,148]},"v":"使用头插可能与缓存的时间局部性原则有关"},{"t":"list_item","d":12,"p":{"lines":[148,149]},"v":"最近访问过的数据下次大概率会再次访问"},{"t":"list_item","d":12,"p":{"lines":[149,150]},"v":"把刚访问过的元素放在链表最前面可以直接被查询到，减少查找次数"}]},{"t":"list_item","d":10,"p":{"lines":[150,151]},"v":"<a href=\"https://juejin.cn/post/6844903554264596487\">resize死循环</a>"},{"t":"list_item","d":10,"p":{"lines":[151,152]},"v":"resize重新计算hash"}]}]},{"t":"list_item","d":6,"p":{"lines":[152,153]},"v":"1.8","c":[{"t":"list_item","d":8,"p":{"lines":[153,154]},"v":"存储结构","c":[{"t":"list_item","d":10,"p":{"lines":[154,155]},"v":"数组+链表+红黑树"},{"t":"list_item","d":10,"p":{"lines":[155,156]},"v":"红黑树结构转换条件","c":[{"t":"list_item","d":12,"p":{"lines":[156,157]},"v":"数组长度64"},{"t":"list_item","d":12,"p":{"lines":[157,158]},"v":"<a href=\"https://juejin.cn/post/6921914880559677447]\">树化阀值8来源</a>"},{"t":"list_item","d":12,"p":{"lines":[158,159]},"v":"退化阀值6"}]}]},{"t":"list_item","d":8,"p":{"lines":[159,160]},"v":"插曲：<a href=\"https://blog.csdn.net/zhichaosong/article/details/88844371\">红黑树由来：2-3树</a>"},{"t":"list_item","d":8,"p":{"lines":[160,161]},"v":"扩容机制","c":[{"t":"list_item","d":10,"p":{"lines":[161,162]},"v":"创建新的数组"},{"t":"list_item","d":10,"p":{"lines":[162,163]},"v":"尾插"},{"t":"list_item","d":10,"p":{"lines":[163,164],"f":true},"v":"<a href=\"https://www.fangzhipeng.com/javainterview/2019/03/11/hashmap-dead-cycle.html\">如何解决的resize死循环</a> ","c":[{"t":"list_item","d":12,"p":{"lines":[164,165],"f":true},"v":"transfer调用 ","c":[{"t":"list_item","d":14,"p":{"lines":[165,166]},"v":"直接将原来transfer()方法中的代码写在自己方法体内，不再调用"}]},{"t":"list_item","d":12,"p":{"lines":[166,167],"f":true},"v":"使用尾插 ","c":[{"t":"list_item","d":14,"p":{"lines":[167,168]},"v":"<strong>扩容后，新数组中的链表顺序依然与旧数组中的链表顺序保持一致</strong>"}]}]},{"t":"list_item","d":10,"p":{"lines":[168,169],"f":true},"v":"<a href=\"https://juejin.cn/post/6844903682664824845\">resize不重新计算hash</a> ","c":[{"t":"list_item","d":12,"p":{"lines":[169,170]},"v":"1.7扩容时需要重新计算哈希值和索引位置"},{"t":"list_item","d":12,"p":{"lines":[170,171]},"v":"1.8并不重新计算哈希值，巧妙地采用和扩容后容量进行&amp;操作来计算新的索引位置。"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[171,172]},"v":"线程不安全","c":[{"t":"list_item","d":8,"p":{"lines":[172,173]},"v":"put的时候导致的多线程数据不一致"}]},{"t":"list_item","d":6,"p":{"lines":[173,174]},"v":"初始化大小"},{"t":"list_item","d":6,"p":{"lines":[174,175]},"v":"扩容时机","c":[{"t":"list_item","d":8,"p":{"lines":[175,176]},"v":"threshold = capacity * loadFactor"},{"t":"list_item","d":8,"p":{"lines":[176,177]},"v":"Size&gt;=threshold"},{"t":"list_item","d":8,"p":{"lines":[177,178]},"v":"<a href=\"https://www.cnblogs.com/aspirant/p/11470928.html\">loadFactor 0.75来源</a>"}]},{"t":"list_item","d":6,"p":{"lines":[178,179]},"v":"put流程"},{"t":"list_item","d":6,"p":{"lines":[179,180]},"v":"容量为什么要2的幂"},{"t":"list_item","d":6,"p":{"lines":[180,181]},"v":"<a href=\"https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow\">遍历方法及性能</a>"},{"t":"list_item","d":6,"p":{"lines":[181,182]},"v":"有什么同步容器/并发容器"},{"t":"list_item","d":6,"p":{"lines":[182,183]},"v":"HashMap,HashTable,ConcurrentHashMap区别","c":[{"t":"list_item","d":8,"p":{"lines":[183,184]},"v":"1.7","c":[{"t":"list_item","d":10,"p":{"lines":[184,185]},"v":"三者数据结构"},{"t":"list_item","d":10,"p":{"lines":[185,186]},"v":"同步机制/锁"},{"t":"list_item","d":10,"p":{"lines":[186,187]},"v":"<code>put(null)</code>"}]},{"t":"list_item","d":8,"p":{"lines":[187,188]},"v":"1.8","c":[{"t":"list_item","d":10,"p":{"lines":[188,189]},"v":"三者数据结构"},{"t":"list_item","d":10,"p":{"lines":[189,190]},"v":"同步机制/锁"},{"t":"list_item","d":10,"p":{"lines":[190,191]},"v":"<code>put(null)</code>"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[191,192]},"v":"TreeMap","c":[{"t":"list_item","d":6,"p":{"lines":[192,193]},"v":"底层结构：红黑树"},{"t":"list_item","d":6,"p":{"lines":[193,194]},"v":"红黑树由来：<a href=\"https://blog.csdn.net/zhichaosong/article/details/88844371\">2-3树</a>","c":[{"t":"list_item","d":8,"p":{"lines":[194,195]},"v":"2-节点,3-节点"},{"t":"list_item","d":8,"p":{"lines":[195,196]},"v":"4-节点分解"},{"t":"list_item","d":8,"p":{"lines":[196,197]},"v":"不平衡时融合"}]}]},{"t":"list_item","d":4,"p":{"lines":[197,198]},"v":"ConcurrentHashMap","c":[{"t":"list_item","d":6,"p":{"lines":[198,199]},"v":"<a href=\"https://www.cnblogs.com/ITtangtang/p/3948786.html\">1.7</a>","c":[{"t":"list_item","d":8,"p":{"lines":[199,200]},"v":"数据结构:分段锁+数组+链表"},{"t":"list_item","d":8,"p":{"lines":[200,201]},"v":"同步机制:","c":[{"t":"list_item","d":10,"p":{"lines":[201,202]},"v":"<strong>segment分段锁</strong> 粒度为一段(几个hash槽)<br />分段锁继承了ReentrantLock"},{"t":"list_item","d":10,"p":{"lines":[202,203]},"v":"尝试获取锁存在并发，竞争，阻塞"}]},{"t":"list_item","d":8,"p":{"lines":[203,204]},"v":"键值对:HashEntry"},{"t":"list_item","d":8,"p":{"lines":[204,205]},"v":"操作","c":[{"t":"list_item","d":10,"p":{"lines":[205,206]},"v":"put"},{"t":"list_item","d":10,"p":{"lines":[206,207]},"v":"size"},{"t":"list_item","d":10,"p":{"lines":[207,208]},"v":"get"}]}]},{"t":"list_item","d":6,"p":{"lines":[208,209]},"v":"<a href=\"https://blog.csdn.net/programmer_at/article/details/79715177\">1.8</a>","c":[{"t":"list_item","d":8,"p":{"lines":[209,210]},"v":"数据结构:数组+链表/红黑树"},{"t":"list_item","d":8,"p":{"lines":[210,211]},"v":"同步机制","c":[{"t":"list_item","d":10,"p":{"lines":[211,212]},"v":"hash槽。减小了加锁粒度"},{"t":"list_item","d":10,"p":{"lines":[212,213],"f":true},"v":"CAS+synchronized ","c":[{"t":"list_item","d":12,"p":{"lines":[213,214]},"v":"CAS失败自旋保证成功"},{"t":"list_item","d":12,"p":{"lines":[214,215]},"v":"再失败就synchronized"}]},{"t":"list_item","d":10,"p":{"lines":[215,216],"f":true},"v":"<a href=\"https://www.cnblogs.com/aspirant/p/8623864.html\">使用synchronized原因</a> ","c":[{"t":"list_item","d":12,"p":{"lines":[216,217]},"v":"锁粒度降低了，synchronized并不比ReentrantLock差"},{"t":"list_item","d":12,"p":{"lines":[217,218]},"v":"synchronized优化空间大"},{"t":"list_item","d":12,"p":{"lines":[218,219]},"v":"大量数据操作，ReentrantLock开销较多内存"}]}]},{"t":"list_item","d":8,"p":{"lines":[219,220]},"v":"键值对：node"},{"t":"list_item","d":8,"p":{"lines":[220,221]},"v":"操作","c":[{"t":"list_item","d":10,"p":{"lines":[221,222]},"v":"put"},{"t":"list_item","d":10,"p":{"lines":[222,223]},"v":"size"},{"t":"list_item","d":10,"p":{"lines":[223,224]},"v":"get"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[224,225]},"v":"<a href=\"https://www.jianshu.com/p/8f4f58b4b8ab\">LinkedHashMap</a>","c":[{"t":"list_item","d":6,"p":{"lines":[225,226]},"v":"结构：HashMap+双向链表"},{"t":"list_item","d":6,"p":{"lines":[226,227]},"v":"两种模式(accessOrder变量)","c":[{"t":"list_item","d":8,"p":{"lines":[227,228]},"v":"插入顺序模式(false)"},{"t":"list_item","d":8,"p":{"lines":[228,229]},"v":"访问顺序模式(true)","c":[{"t":"list_item","d":10,"p":{"lines":[229,230]},"v":"<code>get</code>"},{"t":"list_item","d":10,"p":{"lines":[230,231]},"v":"重排序"}]}]},{"t":"list_item","d":6,"p":{"lines":[231,232]},"v":"扩容:遍历链表"},{"t":"list_item","d":6,"p":{"lines":[232,233]},"v":"实现LRU","c":[{"t":"list_item","d":8,"p":{"lines":[233,234]},"v":"构造器:传入capacity"},{"t":"list_item","d":8,"p":{"lines":[234,235]},"v":"removeEldestEntry:<code>return size() &gt; capacity;</code>"}]}]},{"t":"list_item","d":4,"p":{"lines":[236,237]},"v":"ArrayList","c":[{"t":"list_item","d":6,"p":{"lines":[237,238]},"v":"底层结构：数组"},{"t":"list_item","d":6,"p":{"lines":[238,239]},"v":"初始大小与扩容机制"},{"t":"list_item","d":6,"p":{"lines":[239,240]},"v":"RandomAccess 接口"},{"t":"list_item","d":6,"p":{"lines":[240,241]},"v":"<code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法"},{"t":"list_item","d":6,"p":{"lines":[241,242]},"v":"有什么同步容器/并发容器"},{"t":"list_item","d":6,"p":{"lines":[242,243]},"v":"<strong><a href=\"https://juejin.cn/post/6879291161274482695\">fail-fast、fail-safe机制</a></strong>"}]},{"t":"list_item","d":4,"p":{"lines":[243,244]},"v":"LinkedList","c":[{"t":"list_item","d":6,"p":{"lines":[244,245]},"v":"底层结构：双向链表"}]},{"t":"list_item","d":4,"p":{"lines":[245,246]},"v":"Set","c":[{"t":"list_item","d":6,"p":{"lines":[246,247]},"v":"comparable 和 Comparator 的区别"},{"t":"list_item","d":6,"p":{"lines":[247,248]},"v":"无序性和不可重复性的含义是什么"},{"t":"list_item","d":6,"p":{"lines":[248,249]},"v":"有什么同步容器/并发容器"},{"t":"list_item","d":6,"p":{"lines":[249,250]},"v":"HashMap和HashSet"},{"t":"list_item","d":6,"p":{"lines":[250,251]},"v":"TreeMap和TreeSet"}]},{"t":"list_item","d":4,"p":{"lines":[251,252]},"v":"集合比较问题","c":[{"t":"list_item","d":6,"p":{"lines":[252,253]},"v":"List,Set,Map 三者的区别？"},{"t":"list_item","d":6,"p":{"lines":[253,254]},"v":"Arraylist 和 Vector 的区别?"},{"t":"list_item","d":6,"p":{"lines":[254,255]},"v":"Arraylist 与 LinkedList 区别?"},{"t":"list_item","d":6,"p":{"lines":[255,256]},"v":"ConcurrentHashMap 和 Hashtable 的区别"},{"t":"list_item","d":6,"p":{"lines":[256,257]},"v":"比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"},{"t":"list_item","d":6,"p":{"lines":[257,258]},"v":"HashMap和HashTable区别"},{"t":"list_item","d":6,"p":{"lines":[258,259]},"v":"HashMap与HashSet区别（HashSet底层基于HashMap）"},{"t":"list_item","d":6,"p":{"lines":[259,260]},"v":"HashMap和TreeMap区别"}]}]},{"t":"heading","d":2,"p":{"lines":[261,262],"f":true},"v":"多线程 ","c":[{"t":"list_item","d":4,"p":{"lines":[263,264]},"v":"并发基础","c":[{"t":"list_item","d":6,"p":{"lines":[264,265]},"v":"<a href=\"https://segmentfault.com/a/1190000037589073\">创建线程的方式</a>"},{"t":"list_item","d":6,"p":{"lines":[265,266]},"v":"调用<code>start()</code>和<code>run()</code>方法区别"},{"t":"list_item","d":6,"p":{"lines":[266,267]},"v":"停止线程：interrupt","c":[{"t":"list_item","d":8,"p":{"lines":[267,268]},"v":"原理"},{"t":"list_item","d":8,"p":{"lines":[268,269]},"v":"正确的停止方式"},{"t":"list_item","d":8,"p":{"lines":[269,270]},"v":"错误的停止方式","c":[{"t":"list_item","d":10,"p":{"lines":[270,271]},"v":"被弃用的stop,suspend和resume方法"},{"t":"list_item","d":10,"p":{"lines":[271,272]},"v":"用volatile设置标记位"}]}]},{"t":"list_item","d":6,"p":{"lines":[272,273]},"v":"重要方法","c":[{"t":"list_item","d":8,"p":{"lines":[273,274]},"v":"Object(三个方法都要在synchronized内)","c":[{"t":"list_item","d":10,"p":{"lines":[274,275]},"v":"wait"},{"t":"list_item","d":10,"p":{"lines":[275,276]},"v":"notify"},{"t":"list_item","d":10,"p":{"lines":[276,277]},"v":"notifyAll"}]},{"t":"list_item","d":8,"p":{"lines":[277,278]},"v":"Thread","c":[{"t":"list_item","d":10,"p":{"lines":[278,279]},"v":"sleep"},{"t":"list_item","d":10,"p":{"lines":[279,280]},"v":"join"},{"t":"list_item","d":10,"p":{"lines":[280,281]},"v":"yield"}]}]},{"t":"list_item","d":6,"p":{"lines":[281,282]},"v":"yield和sleep区别"},{"t":"list_item","d":6,"p":{"lines":[282,283]},"v":"java线程状态的切换<br /> 延伸：操作系统进程状态的切换"},{"t":"list_item","d":6,"p":{"lines":[283,284]},"v":"线程属性"},{"t":"list_item","d":6,"p":{"lines":[284,285]},"v":"线程的未捕获异常处理"},{"t":"list_item","d":6,"p":{"lines":[285,286]},"v":"线程组","c":[{"t":"list_item","d":8,"p":{"lines":[286,287]},"v":"结构","c":[{"t":"list_item","d":10,"p":{"lines":[287,288]},"v":"线程组是一个树状的结构，每个线程组下面可以有多个线程或者线程组"},{"t":"list_item","d":10,"p":{"lines":[288,289]},"v":"默认将父线程（当前执行new Thread的线程）线程组设置为自己的线程组。"}]},{"t":"list_item","d":8,"p":{"lines":[289,290]},"v":"线程组的优先级会限制线程的优先级"},{"t":"list_item","d":8,"p":{"lines":[290,291]},"v":"作用","c":[{"t":"list_item","d":10,"p":{"lines":[291,292]},"v":"统一控制线程的优先级"},{"t":"list_item","d":10,"p":{"lines":[292,293]},"v":"检查线程的权限的作用。"},{"t":"list_item","d":10,"p":{"lines":[293,294]},"v":"线程组统一异常处理"}]}]},{"t":"list_item","d":6,"p":{"lines":[294,295]},"v":"常见问题","c":[{"t":"list_item","d":8,"p":{"lines":[295,296]},"v":"并发与并行区别"},{"t":"list_item","d":8,"p":{"lines":[296,297]},"v":"为什么要使用多线程"},{"t":"list_item","d":8,"p":{"lines":[297,298]},"v":"sleep() 方法和 wait() 方法区别和共同点"}]}]},{"t":"list_item","d":4,"p":{"lines":[299,300]},"v":"并发编程三大特性","c":[{"t":"list_item","d":6,"p":{"lines":[300,301]},"v":"原子性"},{"t":"list_item","d":6,"p":{"lines":[301,302]},"v":"可见性"},{"t":"list_item","d":6,"p":{"lines":[302,303]},"v":"有序性"}]},{"t":"list_item","d":4,"p":{"lines":[304,305]},"v":"JMM","c":[{"t":"list_item","d":6,"p":{"lines":[305,306]},"v":"基础结构"},{"t":"list_item","d":6,"p":{"lines":[306,307]},"v":"JMM与Java内存区域划分的区别与联系"},{"t":"list_item","d":6,"p":{"lines":[307,308]},"v":"原子操作"},{"t":"list_item","d":6,"p":{"lines":[308,309]},"v":"重排序","c":[{"t":"list_item","d":8,"p":{"lines":[309,310]},"v":"组成","c":[{"t":"list_item","d":10,"p":{"lines":[310,311]},"v":"编译器优化重排"},{"t":"list_item","d":10,"p":{"lines":[311,312]},"v":"指令并行重排"},{"t":"list_item","d":10,"p":{"lines":[312,313]},"v":"内存系统重排"}]},{"t":"list_item","d":8,"p":{"lines":[313,314]},"v":"编程规则","c":[{"t":"list_item","d":10,"p":{"lines":[314,315]},"v":"as-if-serial"},{"t":"list_item","d":10,"p":{"lines":[315,316]},"v":"happens-before"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[317,318]},"v":"volatile","c":[{"t":"list_item","d":6,"p":{"lines":[318,319]},"v":"保证内存可见性","c":[{"t":"list_item","d":8,"p":{"lines":[319,320]},"v":"说明"},{"t":"list_item","d":8,"p":{"lines":[320,321]},"v":"原理:<br /> MESI缓存一致性协议<br /> cpu总线嗅探机制<br /> lock"},{"t":"list_item","d":8,"p":{"lines":[321,322]},"v":"总线风暴"}]},{"t":"list_item","d":6,"p":{"lines":[322,323]},"v":"禁止重排序","c":[{"t":"list_item","d":8,"p":{"lines":[323,324]},"v":"说明"},{"t":"list_item","d":8,"p":{"lines":[324,325]},"v":"原理:<br />内存屏障"}]},{"t":"list_item","d":6,"p":{"lines":[325,326]},"v":"不保证原子性：","c":[{"t":"list_item","d":8,"p":{"lines":[326,327]},"v":"原因"},{"t":"list_item","d":8,"p":{"lines":[327,328]},"v":"解决","c":[{"t":"list_item","d":10,"p":{"lines":[328,329]},"v":"synchronized"},{"t":"list_item","d":10,"p":{"lines":[329,330]},"v":"Atomic(CAS)"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[331,332]},"v":"锁的变迁","c":[{"t":"list_item","d":6,"p":{"lines":[332,333]},"v":"jdk1.5之前:synchronized重量锁"},{"t":"list_item","d":6,"p":{"lines":[333,334]},"v":"jdk1.5","c":[{"t":"list_item","d":8,"p":{"lines":[334,335]},"v":"原因"},{"t":"list_item","d":8,"p":{"lines":[335,336]},"v":"变化:增加","c":[{"t":"list_item","d":10,"p":{"lines":[336,337]},"v":"Lock锁"},{"t":"list_item","d":10,"p":{"lines":[337,338]},"v":"并发容器"},{"t":"list_item","d":10,"p":{"lines":[338,339]},"v":"线程池"}]},{"t":"list_item","d":8,"p":{"lines":[339,340]},"v":"依据原理","c":[{"t":"list_item","d":10,"p":{"lines":[340,341]},"v":"Atomic--UnSafe--CAS"},{"t":"list_item","d":10,"p":{"lines":[341,342]},"v":"AQS"},{"t":"list_item","d":10,"p":{"lines":[342,343]},"v":"LockSupport"},{"t":"list_item","d":10,"p":{"lines":[343,344]},"v":"volatile"}]}]},{"t":"list_item","d":6,"p":{"lines":[344,345]},"v":"jdk1.6","c":[{"t":"list_item","d":8,"p":{"lines":[345,346]},"v":"变化:synchronized锁的升级"},{"t":"list_item","d":8,"p":{"lines":[346,347]},"v":"原因"}]},{"t":"list_item","d":6,"p":{"lines":[347,348]},"v":"jdk1.8:增加StampedLock"}]},{"t":"list_item","d":4,"p":{"lines":[349,350]},"v":"synchronized","c":[{"t":"list_item","d":6,"p":{"lines":[350,351]},"v":"3种使用方法","c":[{"t":"list_item","d":8,"p":{"lines":[351,352]},"v":"代码块","c":[{"t":"list_item","d":10,"p":{"lines":[352,353]},"v":"自己指定对象锁"},{"t":"list_item","d":10,"p":{"lines":[353,354]},"v":"底层原理：","c":[{"t":"list_item","d":12,"p":{"lines":[354,355]},"v":"monitorenter"},{"t":"list_item","d":12,"p":{"lines":[355,356]},"v":"monitorexit"},{"t":"list_item","d":12,"p":{"lines":[356,357]},"v":"程序计数器"}]}]},{"t":"list_item","d":8,"p":{"lines":[357,358]},"v":"成员方法","c":[{"t":"list_item","d":10,"p":{"lines":[358,359]},"v":"this对象锁"},{"t":"list_item","d":10,"p":{"lines":[359,360]},"v":"底层原理：ACC_SYNCHRONIZED"}]},{"t":"list_item","d":8,"p":{"lines":[360,361]},"v":"静态方法","c":[{"t":"list_item","d":10,"p":{"lines":[361,362]},"v":".class类锁"},{"t":"list_item","d":10,"p":{"lines":[362,363]},"v":"底层原理：ACC_SYNCHRONIZED，ACC_STATIC"}]},{"t":"list_item","d":8,"p":{"lines":[363,364]},"v":"注意：构造方法本身就属于线程安全的，不存在同步的构造方法一说。<br />不能加synchronized"}]},{"t":"list_item","d":6,"p":{"lines":[364,365]},"v":"锁的升级(不可逆)","c":[{"t":"list_item","d":8,"p":{"lines":[365,366]},"v":"无锁(CAS)"},{"t":"list_item","d":8,"p":{"lines":[366,367]},"v":"偏向锁","c":[{"t":"list_item","d":10,"p":{"lines":[367,368]},"v":"原理"},{"t":"list_item","d":10,"p":{"lines":[368,369]},"v":"锁的性质"},{"t":"list_item","d":10,"p":{"lines":[369,370]},"v":"对象头中的内容"},{"t":"list_item","d":10,"p":{"lines":[370,371]},"v":"升级过程"}]},{"t":"list_item","d":8,"p":{"lines":[371,372]},"v":"轻量锁","c":[{"t":"list_item","d":10,"p":{"lines":[372,373]},"v":"原理"},{"t":"list_item","d":10,"p":{"lines":[373,374]},"v":"锁的性质"},{"t":"list_item","d":10,"p":{"lines":[374,375]},"v":"对象头中的内容"},{"t":"list_item","d":10,"p":{"lines":[375,376]},"v":"升级过程"}]},{"t":"list_item","d":8,"p":{"lines":[376,377]},"v":"重量锁","c":[{"t":"list_item","d":10,"p":{"lines":[377,378]},"v":"原理"},{"t":"list_item","d":10,"p":{"lines":[378,379]},"v":"锁的性质"},{"t":"list_item","d":10,"p":{"lines":[379,380]},"v":"对象头中的内容"},{"t":"list_item","d":10,"p":{"lines":[380,381]},"v":"阻塞的好处(cpu)与代价(内核态)"}]}]},{"t":"list_item","d":6,"p":{"lines":[381,382]},"v":"synchronized 和 ReentrantLock 的区别","c":[{"t":"list_item","d":8,"p":{"lines":[382,383]},"v":"jvm-api层面"},{"t":"list_item","d":8,"p":{"lines":[383,384]},"v":"是否可中断"},{"t":"list_item","d":8,"p":{"lines":[384,385]},"v":"公平非公平"},{"t":"list_item","d":8,"p":{"lines":[385,386]},"v":"锁绑定多个条件"}]},{"t":"list_item","d":6,"p":{"lines":[386,387]},"v":"synchronized 和 volatile 的区别"}]},{"t":"list_item","d":4,"p":{"lines":[388,389]},"v":"CAS","c":[{"t":"list_item","d":6,"p":{"lines":[389,390]},"v":"乐观锁与悲观锁"},{"t":"list_item","d":6,"p":{"lines":[390,391]},"v":"概念"},{"t":"list_item","d":6,"p":{"lines":[391,392]},"v":"底层原理"},{"t":"list_item","d":6,"p":{"lines":[392,393]},"v":"CAS的应用：UnSafe和Atomic"},{"t":"list_item","d":6,"p":{"lines":[393,394]},"v":"问题","c":[{"t":"list_item","d":8,"p":{"lines":[394,395]},"v":"ABA问题","c":[{"t":"list_item","d":10,"p":{"lines":[395,396]},"v":"AtomicStampedReference"},{"t":"list_item","d":10,"p":{"lines":[396,397]},"v":"AtomicMarkableReference"}]},{"t":"list_item","d":8,"p":{"lines":[397,398]},"v":"循环时间长开销大","c":[{"t":"list_item","d":10,"p":{"lines":[398,399]},"v":"解决思路是让JVM支持处理器提供的pause指令"}]},{"t":"list_item","d":8,"p":{"lines":[399,400]},"v":"只能保证一个共享变量的原子操作","c":[{"t":"list_item","d":10,"p":{"lines":[400,401]},"v":"使用JDK 1.5开始就提供的AtomicReference类保证对象之间的原子性，<br />把多个变量放到一个对象里面进行CAS操作；"},{"t":"list_item","d":10,"p":{"lines":[401,402]},"v":"使用锁。锁内的临界区代码可以保证只有当前线程能操作。"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[403,404]},"v":"AQS","c":[{"t":"list_item","d":6,"p":{"lines":[404,405]},"v":"概念"},{"t":"list_item","d":6,"p":{"lines":[405,406]},"v":"底层","c":[{"t":"list_item","d":8,"p":{"lines":[406,407]},"v":"Unsafe(提供CAS操作)"},{"t":"list_item","d":8,"p":{"lines":[407,408]},"v":"LockSupport(提供park/unpark操作)"}]},{"t":"list_item","d":6,"p":{"lines":[408,409]},"v":"数据结构"},{"t":"list_item","d":6,"p":{"lines":[409,410]},"v":"资源共享模式/同步方式"},{"t":"list_item","d":6,"p":{"lines":[410,411]},"v":"<strong>模版设计模式</strong>"},{"t":"list_item","d":6,"p":{"lines":[411,412]},"v":"源码分析","c":[{"t":"list_item","d":8,"p":{"lines":[412,413]},"v":"获取资源流程"},{"t":"list_item","d":8,"p":{"lines":[413,414]},"v":"释放资源流程"}]},{"t":"list_item","d":6,"p":{"lines":[414,415]},"v":"三个组件","c":[{"t":"list_item","d":8,"p":{"lines":[415,416]},"v":"Semaphore"},{"t":"list_item","d":8,"p":{"lines":[416,417]},"v":"CountDownLatch"},{"t":"list_item","d":8,"p":{"lines":[417,418]},"v":"CyclicBarrier"}]},{"t":"list_item","d":6,"p":{"lines":[418,419]},"v":"其他","c":[{"t":"list_item","d":8,"p":{"lines":[419,420]},"v":"AOS"},{"t":"list_item","d":8,"p":{"lines":[420,421]},"v":"AQLS"}]}]},{"t":"list_item","d":4,"p":{"lines":[422,423]},"v":"Atomic","c":[{"t":"list_item","d":6,"p":{"lines":[423,424]},"v":"组成","c":[{"t":"list_item","d":8,"p":{"lines":[424,425]},"v":"基本类型"},{"t":"list_item","d":8,"p":{"lines":[425,426]},"v":"数组类型"},{"t":"list_item","d":8,"p":{"lines":[426,427]},"v":"引用类型"},{"t":"list_item","d":8,"p":{"lines":[427,428]},"v":"对象的属性修改类型"}]},{"t":"list_item","d":6,"p":{"lines":[428,429]},"v":"AtomicInteger","c":[{"t":"list_item","d":8,"p":{"lines":[429,430]},"v":"示例"},{"t":"list_item","d":8,"p":{"lines":[430,431]},"v":"基本原理"}]}]},{"t":"list_item","d":4,"p":{"lines":[432,433]},"v":"LockSupport","c":[{"t":"list_item","d":6,"p":{"lines":[433,434]},"v":"park底层使用的是<code>UNSAFE.park</code>"},{"t":"list_item","d":6,"p":{"lines":[434,435]},"v":"为什么LockSupport也是核心基础类? AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park/unpark操作)"},{"t":"list_item","d":6,"p":{"lines":[435,436]},"v":"写出分别通过wait/notify和LockSupport的park/unpark实现同步?"},{"t":"list_item","d":6,"p":{"lines":[436,437]},"v":"LockSupport.park()会释放锁资源吗? 那么Condition.await()呢?"},{"t":"list_item","d":6,"p":{"lines":[437,438]},"v":"Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别? <strong>重点</strong>"},{"t":"list_item","d":6,"p":{"lines":[438,439]},"v":"如果在wait()之前执行了notify()会怎样? 如果在park()之前执行了unpark()会怎样?"}]},{"t":"list_item","d":4,"p":{"lines":[440,441]},"v":"锁、通信工具类<br />和底层使用","c":[{"t":"list_item","d":6,"p":{"lines":[441,442]},"v":"AQS实现的锁(实现Lock接口)","c":[{"t":"list_item","d":8,"p":{"lines":[442,443]},"v":"ReentrantLock","c":[{"t":"list_item","d":10,"p":{"lines":[443,444]},"v":"内部类Sync继承AQS"},{"t":"list_item","d":10,"p":{"lines":[444,445]},"v":"Condition底层使用LockSupport"}]},{"t":"list_item","d":8,"p":{"lines":[445,446]},"v":"ReentrantReadWriteLock","c":[{"t":"list_item","d":10,"p":{"lines":[446,447]},"v":"读锁和写锁都有继承AQS的内部类Sync"}]}]},{"t":"list_item","d":6,"p":{"lines":[447,448]},"v":"AQS通信工具类","c":[{"t":"list_item","d":8,"p":{"lines":[448,449]},"v":"Semaphore","c":[{"t":"list_item","d":10,"p":{"lines":[449,450]},"v":"内部有一个继承了AQS的同步器Sync"}]},{"t":"list_item","d":8,"p":{"lines":[450,451]},"v":"CountDownLatch","c":[{"t":"list_item","d":10,"p":{"lines":[451,452]},"v":"内部有一个继承了AQS的同步器Sync"}]},{"t":"list_item","d":8,"p":{"lines":[452,453]},"v":"CyclicBarrier","c":[{"t":"list_item","d":10,"p":{"lines":[453,454]},"v":"内部使用ReentrantLock"}]}]},{"t":"list_item","d":6,"p":{"lines":[454,455]},"v":"非AQS的通信工具类","c":[{"t":"list_item","d":8,"p":{"lines":[455,456]},"v":"Exchanger","c":[{"t":"list_item","d":10,"p":{"lines":[456,457]},"v":"LockSupport"},{"t":"list_item","d":10,"p":{"lines":[457,458]},"v":"CAS(Atomic)"}]},{"t":"list_item","d":8,"p":{"lines":[458,459]},"v":"Phaser","c":[{"t":"list_item","d":10,"p":{"lines":[459,460]},"v":"有使用LockSupport"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[461,462]},"v":"锁的种类","c":[{"t":"list_item","d":6,"p":{"lines":[462,463]},"v":"锁的有无","c":[{"t":"list_item","d":8,"p":{"lines":[463,464]},"v":"乐观锁"},{"t":"list_item","d":8,"p":{"lines":[464,465]},"v":"悲观锁"}]},{"t":"list_item","d":6,"p":{"lines":[465,466]},"v":"synchronized的锁","c":[{"t":"list_item","d":8,"p":{"lines":[466,467]},"v":"无锁"},{"t":"list_item","d":8,"p":{"lines":[467,468]},"v":"偏向锁"},{"t":"list_item","d":8,"p":{"lines":[468,469]},"v":"轻量锁"},{"t":"list_item","d":8,"p":{"lines":[469,470]},"v":"重量锁"}]},{"t":"list_item","d":6,"p":{"lines":[470,471]},"v":"锁的性质分类","c":[{"t":"list_item","d":8,"p":{"lines":[471,472]},"v":"可重入锁和非可重入锁","c":[{"t":"list_item","d":10,"p":{"lines":[472,473]},"v":"表现"},{"t":"list_item","d":10,"p":{"lines":[473,474]},"v":"原理：粒度（加锁范围）"},{"t":"list_item","d":10,"p":{"lines":[474,475]},"v":"实例","c":[{"t":"list_item","d":12,"p":{"lines":[475,476]},"v":"可重入锁"},{"t":"list_item","d":12,"p":{"lines":[476,477]},"v":"不可重入锁"},{"t":"list_item","d":12,"p":{"lines":[477,478]},"v":"可以切换"}]}]},{"t":"list_item","d":8,"p":{"lines":[478,479]},"v":"公平锁与非公平锁","c":[{"t":"list_item","d":10,"p":{"lines":[479,480]},"v":"表现"},{"t":"list_item","d":10,"p":{"lines":[480,481]},"v":"原理"},{"t":"list_item","d":10,"p":{"lines":[481,482]},"v":"实例","c":[{"t":"list_item","d":12,"p":{"lines":[482,483]},"v":"公平锁"},{"t":"list_item","d":12,"p":{"lines":[483,484]},"v":"非公平锁"},{"t":"list_item","d":12,"p":{"lines":[484,485]},"v":"可以切换"}]}]},{"t":"list_item","d":8,"p":{"lines":[485,486]},"v":"读写锁和排它锁","c":[{"t":"list_item","d":10,"p":{"lines":[486,487]},"v":"表现"},{"t":"list_item","d":10,"p":{"lines":[487,488]},"v":"原理"},{"t":"list_item","d":10,"p":{"lines":[488,489]},"v":"实例","c":[{"t":"list_item","d":12,"p":{"lines":[489,490]},"v":"读写锁"},{"t":"list_item","d":12,"p":{"lines":[490,491]},"v":"排它锁"},{"t":"list_item","d":12,"p":{"lines":[491,492]},"v":"可以切换"}]}]},{"t":"list_item","d":8,"p":{"lines":[492,493]},"v":"是否可中断"}]}]},{"t":"list_item","d":4,"p":{"lines":[494,495]},"v":"并发集合容器","c":[{"t":"list_item","d":6,"p":{"lines":[495,496]},"v":"<a href=\"https://juejin.cn/post/6844903954719965192\">什么是同步容器和并发容器</a>"},{"t":"list_item","d":6,"p":{"lines":[496,497]},"v":"同步容器","c":[{"t":"list_item","d":8,"p":{"lines":[497,498]},"v":"vector:在面对多线程下的复合操作的时候也是需要通过客户端加锁的方式保证原子性"},{"t":"list_item","d":8,"p":{"lines":[498,499]},"v":"HashTable"},{"t":"list_item","d":8,"p":{"lines":[499,500]},"v":"Collections下的各种 SynchronizedXXX"}]},{"t":"list_item","d":6,"p":{"lines":[500,501]},"v":"并发容器","c":[{"t":"list_item","d":8,"p":{"lines":[501,502]},"v":"Queue","c":[{"t":"list_item","d":10,"p":{"lines":[502,503]},"v":"BlockingQueue","c":[{"t":"list_item","d":12,"p":{"lines":[503,504]},"v":"ArrayBlockingQueue"},{"t":"list_item","d":12,"p":{"lines":[504,505]},"v":"LinkedBlockingQueue"},{"t":"list_item","d":12,"p":{"lines":[505,506]},"v":"DelayQueue"},{"t":"list_item","d":12,"p":{"lines":[506,507]},"v":"Priority BlockingQueue"},{"t":"list_item","d":12,"p":{"lines":[507,508]},"v":"SynchronousQueue"},{"t":"list_item","d":12,"p":{"lines":[508,509]},"v":"LinkedBlockingDeque"},{"t":"list_item","d":12,"p":{"lines":[509,510]},"v":"LinkedTransferQueue"}]},{"t":"list_item","d":10,"p":{"lines":[510,511]},"v":"ConcurrenLinkedQueue","c":[{"t":"list_item","d":12,"p":{"lines":[511,512]},"v":"Unsafe:CAS"},{"t":"list_item","d":12,"p":{"lines":[512,513]},"v":"<a href=\"https://blog.csdn.net/lzxlfly/article/details/86710382\">LinkedBlockingQueue与ConcurrentLinkedQueue的区别</a>"}]}]},{"t":"list_item","d":8,"p":{"lines":[513,514]},"v":"ConcurrentMap","c":[{"t":"list_item","d":10,"p":{"lines":[514,515]},"v":"ConcurrentHashMap","c":[{"t":"list_item","d":12,"p":{"lines":[515,516]},"v":"LockSupport"},{"t":"list_item","d":12,"p":{"lines":[516,517]},"v":"分段锁继承ReentrantLock"},{"t":"list_item","d":12,"p":{"lines":[517,518]},"v":"Unsafe:CAS"},{"t":"list_item","d":12,"p":{"lines":[518,519]},"v":"AtomicInteger"}]},{"t":"list_item","d":10,"p":{"lines":[519,520]},"v":"ConcurrentNavigableMap"},{"t":"list_item","d":10,"p":{"lines":[520,521]},"v":"ConcurrentSkipListMap"}]},{"t":"list_item","d":8,"p":{"lines":[521,522]},"v":"CopyOnWrite","c":[{"t":"list_item","d":10,"p":{"lines":[522,523]},"v":"CopyOnWriteArrayList","c":[{"t":"list_item","d":12,"p":{"lines":[523,524]},"v":"ReentrantLock加锁"}]},{"t":"list_item","d":10,"p":{"lines":[524,525]},"v":"CopyOnWriteArrayMap"},{"t":"list_item","d":10,"p":{"lines":[525,526]},"v":"CopyOnWriteArraySet"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[526,527]},"v":"线程池","c":[{"t":"list_item","d":6,"p":{"lines":[527,528]},"v":"结构","c":[{"t":"list_item","d":8,"p":{"lines":[528,529]},"v":"任务(Runnable /Callable)"},{"t":"list_item","d":8,"p":{"lines":[529,530]},"v":"任务的执行(Executor)"},{"t":"list_item","d":8,"p":{"lines":[530,531]},"v":"异步计算的结果(Future)"}]},{"t":"list_item","d":6,"p":{"lines":[531,532]},"v":"创建","c":[{"t":"list_item","d":8,"p":{"lines":[532,533]},"v":"ThreadPoolExecutor构造方法参数的含义","c":[{"t":"list_item","d":10,"p":{"lines":[533,534]},"v":"int corePoolSize：该线程池中核心线程数最大值"},{"t":"list_item","d":10,"p":{"lines":[534,535]},"v":"int maximumPoolSize：该线程池中线程总数最大值 。"},{"t":"list_item","d":10,"p":{"lines":[535,536]},"v":"long keepAliveTime：非核心线程闲置超时时长。"},{"t":"list_item","d":10,"p":{"lines":[536,537]},"v":"TimeUnit unit：keepAliveTime的单位。"},{"t":"list_item","d":10,"p":{"lines":[537,538]},"v":"BlockingQueue workQueue：阻塞队列，维护着等待执行的Runnable任务对象。"},{"t":"list_item","d":10,"p":{"lines":[538,539]},"v":"ThreadFactory threadFactory：<br />创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，<br/>如是否守护线程、线程的优先级等。<br />如果不指定，会新建一个默认的线程工厂。"},{"t":"list_item","d":10,"p":{"lines":[539,540]},"v":"RejectedExecutionHandler handler 拒绝策略","c":[{"t":"list_item","d":12,"p":{"lines":[540,541]},"v":"AbortPolicy：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。"},{"t":"list_item","d":12,"p":{"lines":[541,542]},"v":"DiscardPolicy：丢弃新来的任务，但是不抛出异常。"},{"t":"list_item","d":12,"p":{"lines":[542,543]},"v":"DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。"},{"t":"list_item","d":12,"p":{"lines":[543,544]},"v":"CallerRunsPolicy：由调用线程处理该任务。"}]}]},{"t":"list_item","d":8,"p":{"lines":[544,545]},"v":"Executors默认实现(底层使用ThreadPoolExecutor)","c":[{"t":"list_item","d":10,"p":{"lines":[545,546]},"v":"FixedThreadPool","c":[{"t":"list_item","d":12,"p":{"lines":[546,547]},"v":"参数设置"},{"t":"list_item","d":12,"p":{"lines":[547,548]},"v":"执行过程"},{"t":"list_item","d":12,"p":{"lines":[548,549]},"v":"弊端"}]},{"t":"list_item","d":10,"p":{"lines":[549,550]},"v":"CachedThreadPool","c":[{"t":"list_item","d":12,"p":{"lines":[550,551]},"v":"参数设置"},{"t":"list_item","d":12,"p":{"lines":[551,552]},"v":"执行过程"},{"t":"list_item","d":12,"p":{"lines":[552,553]},"v":"弊端"}]},{"t":"list_item","d":10,"p":{"lines":[553,554]},"v":"SingleThreadExecutor","c":[{"t":"list_item","d":12,"p":{"lines":[554,555]},"v":"参数设置"},{"t":"list_item","d":12,"p":{"lines":[555,556]},"v":"执行过程"},{"t":"list_item","d":12,"p":{"lines":[556,557]},"v":"弊端"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[557,558]},"v":"<strong>线程池工作流程</strong>"},{"t":"list_item","d":6,"p":{"lines":[558,559]},"v":"ThreadPool状态转换","c":[{"t":"list_item","d":8,"p":{"lines":[559,560]},"v":"RUNNING"},{"t":"list_item","d":8,"p":{"lines":[560,561]},"v":"SHUTDOWN"},{"t":"list_item","d":8,"p":{"lines":[561,562]},"v":"STOP"},{"t":"list_item","d":8,"p":{"lines":[562,563]},"v":"TIDYING"},{"t":"list_item","d":8,"p":{"lines":[563,564]},"v":"TERMINATED"}]},{"t":"list_item","d":6,"p":{"lines":[564,565]},"v":"ScheduledThreadPool:","c":[{"t":"list_item","d":8,"p":{"lines":[565,566]},"v":"继承了ThreadPoolExecutor"},{"t":"list_item","d":8,"p":{"lines":[566,567]},"v":"主要用来在给定的延迟后运行任务，或者定期执行任务"},{"t":"list_item","d":8,"p":{"lines":[567,568]},"v":"实际项目中会使<code>用quartz</code>"}]},{"t":"list_item","d":6,"p":{"lines":[568,569]},"v":"<strong>为什么不要用默认实现</strong> <br/> (上面的默认实现有什么弊端)"},{"t":"list_item","d":6,"p":{"lines":[569,570]},"v":"参数如何设置(N+1,2N)"},{"t":"list_item","d":6,"p":{"lines":[570,571]},"v":"<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&amp;mid=2247505057&amp;idx=1&amp;sn=621ebc409b589478e2e05388e079d8c0&amp;source=41#wechat_redirect\">异常线程处理</a>"},{"t":"list_item","d":6,"p":{"lines":[571,572]},"v":"常见区别","c":[{"t":"list_item","d":8,"p":{"lines":[572,573]},"v":"sumbit() vs execute()","c":[{"t":"list_item","d":10,"p":{"lines":[573,574]},"v":"execute()方法不会返回结果"},{"t":"list_item","d":10,"p":{"lines":[574,575]},"v":"submit()会返回一个 FutureTask 对象，并可以获得结果"},{"t":"list_item","d":10,"p":{"lines":[575,576]},"v":"<a href=\"https://www.jianshu.com/p/29610984f1dd\">异常处理</a>"}]},{"t":"list_item","d":8,"p":{"lines":[576,577]},"v":"Runnable vs Callable"},{"t":"list_item","d":8,"p":{"lines":[577,578]},"v":"shutdown() vs shutdownNow()"}]}]},{"t":"list_item","d":4,"p":{"lines":[579,580]},"v":"<strong>ThreadLocal(待做)</strong>"}]},{"t":"heading","d":2,"p":{"lines":[581,582],"f":true},"v":"IO/NIO/AIO "}]},{"t":"heading","d":1,"p":{"lines":[583,584]},"v":"JVM","c":[{"t":"heading","d":2,"p":{"lines":[585,586],"f":true},"v":"基础知识 ","c":[{"t":"list_item","d":4,"p":{"lines":[587,588]},"v":"jvm发展"},{"t":"list_item","d":4,"p":{"lines":[588,589]},"v":"特点：","c":[{"t":"list_item","d":6,"p":{"lines":[589,590]},"v":"一次编译，到处运行"},{"t":"list_item","d":6,"p":{"lines":[590,591]},"v":"自动内存管理"},{"t":"list_item","d":6,"p":{"lines":[591,592]},"v":"自动垃圾回收"}]},{"t":"list_item","d":4,"p":{"lines":[592,593]},"v":"架构模型","c":[{"t":"list_item","d":6,"p":{"lines":[593,594]},"v":"基于栈式架构"},{"t":"list_item","d":6,"p":{"lines":[594,595]},"v":"基于寄存器架构"}]},{"t":"list_item","d":4,"p":{"lines":[595,596]},"v":"JVM生命周期","c":[{"t":"list_item","d":6,"p":{"lines":[596,597]},"v":"启动"},{"t":"list_item","d":6,"p":{"lines":[597,598]},"v":"执行"},{"t":"list_item","d":6,"p":{"lines":[598,599]},"v":"退出"}]}]},{"t":"heading","d":2,"p":{"lines":[600,601],"f":true},"v":"内存与垃圾回收 ","c":[{"t":"heading","d":3,"p":{"lines":[602,603]},"v":"上层","c":[{"t":"list_item","d":5,"p":{"lines":[604,605]},"v":"画出详细架构"},{"t":"list_item","d":5,"p":{"lines":[605,606]},"v":"类加载过程","c":[{"t":"list_item","d":7,"p":{"lines":[606,607]},"v":"loading 加载(加载和链接交叉进行)","c":[{"t":"list_item","d":9,"p":{"lines":[607,608]},"v":"目的"}]},{"t":"list_item","d":7,"p":{"lines":[608,609]},"v":"linking 链接(加载和链接交叉进行)","c":[{"t":"list_item","d":9,"p":{"lines":[609,610]},"v":"verify 验证","c":[{"t":"list_item","d":11,"p":{"lines":[610,611]},"v":"目的"}]},{"t":"list_item","d":9,"p":{"lines":[611,612]},"v":"prepare 准备","c":[{"t":"list_item","d":11,"p":{"lines":[612,613]},"v":"目的"}]},{"t":"list_item","d":9,"p":{"lines":[613,614]},"v":"Resolve 解析","c":[{"t":"list_item","d":11,"p":{"lines":[614,615]},"v":"目的"},{"t":"list_item","d":11,"p":{"lines":[615,616]},"v":"执行时机"}]}]},{"t":"list_item","d":7,"p":{"lines":[616,617]},"v":"initialization 初始化","c":[{"t":"list_item","d":9,"p":{"lines":[617,618]},"v":"目的"},{"t":"list_item","d":9,"p":{"lines":[618,619]},"v":"特点","c":[{"t":"list_item","d":11,"p":{"lines":[619,620]},"v":"顺序执行"},{"t":"list_item","d":11,"p":{"lines":[620,621]},"v":"父类先与子类"},{"t":"list_item","d":11,"p":{"lines":[621,622]},"v":"<code>&lt;clint&gt;</code>多线程同步加锁"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[622,623]},"v":"类加载器","c":[{"t":"list_item","d":7,"p":{"lines":[623,624]},"v":"分清关系","c":[{"t":"list_item","d":9,"p":{"lines":[624,625]},"v":"继承关系"},{"t":"list_item","d":9,"p":{"lines":[625,626]},"v":"上下层关系<br />(涉及双亲委派)"},{"t":"list_item","d":9,"p":{"lines":[626,627]},"v":"包含关系<br />(自定义类加载器包含其他java编写类加载器)"}]},{"t":"list_item","d":7,"p":{"lines":[627,628]},"v":"通常分类","c":[{"t":"list_item","d":9,"p":{"lines":[628,629]},"v":"BootStrap ClassLoader","c":[{"t":"list_item","d":11,"p":{"lines":[629,630]},"v":"目的"},{"t":"list_item","d":11,"p":{"lines":[630,631]},"v":"父类"},{"t":"list_item","d":11,"p":{"lines":[631,632]},"v":"加载库"}]},{"t":"list_item","d":9,"p":{"lines":[632,633]},"v":"Extension ClassLoader","c":[{"t":"list_item","d":11,"p":{"lines":[633,634]},"v":"目的"},{"t":"list_item","d":11,"p":{"lines":[634,635]},"v":"父类"},{"t":"list_item","d":11,"p":{"lines":[635,636]},"v":"加载库"}]},{"t":"list_item","d":9,"p":{"lines":[636,637]},"v":"AppClassLoader ClassLoader","c":[{"t":"list_item","d":11,"p":{"lines":[637,638]},"v":"目的"},{"t":"list_item","d":11,"p":{"lines":[638,639]},"v":"父类"},{"t":"list_item","d":11,"p":{"lines":[639,640]},"v":"加载库"}]}]},{"t":"list_item","d":7,"p":{"lines":[640,641]},"v":"按照规范","c":[{"t":"list_item","d":9,"p":{"lines":[641,642]},"v":"引导类加载器（Bootstrap ClassLoader） c/c++编写"},{"t":"list_item","d":9,"p":{"lines":[642,643]},"v":"自定义类加载器（User-Defined ClassLoader） java编写","c":[{"t":"list_item","d":11,"p":{"lines":[643,644]},"v":"为何要自定义类加载器"}]}]},{"t":"list_item","d":7,"p":{"lines":[644,645]},"v":"抽象类ClassLoader","c":[{"t":"list_item","d":9,"p":{"lines":[645,646]},"v":"继承结构"},{"t":"list_item","d":9,"p":{"lines":[646,647]},"v":"虚拟机的入口应用:<code>sun.misc.Launcher</code>"},{"t":"list_item","d":9,"p":{"lines":[647,648]},"v":"获取classloader的方式"}]},{"t":"list_item","d":7,"p":{"lines":[648,649]},"v":"<strong>双亲委派机制</strong>","c":[{"t":"list_item","d":9,"p":{"lines":[649,650]},"v":"<strong>原理</strong>"},{"t":"list_item","d":9,"p":{"lines":[650,651]},"v":"自定义java.lang.String是否会加载"},{"t":"list_item","d":9,"p":{"lines":[651,652]},"v":"优势","c":[{"t":"list_item","d":11,"p":{"lines":[652,653]},"v":"避免类的重复加载"},{"t":"list_item","d":11,"p":{"lines":[653,654]},"v":"保护程序安全，防止核心api被随意篡改"}]},{"t":"list_item","d":9,"p":{"lines":[654,655]},"v":"例外案例"}]},{"t":"list_item","d":7,"p":{"lines":[655,656]},"v":"沙箱安全机制"},{"t":"list_item","d":7,"p":{"lines":[656,657]},"v":"其他","c":[{"t":"list_item","d":9,"p":{"lines":[657,658]},"v":"jvm 中判断两个class对象是否为同一个类2个判断条件"},{"t":"list_item","d":9,"p":{"lines":[658,659]},"v":"类加载器作为类型信息，引用类型转换"}]}]}]},{"t":"heading","d":3,"p":{"lines":[660,661]},"v":"中层","c":[{"t":"list_item","d":5,"p":{"lines":[662,663]},"v":"<strong>Java内存区域布局说明</strong>"},{"t":"list_item","d":5,"p":{"lines":[663,664]},"v":"程序计数器","c":[{"t":"list_item","d":7,"p":{"lines":[664,665]},"v":"是什么","c":[{"t":"list_item","d":9,"p":{"lines":[665,666]},"v":"线程私有"},{"t":"list_item","d":9,"p":{"lines":[666,667]},"v":"取值"},{"t":"list_item","d":9,"p":{"lines":[667,668]},"v":"作用"},{"t":"list_item","d":9,"p":{"lines":[668,669]},"v":"没有OOM"},{"t":"list_item","d":9,"p":{"lines":[669,670]},"v":"生命周期"}]},{"t":"list_item","d":7,"p":{"lines":[670,671]},"v":"问题","c":[{"t":"list_item","d":9,"p":{"lines":[671,672]},"v":"为什么使用PC寄存字器记录当当前线程的执行地址"},{"t":"list_item","d":9,"p":{"lines":[672,673]},"v":"pc寄存器为什么被设定为线程私有"}]}]},{"t":"list_item","d":5,"p":{"lines":[673,674]},"v":"虚拟机栈","c":[{"t":"list_item","d":7,"p":{"lines":[674,675]},"v":"是什么","c":[{"t":"list_item","d":9,"p":{"lines":[675,676]},"v":"线程私有"},{"t":"list_item","d":9,"p":{"lines":[676,677]},"v":"对应方法调用，入栈，出栈"},{"t":"list_item","d":9,"p":{"lines":[677,678]},"v":"作用"},{"t":"list_item","d":9,"p":{"lines":[678,679]},"v":"没有垃圾回收"},{"t":"list_item","d":9,"p":{"lines":[679,680]},"v":"异常"}]},{"t":"list_item","d":7,"p":{"lines":[680,681]},"v":"参数设置","c":[{"t":"list_item","d":9,"p":{"lines":[681,682]},"v":"<code>-Xss</code>"}]},{"t":"list_item","d":7,"p":{"lines":[682,683]},"v":"栈帧","c":[{"t":"list_item","d":9,"p":{"lines":[683,684]},"v":"是什么","c":[{"t":"list_item","d":11,"p":{"lines":[684,685]},"v":"Java虚拟机栈（Java Virtual Machine Stack),早期也叫Java栈。"},{"t":"list_item","d":11,"p":{"lines":[685,686]},"v":"每个线程在创建时都会创建一个虚拟机栈，<br />其内部保存一个个的栈帧 (Stack Frame),对应着一次次的Java方法调用。"},{"t":"list_item","d":11,"p":{"lines":[686,687]},"v":"是线程私有的"}]},{"t":"list_item","d":9,"p":{"lines":[687,688]},"v":"运行原理-栈帧弹出"},{"t":"list_item","d":9,"p":{"lines":[688,689]},"v":"内部组成","c":[{"t":"list_item","d":11,"p":{"lines":[689,690]},"v":"局部变量表","c":[{"t":"list_item","d":13,"p":{"lines":[690,691]},"v":"作用"},{"t":"list_item","d":13,"p":{"lines":[691,692]},"v":"生命周期"},{"t":"list_item","d":13,"p":{"lines":[692,693]},"v":"slot","c":[{"t":"list_item","d":15,"p":{"lines":[693,694]},"v":"概念"},{"t":"list_item","d":15,"p":{"lines":[694,695]},"v":"类型"},{"t":"list_item","d":15,"p":{"lines":[695,696]},"v":"存储内容与顺序"},{"t":"list_item","d":15,"p":{"lines":[696,697]},"v":"重用"}]},{"t":"list_item","d":13,"p":{"lines":[697,698]},"v":"内存分配(<strong>编译期间</strong>完成分配)"},{"t":"list_item","d":13,"p":{"lines":[698,699]},"v":"垃圾回收：局部变量表中的变量也是重要的垃圾回收根节点"}]},{"t":"list_item","d":11,"p":{"lines":[699,700]},"v":"操作数栈","c":[{"t":"list_item","d":13,"p":{"lines":[700,701]},"v":"编译时就已经确定深度<code>max_stacks</code>"},{"t":"list_item","d":13,"p":{"lines":[701,702]},"v":"操作：出栈入栈"},{"t":"list_item","d":13,"p":{"lines":[702,703]},"v":"具体流程示例"}]},{"t":"list_item","d":11,"p":{"lines":[703,704]},"v":"帧数据区","c":[{"t":"list_item","d":13,"p":{"lines":[704,705]},"v":"动态链接","c":[{"t":"list_item","d":15,"p":{"lines":[705,706]},"v":"什么是动态链接"},{"t":"list_item","d":15,"p":{"lines":[706,707]},"v":"<strong>深入</strong>：方法的调用：解析和分派","c":[{"t":"list_item","d":17,"p":{"lines":[707,708]},"v":"绑定与链接","c":[{"t":"list_item","d":19,"p":{"lines":[708,709]},"v":"早期绑定"},{"t":"list_item","d":19,"p":{"lines":[709,710]},"v":"晚期绑定"},{"t":"list_item","d":19,"p":{"lines":[710,711]},"v":"静态连接"},{"t":"list_item","d":19,"p":{"lines":[711,712]},"v":"动态链接"}]},{"t":"list_item","d":17,"p":{"lines":[712,713]},"v":"<strong>非虚方法与虚方法</strong>","c":[{"t":"list_item","d":19,"p":{"lines":[713,714]},"v":"概念"},{"t":"list_item","d":19,"p":{"lines":[714,715]},"v":"四个调用指令"},{"t":"list_item","d":19,"p":{"lines":[715,716]},"v":"方法重写本质"},{"t":"list_item","d":19,"p":{"lines":[716,717]},"v":"虚方法表"}]}]}]},{"t":"list_item","d":13,"p":{"lines":[717,718]},"v":"方法返回地址","c":[{"t":"list_item","d":15,"p":{"lines":[718,719]},"v":"栈帧退出方式"},{"t":"list_item","d":15,"p":{"lines":[719,720]},"v":"作用"}]},{"t":"list_item","d":13,"p":{"lines":[720,721]},"v":"一些附加信息"}]}]}]},{"t":"list_item","d":7,"p":{"lines":[721,722]},"v":"问题","c":[{"t":"list_item","d":9,"p":{"lines":[722,723]},"v":"栈中可能出现的异常"},{"t":"list_item","d":9,"p":{"lines":[723,724]},"v":"i++和++i的区别。<br />从字节码，局部变量表，操作数栈层面解释"},{"t":"list_item","d":9,"p":{"lines":[724,725]},"v":"举例栈溢出的情况？(StackOverflowError)"},{"t":"list_item","d":9,"p":{"lines":[725,726]},"v":"调整栈大小，就能保证不出现溢出吗？"},{"t":"list_item","d":9,"p":{"lines":[726,727]},"v":"分配的栈内存越大越好吗？"},{"t":"list_item","d":9,"p":{"lines":[727,728]},"v":"垃圾回收是否会涉及到虚拟机栈？"},{"t":"list_item","d":9,"p":{"lines":[728,729]},"v":"方法中定义的局部变量是否线程安全？"}]}]},{"t":"list_item","d":5,"p":{"lines":[729,730]},"v":"本地方法接口+库(非运行时数据区结构)","c":[{"t":"list_item","d":7,"p":{"lines":[730,731]},"v":"定义:一个Native Method就是一个Java调用非Java代码的接口。"},{"t":"list_item","d":7,"p":{"lines":[731,732]},"v":"特点:该方法的实现由非Java语言实现，比如 C。"},{"t":"list_item","d":7,"p":{"lines":[732,733]},"v":"目的:","c":[{"t":"list_item","d":9,"p":{"lines":[733,734]},"v":"与java环境外交互"},{"t":"list_item","d":9,"p":{"lines":[734,735]},"v":"与操作系统交互"},{"t":"list_item","d":9,"p":{"lines":[735,736]},"v":"Sun's java"}]}]},{"t":"list_item","d":5,"p":{"lines":[736,737]},"v":"本地方法栈","c":[{"t":"list_item","d":7,"p":{"lines":[737,738]},"v":"目的"},{"t":"list_item","d":7,"p":{"lines":[738,739]},"v":"在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。"}]},{"t":"list_item","d":5,"p":{"lines":[740,741]},"v":"堆","c":[{"t":"list_item","d":7,"p":{"lines":[741,742]},"v":"空间划分与比例<code>1:2</code> <code>6:1:1</code>"},{"t":"list_item","d":7,"p":{"lines":[742,743]},"v":"堆大小设置参数<code>-Xms``-Xmx</code>"},{"t":"list_item","d":7,"p":{"lines":[743,744]},"v":"对象分配","c":[{"t":"list_item","d":9,"p":{"lines":[744,745]},"v":"一般过程"},{"t":"list_item","d":9,"p":{"lines":[745,746]},"v":"特殊情况"}]},{"t":"list_item","d":7,"p":{"lines":[746,747]},"v":"四种GC","c":[{"t":"list_item","d":9,"p":{"lines":[747,748]},"v":"Minor GC","c":[{"t":"list_item","d":11,"p":{"lines":[748,749]},"v":"回收区域"},{"t":"list_item","d":11,"p":{"lines":[749,750]},"v":"触发机制"},{"t":"list_item","d":11,"p":{"lines":[750,751]},"v":"耗时代价"},{"t":"list_item","d":11,"p":{"lines":[751,752]},"v":"Survivor的被动收集"}]},{"t":"list_item","d":9,"p":{"lines":[752,753]},"v":"Major GC","c":[{"t":"list_item","d":11,"p":{"lines":[753,754]},"v":"回收区域"},{"t":"list_item","d":11,"p":{"lines":[754,755]},"v":"触发机制"},{"t":"list_item","d":11,"p":{"lines":[755,756]},"v":"耗时代价"}]},{"t":"list_item","d":9,"p":{"lines":[756,757]},"v":"Mixed GC","c":[{"t":"list_item","d":11,"p":{"lines":[757,758]},"v":"回收区域"},{"t":"list_item","d":11,"p":{"lines":[758,759]},"v":"只有G1回收器有该GC"}]},{"t":"list_item","d":9,"p":{"lines":[759,760]},"v":"Full GC","c":[{"t":"list_item","d":11,"p":{"lines":[760,761]},"v":"回收区域"},{"t":"list_item","d":11,"p":{"lines":[761,762]},"v":"触发机制"},{"t":"list_item","d":11,"p":{"lines":[762,763]},"v":"耗时代价"}]}]},{"t":"list_item","d":7,"p":{"lines":[763,764]},"v":"TLAB:快速分配策略。","c":[{"t":"list_item","d":9,"p":{"lines":[764,765]},"v":"作用"},{"t":"list_item","d":9,"p":{"lines":[765,766]},"v":"分配流程：","c":[{"t":"list_item","d":11,"p":{"lines":[766,767]},"v":"JVM确实是将TLAB作为内存分配的首选"},{"t":"list_item","d":11,"p":{"lines":[767,768]},"v":"失败后，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，<br />从而直接在Eden空间中分配内存。"}]},{"t":"list_item","d":9,"p":{"lines":[768,769]},"v":"大小：默认整个Eden空间的1%<br /> <code>-XX:TLABWasteTargetPercent</code>设置"}]},{"t":"list_item","d":7,"p":{"lines":[769,770]},"v":"逃逸分析( <strong>十分不成熟，Hotspot也没用</strong> )","c":[{"t":"list_item","d":9,"p":{"lines":[770,771]},"v":"种类：","c":[{"t":"list_item","d":11,"p":{"lines":[771,772]},"v":"方法逃逸"},{"t":"list_item","d":11,"p":{"lines":[772,773]},"v":"线程逃逸"}]},{"t":"list_item","d":9,"p":{"lines":[773,774]},"v":"基于逃逸分析的优化","c":[{"t":"list_item","d":11,"p":{"lines":[774,775]},"v":"栈上分配(就没实现)"},{"t":"list_item","d":11,"p":{"lines":[775,776]},"v":"同步省略"},{"t":"list_item","d":11,"p":{"lines":[776,777]},"v":"标量替换"}]}]},{"t":"list_item","d":7,"p":{"lines":[777,778]},"v":"堆是分配对象的唯一选择:否定-&gt;肯定"}]},{"t":"list_item","d":5,"p":{"lines":[779,780]},"v":"方法区","c":[{"t":"list_item","d":7,"p":{"lines":[780,781]},"v":"特点","c":[{"t":"list_item","d":9,"p":{"lines":[781,782]},"v":"线程共享"},{"t":"list_item","d":9,"p":{"lines":[782,783]},"v":"本地内存"}]},{"t":"list_item","d":7,"p":{"lines":[783,784]},"v":"存储内容：具体看 <strong>细节演进</strong>"},{"t":"list_item","d":7,"p":{"lines":[784,785]},"v":"大小设置","c":[{"t":"list_item","d":9,"p":{"lines":[785,786]},"v":"1.7","c":[{"t":"list_item","d":11,"p":{"lines":[786,787]},"v":"<code>-XX:PermSize</code>"},{"t":"list_item","d":11,"p":{"lines":[787,788]},"v":"<code>-XX:MaxPermSize</code>"}]},{"t":"list_item","d":9,"p":{"lines":[788,789]},"v":"1.8","c":[{"t":"list_item","d":11,"p":{"lines":[789,790]},"v":"<code>-XX:MetaspaceSize</code><br />初始分配空间大小，<br />同时也是水位线大小"},{"t":"list_item","d":11,"p":{"lines":[790,791]},"v":"<code>-XX:MaxMetaspaceSize</code>方法区最大大小，默认-1"},{"t":"list_item","d":11,"p":{"lines":[791,792]},"v":"水位线--full GC--自动调整"}]}]},{"t":"list_item","d":7,"p":{"lines":[792,793]},"v":"<strong>内部结构演进变迁</strong>:看图去"},{"t":"list_item","d":7,"p":{"lines":[793,794]},"v":"常量池和运行时常量池"},{"t":"list_item","d":7,"p":{"lines":[794,795]},"v":"为何要移除永久代"},{"t":"list_item","d":7,"p":{"lines":[795,796]},"v":"垃圾回收","c":[{"t":"list_item","d":9,"p":{"lines":[796,797]},"v":"是否要回收","c":[{"t":"list_item","d":11,"p":{"lines":[797,798]},"v":"《规范》提到过可以不要求虚拟机在方法区中实现垃圾收集"},{"t":"list_item","d":11,"p":{"lines":[798,799]},"v":"回收条件苛刻，效果比较难令人满意。"}]},{"t":"list_item","d":9,"p":{"lines":[799,800]},"v":"回收内容","c":[{"t":"list_item","d":11,"p":{"lines":[800,801]},"v":"常量池中废弃的常量","c":[{"t":"list_item","d":13,"p":{"lines":[801,802]},"v":"回收策略"},{"t":"list_item","d":13,"p":{"lines":[802,803]},"v":"组成"}]},{"t":"list_item","d":11,"p":{"lines":[803,804]},"v":"不再使用的类","c":[{"t":"list_item","d":13,"p":{"lines":[804,805]},"v":"回收策略"}]}]}]}]},{"t":"list_item","d":5,"p":{"lines":[805,806]},"v":"问题","c":[{"t":"list_item","d":7,"p":{"lines":[806,807]},"v":"说一下JVM内存模型吧，有哪些区？分别干什么的？"},{"t":"list_item","d":7,"p":{"lines":[807,808]},"v":"Java8的内存分代改进"},{"t":"list_item","d":7,"p":{"lines":[808,809]},"v":"JVM内存分哪几个区，每个区的作用是什么？"},{"t":"list_item","d":7,"p":{"lines":[809,810]},"v":"JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？"},{"t":"list_item","d":7,"p":{"lines":[810,811]},"v":"Eden和Survior的比例分配"},{"t":"list_item","d":7,"p":{"lines":[811,812]},"v":"jvm内存分区，为什么要有新生代和老年代"},{"t":"list_item","d":7,"p":{"lines":[812,813]},"v":"Java的内存分区"},{"t":"list_item","d":7,"p":{"lines":[813,814]},"v":"讲讲jvm运行时数据库区"},{"t":"list_item","d":7,"p":{"lines":[814,815]},"v":"什么时候对象会进入老年代？"},{"t":"list_item","d":7,"p":{"lines":[815,816]},"v":"JVM内存为什么要分成新生代，老年代，持久代。<br />新生代中为什么要分为Eden和Survivor。"},{"t":"list_item","d":7,"p":{"lines":[816,817]},"v":"Jvm内存模型以及分区，需要详细到每个区放什么。"},{"t":"list_item","d":7,"p":{"lines":[817,818]},"v":"JVM的内存模型，Java8做了什么修改"},{"t":"list_item","d":7,"p":{"lines":[818,819]},"v":"JVM内存分哪几个区，每个区的作用是什么？"},{"t":"list_item","d":7,"p":{"lines":[819,820]},"v":"java内存分配"},{"t":"list_item","d":7,"p":{"lines":[820,821]},"v":"jvm的永久代中会发生垃圾回收吗？"},{"t":"list_item","d":7,"p":{"lines":[821,822]},"v":"jvm内存分区，为什么要有新生代和老年代？"}]},{"t":"list_item","d":5,"p":{"lines":[823,824]},"v":"<strong>对象的实例化内存布局和访问定位</strong>","c":[{"t":"list_item","d":7,"p":{"lines":[824,825]},"v":"创建对象的方式"},{"t":"list_item","d":7,"p":{"lines":[825,826]},"v":"实例化步骤","c":[{"t":"list_item","d":9,"p":{"lines":[826,827]},"v":"创建对象的步骤（六步）","c":[{"t":"list_item","d":11,"p":{"lines":[827,828]},"v":"判断对象对应的类是否加载，链接，初始化。（加载类元信息）"},{"t":"list_item","d":11,"p":{"lines":[828,829]},"v":"为对象分配内存","c":[{"t":"list_item","d":13,"p":{"lines":[829,830]},"v":"指针碰撞","c":[{"t":"list_item","d":15,"p":{"lines":[830,831]},"v":"原理"},{"t":"list_item","d":15,"p":{"lines":[831,832]},"v":"对应算法"}]},{"t":"list_item","d":13,"p":{"lines":[832,833]},"v":"空闲列表分配","c":[{"t":"list_item","d":15,"p":{"lines":[833,834]},"v":"原理"},{"t":"list_item","d":15,"p":{"lines":[834,835]},"v":"对应算法"}]}]},{"t":"list_item","d":11,"p":{"lines":[835,836]},"v":"处理并发安全问题","c":[{"t":"list_item","d":13,"p":{"lines":[836,837]},"v":"CAS"},{"t":"list_item","d":13,"p":{"lines":[837,838]},"v":"TLAB"}]},{"t":"list_item","d":11,"p":{"lines":[838,839]},"v":"初始化分配到的空间"},{"t":"list_item","d":11,"p":{"lines":[839,840]},"v":"设置对象的对象头"},{"t":"list_item","d":11,"p":{"lines":[840,841]},"v":"执行init方法进行初始化","c":[{"t":"list_item","d":13,"p":{"lines":[841,842]},"v":"属性初始化方式","c":[{"t":"list_item","d":15,"p":{"lines":[842,843]},"v":"1.默认初始化"},{"t":"list_item","d":15,"p":{"lines":[843,844]},"v":"2.显式初始化"},{"t":"list_item","d":15,"p":{"lines":[844,845]},"v":"3.代码块中初始化"},{"t":"list_item","d":15,"p":{"lines":[845,846]},"v":"4.构造器中初始化"},{"t":"list_item","d":15,"p":{"lines":[846,847]},"v":"5.对象.属性 初始化"}]},{"t":"list_item","d":13,"p":{"lines":[847,848]},"v":"init中包括2,3,4"}]}]}]},{"t":"list_item","d":7,"p":{"lines":[848,849]},"v":"内部布局","c":[{"t":"list_item","d":9,"p":{"lines":[849,850]},"v":"对象头(下面3项都是一字宽)","c":[{"t":"list_item","d":11,"p":{"lines":[850,851]},"v":"Mark Word--存储对象的hashCode或锁信息等","c":[{"t":"list_item","d":13,"p":{"lines":[851,852]},"v":"不同锁状态内容不同"}]},{"t":"list_item","d":11,"p":{"lines":[852,853]},"v":"Class Metadata Address--存储到对象类型数据的指针"},{"t":"list_item","d":11,"p":{"lines":[853,854]},"v":"Array length--数组的长度（如果是数组）"}]},{"t":"list_item","d":9,"p":{"lines":[854,855]},"v":"实例数据:"},{"t":"list_item","d":9,"p":{"lines":[855,856]},"v":"对齐填充:占位符"}]},{"t":"list_item","d":7,"p":{"lines":[856,857]},"v":"定位访问","c":[{"t":"list_item","d":9,"p":{"lines":[857,858]},"v":"句柄访问","c":[{"t":"list_item","d":11,"p":{"lines":[858,859]},"v":"说明"},{"t":"list_item","d":11,"p":{"lines":[859,860]},"v":"优点"},{"t":"list_item","d":11,"p":{"lines":[860,861]},"v":"缺点"}]},{"t":"list_item","d":9,"p":{"lines":[861,862]},"v":"直接指针","c":[{"t":"list_item","d":11,"p":{"lines":[862,863]},"v":"说明"},{"t":"list_item","d":11,"p":{"lines":[863,864]},"v":"优点"},{"t":"list_item","d":11,"p":{"lines":[864,865]},"v":"缺点"}]}]},{"t":"list_item","d":7,"p":{"lines":[865,866]},"v":"问题","c":[{"t":"list_item","d":9,"p":{"lines":[866,867]},"v":"对象在JVM中是怎么存储的？"},{"t":"list_item","d":9,"p":{"lines":[867,868]},"v":"对象头信息里面有哪些东西？"},{"t":"list_item","d":9,"p":{"lines":[868,869]},"v":"java对象头里有什么"}]}]},{"t":"list_item","d":5,"p":{"lines":[869,870]},"v":"直接内存"}]},{"t":"heading","d":3,"p":{"lines":[871,872]},"v":"下层","c":[{"t":"list_item","d":5,"p":{"lines":[873,874]},"v":"执行引擎","c":[{"t":"list_item","d":7,"p":{"lines":[874,875]},"v":"作用"},{"t":"list_item","d":7,"p":{"lines":[875,876]},"v":"相关概念","c":[{"t":"list_item","d":9,"p":{"lines":[876,877]},"v":"编译原理"},{"t":"list_item","d":9,"p":{"lines":[877,878]},"v":"机器码"},{"t":"list_item","d":9,"p":{"lines":[878,879]},"v":"指令"},{"t":"list_item","d":9,"p":{"lines":[879,880]},"v":"指令集"},{"t":"list_item","d":9,"p":{"lines":[880,881]},"v":"汇编"},{"t":"list_item","d":9,"p":{"lines":[881,882]},"v":"高级语言"}]},{"t":"list_item","d":7,"p":{"lines":[882,883]},"v":"编译器分类","c":[{"t":"list_item","d":9,"p":{"lines":[883,884]},"v":"前端编译器<br />java--&gt;.class"},{"t":"list_item","d":9,"p":{"lines":[884,885]},"v":"后端运行期编译器：JIT<br /> .class--&gt;机器码"},{"t":"list_item","d":9,"p":{"lines":[885,886]},"v":"静态提前编译器：AOT(Ahead of Time Compiler)编译器，<br /> .java--&gt;机器码"}]},{"t":"list_item","d":7,"p":{"lines":[886,887]},"v":"Java代码执行方式分类","c":[{"t":"list_item","d":9,"p":{"lines":[887,888]},"v":"种类","c":[{"t":"list_item","d":11,"p":{"lines":[888,889]},"v":"源代码编译成字节码文件，<br />然后在运行时通过解释器将字节码文件转为机器码执行"},{"t":"list_item","d":11,"p":{"lines":[889,890]},"v":"直接编译成机器码"}]},{"t":"list_item","d":9,"p":{"lines":[890,891]},"v":"HotSpot执行方式","c":[{"t":"list_item","d":11,"p":{"lines":[891,892]},"v":"<code>-Xint</code>:完全采用解释器模式执行程序；"},{"t":"list_item","d":11,"p":{"lines":[892,893]},"v":"<code>-Xcomp</code>:完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。"},{"t":"list_item","d":11,"p":{"lines":[893,894]},"v":"<code>-Xmixed</code>(默认):采用解释器+即时编译器的混合模式共同执行程序。"}]}]},{"t":"list_item","d":7,"p":{"lines":[894,895]},"v":"Java执行引擎组成","c":[{"t":"list_item","d":9,"p":{"lines":[895,896]},"v":"解释器","c":[{"t":"list_item","d":11,"p":{"lines":[896,897]},"v":"为什么java源码到机器语言中间要有个字节码"},{"t":"list_item","d":11,"p":{"lines":[897,898]},"v":"工作机制"},{"t":"list_item","d":11,"p":{"lines":[898,899]},"v":"种类","c":[{"t":"list_item","d":13,"p":{"lines":[899,900]},"v":"字节码解释器"},{"t":"list_item","d":13,"p":{"lines":[900,901]},"v":"模板解释器"}]}]},{"t":"list_item","d":9,"p":{"lines":[901,902]},"v":"即时编译器","c":[{"t":"list_item","d":11,"p":{"lines":[902,903]},"v":"工作机制"},{"t":"list_item","d":11,"p":{"lines":[903,904]},"v":"热点代码","c":[{"t":"list_item","d":13,"p":{"lines":[904,905]},"v":"概念"},{"t":"list_item","d":13,"p":{"lines":[905,906]},"v":"热点探测","c":[{"t":"list_item","d":15,"p":{"lines":[906,907]},"v":"方法调用计数器","c":[{"t":"list_item","d":17,"p":{"lines":[907,908]},"v":"工作机制"},{"t":"list_item","d":17,"p":{"lines":[908,909]},"v":"默认使用相对频率<br />关闭热度衰减使用绝对次数"},{"t":"list_item","d":17,"p":{"lines":[909,910]},"v":"阀值"},{"t":"list_item","d":17,"p":{"lines":[910,911]},"v":"设置阀值<code>-XX:CompileThreshold</code>"},{"t":"list_item","d":17,"p":{"lines":[911,912]},"v":"执行逻辑"},{"t":"list_item","d":17,"p":{"lines":[912,913]},"v":"热度衰减","c":[{"t":"list_item","d":19,"p":{"lines":[913,914]},"v":"半衰期：<code>-XX:CounterHalfLifeTime</code>"},{"t":"list_item","d":19,"p":{"lines":[914,915]},"v":"关闭：<code>-XX:-UseCounterDecay</code>"}]}]},{"t":"list_item","d":15,"p":{"lines":[915,916]},"v":"回边计数器","c":[{"t":"list_item","d":17,"p":{"lines":[916,917]},"v":"工作机制"},{"t":"list_item","d":17,"p":{"lines":[917,918]},"v":"栈上替换(OSR)"}]}]}]},{"t":"list_item","d":11,"p":{"lines":[918,919]},"v":"Java内置JIT编译器","c":[{"t":"list_item","d":13,"p":{"lines":[919,920]},"v":"C1","c":[{"t":"list_item","d":15,"p":{"lines":[920,921]},"v":"client模式下运行"},{"t":"list_item","d":15,"p":{"lines":[921,922]},"v":"简单和可靠的优化，耗时短"},{"t":"list_item","d":15,"p":{"lines":[922,923]},"v":"优化策略","c":[{"t":"list_item","d":17,"p":{"lines":[923,924]},"v":"方法内联：将引用的函数代码编译到引用点处，<br />这样可以减少栈帧的生成，减少参数传递以及跳转过程"},{"t":"list_item","d":17,"p":{"lines":[924,925]},"v":"去虚拟化：对唯一的实现类进行内联"},{"t":"list_item","d":17,"p":{"lines":[925,926]},"v":"沉余消除：在运行期间把一些不会执行的代码折叠掉"}]}]},{"t":"list_item","d":13,"p":{"lines":[926,927]},"v":"C2","c":[{"t":"list_item","d":15,"p":{"lines":[927,928]},"v":"server模式下运行"},{"t":"list_item","d":15,"p":{"lines":[928,929]},"v":"耗时较长的优化，以及激进优化"},{"t":"list_item","d":15,"p":{"lines":[929,930]},"v":"优化策略","c":[{"t":"list_item","d":17,"p":{"lines":[930,931]},"v":"标量替换：用标量值代替聚合对象的属性值"},{"t":"list_item","d":17,"p":{"lines":[931,932]},"v":"栈上分配：对于未逃逸的对象分配对象在栈而不是堆"},{"t":"list_item","d":17,"p":{"lines":[932,933]},"v":"同步消除：清除同步操作，通常指synchronized"}]}]}]},{"t":"list_item","d":11,"p":{"lines":[933,934]},"v":"java中的实际优化策略：<a href=\"http://zhongmingmao.me/2019/01/02/jvm-advanced-jit/\">分层编译(1.7引入,1.8默认开启)</a>"}]}]},{"t":"list_item","d":7,"p":{"lines":[934,935]},"v":"其他编译器：","c":[{"t":"list_item","d":9,"p":{"lines":[935,936]},"v":"Graa1"},{"t":"list_item","d":9,"p":{"lines":[936,937]},"v":"AOT"}]}]},{"t":"list_item","d":5,"p":{"lines":[938,939]},"v":"String与StringTable(中间插曲)","c":[{"t":"list_item","d":7,"p":{"lines":[939,940]},"v":"创建String","c":[{"t":"list_item","d":9,"p":{"lines":[940,941]},"v":"字面量","c":[{"t":"list_item","d":11,"p":{"lines":[941,942]},"v":"一个对象"},{"t":"list_item","d":11,"p":{"lines":[942,943]},"v":"返回的索引指向"}]},{"t":"list_item","d":9,"p":{"lines":[943,944]},"v":"new","c":[{"t":"list_item","d":11,"p":{"lines":[944,945]},"v":"两个对象"},{"t":"list_item","d":11,"p":{"lines":[945,946]},"v":"返回的索引指向"}]},{"t":"list_item","d":9,"p":{"lines":[946,947]},"v":"<strong>StringBuilder和StringBuffer的toString</strong>"},{"t":"list_item","d":9,"p":{"lines":[947,948]},"v":"(本质同上)new String(&quot;a&quot;)+new String(&quot;b&quot;)"}]},{"t":"list_item","d":7,"p":{"lines":[948,949]},"v":"String的不可变性"},{"t":"list_item","d":7,"p":{"lines":[949,950]},"v":"String底层存储结构","c":[{"t":"list_item","d":9,"p":{"lines":[950,951]},"v":"jdk8:final char[]"},{"t":"list_item","d":9,"p":{"lines":[951,952]},"v":"jdk9:final byte[]"}]},{"t":"list_item","d":7,"p":{"lines":[952,953]},"v":"String Table相关","c":[{"t":"list_item","d":9,"p":{"lines":[953,954]},"v":"特点"},{"t":"list_item","d":9,"p":{"lines":[954,955]},"v":"长度","c":[{"t":"list_item","d":11,"p":{"lines":[955,956]},"v":"默认长度","c":[{"t":"list_item","d":13,"p":{"lines":[956,957]},"v":"jdk6"},{"t":"list_item","d":13,"p":{"lines":[957,958]},"v":"jdk7"},{"t":"list_item","d":13,"p":{"lines":[958,959]},"v":"jdk8"}]},{"t":"list_item","d":11,"p":{"lines":[959,960]},"v":"长度设置"}]},{"t":"list_item","d":9,"p":{"lines":[960,961]},"v":"内存分配变迁","c":[{"t":"list_item","d":11,"p":{"lines":[961,962]},"v":"jdk6"},{"t":"list_item","d":11,"p":{"lines":[962,963]},"v":"jdk7"},{"t":"list_item","d":11,"p":{"lines":[963,964]},"v":"jdk8"}]}]},{"t":"list_item","d":7,"p":{"lines":[964,965]},"v":"<strong>inter()的使用</strong>","c":[{"t":"list_item","d":9,"p":{"lines":[965,966]},"v":"1.7之前"},{"t":"list_item","d":9,"p":{"lines":[966,967]},"v":"1.7及之后"}]},{"t":"list_item","d":7,"p":{"lines":[967,968]},"v":"StringTable垃圾回收:<br />GC时也会对StringTable进行垃圾回收"},{"t":"list_item","d":7,"p":{"lines":[968,969]},"v":"G1中的String去重操作(了解)"},{"t":"list_item","d":7,"p":{"lines":[969,970]},"v":"<strong>面试题</strong>"}]},{"t":"list_item","d":5,"p":{"lines":[971,972]},"v":"垃圾回收器","c":[{"t":"list_item","d":7,"p":{"lines":[972,973]},"v":"整体概述"},{"t":"list_item","d":7,"p":{"lines":[973,974]},"v":"垃圾回收相关算法","c":[{"t":"list_item","d":9,"p":{"lines":[974,975]},"v":"标记阶段","c":[{"t":"list_item","d":11,"p":{"lines":[975,976]},"v":"说明"},{"t":"list_item","d":11,"p":{"lines":[976,977]},"v":"算法","c":[{"t":"list_item","d":13,"p":{"lines":[977,978]},"v":"引用计数算法"},{"t":"list_item","d":13,"p":{"lines":[978,979]},"v":"可达性分析算法。"}]}]},{"t":"list_item","d":9,"p":{"lines":[979,980]},"v":"清除阶段","c":[{"t":"list_item","d":11,"p":{"lines":[980,981]},"v":"说明"},{"t":"list_item","d":11,"p":{"lines":[981,982]},"v":"算法","c":[{"t":"list_item","d":13,"p":{"lines":[982,983]},"v":"标记一清除算法（Mark-Sweep)"},{"t":"list_item","d":13,"p":{"lines":[983,984]},"v":"复制算法（Copying)"},{"t":"list_item","d":13,"p":{"lines":[984,985]},"v":"标记-压缩算法（Mark-Compact )"}]}]},{"t":"list_item","d":9,"p":{"lines":[985,986]},"v":"对象的finalization机制"},{"t":"list_item","d":9,"p":{"lines":[986,987]},"v":"对象的三种状态"},{"t":"list_item","d":9,"p":{"lines":[987,988]},"v":"其他算法","c":[{"t":"list_item","d":11,"p":{"lines":[988,989]},"v":"清除阶段：分代收集算法"},{"t":"list_item","d":11,"p":{"lines":[989,990]},"v":"清除阶段：增量收集算法"},{"t":"list_item","d":11,"p":{"lines":[990,991]},"v":"清除阶段：分区算法"}]}]},{"t":"list_item","d":7,"p":{"lines":[991,992]},"v":"垃圾回收相关概念","c":[{"t":"list_item","d":9,"p":{"lines":[992,993]},"v":"<code>System.gc()</code>"},{"t":"list_item","d":9,"p":{"lines":[993,994]},"v":"内存溢出"},{"t":"list_item","d":9,"p":{"lines":[994,995]},"v":"内存泄漏"},{"t":"list_item","d":9,"p":{"lines":[995,996]},"v":"Stop the world"},{"t":"list_item","d":9,"p":{"lines":[996,997]},"v":"垃圾回收的串行，并发与并行"},{"t":"list_item","d":9,"p":{"lines":[997,998]},"v":"安全点与安全区域"},{"t":"list_item","d":9,"p":{"lines":[998,999]},"v":"<strong>java中的引用</strong>","c":[{"t":"list_item","d":11,"p":{"lines":[999,1000]},"v":"强引用"},{"t":"list_item","d":11,"p":{"lines":[1000,1001]},"v":"软引用"},{"t":"list_item","d":11,"p":{"lines":[1001,1002]},"v":"弱引用"},{"t":"list_item","d":11,"p":{"lines":[1002,1003]},"v":"虚引用"},{"t":"list_item","d":11,"p":{"lines":[1003,1004]},"v":"<code>-------------------</code>"},{"t":"list_item","d":11,"p":{"lines":[1004,1005]},"v":"终结器引用"}]}]},{"t":"list_item","d":7,"p":{"lines":[1005,1006]},"v":"垃圾回收器","c":[{"t":"list_item","d":9,"p":{"lines":[1006,1007]},"v":"分类","c":[{"t":"list_item","d":11,"p":{"lines":[1007,1008]},"v":"按线程数","c":[{"t":"list_item","d":13,"p":{"lines":[1008,1009]},"v":"串行"},{"t":"list_item","d":13,"p":{"lines":[1009,1010]},"v":"并行"}]},{"t":"list_item","d":11,"p":{"lines":[1010,1011]},"v":"按工作模式","c":[{"t":"list_item","d":13,"p":{"lines":[1011,1012]},"v":"并发"},{"t":"list_item","d":13,"p":{"lines":[1012,1013]},"v":"独占"}]},{"t":"list_item","d":11,"p":{"lines":[1013,1014]},"v":"按碎片处理方式分","c":[{"t":"list_item","d":13,"p":{"lines":[1014,1015]},"v":"压缩整理"},{"t":"list_item","d":13,"p":{"lines":[1015,1016]},"v":"非压缩整理，空闲列表"}]},{"t":"list_item","d":11,"p":{"lines":[1016,1017]},"v":"按工作的区间分","c":[{"t":"list_item","d":13,"p":{"lines":[1017,1018]},"v":"新生代"},{"t":"list_item","d":13,"p":{"lines":[1018,1019]},"v":"老年代"},{"t":"list_item","d":13,"p":{"lines":[1019,1020]},"v":"混合"},{"t":"list_item","d":13,"p":{"lines":[1020,1021]},"v":"Full"}]}]},{"t":"list_item","d":9,"p":{"lines":[1021,1022]},"v":"性能指标","c":[{"t":"list_item","d":11,"p":{"lines":[1022,1023]},"v":"主要的三个：","c":[{"t":"list_item","d":13,"p":{"lines":[1023,1024]},"v":"<strong>吞吐量</strong>"},{"t":"list_item","d":13,"p":{"lines":[1024,1025]},"v":"垃圾收集开销"},{"t":"list_item","d":13,"p":{"lines":[1025,1026]},"v":"<strong>暂停时间</strong>"},{"t":"list_item","d":13,"p":{"lines":[1026,1027]},"v":"收集频率"},{"t":"list_item","d":13,"p":{"lines":[1027,1028]},"v":"<strong>内存占用</strong>"},{"t":"list_item","d":13,"p":{"lines":[1028,1029]},"v":"快速"}]},{"t":"list_item","d":11,"p":{"lines":[1029,1030]},"v":"吞吐量，暂停时间的相互限制"}]},{"t":"list_item","d":9,"p":{"lines":[1030,1031]},"v":"为什么要有多种垃圾回收器"},{"t":"list_item","d":9,"p":{"lines":[1031,1032]},"v":"7中经典垃圾回收器","c":[{"t":"list_item","d":11,"p":{"lines":[1032,1033]},"v":"时间顺序：","c":[{"t":"list_item","d":13,"p":{"lines":[1033,1034]},"v":"serial<br />parNew(是serial多线程版本)"},{"t":"list_item","d":13,"p":{"lines":[1034,1035]},"v":"Parallel<br />CMS"},{"t":"list_item","d":13,"p":{"lines":[1035,1036]},"v":"G1"}]},{"t":"list_item","d":11,"p":{"lines":[1036,1037]},"v":"<strong>组合关系</strong>"},{"t":"list_item","d":11,"p":{"lines":[1037,1038]},"v":"<strong>详细说明</strong> <br /> <strong>(分类，作用位置，使用算法，特点，适用场景)</strong>","c":[{"t":"list_item","d":13,"p":{"lines":[1038,1039]},"v":"Serial"},{"t":"list_item","d":13,"p":{"lines":[1039,1040]},"v":"Serial Old"},{"t":"list_item","d":13,"p":{"lines":[1040,1041]},"v":"ParNew"},{"t":"list_item","d":13,"p":{"lines":[1041,1042]},"v":"Parallel Scavenge","c":[{"t":"list_item","d":15,"p":{"lines":[1042,1043]},"v":"与parNew区别"}]},{"t":"list_item","d":13,"p":{"lines":[1043,1044]},"v":"Parallel Old"},{"t":"list_item","d":13,"p":{"lines":[1044,1045]},"v":"CMS","c":[{"t":"list_item","d":15,"p":{"lines":[1045,1046]},"v":"工作流程"},{"t":"list_item","d":15,"p":{"lines":[1046,1047]},"v":"优缺点"}]},{"t":"list_item","d":13,"p":{"lines":[1047,1048]},"v":"G1"}]},{"t":"list_item","d":11,"p":{"lines":[1048,1049]},"v":"垃圾回收器的选择"}]}]},{"t":"list_item","d":7,"p":{"lines":[1049,1050]},"v":"问题：","c":[{"t":"list_item","d":9,"p":{"lines":[1050,1051]},"v":"垃圾收集的算法有哪些？如何判断一个对象是否可以回收？"},{"t":"list_item","d":9,"p":{"lines":[1051,1052]},"v":"垃圾收集器工作的基本流程。"},{"t":"list_item","d":9,"p":{"lines":[1052,1053]},"v":"JVMGC算法有哪些，目前的JDK版本采用什么回收算法"},{"t":"list_item","d":9,"p":{"lines":[1053,1054]},"v":"G1回收器讲下回收过程"},{"t":"list_item","d":9,"p":{"lines":[1054,1055]},"v":"GC是什么？为什么要有GC?"},{"t":"list_item","d":9,"p":{"lines":[1055,1056]},"v":"GC的两种判定方法？CMS收集器与G1收集器的特点。"},{"t":"list_item","d":9,"p":{"lines":[1056,1057]},"v":"说一下GC算法，分代回收说下"},{"t":"list_item","d":9,"p":{"lines":[1057,1058]},"v":"垃圾收集策略和算法"},{"t":"list_item","d":9,"p":{"lines":[1058,1059]},"v":"jvm GC原理，JVM怎么回收内存"},{"t":"list_item","d":9,"p":{"lines":[1059,1060]},"v":"CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？"},{"t":"list_item","d":9,"p":{"lines":[1060,1061]},"v":"java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的"},{"t":"list_item","d":9,"p":{"lines":[1061,1062]},"v":"你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1,包括原理，流程，优缺点。"},{"t":"list_item","d":9,"p":{"lines":[1062,1063]},"v":"垃圾回收算法的实现原理。"},{"t":"list_item","d":9,"p":{"lines":[1063,1064]},"v":"讲一讲垃圾回收算法。"},{"t":"list_item","d":9,"p":{"lines":[1064,1065]},"v":"什么情况下触发垃圾回收？"},{"t":"list_item","d":9,"p":{"lines":[1065,1066]},"v":"如何选择合适的垃圾收集算法？"},{"t":"list_item","d":9,"p":{"lines":[1066,1067]},"v":"JVM有哪三种垃圾回收器？"},{"t":"list_item","d":9,"p":{"lines":[1067,1068]},"v":"常见的垃圾回收器算法有哪些，各有什么优劣？"},{"t":"list_item","d":9,"p":{"lines":[1068,1069]},"v":"system.gc()和runtime.gc()会做什么事情？"},{"t":"list_item","d":9,"p":{"lines":[1069,1070]},"v":"Java GC机制？GC Roots有哪些？"},{"t":"list_item","d":9,"p":{"lines":[1070,1071]},"v":"Java对象的回收方式，回收算法。"},{"t":"list_item","d":9,"p":{"lines":[1071,1072]},"v":"CMS和G1了解么，CMS解决什么问题，说一下回收的过程。"},{"t":"list_item","d":9,"p":{"lines":[1072,1073]},"v":"CMS回收停顿了几次，为什么要停顿两次。"}]}]}]}]},{"t":"heading","d":2,"p":{"lines":[1074,1075],"f":true},"v":"字节码与类加载子系统 "},{"t":"heading","d":2,"p":{"lines":[1076,1077],"f":true},"v":"jvm调优 "}]},{"t":"heading","d":1,"p":{"lines":[1078,1079]},"v":"常用框架","c":[{"t":"heading","d":2,"p":{"lines":[1080,1081],"f":true},"v":"Spring","c":[{"t":"heading","d":3,"p":{"lines":[1082,1083]},"v":"基础","c":[{"t":"list_item","d":5,"p":{"lines":[1084,1085]},"v":"什么是Spring框架"},{"t":"list_item","d":5,"p":{"lines":[1085,1086]},"v":"Spring框架的重要模块"},{"t":"list_item","d":5,"p":{"lines":[1086,1087]},"v":"为什么要使用Spring框架"},{"t":"list_item","d":5,"p":{"lines":[1087,1088]},"v":"Spring框架的两大核心","c":[{"t":"list_item","d":7,"p":{"lines":[1088,1089]},"v":"IOC"},{"t":"list_item","d":7,"p":{"lines":[1089,1090]},"v":"AOP"}]},{"t":"list_item","d":5,"p":{"lines":[1090,1091]},"v":"BeanFactory和ApplicationContextSpring"}]},{"t":"heading","d":3,"p":{"lines":[1092,1093]},"v":"IOC","c":[{"t":"list_item","d":5,"p":{"lines":[1094,1095]},"v":"概念"},{"t":"list_item","d":5,"p":{"lines":[1095,1096]},"v":"<a href=\"https://javadoop.com/post/spring-ioc\">IOC容器初始化过程</a>"},{"t":"list_item","d":5,"p":{"lines":[1097,1098]},"v":"基于xml的IOC","c":[{"t":"list_item","d":7,"p":{"lines":[1098,1099]},"v":"存入容器方式","c":[{"t":"list_item","d":9,"p":{"lines":[1099,1100]},"v":"Bean标签(各种属性可以进行配置)"}]},{"t":"list_item","d":7,"p":{"lines":[1100,1101]},"v":"依赖注入方式","c":[{"t":"list_item","d":9,"p":{"lines":[1101,1102]},"v":"注入Bean类型","c":[{"t":"list_item","d":11,"p":{"lines":[1102,1103]},"v":"使用构造函数(一般不用)"},{"t":"list_item","d":11,"p":{"lines":[1103,1104]},"v":"使用set方法(常用)"},{"t":"list_item","d":11,"p":{"lines":[1104,1105]},"v":"使用注解"}]},{"t":"list_item","d":9,"p":{"lines":[1105,1106]},"v":"注入基本类型和集合类型","c":[{"t":"list_item","d":11,"p":{"lines":[1106,1107]},"v":"通过xml"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[1108,1109]},"v":"基于注解的IOC","c":[{"t":"list_item","d":7,"p":{"lines":[1109,1110]},"v":"存入容器的注解","c":[{"t":"list_item","d":9,"p":{"lines":[1110,1111]},"v":"@Component"},{"t":"list_item","d":9,"p":{"lines":[1111,1112]},"v":"@Controller"},{"t":"list_item","d":9,"p":{"lines":[1112,1113]},"v":"@Service"},{"t":"list_item","d":9,"p":{"lines":[1113,1114]},"v":"@Repository"}]},{"t":"list_item","d":7,"p":{"lines":[1114,1115]},"v":"依赖注入的注解","c":[{"t":"list_item","d":9,"p":{"lines":[1115,1116]},"v":"注入Bean类型","c":[{"t":"list_item","d":11,"p":{"lines":[1116,1117]},"v":"@AutoWired"},{"t":"list_item","d":11,"p":{"lines":[1117,1118]},"v":"@Qualifier"},{"t":"list_item","d":11,"p":{"lines":[1118,1119]},"v":"@Reasource"}]},{"t":"list_item","d":9,"p":{"lines":[1119,1120]},"v":"注入基本类型","c":[{"t":"list_item","d":11,"p":{"lines":[1120,1121]},"v":"@Value"}]}]},{"t":"list_item","d":7,"p":{"lines":[1121,1122]},"v":"改变作用范围(和存入容器的注解搭配使用)","c":[{"t":"list_item","d":9,"p":{"lines":[1122,1123]},"v":"@Scope"}]},{"t":"list_item","d":7,"p":{"lines":[1123,1124]},"v":"生命周期相关注解","c":[{"t":"list_item","d":9,"p":{"lines":[1124,1125]},"v":"@PostConstruct"},{"t":"list_item","d":9,"p":{"lines":[1125,1126]},"v":"@PreDestroy"}]}]},{"t":"list_item","d":5,"p":{"lines":[1127,1128]},"v":"注意：对于无法添加注解<br />如导入的第三方依赖<br />可以通过xml将其存入或者向其注入<br />或者使用下面的<code>@Bean</code>"}]},{"t":"heading","d":3,"p":{"lines":[1129,1130]},"v":"摆脱xml的注解","c":[{"t":"list_item","d":5,"p":{"lines":[1131,1132]},"v":"@Configuration"},{"t":"list_item","d":5,"p":{"lines":[1132,1133]},"v":"@ComponentScan","c":[{"t":"list_item","d":7,"p":{"lines":[1133,1134]},"v":"对应<code>component:scan</code>"}]},{"t":"list_item","d":5,"p":{"lines":[1134,1135]},"v":"@Bean","c":[{"t":"list_item","d":7,"p":{"lines":[1135,1136]},"v":"对应xml中的工厂方法"},{"t":"list_item","d":7,"p":{"lines":[1136,1137]},"v":"通常配置在Config类<br />返回指定对象的上方"}]},{"t":"list_item","d":5,"p":{"lines":[1137,1138]},"v":"@Import"},{"t":"list_item","d":5,"p":{"lines":[1138,1139]},"v":"@PropertySource"}]},{"t":"heading","d":3,"p":{"lines":[1140,1141]},"v":"AOP","c":[{"t":"list_item","d":5,"p":{"lines":[1142,1143]},"v":"说明"},{"t":"list_item","d":5,"p":{"lines":[1143,1144]},"v":"相关概念","c":[{"t":"list_item","d":7,"p":{"lines":[1144,1145]},"v":"Joinpoint"},{"t":"list_item","d":7,"p":{"lines":[1145,1146]},"v":"Pointcut"},{"t":"list_item","d":7,"p":{"lines":[1146,1147]},"v":"Advice","c":[{"t":"list_item","d":9,"p":{"lines":[1147,1148]},"v":"前置通知"},{"t":"list_item","d":9,"p":{"lines":[1148,1149]},"v":"后置通知"},{"t":"list_item","d":9,"p":{"lines":[1149,1150]},"v":"异常通知"},{"t":"list_item","d":9,"p":{"lines":[1150,1151]},"v":"最终通知"},{"t":"list_item","d":9,"p":{"lines":[1151,1152]},"v":"环绕通知"}]},{"t":"list_item","d":7,"p":{"lines":[1152,1153]},"v":"Introduction"},{"t":"list_item","d":7,"p":{"lines":[1153,1154]},"v":"Target"},{"t":"list_item","d":7,"p":{"lines":[1154,1155]},"v":"Weaving"},{"t":"list_item","d":7,"p":{"lines":[1155,1156]},"v":"Proxy"},{"t":"list_item","d":7,"p":{"lines":[1156,1157]},"v":"Aspect"}]},{"t":"list_item","d":5,"p":{"lines":[1158,1159]},"v":"实现原理","c":[{"t":"list_item","d":7,"p":{"lines":[1159,1160]},"v":"静态代理AspectJ"},{"t":"list_item","d":7,"p":{"lines":[1160,1161]},"v":"动态代理","c":[{"t":"list_item","d":9,"p":{"lines":[1161,1162]},"v":"JDK"},{"t":"list_item","d":9,"p":{"lines":[1162,1163]},"v":"GBLib"},{"t":"list_item","d":9,"p":{"lines":[1163,1164]},"v":"两者对比"}]},{"t":"list_item","d":7,"p":{"lines":[1164,1165]},"v":"动态和静态对比"}]},{"t":"list_item","d":5,"p":{"lines":[1166,1167]},"v":"使用","c":[{"t":"list_item","d":7,"p":{"lines":[1167,1168]},"v":"xml","c":[{"t":"list_item","d":9,"p":{"lines":[1168,1169]},"v":"配置步骤"},{"t":"list_item","d":9,"p":{"lines":[1169,1170]},"v":"切入点表达式"}]},{"t":"list_item","d":7,"p":{"lines":[1170,1171]},"v":"注解","c":[{"t":"list_item","d":9,"p":{"lines":[1171,1172]},"v":"开启支持","c":[{"t":"list_item","d":11,"p":{"lines":[1172,1173]},"v":"xml：<code>aop:aspectj-autoproxy</code>"},{"t":"list_item","d":11,"p":{"lines":[1173,1174]},"v":"注解：<code>@EnableAspectJAutoProxy</code>"}]},{"t":"list_item","d":9,"p":{"lines":[1174,1175]},"v":"配置步骤"},{"t":"list_item","d":9,"p":{"lines":[1175,1176]},"v":"切入点表达式"}]}]}]},{"t":"heading","d":3,"p":{"lines":[1177,1178]},"v":"Bean","c":[{"t":"list_item","d":5,"p":{"lines":[1179,1180]},"v":"创建Bean的方式","c":[{"t":"list_item","d":7,"p":{"lines":[1180,1181]},"v":"默认构造函数"},{"t":"list_item","d":7,"p":{"lines":[1181,1182]},"v":"工厂类"},{"t":"list_item","d":7,"p":{"lines":[1182,1183]},"v":"静态工厂"}]},{"t":"list_item","d":5,"p":{"lines":[1184,1185]},"v":"Scope作用范围","c":[{"t":"list_item","d":7,"p":{"lines":[1185,1186]},"v":"singleton：单例的（默认值）"},{"t":"list_item","d":7,"p":{"lines":[1186,1187]},"v":"prototype：多例的"},{"t":"list_item","d":7,"p":{"lines":[1187,1188]},"v":"request：作用于web应用的请求范围"},{"t":"list_item","d":7,"p":{"lines":[1188,1189]},"v":"session：作用于web应用的会话范围"},{"t":"list_item","d":7,"p":{"lines":[1189,1190]},"v":"global-session：Spring5中已经没有了"}]},{"t":"list_item","d":5,"p":{"lines":[1191,1192]},"v":"生命周期"},{"t":"list_item","d":5,"p":{"lines":[1193,1194]},"v":"线程安全问题"}]},{"t":"heading","d":3,"p":{"lines":[1195,1196]},"v":"事务","c":[{"t":"list_item","d":5,"p":{"lines":[1197,1198]},"v":"Spring对事务的支持","c":[{"t":"list_item","d":7,"p":{"lines":[1198,1199]},"v":"取决于数据库"}]},{"t":"list_item","d":5,"p":{"lines":[1200,1201]},"v":"Spring事务相关API","c":[{"t":"list_item","d":7,"p":{"lines":[1201,1202]},"v":"PlatformTransactionManager"},{"t":"list_item","d":7,"p":{"lines":[1202,1203]},"v":"TransactionDefinition"},{"t":"list_item","d":7,"p":{"lines":[1203,1204]},"v":"TransactionStatus"}]},{"t":"list_item","d":5,"p":{"lines":[1205,1206]},"v":"事务管理方式","c":[{"t":"list_item","d":7,"p":{"lines":[1206,1207]},"v":"编程式（基本不用，仅仅为了了解原理）"},{"t":"list_item","d":7,"p":{"lines":[1207,1208]},"v":"声明式（基于AOP）","c":[{"t":"list_item","d":9,"p":{"lines":[1208,1209]},"v":"基于xml","c":[{"t":"list_item","d":11,"p":{"lines":[1209,1210]},"v":"配置流程"}]},{"t":"list_item","d":9,"p":{"lines":[1210,1211]},"v":"xml开启支持+注解配置","c":[{"t":"list_item","d":11,"p":{"lines":[1211,1212]},"v":"配置流程"}]},{"t":"list_item","d":9,"p":{"lines":[1212,1213]},"v":"纯注解配置","c":[{"t":"list_item","d":11,"p":{"lines":[1213,1214]},"v":"配置流程"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[1215,1216]},"v":"<strong>事务属性</strong><br />tx:advice标签内部可以配置<br />也可以使用注解配置","c":[{"t":"list_item","d":7,"p":{"lines":[1216,1217]},"v":"propagation(传播行为):(7)","c":[{"t":"list_item","d":9,"p":{"lines":[1217,1218]},"v":"支持当前事务的情况(3)","c":[{"t":"list_item","d":11,"p":{"lines":[1218,1219]},"v":"required(默认)"},{"t":"list_item","d":11,"p":{"lines":[1219,1220]},"v":"supports"},{"t":"list_item","d":11,"p":{"lines":[1220,1221]},"v":"mandatory"}]},{"t":"list_item","d":9,"p":{"lines":[1221,1222]},"v":"不支持当前事务的情况(3)","c":[{"t":"list_item","d":11,"p":{"lines":[1222,1223]},"v":"requires_new"},{"t":"list_item","d":11,"p":{"lines":[1223,1224]},"v":"not_supported"},{"t":"list_item","d":11,"p":{"lines":[1224,1225]},"v":"never"}]},{"t":"list_item","d":9,"p":{"lines":[1225,1226]},"v":"其他情况(1)","c":[{"t":"list_item","d":11,"p":{"lines":[1226,1227]},"v":"nested"}]}]},{"t":"list_item","d":7,"p":{"lines":[1227,1228]},"v":"isolation(隔离级别)(5)","c":[{"t":"list_item","d":9,"p":{"lines":[1228,1229]},"v":"default"},{"t":"list_item","d":9,"p":{"lines":[1229,1230]},"v":"read_uncommitted"},{"t":"list_item","d":9,"p":{"lines":[1230,1231]},"v":"read_committed"},{"t":"list_item","d":9,"p":{"lines":[1231,1232]},"v":"repeatable_read"},{"t":"list_item","d":9,"p":{"lines":[1232,1233]},"v":"serializable"}]},{"t":"list_item","d":7,"p":{"lines":[1233,1234]},"v":"timeout(超时属性)","c":[{"t":"list_item","d":9,"p":{"lines":[1234,1235]},"v":"用于指定事务的超时时间"},{"t":"list_item","d":9,"p":{"lines":[1235,1236]},"v":"默认值是-1"}]},{"t":"list_item","d":7,"p":{"lines":[1236,1237]},"v":"read-only(只读属性)","c":[{"t":"list_item","d":9,"p":{"lines":[1237,1238]},"v":"用于指定事务是否只读"},{"t":"list_item","d":9,"p":{"lines":[1238,1239]},"v":"默认false"}]},{"t":"list_item","d":7,"p":{"lines":[1239,1240]},"v":"回滚规则","c":[{"t":"list_item","d":9,"p":{"lines":[1240,1241]},"v":"rollback-for"},{"t":"list_item","d":9,"p":{"lines":[1241,1242]},"v":"no-rollback-for"}]}]}]},{"t":"heading","d":3,"p":{"lines":[1244,1245]},"v":"设计模式","c":[{"t":"list_item","d":5,"p":{"lines":[1246,1247]},"v":"工厂设计模式","c":[{"t":"list_item","d":7,"p":{"lines":[1247,1248]},"v":"BeanFactory"},{"t":"list_item","d":7,"p":{"lines":[1248,1249]},"v":"ApplicationContext"}]},{"t":"list_item","d":5,"p":{"lines":[1249,1250]},"v":"单例设计模式","c":[{"t":"list_item","d":7,"p":{"lines":[1250,1251]},"v":"bean默认作用域"},{"t":"list_item","d":7,"p":{"lines":[1251,1252]},"v":"实现：ConcurrentHashMap 实现单例注册表的特殊方式"}]},{"t":"list_item","d":5,"p":{"lines":[1252,1253]},"v":"代理设计模式","c":[{"t":"list_item","d":7,"p":{"lines":[1253,1254]},"v":"代理模式在 AOP 中的应用"},{"t":"list_item","d":7,"p":{"lines":[1254,1255]},"v":"代理模式的实现","c":[{"t":"list_item","d":9,"p":{"lines":[1255,1256]},"v":"静态代理AspectJ"},{"t":"list_item","d":9,"p":{"lines":[1256,1257]},"v":"动态代理","c":[{"t":"list_item","d":11,"p":{"lines":[1257,1258]},"v":"JDK"},{"t":"list_item","d":11,"p":{"lines":[1258,1259]},"v":"GBLib"},{"t":"list_item","d":11,"p":{"lines":[1259,1260]},"v":"两者对比"}]},{"t":"list_item","d":9,"p":{"lines":[1260,1261]},"v":"动态和静态对比"}]}]},{"t":"list_item","d":5,"p":{"lines":[1261,1262]},"v":"模板方法","c":[{"t":"list_item","d":7,"p":{"lines":[1262,1263]},"v":"jdbcTemplate"},{"t":"list_item","d":7,"p":{"lines":[1263,1264]},"v":"hibernateTemplate"},{"t":"list_item","d":7,"p":{"lines":[1264,1265]},"v":"RedisTemplate"}]},{"t":"list_item","d":5,"p":{"lines":[1265,1266]},"v":"观察者模式","c":[{"t":"list_item","d":7,"p":{"lines":[1266,1267]},"v":"Spring 事件驱动模型中的三种角色","c":[{"t":"list_item","d":9,"p":{"lines":[1267,1268]},"v":"事件角色"},{"t":"list_item","d":9,"p":{"lines":[1268,1269]},"v":"事件监听者角色"},{"t":"list_item","d":9,"p":{"lines":[1269,1270]},"v":"事件发布者角色"}]},{"t":"list_item","d":7,"p":{"lines":[1270,1271]},"v":"Spring 的事件流程总结"}]},{"t":"list_item","d":5,"p":{"lines":[1271,1272]},"v":"适配器模式","c":[{"t":"list_item","d":7,"p":{"lines":[1272,1273]},"v":"spring AOP中的适配器模式"},{"t":"list_item","d":7,"p":{"lines":[1273,1274]},"v":"spring MVC中的适配器模式"}]},{"t":"list_item","d":5,"p":{"lines":[1274,1275]},"v":"装饰者模式"}]}]},{"t":"heading","d":2,"p":{"lines":[1276,1277],"f":true},"v":"SpringMVC "},{"t":"heading","d":2,"p":{"lines":[1278,1279],"f":true},"v":"SpringBoot "},{"t":"heading","d":2,"p":{"lines":[1280,1281],"f":true},"v":"Mybatis ","c":[{"t":"bullet_list","d":3,"p":{"lines":[1282,1324]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[1282,1283]},"v":"基本使用","c":[{"t":"list_item","d":6,"p":{"lines":[1283,1284]},"v":"xml","c":[{"t":"list_item","d":8,"p":{"lines":[1284,1285]},"v":"常见标签","c":[{"t":"list_item","d":10,"p":{"lines":[1285,1286]},"v":"select"},{"t":"list_item","d":10,"p":{"lines":[1286,1287]},"v":"insert","c":[{"t":"list_item","d":12,"p":{"lines":[1287,1288]},"v":"selectKey(获取插入数据的主键)"}]},{"t":"list_item","d":10,"p":{"lines":[1288,1289]},"v":"update"},{"t":"list_item","d":10,"p":{"lines":[1289,1290]},"v":"delete"}]},{"t":"list_item","d":8,"p":{"lines":[1290,1291]},"v":"配置标签","c":[{"t":"list_item","d":10,"p":{"lines":[1291,1292]},"v":"typeAliases","c":[{"t":"list_item","d":12,"p":{"lines":[1292,1293]},"v":"package<br />(指定<strong>实体类</strong>包，用于起别名)"}]},{"t":"list_item","d":10,"p":{"lines":[1293,1294]},"v":"mapper","c":[{"t":"list_item","d":12,"p":{"lines":[1294,1295]},"v":"package<br />(指定<strong>dao类</strong>包，避免往SqlConfig文件中的<br />mappers中添加mapper标签)"}]}]},{"t":"list_item","d":8,"p":{"lines":[1295,1296]},"v":"其他标签","c":[{"t":"list_item","d":10,"p":{"lines":[1296,1297]},"v":"resultMap"},{"t":"list_item","d":10,"p":{"lines":[1297,1298]},"v":"parameterMap"},{"t":"list_item","d":10,"p":{"lines":[1298,1299]},"v":"include"},{"t":"list_item","d":10,"p":{"lines":[1299,1300]},"v":"sql"},{"t":"list_item","d":10,"p":{"lines":[1300,1301]},"v":"selectKey"}]},{"t":"list_item","d":8,"p":{"lines":[1301,1302]},"v":"动态sql标签","c":[{"t":"list_item","d":10,"p":{"lines":[1302,1303]},"v":"trim"},{"t":"list_item","d":10,"p":{"lines":[1303,1304]},"v":"where"},{"t":"list_item","d":10,"p":{"lines":[1304,1305]},"v":"set"},{"t":"list_item","d":10,"p":{"lines":[1305,1306]},"v":"foreach"},{"t":"list_item","d":10,"p":{"lines":[1306,1307]},"v":"if"},{"t":"list_item","d":10,"p":{"lines":[1307,1308]},"v":"choose"},{"t":"list_item","d":10,"p":{"lines":[1308,1309]},"v":"when"},{"t":"list_item","d":10,"p":{"lines":[1309,1310]},"v":"otherwise"},{"t":"list_item","d":10,"p":{"lines":[1310,1311]},"v":"bind"},{"t":"list_item","d":10,"p":{"lines":[1311,1312]},"v":"include","c":[{"t":"list_item","d":12,"p":{"lines":[1312,1313]},"v":"搭配<code>sql</code>标签"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[1313,1314]},"v":"注解","c":[{"t":"list_item","d":8,"p":{"lines":[1314,1315]},"v":"常见标签","c":[{"t":"list_item","d":10,"p":{"lines":[1315,1316]},"v":"@Select"},{"t":"list_item","d":10,"p":{"lines":[1316,1317]},"v":"@Insert"},{"t":"list_item","d":10,"p":{"lines":[1317,1318]},"v":"@Update"},{"t":"list_item","d":10,"p":{"lines":[1318,1319]},"v":"@Delete"}]},{"t":"list_item","d":8,"p":{"lines":[1319,1320]},"v":"其他标签","c":[{"t":"list_item","d":10,"p":{"lines":[1320,1321]},"v":"@Results","c":[{"t":"list_item","d":12,"p":{"lines":[1321,1322]},"v":"定义并使用"}]},{"t":"list_item","d":10,"p":{"lines":[1322,1323]},"v":"@ResultMap","c":[{"t":"list_item","d":12,"p":{"lines":[1323,1324]},"v":"使用已定义的"}]}]}]}]}]},{"t":"bullet_list","d":3,"p":{"lines":[1326,1361]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[1326,1327]},"v":"<strong>执行流程</strong>"},{"t":"list_item","d":4,"p":{"lines":[1328,1329]},"v":"动态sql"},{"t":"list_item","d":4,"p":{"lines":[1330,1331]},"v":"多表查询","c":[{"t":"list_item","d":6,"p":{"lines":[1331,1332]},"v":"一对一(多对一)"},{"t":"list_item","d":6,"p":{"lines":[1332,1333]},"v":"一对多"},{"t":"list_item","d":6,"p":{"lines":[1333,1334]},"v":"多对多"}]},{"t":"list_item","d":4,"p":{"lines":[1335,1336]},"v":"加载","c":[{"t":"list_item","d":6,"p":{"lines":[1336,1337]},"v":"立即加载","c":[{"t":"list_item","d":8,"p":{"lines":[1337,1338]},"v":"使用场景"},{"t":"list_item","d":8,"p":{"lines":[1338,1339]},"v":"说明"}]},{"t":"list_item","d":6,"p":{"lines":[1339,1340]},"v":"延迟加载","c":[{"t":"list_item","d":8,"p":{"lines":[1340,1341]},"v":"使用场景"},{"t":"list_item","d":8,"p":{"lines":[1341,1342]},"v":"说明"},{"t":"list_item","d":8,"p":{"lines":[1342,1343]},"v":"配置"}]}]},{"t":"list_item","d":4,"p":{"lines":[1343,1344]},"v":"缓存","c":[{"t":"list_item","d":6,"p":{"lines":[1344,1345]},"v":"说明"},{"t":"list_item","d":6,"p":{"lines":[1345,1346]},"v":"种类","c":[{"t":"list_item","d":8,"p":{"lines":[1346,1347]},"v":"一级缓存","c":[{"t":"list_item","d":10,"p":{"lines":[1347,1348]},"v":"概念"},{"t":"list_item","d":10,"p":{"lines":[1348,1349]},"v":"触发"}]},{"t":"list_item","d":8,"p":{"lines":[1349,1350]},"v":"二级缓存","c":[{"t":"list_item","d":10,"p":{"lines":[1350,1351]},"v":"概念"},{"t":"list_item","d":10,"p":{"lines":[1351,1352]},"v":"配置开启","c":[{"t":"list_item","d":12,"p":{"lines":[1352,1353]},"v":"xml","c":[{"t":"list_item","d":14,"p":{"lines":[1353,1354]},"v":"config.xml"},{"t":"list_item","d":14,"p":{"lines":[1354,1355]},"v":"dao.xml"},{"t":"list_item","d":14,"p":{"lines":[1355,1356]},"v":"<code>&lt;select&gt;</code>"}]},{"t":"list_item","d":12,"p":{"lines":[1356,1357]},"v":"注解","c":[{"t":"list_item","d":14,"p":{"lines":[1357,1358]},"v":"SqlMapConfig.xml"},{"t":"list_item","d":14,"p":{"lines":[1358,1359]},"v":"@CacheNamespace(blocking=true)"}]}]},{"t":"list_item","d":10,"p":{"lines":[1359,1360]},"v":"触发"}]}]}]}]}]},{"t":"heading","d":2,"p":{"lines":[1361,1362],"f":true},"v":"Netty "},{"t":"heading","d":2,"p":{"lines":[1363,1364],"f":true},"v":"quartz "}]},{"t":"heading","d":1,"p":{"lines":[1365,1366]},"v":"数据库","c":[{"t":"heading","d":2,"p":{"lines":[1367,1368]},"v":"关系型数据库","c":[{"t":"heading","d":3,"p":{"lines":[1369,1370],"f":true},"v":"Mysql","c":[{"t":"list_item","d":5,"p":{"lines":[1371,1372]},"v":"存储引擎","c":[{"t":"list_item","d":7,"p":{"lines":[1372,1373]},"v":"MyISAM"},{"t":"list_item","d":7,"p":{"lines":[1373,1374]},"v":"Innodb"},{"t":"list_item","d":7,"p":{"lines":[1374,1375]},"v":"两者区别"}]},{"t":"list_item","d":5,"p":{"lines":[1376,1377]},"v":"锁机制","c":[{"t":"list_item","d":7,"p":{"lines":[1377,1378]},"v":"MyISAM"},{"t":"list_item","d":7,"p":{"lines":[1378,1379]},"v":"Innodb"}]},{"t":"list_item","d":5,"p":{"lines":[1380,1381]},"v":"范式","c":[{"t":"list_item","d":7,"p":{"lines":[1381,1382]},"v":"第一范式"},{"t":"list_item","d":7,"p":{"lines":[1382,1383]},"v":"第二范式"},{"t":"list_item","d":7,"p":{"lines":[1383,1384]},"v":"第三范式"},{"t":"list_item","d":7,"p":{"lines":[1384,1385]},"v":"Boyce-Codd 范式（BCNF）"}]},{"t":"list_item","d":5,"p":{"lines":[1386,1387]},"v":"事务","c":[{"t":"list_item","d":7,"p":{"lines":[1387,1388]},"v":"四大特征","c":[{"t":"list_item","d":9,"p":{"lines":[1388,1389]},"v":"原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败"},{"t":"list_item","d":9,"p":{"lines":[1389,1390]},"v":"持久性：如果事务一旦提交或者回滚，数据库会持久更新数据。"},{"t":"list_item","d":9,"p":{"lines":[1390,1391]},"v":"隔离性：多个事务之间相互独立。但一般会相互影响。"},{"t":"list_item","d":9,"p":{"lines":[1391,1392]},"v":"一致性：表示事务操作前后数据总量不变。"}]},{"t":"list_item","d":7,"p":{"lines":[1392,1393]},"v":"隔离等级","c":[{"t":"list_item","d":9,"p":{"lines":[1393,1394]},"v":"并发事务的问题","c":[{"t":"list_item","d":11,"p":{"lines":[1394,1395]},"v":"脏读"},{"t":"list_item","d":11,"p":{"lines":[1395,1396]},"v":"丢失修改"},{"t":"list_item","d":11,"p":{"lines":[1396,1397]},"v":"不可重复读（虚读）"},{"t":"list_item","d":11,"p":{"lines":[1397,1398]},"v":"幻读"}]},{"t":"list_item","d":9,"p":{"lines":[1398,1399]},"v":"隔离级别<br />与问题解决","c":[{"t":"list_item","d":11,"p":{"lines":[1399,1400]},"v":"read uncommitted:","c":[{"t":"list_item","d":13,"p":{"lines":[1400,1401]},"v":"说明"},{"t":"list_item","d":13,"p":{"lines":[1401,1402]},"v":"产生问题：脏读，不可重复读，幻读"}]},{"t":"list_item","d":11,"p":{"lines":[1402,1403]},"v":"read committed:","c":[{"t":"list_item","d":13,"p":{"lines":[1403,1404]},"v":"说明"},{"t":"list_item","d":13,"p":{"lines":[1404,1405]},"v":"产生问题：不可重复读，幻读"}]},{"t":"list_item","d":11,"p":{"lines":[1405,1406]},"v":"repeatalbe read:","c":[{"t":"list_item","d":13,"p":{"lines":[1406,1407]},"v":"说明"},{"t":"list_item","d":13,"p":{"lines":[1407,1408]},"v":"产生问题：幻读"}]},{"t":"list_item","d":11,"p":{"lines":[1408,1409]},"v":"serializable","c":[{"t":"list_item","d":13,"p":{"lines":[1409,1410]},"v":"说明"},{"t":"list_item","d":13,"p":{"lines":[1410,1411]},"v":"可以解决所有问题"}]}]}]}]}]},{"t":"heading","d":3,"p":{"lines":[1413,1414],"f":true},"v":"oracle"}]},{"t":"heading","d":2,"p":{"lines":[1415,1416]},"v":"nosql","c":[{"t":"heading","d":3,"p":{"lines":[1417,1418],"f":true},"v":"Redis","c":[{"t":"list_item","d":5,"p":{"lines":[1419,1420]},"v":"基本数据类型","c":[{"t":"list_item","d":7,"p":{"lines":[1420,1421]},"v":"String","c":[{"t":"list_item","d":9,"p":{"lines":[1421,1422]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1422,1423]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1423,1424]},"v":"数据结构"}]},{"t":"list_item","d":7,"p":{"lines":[1424,1425]},"v":"Hash","c":[{"t":"list_item","d":9,"p":{"lines":[1425,1426]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1426,1427]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1427,1428]},"v":"数据结构"}]},{"t":"list_item","d":7,"p":{"lines":[1428,1429]},"v":"List","c":[{"t":"list_item","d":9,"p":{"lines":[1429,1430]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1430,1431]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1431,1432]},"v":"数据结构"}]},{"t":"list_item","d":7,"p":{"lines":[1432,1433]},"v":"Set","c":[{"t":"list_item","d":9,"p":{"lines":[1433,1434]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1434,1435]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1435,1436]},"v":"数据结构"}]},{"t":"list_item","d":7,"p":{"lines":[1436,1437]},"v":"ZSet","c":[{"t":"list_item","d":9,"p":{"lines":[1437,1438]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1438,1439]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1439,1440]},"v":"数据结构"}]},{"t":"list_item","d":7,"p":{"lines":[1440,1441]},"v":"HyperLogLog","c":[{"t":"list_item","d":9,"p":{"lines":[1441,1442]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1442,1443]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1443,1444]},"v":"数据结构"}]}]},{"t":"list_item","d":5,"p":{"lines":[1445,1446]},"v":"高级算法","c":[{"t":"list_item","d":7,"p":{"lines":[1446,1447]},"v":"scan"},{"t":"list_item","d":7,"p":{"lines":[1447,1448]},"v":"GeoHash"}]},{"t":"list_item","d":5,"p":{"lines":[1449,1450]},"v":"过期淘汰","c":[{"t":"list_item","d":7,"p":{"lines":[1450,1451]},"v":"过期删除策略","c":[{"t":"list_item","d":9,"p":{"lines":[1451,1452]},"v":"定时删除"},{"t":"list_item","d":9,"p":{"lines":[1452,1453]},"v":"惰性删除"},{"t":"list_item","d":9,"p":{"lines":[1453,1454]},"v":"定期删除"}]},{"t":"list_item","d":7,"p":{"lines":[1454,1455]},"v":"内存淘汰策略","c":[{"t":"list_item","d":9,"p":{"lines":[1455,1456]},"v":"no-eviction"},{"t":"list_item","d":9,"p":{"lines":[1456,1457]},"v":"allkeys","c":[{"t":"list_item","d":11,"p":{"lines":[1457,1458]},"v":"random"},{"t":"list_item","d":11,"p":{"lines":[1458,1459]},"v":"lru"},{"t":"list_item","d":11,"p":{"lines":[1459,1460]},"v":"lfu"}]},{"t":"list_item","d":9,"p":{"lines":[1460,1461]},"v":"volatile","c":[{"t":"list_item","d":11,"p":{"lines":[1461,1462]},"v":"ttl"},{"t":"list_item","d":11,"p":{"lines":[1462,1463]},"v":"random"},{"t":"list_item","d":11,"p":{"lines":[1463,1464]},"v":"lru"},{"t":"list_item","d":11,"p":{"lines":[1464,1465]},"v":"lfu"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[1465,1466]},"v":"持久化","c":[{"t":"list_item","d":7,"p":{"lines":[1466,1467]},"v":"RDB","c":[{"t":"list_item","d":9,"p":{"lines":[1467,1468]},"v":"持久化原理/过程"},{"t":"list_item","d":9,"p":{"lines":[1468,1469]},"v":"配置"},{"t":"list_item","d":9,"p":{"lines":[1469,1470]},"v":"触发","c":[{"t":"list_item","d":11,"p":{"lines":[1470,1471]},"v":"自动","c":[{"t":"list_item","d":13,"p":{"lines":[1471,1472]},"v":"默认的三个"},{"t":"list_item","d":13,"p":{"lines":[1472,1473]},"v":"原理"}]},{"t":"list_item","d":11,"p":{"lines":[1473,1474]},"v":"手动(4种)"}]},{"t":"list_item","d":9,"p":{"lines":[1474,1475]},"v":"check检查"},{"t":"list_item","d":9,"p":{"lines":[1475,1476]},"v":"优劣势"}]},{"t":"list_item","d":7,"p":{"lines":[1476,1477]},"v":"AOF","c":[{"t":"list_item","d":9,"p":{"lines":[1477,1478]},"v":"持久化原理/过程"},{"t":"list_item","d":9,"p":{"lines":[1478,1479]},"v":"配置"},{"t":"list_item","d":9,"p":{"lines":[1479,1480]},"v":"触发","c":[{"t":"list_item","d":11,"p":{"lines":[1480,1481]},"v":"开启后自动"},{"t":"list_item","d":11,"p":{"lines":[1481,1482]},"v":"手动<code>bgrewriteaof</code>"}]},{"t":"list_item","d":9,"p":{"lines":[1482,1483]},"v":"check检查"},{"t":"list_item","d":9,"p":{"lines":[1483,1484]},"v":"AOF重写","c":[{"t":"list_item","d":11,"p":{"lines":[1484,1485]},"v":"原理","c":[{"t":"list_item","d":13,"p":{"lines":[1485,1486]},"v":"读取服务器现有KV"},{"t":"list_item","d":13,"p":{"lines":[1486,1487]},"v":"fork子<strong>进程</strong>"}]},{"t":"list_item","d":11,"p":{"lines":[1487,1488]},"v":"触发"},{"t":"list_item","d":11,"p":{"lines":[1488,1489]},"v":"重写数据不一致问题"},{"t":"list_item","d":11,"p":{"lines":[1489,1490]},"v":"重写数据不一致问题解决"}]},{"t":"list_item","d":9,"p":{"lines":[1490,1491]},"v":"(总结)两个缓冲区"}]}]},{"t":"list_item","d":5,"p":{"lines":[1492,1493]},"v":"事务","c":[{"t":"list_item","d":7,"p":{"lines":[1493,1494]},"v":"基本命令"},{"t":"list_item","d":7,"p":{"lines":[1494,1495]},"v":"乐观锁"},{"t":"list_item","d":7,"p":{"lines":[1495,1496]},"v":"两种异常情况：","c":[{"t":"list_item","d":9,"p":{"lines":[1496,1497]},"v":"全都不执行"},{"t":"list_item","d":9,"p":{"lines":[1497,1498]},"v":"执行可以执行的"}]}]},{"t":"list_item","d":5,"p":{"lines":[1499,1500]},"v":"并发问题解决","c":[{"t":"list_item","d":7,"p":{"lines":[1500,1501]},"v":"乐观锁"},{"t":"list_item","d":7,"p":{"lines":[1501,1502]},"v":"分布式锁"},{"t":"list_item","d":7,"p":{"lines":[1502,1503]},"v":"消息队列"},{"t":"list_item","d":7,"p":{"lines":[1503,1504]},"v":"时间戳"}]},{"t":"list_item","d":5,"p":{"lines":[1505,1506]},"v":"消息发布订阅"},{"t":"list_item","d":5,"p":{"lines":[1507,1508]},"v":"集群","c":[{"t":"list_item","d":7,"p":{"lines":[1508,1509]},"v":"主从复制"},{"t":"list_item","d":7,"p":{"lines":[1509,1510]},"v":"哨兵模式"},{"t":"list_item","d":7,"p":{"lines":[1510,1511]},"v":"分片cluster"}]},{"t":"list_item","d":5,"p":{"lines":[1512,1513]},"v":"常见问题","c":[{"t":"list_item","d":7,"p":{"lines":[1513,1514]},"v":"缓存雪崩","c":[{"t":"list_item","d":9,"p":{"lines":[1514,1515]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1515,1516]},"v":"解决方案"}]},{"t":"list_item","d":7,"p":{"lines":[1516,1517]},"v":"缓存穿透","c":[{"t":"list_item","d":9,"p":{"lines":[1517,1518]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1518,1519]},"v":"解决方案"}]},{"t":"list_item","d":7,"p":{"lines":[1519,1520]},"v":"双写一致","c":[{"t":"list_item","d":9,"p":{"lines":[1520,1521]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1521,1522]},"v":"解决方案"}]},{"t":"list_item","d":7,"p":{"lines":[1522,1523]},"v":"线程模型","c":[{"t":"list_item","d":9,"p":{"lines":[1523,1524]},"v":"为什么能单线程处理那么多客户端"},{"t":"list_item","d":9,"p":{"lines":[1524,1525]},"v":"为什么6.0前不使用多线程"},{"t":"list_item","d":9,"p":{"lines":[1525,1526]},"v":"Redis 6.0为什么使用多线程"}]}]},{"t":"list_item","d":5,"p":{"lines":[1527,1528]},"v":"redis应用","c":[{"t":"list_item","d":7,"p":{"lines":[1528,1529]},"v":"redis分布式锁","c":[{"t":"list_item","d":9,"p":{"lines":[1529,1530]},"v":"高校分布式锁条件","c":[{"t":"list_item","d":11,"p":{"lines":[1530,1531]},"v":"互斥"},{"t":"list_item","d":11,"p":{"lines":[1531,1532]},"v":"防止死锁"},{"t":"list_item","d":11,"p":{"lines":[1532,1533]},"v":"性能"},{"t":"list_item","d":11,"p":{"lines":[1533,1534]},"v":"可重入"}]},{"t":"list_item","d":9,"p":{"lines":[1534,1535]},"v":"两个问题及解决思路","c":[{"t":"list_item","d":11,"p":{"lines":[1535,1536]},"v":"setnx,expire原子性"},{"t":"list_item","d":11,"p":{"lines":[1536,1537]},"v":"锁提前失效"}]},{"t":"list_item","d":9,"p":{"lines":[1537,1538]},"v":"redisson锁","c":[{"t":"list_item","d":11,"p":{"lines":[1538,1539]},"v":"流程/原理"},{"t":"list_item","d":11,"p":{"lines":[1539,1540]},"v":"看门狗机制"},{"t":"list_item","d":11,"p":{"lines":[1540,1541]},"v":"lua脚本"},{"t":"list_item","d":11,"p":{"lines":[1541,1542]},"v":"实现可重入:Hash"},{"t":"list_item","d":11,"p":{"lines":[1542,1543]},"v":"缺陷"}]}]},{"t":"list_item","d":7,"p":{"lines":[1543,1544]},"v":"缓存","c":[{"t":"list_item","d":9,"p":{"lines":[1544,1545]},"v":"旁路缓存模式"},{"t":"list_item","d":9,"p":{"lines":[1545,1546]},"v":"读写穿透"},{"t":"list_item","d":9,"p":{"lines":[1546,1547]},"v":"异步缓存写入"}]},{"t":"list_item","d":7,"p":{"lines":[1547,1548]},"v":"布隆过滤器"},{"t":"list_item","d":7,"p":{"lines":[1548,1549]},"v":"布谷鸟过滤器"}]}]},{"t":"heading","d":3,"p":{"lines":[1551,1552],"f":true},"v":"MongoDB"}]}]},{"t":"heading","d":1,"p":{"lines":[1553,1554]},"v":"基础","c":[{"t":"heading","d":2,"p":{"lines":[1556,1557],"f":true},"v":"设计模式","c":[{"t":"heading","d":3,"p":{"lines":[1558,1559]},"v":"七大原则"},{"t":"heading","d":3,"p":{"lines":[1560,1561]},"v":"设计模式","c":[{"t":"heading","d":4,"p":{"lines":[1562,1563]},"v":"创建型模式"},{"t":"heading","d":4,"p":{"lines":[1564,1565]},"v":"结构型模式"},{"t":"heading","d":4,"p":{"lines":[1566,1567]},"v":"行为型模式"},{"t":"heading","d":4,"p":{"lines":[1568,1569]},"v":"J2EE型模式"}]}]},{"t":"heading","d":2,"p":{"lines":[1570,1571],"f":true},"v":"计算机网络","c":[{"t":"list_item","d":4,"p":{"lines":[1572,1573]},"v":"理论<br />(参考《计算机网络》谢希仁)","c":[{"t":"list_item","d":6,"p":{"lines":[1573,1574]},"v":"概述","c":[{"t":"list_item","d":8,"p":{"lines":[1574,1575]},"v":"基本概念","c":[{"t":"list_item","d":10,"p":{"lines":[1575,1576]},"v":"结点"},{"t":"list_item","d":10,"p":{"lines":[1576,1577]},"v":"链路"},{"t":"list_item","d":10,"p":{"lines":[1577,1578]},"v":"主机"},{"t":"list_item","d":10,"p":{"lines":[1578,1579]},"v":"internet和Internet"},{"t":"list_item","d":10,"p":{"lines":[1579,1580]},"v":"ISP和IXP"}]},{"t":"list_item","d":8,"p":{"lines":[1580,1581]},"v":"因特网组成","c":[{"t":"list_item","d":10,"p":{"lines":[1581,1582]},"v":"边缘部分","c":[{"t":"list_item","d":12,"p":{"lines":[1582,1583]},"v":"client-server"},{"t":"list_item","d":12,"p":{"lines":[1583,1584]},"v":"p2p"}]},{"t":"list_item","d":10,"p":{"lines":[1584,1585]},"v":"核心部分","c":[{"t":"list_item","d":12,"p":{"lines":[1585,1586]},"v":"电路交换"},{"t":"list_item","d":12,"p":{"lines":[1586,1587]},"v":"报文交换"},{"t":"list_item","d":12,"p":{"lines":[1587,1588]},"v":"分组交换"}]}]},{"t":"list_item","d":8,"p":{"lines":[1588,1589]},"v":"计算机网络类别","c":[{"t":"list_item","d":10,"p":{"lines":[1589,1590]},"v":"广域网WAN"},{"t":"list_item","d":10,"p":{"lines":[1590,1591]},"v":"区域网MAN"},{"t":"list_item","d":10,"p":{"lines":[1591,1592]},"v":"城域网LAN"},{"t":"list_item","d":10,"p":{"lines":[1592,1593]},"v":"个人区域网PAN"}]},{"t":"list_item","d":8,"p":{"lines":[1593,1594]},"v":"计算机网络性能指标","c":[{"t":"list_item","d":10,"p":{"lines":[1594,1595]},"v":"速率"},{"t":"list_item","d":10,"p":{"lines":[1595,1596]},"v":"管带"},{"t":"list_item","d":10,"p":{"lines":[1596,1597]},"v":"吞吐量"},{"t":"list_item","d":10,"p":{"lines":[1597,1598]},"v":"时延","c":[{"t":"list_item","d":12,"p":{"lines":[1598,1599]},"v":"发送"},{"t":"list_item","d":12,"p":{"lines":[1599,1600]},"v":"处理"},{"t":"list_item","d":12,"p":{"lines":[1600,1601]},"v":"传播"},{"t":"list_item","d":12,"p":{"lines":[1601,1602]},"v":"排队"}]},{"t":"list_item","d":10,"p":{"lines":[1602,1603]},"v":"时延带宽积"},{"t":"list_item","d":10,"p":{"lines":[1603,1604]},"v":"往返时间RRT"},{"t":"list_item","d":10,"p":{"lines":[1604,1605]},"v":"利用率"}]},{"t":"list_item","d":8,"p":{"lines":[1605,1606]},"v":"计算机网络体系结构","c":[{"t":"list_item","d":10,"p":{"lines":[1606,1607]},"v":"OSI七层"},{"t":"list_item","d":10,"p":{"lines":[1607,1608]},"v":"TCP/IP四层"},{"t":"list_item","d":10,"p":{"lines":[1608,1609]},"v":"课本按照五层"}]}]},{"t":"list_item","d":6,"p":{"lines":[1609,1610]},"v":"物理层"},{"t":"list_item","d":6,"p":{"lines":[1610,1611]},"v":"链路层","c":[{"t":"list_item","d":8,"p":{"lines":[1611,1612]},"v":"点对点信道","c":[{"t":"list_item","d":10,"p":{"lines":[1612,1613]},"v":"基本概念","c":[{"t":"list_item","d":12,"p":{"lines":[1613,1614]},"v":"链路"},{"t":"list_item","d":12,"p":{"lines":[1614,1615]},"v":"数据链路"},{"t":"list_item","d":12,"p":{"lines":[1615,1616]},"v":"网络适配器"}]},{"t":"list_item","d":10,"p":{"lines":[1616,1617]},"v":"三个基本问题","c":[{"t":"list_item","d":12,"p":{"lines":[1617,1618]},"v":"封装成帧:帧格式"},{"t":"list_item","d":12,"p":{"lines":[1618,1619]},"v":"透明传输:原理"},{"t":"list_item","d":12,"p":{"lines":[1619,1620]},"v":"差错检测","c":[{"t":"list_item","d":14,"p":{"lines":[1620,1621]},"v":"循环冗余检验CRC"},{"t":"list_item","d":14,"p":{"lines":[1621,1622]},"v":"帧检验序列FCS"}]}]},{"t":"list_item","d":10,"p":{"lines":[1622,1623]},"v":"ppp协议","c":[{"t":"list_item","d":12,"p":{"lines":[1623,1624]},"v":"协议特点"},{"t":"list_item","d":12,"p":{"lines":[1624,1625]},"v":"协议组成"},{"t":"list_item","d":12,"p":{"lines":[1625,1626]},"v":"PPP帧格式"},{"t":"list_item","d":12,"p":{"lines":[1626,1627]},"v":"透明传输","c":[{"t":"list_item","d":14,"p":{"lines":[1627,1628]},"v":"异步传输：字节填充"},{"t":"list_item","d":14,"p":{"lines":[1628,1629]},"v":"同步传输：零比特填充"}]},{"t":"list_item","d":12,"p":{"lines":[1629,1630]},"v":"确保边界：零比特填充"},{"t":"list_item","d":12,"p":{"lines":[1630,1631]},"v":"PPP工作状态"}]}]},{"t":"list_item","d":8,"p":{"lines":[1631,1632]},"v":"广播信道","c":[{"t":"list_item","d":10,"p":{"lines":[1632,1633]},"v":"适配器作用"},{"t":"list_item","d":10,"p":{"lines":[1633,1634]},"v":"三个基本问题","c":[{"t":"list_item","d":12,"p":{"lines":[1634,1635]},"v":"封装成帧:帧格式"},{"t":"list_item","d":12,"p":{"lines":[1635,1636]},"v":"透明传输:不需要"},{"t":"list_item","d":12,"p":{"lines":[1636,1637]},"v":"差错检测","c":[{"t":"list_item","d":14,"p":{"lines":[1637,1638]},"v":"循环冗余检验CRC"},{"t":"list_item","d":14,"p":{"lines":[1638,1639]},"v":"帧检验序列FCS"}]}]},{"t":"list_item","d":10,"p":{"lines":[1639,1640]},"v":"协议","c":[{"t":"list_item","d":12,"p":{"lines":[1640,1641]},"v":"<strong>CSMA/CD碰撞检测</strong>"},{"t":"list_item","d":12,"p":{"lines":[1641,1642]},"v":"TDMA"},{"t":"list_item","d":12,"p":{"lines":[1642,1643]},"v":"FDMA"},{"t":"list_item","d":12,"p":{"lines":[1643,1644]},"v":"slotted ALOHA"},{"t":"list_item","d":12,"p":{"lines":[1644,1645]},"v":"ALOHA"}]},{"t":"list_item","d":10,"p":{"lines":[1645,1646]},"v":"MAC地址","c":[{"t":"list_item","d":12,"p":{"lines":[1646,1647]},"v":"概念"},{"t":"list_item","d":12,"p":{"lines":[1647,1648]},"v":"作用"},{"t":"list_item","d":12,"p":{"lines":[1648,1649]},"v":"地址格式"},{"t":"list_item","d":12,"p":{"lines":[1649,1650]},"v":"MAC帧格式"}]}]},{"t":"list_item","d":8,"p":{"lines":[1650,1651]},"v":"扩展以太网","c":[{"t":"list_item","d":10,"p":{"lines":[1651,1652]},"v":"物理层","c":[{"t":"list_item","d":12,"p":{"lines":[1652,1653]},"v":"集线器"}]},{"t":"list_item","d":10,"p":{"lines":[1653,1654]},"v":"链路层","c":[{"t":"list_item","d":12,"p":{"lines":[1654,1655]},"v":"网桥","c":[{"t":"list_item","d":14,"p":{"lines":[1655,1656]},"v":"<strong>自学习和转发过程</strong>"},{"t":"list_item","d":14,"p":{"lines":[1656,1657]},"v":"生成树算法"}]},{"t":"list_item","d":12,"p":{"lines":[1657,1658]},"v":"交换机(多接口网桥)"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[1658,1659]},"v":"网络层","c":[{"t":"list_item","d":8,"p":{"lines":[1659,1660]},"v":"网络层提供的两种服务","c":[{"t":"list_item","d":10,"p":{"lines":[1660,1661]},"v":"面向连接：VC(虚电路)"},{"t":"list_item","d":10,"p":{"lines":[1661,1662]},"v":"无连接：数据报"}]}]},{"t":"list_item","d":6,"p":{"lines":[1662,1663]},"v":"运输层"},{"t":"list_item","d":6,"p":{"lines":[1663,1664]},"v":"应用层"}]},{"t":"list_item","d":4,"p":{"lines":[1664,1665]},"v":"问题","c":[{"t":"list_item","d":6,"p":{"lines":[1665,1666]},"v":"计算机网络体系结构"},{"t":"list_item","d":6,"p":{"lines":[1666,1667]},"v":"传输层：TCP和UDP","c":[{"t":"list_item","d":8,"p":{"lines":[1667,1668]},"v":"什么是三次握手？"},{"t":"list_item","d":8,"p":{"lines":[1668,1669]},"v":"什么是四次挥手？"},{"t":"list_item","d":8,"p":{"lines":[1669,1670]},"v":"TCP如何实现流量控制？"},{"t":"list_item","d":8,"p":{"lines":[1670,1671]},"v":"TCP的拥塞控制是怎么实现的？"},{"t":"list_item","d":8,"p":{"lines":[1671,1672]},"v":"TCP如何最大利用带宽？"},{"t":"list_item","d":8,"p":{"lines":[1672,1673]},"v":"TCP与UDP的区别"},{"t":"list_item","d":8,"p":{"lines":[1673,1674]},"v":"TCP如何保证传输的可靠性"},{"t":"list_item","d":8,"p":{"lines":[1674,1675]},"v":"什么是TCP粘包？"}]},{"t":"list_item","d":6,"p":{"lines":[1675,1676]},"v":"应用层：HTTP和HTTPS","c":[{"t":"list_item","d":8,"p":{"lines":[1676,1677]},"v":"HTTP和HTTPS有什么区别？"},{"t":"list_item","d":8,"p":{"lines":[1677,1678]},"v":"GET与POST的区别？"},{"t":"list_item","d":8,"p":{"lines":[1678,1679]},"v":"Session与Cookie的区别？"},{"t":"list_item","d":8,"p":{"lines":[1679,1680]},"v":"从输入网址到获得页面的过程 (越详细越好)？"},{"t":"list_item","d":8,"p":{"lines":[1680,1681]},"v":"HTTP请求有哪些常见状态码？"},{"t":"list_item","d":8,"p":{"lines":[1681,1682]},"v":"什么是RIP (距离矢量路由协议)?"}]},{"t":"list_item","d":6,"p":{"lines":[1682,1683]},"v":"网络层协议IP","c":[{"t":"list_item","d":8,"p":{"lines":[1683,1684]},"v":"IP地址的分类？"},{"t":"list_item","d":8,"p":{"lines":[1684,1685]},"v":"什么叫划分子网？"},{"t":"list_item","d":8,"p":{"lines":[1685,1686]},"v":"什么是ARP协议？"},{"t":"list_item","d":8,"p":{"lines":[1686,1687]},"v":"什么是NAT (网络地址转换)？"}]},{"t":"list_item","d":6,"p":{"lines":[1687,1688]},"v":"从 URL 输入到页面展现到底发生什么"}]}]},{"t":"heading","d":2,"p":{"lines":[1689,1690],"f":true},"v":"操作系统"},{"t":"heading","d":2,"p":{"lines":[1691,1692],"f":true},"v":"算法"}]},{"t":"heading","d":1,"p":{"lines":[1693,1694]},"v":"分布式相关","c":[{"t":"heading","d":2,"p":{"lines":[1695,1696],"f":true},"v":"分布式理论 ","c":[{"t":"heading","d":3,"p":{"lines":[1697,1698]},"v":"基础理论","c":[{"t":"heading","d":4,"p":{"lines":[1699,1700]},"v":"分布式"},{"t":"heading","d":4,"p":{"lines":[1701,1702]},"v":"分布式和集群"},{"t":"heading","d":4,"p":{"lines":[1703,1704]},"v":"微服务"}]},{"t":"heading","d":3,"p":{"lines":[1705,1706]},"v":"通信设计","c":[{"t":"heading","d":4,"p":{"lines":[1707,1708]},"v":"RPC"},{"t":"heading","d":4,"p":{"lines":[1709,1710]},"v":"REST"}]},{"t":"heading","d":3,"p":{"lines":[1711,1712]},"v":"分布式事务算法","c":[{"t":"heading","d":4,"p":{"lines":[1713,1714]},"v":"一致性问题"},{"t":"heading","d":4,"p":{"lines":[1715,1716]},"v":"2PC"},{"t":"heading","d":4,"p":{"lines":[1717,1718]},"v":"3PC"},{"t":"heading","d":4,"p":{"lines":[1719,1720]},"v":"paxos"},{"t":"heading","d":4,"p":{"lines":[1721,1722]},"v":"raft"}]}]},{"t":"heading","d":2,"p":{"lines":[1723,1724]},"v":"高可用"},{"t":"heading","d":2,"p":{"lines":[1725,1726]},"v":"分布式锁","c":[{"t":"heading","d":3,"p":{"lines":[1727,1728]},"v":"数据库"},{"t":"heading","d":3,"p":{"lines":[1729,1730]},"v":"redis"},{"t":"heading","d":3,"p":{"lines":[1731,1732]},"v":"zookeeper"},{"t":"heading","d":3,"p":{"lines":[1733,1734]},"v":"etcd"}]},{"t":"heading","d":2,"p":{"lines":[1735,1736]},"v":"分布式协调框架","c":[{"t":"heading","d":3,"p":{"lines":[1737,1738]},"v":"zookeeper"}]},{"t":"heading","d":2,"p":{"lines":[1739,1740]},"v":"RPC框架","c":[{"t":"heading","d":3,"p":{"lines":[1741,1742]},"v":"SpringCloud"},{"t":"heading","d":3,"p":{"lines":[1743,1744],"f":true},"v":"Dubbo"}]}]},{"t":"heading","d":1,"p":{"lines":[1745,1746]},"v":"消息队列","c":[{"t":"heading","d":2,"p":{"lines":[1747,1748],"f":true},"v":"Kafka"},{"t":"heading","d":2,"p":{"lines":[1749,1750],"f":true},"v":"RocketMQ"}]}],"p":{}})</script>
</body>
</html>
