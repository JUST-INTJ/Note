<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.1.6/dist/style.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.6.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.6"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.1.6/dist/index.umd.min.js"></script><script>(r => {
          setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[3,4]},"v":"Java 基础","c":[{"t":"heading","d":2,"p":{"lines":[5,6],"f":true},"v":"基础 ","c":[{"t":"heading","d":3,"p":{"lines":[7,8]},"v":"基础中的基础","c":[{"t":"list_item","d":5,"p":{"lines":[9,10]},"v":"基本概念","c":[{"t":"list_item","d":7,"p":{"lines":[10,11]},"v":"JRE与JDK"},{"t":"list_item","d":7,"p":{"lines":[11,12]},"v":"Java 7 和 Java SE 7"},{"t":"list_item","d":7,"p":{"lines":[12,13]},"v":"JDK1.8和Java8"}]},{"t":"list_item","d":5,"p":{"lines":[14,15]},"v":"Object的11个方法","c":[{"t":"list_item","d":7,"p":{"lines":[15,16]},"v":"equals","c":[{"t":"list_item","d":9,"p":{"lines":[16,17]},"v":"<code>常量.equals</code>"},{"t":"list_item","d":9,"p":{"lines":[17,18]},"v":"<code>Objects.equals</code> <strong>推荐</strong>"},{"t":"list_item","d":9,"p":{"lines":[18,19]},"v":"<a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\">hashcode和equals(重要)</a>"}]}]},{"t":"list_item","d":5,"p":{"lines":[20,21]},"v":"面向对象","c":[{"t":"list_item","d":7,"p":{"lines":[21,22]},"v":"封装"},{"t":"list_item","d":7,"p":{"lines":[22,23]},"v":"继承"},{"t":"list_item","d":7,"p":{"lines":[23,24]},"v":"多态","c":[{"t":"list_item","d":9,"p":{"lines":[24,25]},"v":"上转下转"},{"t":"list_item","d":9,"p":{"lines":[25,26]},"v":"深入(JVM内容)","c":[{"t":"list_item","d":11,"p":{"lines":[26,27]},"v":"动态链接"},{"t":"list_item","d":11,"p":{"lines":[27,28]},"v":"非虚方法和虚方法"},{"t":"list_item","d":11,"p":{"lines":[28,29]},"v":"方法重写本质"},{"t":"list_item","d":11,"p":{"lines":[29,30]},"v":"虚方法表"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[31,32]},"v":"Java异常体系"},{"t":"list_item","d":5,"p":{"lines":[33,34]},"v":"常用关键字"},{"t":"list_item","d":5,"p":{"lines":[35,36]},"v":"<a href=\"https://juejin.cn/post/6844903791863529480\">静/非静态内部类</a>","c":[{"t":"list_item","d":7,"p":{"lines":[36,37]},"v":"是否懒加载"},{"t":"list_item","d":7,"p":{"lines":[37,38]},"v":"是否可以创建静态成员"},{"t":"list_item","d":7,"p":{"lines":[38,39]},"v":"能否调用调用外部类静态成员"},{"t":"list_item","d":7,"p":{"lines":[39,40]},"v":"有没有指向外部类的引用<br /><code>外部类类名.this</code>"},{"t":"list_item","d":7,"p":{"lines":[40,41]},"v":"创建方式"}]},{"t":"list_item","d":5,"p":{"lines":[42,43]},"v":"枚举","c":[{"t":"list_item","d":7,"p":{"lines":[43,44]},"v":"本质"},{"t":"list_item","d":7,"p":{"lines":[44,45]},"v":"常见用法"}]},{"t":"list_item","d":5,"p":{"lines":[46,47]},"v":"包装类","c":[{"t":"list_item","d":7,"p":{"lines":[47,48]},"v":"缓存机制","c":[{"t":"list_item","d":9,"p":{"lines":[48,49]},"v":"Integer当数值在-128 ~127时，会将创建的 Integer 对象缓存起来"},{"t":"list_item","d":9,"p":{"lines":[49,50]},"v":"Character当数值在0-~127时，会将创建的Character对象缓存起来"},{"t":"list_item","d":9,"p":{"lines":[50,51]},"v":"因此，整型包装类对象之间值的比较，全部使用 equals 方法比较"}]},{"t":"list_item","d":7,"p":{"lines":[51,52]},"v":"BigDecimal","c":[{"t":"list_item","d":9,"p":{"lines":[52,53]},"v":"浮点数之间的等值判断","c":[{"t":"list_item","d":11,"p":{"lines":[53,54]},"v":"基本数据类型不能用==来比较（精度丢失）"},{"t":"list_item","d":11,"p":{"lines":[54,55]},"v":"包装数据类型不能用 equals 来判断"},{"t":"list_item","d":11,"p":{"lines":[55,56]},"v":"<strong>使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作</strong>"}]},{"t":"list_item","d":9,"p":{"lines":[56,57]},"v":"使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。"},{"t":"list_item","d":9,"p":{"lines":[57,58]},"v":"推荐使用String作为参数传入BigDecimal构造方法"}]},{"t":"list_item","d":7,"p":{"lines":[58,59]},"v":"使用标准","c":[{"t":"list_item","d":9,"p":{"lines":[59,60]},"v":"所有的 POJO 类属性必须使用包装数据类型。"},{"t":"list_item","d":9,"p":{"lines":[60,61]},"v":"RPC 方法的返回值和参数必须使用包装数据类型。"},{"t":"list_item","d":9,"p":{"lines":[61,62]},"v":"所有的局部变量使用基本数据类型。"}]}]},{"t":"list_item","d":5,"p":{"lines":[63,64]},"v":"Arrays.asList","c":[{"t":"list_item","d":7,"p":{"lines":[64,65]},"v":"Arrays.asList()将数组转换为集合后,底层其实还是数组"},{"t":"list_item","d":7,"p":{"lines":[65,66]},"v":"传递的数组必须是对象数组，而不是基本类型。<br /><strong>当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身</strong>"},{"t":"list_item","d":7,"p":{"lines":[66,67]},"v":"使用集合的修改方法:<code>add()、remove()、clear()</code>会抛出异常。<br />Arrays.asList() 方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类,"},{"t":"list_item","d":7,"p":{"lines":[67,68]},"v":"如何正确的将数组转换为ArrayList?","c":[{"t":"list_item","d":9,"p":{"lines":[68,69]},"v":"<code>new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code>(推荐)"},{"t":"list_item","d":9,"p":{"lines":[69,70]},"v":"使用 Java8 的Stream(推荐)"},{"t":"list_item","d":9,"p":{"lines":[70,71]},"v":"使用 Guava(推荐)"},{"t":"list_item","d":9,"p":{"lines":[71,72]},"v":"使用 Apache Commons Collections"},{"t":"list_item","d":9,"p":{"lines":[72,73]},"v":"使用 Java9 的 List.of()方法"}]}]}]},{"t":"heading","d":3,"p":{"lines":[74,75]},"v":"<a href=\"https://www.cnblogs.com/yougewe/p/10125073.html\">反射</a>","c":[{"t":"list_item","d":5,"p":{"lines":[76,77]},"v":"说明"},{"t":"list_item","d":5,"p":{"lines":[77,78]},"v":"原理","c":[{"t":"list_item","d":7,"p":{"lines":[78,79]},"v":"如何获取"},{"t":"list_item","d":7,"p":{"lines":[79,80]},"v":"成员的查找"},{"t":"list_item","d":7,"p":{"lines":[80,81]},"v":"线程安全"},{"t":"list_item","d":7,"p":{"lines":[81,82]},"v":"内存使用（软指针）"},{"t":"list_item","d":7,"p":{"lines":[82,83]},"v":"数据隔离"},{"t":"list_item","d":7,"p":{"lines":[83,84]},"v":"方法执行"}]}]},{"t":"heading","d":3,"p":{"lines":[85,86]},"v":"java泛型","c":[{"t":"list_item","d":5,"p":{"lines":[87,88]},"v":"什么是泛型"},{"t":"list_item","d":5,"p":{"lines":[88,89]},"v":"原理与类型擦除"},{"t":"list_item","d":5,"p":{"lines":[89,90]},"v":"使用方式和场景"},{"t":"list_item","d":5,"p":{"lines":[90,91]},"v":"泛型通配符"},{"t":"list_item","d":5,"p":{"lines":[91,92]},"v":"泛型数组"},{"t":"list_item","d":5,"p":{"lines":[93,94]},"v":"常见问题：","c":[{"t":"list_item","d":7,"p":{"lines":[94,95]},"v":"T ,T extends xxx, ？,？extends xxx <br />和 ？super xxx 的区别？"},{"t":"list_item","d":7,"p":{"lines":[95,96]},"v":"为何不能通过直接通过<code>T[] arr=new T[10]</code>的方式来创建数组<br />如何正确创建泛型数组。"}]}]},{"t":"heading","d":3,"p":{"lines":[97,98]},"v":"String","c":[{"t":"list_item","d":5,"p":{"lines":[99,100]},"v":"String,StringBuilder,StringBuffer 使用场景"},{"t":"list_item","d":5,"p":{"lines":[100,101]},"v":"AbstractStringBilder,建造者"},{"t":"list_item","d":5,"p":{"lines":[101,102]},"v":"synchronized"},{"t":"list_item","d":5,"p":{"lines":[102,103]},"v":"字符串拼接","c":[{"t":"list_item","d":7,"p":{"lines":[103,104]},"v":"编译器优化"},{"t":"list_item","d":7,"p":{"lines":[104,105]},"v":"StringBuilder"}]},{"t":"list_item","d":5,"p":{"lines":[105,106]},"v":"字符串常量池"}]},{"t":"heading","d":3,"p":{"lines":[108,109]},"v":"SPI","c":[{"t":"list_item","d":5,"p":{"lines":[110,111]},"v":"原理","c":[{"t":"list_item","d":7,"p":{"lines":[111,112]},"v":"api"},{"t":"list_item","d":7,"p":{"lines":[112,113]},"v":"spi"}]},{"t":"list_item","d":5,"p":{"lines":[113,114]},"v":"示例","c":[{"t":"list_item","d":7,"p":{"lines":[114,115]},"v":"java spi","c":[{"t":"list_item","d":9,"p":{"lines":[115,116]},"v":"提供的api及使用"},{"t":"list_item","d":9,"p":{"lines":[116,117]},"v":"DriverManager","c":[{"t":"list_item","d":11,"p":{"lines":[117,118]},"v":"mysql自动加载"},{"t":"list_item","d":11,"p":{"lines":[118,119]},"v":"oracle必须手动加载"}]}]},{"t":"list_item","d":7,"p":{"lines":[119,120]},"v":"Spring spi思想","c":[{"t":"list_item","d":9,"p":{"lines":[120,121]},"v":"scan"},{"t":"list_item","d":9,"p":{"lines":[121,122]},"v":"自定义scope"},{"t":"list_item","d":9,"p":{"lines":[122,123]},"v":"自定义标签"}]}]}]},{"t":"heading","d":3,"p":{"lines":[125,126]},"v":"java8新特性","c":[{"t":"list_item","d":5,"p":{"lines":[127,128]},"v":"Stream"},{"t":"list_item","d":5,"p":{"lines":[128,129]},"v":"Function Interface"},{"t":"list_item","d":5,"p":{"lines":[129,130]},"v":"Lambda"},{"t":"list_item","d":5,"p":{"lines":[130,131]},"v":"Optional"},{"t":"list_item","d":5,"p":{"lines":[131,132]},"v":"Data Time-api"}]},{"t":"heading","d":3,"p":{"lines":[133,134]},"v":"语法糖","c":[{"t":"list_item","d":5,"p":{"lines":[135,136]},"v":"双大括号初始化(不推荐)"},{"t":"list_item","d":5,"p":{"lines":[136,137]},"v":"try-with-resources(针对io资源，推荐)"}]}]},{"t":"heading","d":2,"p":{"lines":[138,139],"f":true},"v":"集合 ","c":[{"t":"list_item","d":4,"p":{"lines":[140,141]},"v":"为什么要使用集合"},{"t":"list_item","d":4,"p":{"lines":[141,142]},"v":"HashMap","c":[{"t":"list_item","d":6,"p":{"lines":[142,143]},"v":"1.7","c":[{"t":"list_item","d":8,"p":{"lines":[143,144]},"v":"存储结构：数组+链表"},{"t":"list_item","d":8,"p":{"lines":[144,145]},"v":"扩容机制","c":[{"t":"list_item","d":10,"p":{"lines":[145,146]},"v":"创建新的数组"},{"t":"list_item","d":10,"p":{"lines":[146,147],"f":true},"v":"头插 ","c":[{"t":"list_item","d":12,"p":{"lines":[147,148]},"v":"使用头插可能与缓存的时间局部性原则有关"},{"t":"list_item","d":12,"p":{"lines":[148,149]},"v":"最近访问过的数据下次大概率会再次访问"},{"t":"list_item","d":12,"p":{"lines":[149,150]},"v":"把刚访问过的元素放在链表最前面可以直接被查询到，减少查找次数"}]},{"t":"list_item","d":10,"p":{"lines":[150,151]},"v":"<a href=\"https://juejin.cn/post/6844903554264596487\">resize死循环</a>"},{"t":"list_item","d":10,"p":{"lines":[151,152]},"v":"resize重新计算hash"}]}]},{"t":"list_item","d":6,"p":{"lines":[152,153]},"v":"1.8","c":[{"t":"list_item","d":8,"p":{"lines":[153,154]},"v":"存储结构","c":[{"t":"list_item","d":10,"p":{"lines":[154,155]},"v":"数组+链表+红黑树"},{"t":"list_item","d":10,"p":{"lines":[155,156]},"v":"红黑树结构转换条件","c":[{"t":"list_item","d":12,"p":{"lines":[156,157]},"v":"数组长度64"},{"t":"list_item","d":12,"p":{"lines":[157,158]},"v":"<a href=\"https://juejin.cn/post/6921914880559677447]\">树化阀值8来源</a>"},{"t":"list_item","d":12,"p":{"lines":[158,159]},"v":"退化阀值6"}]}]},{"t":"list_item","d":8,"p":{"lines":[159,160]},"v":"插曲：<a href=\"https://blog.csdn.net/zhichaosong/article/details/88844371\">红黑树由来：2-3树</a>"},{"t":"list_item","d":8,"p":{"lines":[160,161]},"v":"扩容机制","c":[{"t":"list_item","d":10,"p":{"lines":[161,162]},"v":"创建新的数组"},{"t":"list_item","d":10,"p":{"lines":[162,163]},"v":"尾插"},{"t":"list_item","d":10,"p":{"lines":[163,164],"f":true},"v":"<a href=\"https://www.fangzhipeng.com/javainterview/2019/03/11/hashmap-dead-cycle.html\">如何解决的resize死循环</a> ","c":[{"t":"list_item","d":12,"p":{"lines":[164,165],"f":true},"v":"transfer调用 ","c":[{"t":"list_item","d":14,"p":{"lines":[165,166]},"v":"直接将原来transfer()方法中的代码写在自己方法体内，不再调用"}]},{"t":"list_item","d":12,"p":{"lines":[166,167],"f":true},"v":"使用尾插 ","c":[{"t":"list_item","d":14,"p":{"lines":[167,168]},"v":"<strong>扩容后，新数组中的链表顺序依然与旧数组中的链表顺序保持一致</strong>"}]}]},{"t":"list_item","d":10,"p":{"lines":[168,169],"f":true},"v":"<a href=\"https://juejin.cn/post/6844903682664824845\">resize不重新计算hash</a> ","c":[{"t":"list_item","d":12,"p":{"lines":[169,170]},"v":"1.7扩容时需要重新计算哈希值和索引位置"},{"t":"list_item","d":12,"p":{"lines":[170,171]},"v":"1.8并不重新计算哈希值，巧妙地采用和扩容后容量进行&amp;操作来计算新的索引位置。"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[171,172]},"v":"线程不安全","c":[{"t":"list_item","d":8,"p":{"lines":[172,173]},"v":"put的时候导致的多线程数据不一致"}]},{"t":"list_item","d":6,"p":{"lines":[173,174]},"v":"初始化大小"},{"t":"list_item","d":6,"p":{"lines":[174,175]},"v":"扩容时机","c":[{"t":"list_item","d":8,"p":{"lines":[175,176]},"v":"threshold = capacity * loadFactor"},{"t":"list_item","d":8,"p":{"lines":[176,177]},"v":"Size&gt;=threshold"},{"t":"list_item","d":8,"p":{"lines":[177,178]},"v":"<a href=\"https://www.cnblogs.com/aspirant/p/11470928.html\">loadFactor 0.75来源</a>"}]},{"t":"list_item","d":6,"p":{"lines":[178,179]},"v":"put流程"},{"t":"list_item","d":6,"p":{"lines":[179,180]},"v":"容量为什么要2的幂"},{"t":"list_item","d":6,"p":{"lines":[180,181]},"v":"<a href=\"https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow\">遍历方法及性能</a>"},{"t":"list_item","d":6,"p":{"lines":[181,182]},"v":"有什么同步容器/并发容器"},{"t":"list_item","d":6,"p":{"lines":[182,183]},"v":"HashMap,HashTable,ConcurrentHashMap区别","c":[{"t":"list_item","d":8,"p":{"lines":[183,184]},"v":"1.7","c":[{"t":"list_item","d":10,"p":{"lines":[184,185]},"v":"三者数据结构"},{"t":"list_item","d":10,"p":{"lines":[185,186]},"v":"同步机制/锁"},{"t":"list_item","d":10,"p":{"lines":[186,187]},"v":"<code>put(null)</code>"}]},{"t":"list_item","d":8,"p":{"lines":[187,188]},"v":"1.8","c":[{"t":"list_item","d":10,"p":{"lines":[188,189]},"v":"三者数据结构"},{"t":"list_item","d":10,"p":{"lines":[189,190]},"v":"同步机制/锁"},{"t":"list_item","d":10,"p":{"lines":[190,191]},"v":"<code>put(null)</code>"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[191,192]},"v":"TreeMap","c":[{"t":"list_item","d":6,"p":{"lines":[192,193]},"v":"底层结构：红黑树"},{"t":"list_item","d":6,"p":{"lines":[193,194]},"v":"红黑树由来：<a href=\"https://blog.csdn.net/zhichaosong/article/details/88844371\">2-3树</a>","c":[{"t":"list_item","d":8,"p":{"lines":[194,195]},"v":"2-节点,3-节点"},{"t":"list_item","d":8,"p":{"lines":[195,196]},"v":"4-节点分解"},{"t":"list_item","d":8,"p":{"lines":[196,197]},"v":"不平衡时融合"}]}]},{"t":"list_item","d":4,"p":{"lines":[197,198]},"v":"ConcurrentHashMap","c":[{"t":"list_item","d":6,"p":{"lines":[198,199]},"v":"<a href=\"https://www.cnblogs.com/ITtangtang/p/3948786.html\">1.7</a>","c":[{"t":"list_item","d":8,"p":{"lines":[199,200]},"v":"数据结构:分段锁+数组+链表"},{"t":"list_item","d":8,"p":{"lines":[200,201]},"v":"同步机制:","c":[{"t":"list_item","d":10,"p":{"lines":[201,202]},"v":"<strong>segment分段锁</strong> 粒度为一段(几个hash槽)<br />分段锁继承了ReentrantLock"},{"t":"list_item","d":10,"p":{"lines":[202,203]},"v":"尝试获取锁存在并发，竞争，阻塞"}]},{"t":"list_item","d":8,"p":{"lines":[203,204]},"v":"键值对:HashEntry"},{"t":"list_item","d":8,"p":{"lines":[204,205]},"v":"操作","c":[{"t":"list_item","d":10,"p":{"lines":[205,206]},"v":"put"},{"t":"list_item","d":10,"p":{"lines":[206,207]},"v":"size"},{"t":"list_item","d":10,"p":{"lines":[207,208]},"v":"get"}]}]},{"t":"list_item","d":6,"p":{"lines":[208,209]},"v":"<a href=\"https://blog.csdn.net/programmer_at/article/details/79715177\">1.8</a>","c":[{"t":"list_item","d":8,"p":{"lines":[209,210]},"v":"数据结构:数组+链表/红黑树"},{"t":"list_item","d":8,"p":{"lines":[210,211]},"v":"同步机制","c":[{"t":"list_item","d":10,"p":{"lines":[211,212]},"v":"hash槽。减小了加锁粒度"},{"t":"list_item","d":10,"p":{"lines":[212,213],"f":true},"v":"CAS+synchronized ","c":[{"t":"list_item","d":12,"p":{"lines":[213,214]},"v":"CAS失败自旋保证成功"},{"t":"list_item","d":12,"p":{"lines":[214,215]},"v":"再失败就synchronized"}]},{"t":"list_item","d":10,"p":{"lines":[215,216],"f":true},"v":"<a href=\"https://www.cnblogs.com/aspirant/p/8623864.html\">使用synchronized原因</a> ","c":[{"t":"list_item","d":12,"p":{"lines":[216,217]},"v":"锁粒度降低了，synchronized并不比ReentrantLock差"},{"t":"list_item","d":12,"p":{"lines":[217,218]},"v":"synchronized优化空间大"},{"t":"list_item","d":12,"p":{"lines":[218,219]},"v":"大量数据操作，ReentrantLock开销较多内存"}]}]},{"t":"list_item","d":8,"p":{"lines":[219,220]},"v":"键值对：node"},{"t":"list_item","d":8,"p":{"lines":[220,221]},"v":"操作","c":[{"t":"list_item","d":10,"p":{"lines":[221,222]},"v":"put"},{"t":"list_item","d":10,"p":{"lines":[222,223]},"v":"size"},{"t":"list_item","d":10,"p":{"lines":[223,224]},"v":"get"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[224,225]},"v":"<a href=\"https://www.jianshu.com/p/8f4f58b4b8ab\">LinkedHashMap</a>","c":[{"t":"list_item","d":6,"p":{"lines":[225,226]},"v":"结构：HashMap+双向链表"},{"t":"list_item","d":6,"p":{"lines":[226,227]},"v":"两种模式(accessOrder变量)","c":[{"t":"list_item","d":8,"p":{"lines":[227,228]},"v":"插入顺序模式(false)"},{"t":"list_item","d":8,"p":{"lines":[228,229]},"v":"访问顺序模式(true)","c":[{"t":"list_item","d":10,"p":{"lines":[229,230]},"v":"<code>get</code>"},{"t":"list_item","d":10,"p":{"lines":[230,231]},"v":"重排序"}]}]},{"t":"list_item","d":6,"p":{"lines":[231,232]},"v":"扩容:遍历链表"},{"t":"list_item","d":6,"p":{"lines":[232,233]},"v":"实现LRU","c":[{"t":"list_item","d":8,"p":{"lines":[233,234]},"v":"构造器:传入capacity"},{"t":"list_item","d":8,"p":{"lines":[234,235]},"v":"removeEldestEntry:<code>return size() &gt; capacity;</code>"}]}]},{"t":"list_item","d":4,"p":{"lines":[236,237]},"v":"ArrayList","c":[{"t":"list_item","d":6,"p":{"lines":[237,238]},"v":"底层结构：数组"},{"t":"list_item","d":6,"p":{"lines":[238,239]},"v":"初始大小与扩容机制"},{"t":"list_item","d":6,"p":{"lines":[239,240]},"v":"RandomAccess 接口"},{"t":"list_item","d":6,"p":{"lines":[240,241]},"v":"<code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法"},{"t":"list_item","d":6,"p":{"lines":[241,242]},"v":"有什么同步容器/并发容器"},{"t":"list_item","d":6,"p":{"lines":[242,243]},"v":"<strong><a href=\"https://juejin.cn/post/6879291161274482695\">fail-fast、fail-safe机制</a></strong>"}]},{"t":"list_item","d":4,"p":{"lines":[243,244]},"v":"LinkedList","c":[{"t":"list_item","d":6,"p":{"lines":[244,245]},"v":"底层结构：双向链表"}]},{"t":"list_item","d":4,"p":{"lines":[245,246]},"v":"Set","c":[{"t":"list_item","d":6,"p":{"lines":[246,247]},"v":"comparable 和 Comparator 的区别"},{"t":"list_item","d":6,"p":{"lines":[247,248]},"v":"无序性和不可重复性的含义是什么"},{"t":"list_item","d":6,"p":{"lines":[248,249]},"v":"有什么同步容器/并发容器"},{"t":"list_item","d":6,"p":{"lines":[249,250]},"v":"HashMap和HashSet"},{"t":"list_item","d":6,"p":{"lines":[250,251]},"v":"TreeMap和TreeSet"}]},{"t":"list_item","d":4,"p":{"lines":[251,252]},"v":"集合比较问题","c":[{"t":"list_item","d":6,"p":{"lines":[252,253]},"v":"List,Set,Map 三者的区别？"},{"t":"list_item","d":6,"p":{"lines":[253,254]},"v":"Arraylist 和 Vector 的区别?"},{"t":"list_item","d":6,"p":{"lines":[254,255]},"v":"Arraylist 与 LinkedList 区别?"},{"t":"list_item","d":6,"p":{"lines":[255,256]},"v":"ConcurrentHashMap 和 Hashtable 的区别"},{"t":"list_item","d":6,"p":{"lines":[256,257]},"v":"比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"},{"t":"list_item","d":6,"p":{"lines":[257,258]},"v":"HashMap和HashTable区别"},{"t":"list_item","d":6,"p":{"lines":[258,259]},"v":"HashMap与HashSet区别（HashSet底层基于HashMap）"},{"t":"list_item","d":6,"p":{"lines":[259,260]},"v":"HashMap和TreeMap区别"}]}]},{"t":"heading","d":2,"p":{"lines":[261,262],"f":true},"v":"多线程 ","c":[{"t":"bullet_list","d":3,"p":{"lines":[263,409]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[263,264]},"v":"并发基础","c":[{"t":"list_item","d":6,"p":{"lines":[264,265]},"v":"<a href=\"https://segmentfault.com/a/1190000037589073\">创建线程的方式</a>"},{"t":"list_item","d":6,"p":{"lines":[265,266]},"v":"调用<code>start()</code>和<code>run()</code>方法区别"},{"t":"list_item","d":6,"p":{"lines":[266,267]},"v":"停止线程：interrupt","c":[{"t":"list_item","d":8,"p":{"lines":[267,268]},"v":"原理"},{"t":"list_item","d":8,"p":{"lines":[268,269]},"v":"正确的停止方式"},{"t":"list_item","d":8,"p":{"lines":[269,270]},"v":"错误的停止方式","c":[{"t":"list_item","d":10,"p":{"lines":[270,271]},"v":"被弃用的stop,suspend和resume方法"},{"t":"list_item","d":10,"p":{"lines":[271,272]},"v":"用volatile设置标记位"}]}]},{"t":"list_item","d":6,"p":{"lines":[272,273]},"v":"重要方法","c":[{"t":"list_item","d":8,"p":{"lines":[273,274]},"v":"Object(三个方法都要在synchronized内)","c":[{"t":"list_item","d":10,"p":{"lines":[274,275]},"v":"wait"},{"t":"list_item","d":10,"p":{"lines":[275,276]},"v":"notify"},{"t":"list_item","d":10,"p":{"lines":[276,277]},"v":"notifyAll"}]},{"t":"list_item","d":8,"p":{"lines":[277,278]},"v":"Thread","c":[{"t":"list_item","d":10,"p":{"lines":[278,279]},"v":"sleep"},{"t":"list_item","d":10,"p":{"lines":[279,280]},"v":"join"},{"t":"list_item","d":10,"p":{"lines":[280,281]},"v":"yield"}]}]},{"t":"list_item","d":6,"p":{"lines":[281,282]},"v":"yield和sleep区别"},{"t":"list_item","d":6,"p":{"lines":[282,283]},"v":"java线程状态的切换<br /> 延伸：操作系统进程状态的切换"},{"t":"list_item","d":6,"p":{"lines":[283,284]},"v":"线程属性"},{"t":"list_item","d":6,"p":{"lines":[284,285]},"v":"线程的未捕获异常处理"},{"t":"list_item","d":6,"p":{"lines":[285,286]},"v":"线程组","c":[{"t":"list_item","d":8,"p":{"lines":[286,287]},"v":"结构","c":[{"t":"list_item","d":10,"p":{"lines":[287,288]},"v":"线程组是一个树状的结构，每个线程组下面可以有多个线程或者线程组"},{"t":"list_item","d":10,"p":{"lines":[288,289]},"v":"默认将父线程（当前执行new Thread的线程）线程组设置为自己的线程组。"}]},{"t":"list_item","d":8,"p":{"lines":[289,290]},"v":"线程组的优先级会限制线程的优先级"},{"t":"list_item","d":8,"p":{"lines":[290,291]},"v":"作用","c":[{"t":"list_item","d":10,"p":{"lines":[291,292]},"v":"统一控制线程的优先级"},{"t":"list_item","d":10,"p":{"lines":[292,293]},"v":"检查线程的权限的作用。"},{"t":"list_item","d":10,"p":{"lines":[293,294]},"v":"线程组统一异常处理"}]}]},{"t":"list_item","d":6,"p":{"lines":[294,295]},"v":"常见问题","c":[{"t":"list_item","d":8,"p":{"lines":[295,296]},"v":"并发与并行区别"},{"t":"list_item","d":8,"p":{"lines":[296,297]},"v":"为什么要使用多线程"},{"t":"list_item","d":8,"p":{"lines":[297,298]},"v":"sleep() 方法和 wait() 方法区别和共同点"}]}]},{"t":"list_item","d":4,"p":{"lines":[299,300],"f":true},"v":"<strong>并发编程三大特性</strong> ","c":[{"t":"list_item","d":6,"p":{"lines":[300,301]},"v":"原子性"},{"t":"list_item","d":6,"p":{"lines":[301,302]},"v":"可见性"},{"t":"list_item","d":6,"p":{"lines":[302,303]},"v":"有序性"}]},{"t":"list_item","d":4,"p":{"lines":[304,305]},"v":"JMM","c":[{"t":"list_item","d":6,"p":{"lines":[305,306]},"v":"基础结构"},{"t":"list_item","d":6,"p":{"lines":[306,307]},"v":"JMM与Java内存区域划分的区别与联系"},{"t":"list_item","d":6,"p":{"lines":[307,308],"f":true},"v":"JMM原子操作 ","c":[{"t":"list_item","d":8,"p":{"lines":[308,309]},"v":"read(读取）:从主内存读取数据"},{"t":"list_item","d":8,"p":{"lines":[309,310]},"v":"load(载入）:将主内存读取到的数据写入工作内存"},{"t":"list_item","d":8,"p":{"lines":[310,311]},"v":"use(使用）:从工作内存读取数据来计算"},{"t":"list_item","d":8,"p":{"lines":[311,312]},"v":"assign(赋值）:将计算好的值重新赋值到工作内存中"},{"t":"list_item","d":8,"p":{"lines":[312,313]},"v":"store(存储）:将工作内存数据写入主内存"},{"t":"list_item","d":8,"p":{"lines":[313,314]},"v":"write(写入）:将store过去的变量值赋值给主内存中的变量"},{"t":"list_item","d":8,"p":{"lines":[314,315]},"v":"lock(锁定）:将主内存变量加锁，标识为线程独占状态。其他线程将无法读或写"},{"t":"list_item","d":8,"p":{"lines":[315,316]},"v":"unlock(解锁）:将主内存变量解锁，解锁后其他线程可以锁定该变量"}]},{"t":"list_item","d":6,"p":{"lines":[316,317]},"v":"重排序","c":[{"t":"list_item","d":8,"p":{"lines":[317,318],"f":true},"v":"组成 ","c":[{"t":"list_item","d":10,"p":{"lines":[318,319]},"v":"编译器优化重排"},{"t":"list_item","d":10,"p":{"lines":[319,320]},"v":"指令并行重排"},{"t":"list_item","d":10,"p":{"lines":[320,321]},"v":"内存系统重排"}]},{"t":"list_item","d":8,"p":{"lines":[321,322]},"v":"编程规则","c":[{"t":"list_item","d":10,"p":{"lines":[322,323]},"v":"as-if-serial"},{"t":"list_item","d":10,"p":{"lines":[323,324]},"v":"happens-before"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[325,326]},"v":"<a href=\"https://zhuanlan.zhihu.com/p/137193948\">volatile</a>","c":[{"t":"list_item","d":6,"p":{"lines":[326,327]},"v":"保证内存可见性","c":[{"t":"list_item","d":8,"p":{"lines":[327,328]},"v":"说明"},{"t":"list_item","d":8,"p":{"lines":[328,329]},"v":"原理","c":[{"t":"list_item","d":10,"p":{"lines":[329,330]},"v":"MESI缓存一致性协议"},{"t":"list_item","d":10,"p":{"lines":[330,331]},"v":"cpu总线嗅探机制"},{"t":"list_item","d":10,"p":{"lines":[331,332]},"v":"lock"}]},{"t":"list_item","d":8,"p":{"lines":[332,333]},"v":"总线风暴"}]},{"t":"list_item","d":6,"p":{"lines":[333,334]},"v":"禁止重排序","c":[{"t":"list_item","d":8,"p":{"lines":[334,335]},"v":"说明"},{"t":"list_item","d":8,"p":{"lines":[335,336],"f":true},"v":"原理(内存屏障) ","c":[{"t":"list_item","d":10,"p":{"lines":[336,337]},"v":"volatile写","c":[{"t":"list_item","d":12,"p":{"lines":[337,338]},"v":"前面:storestore"},{"t":"list_item","d":12,"p":{"lines":[338,339]},"v":"后面:sotreload"}]},{"t":"list_item","d":10,"p":{"lines":[339,340]},"v":"volatile写","c":[{"t":"list_item","d":12,"p":{"lines":[340,341]},"v":"后面1:loadload"},{"t":"list_item","d":12,"p":{"lines":[341,342]},"v":"后面2:loadstore"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[342,343]},"v":"不保证原子性：","c":[{"t":"list_item","d":8,"p":{"lines":[343,344]},"v":"原因"},{"t":"list_item","d":8,"p":{"lines":[344,345]},"v":"解决","c":[{"t":"list_item","d":10,"p":{"lines":[345,346]},"v":"synchronized"},{"t":"list_item","d":10,"p":{"lines":[346,347]},"v":"Atomic(CAS)"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[348,349]},"v":"锁的变迁","c":[{"t":"list_item","d":6,"p":{"lines":[349,350]},"v":"jdk1.5之前:synchronized重量锁"},{"t":"list_item","d":6,"p":{"lines":[350,351]},"v":"jdk1.5","c":[{"t":"list_item","d":8,"p":{"lines":[351,352]},"v":"原因"},{"t":"list_item","d":8,"p":{"lines":[352,353]},"v":"变化:增加","c":[{"t":"list_item","d":10,"p":{"lines":[353,354]},"v":"Lock锁"},{"t":"list_item","d":10,"p":{"lines":[354,355]},"v":"并发容器"},{"t":"list_item","d":10,"p":{"lines":[355,356]},"v":"线程池"}]},{"t":"list_item","d":8,"p":{"lines":[356,357]},"v":"依据原理","c":[{"t":"list_item","d":10,"p":{"lines":[357,358]},"v":"Atomic--UnSafe--CAS"},{"t":"list_item","d":10,"p":{"lines":[358,359]},"v":"AQS"},{"t":"list_item","d":10,"p":{"lines":[359,360]},"v":"LockSupport"},{"t":"list_item","d":10,"p":{"lines":[360,361]},"v":"volatile"}]}]},{"t":"list_item","d":6,"p":{"lines":[361,362]},"v":"jdk1.6","c":[{"t":"list_item","d":8,"p":{"lines":[362,363]},"v":"变化:synchronized锁的升级"},{"t":"list_item","d":8,"p":{"lines":[363,364]},"v":"原因"}]},{"t":"list_item","d":6,"p":{"lines":[364,365]},"v":"jdk1.8:增加StampedLock"}]},{"t":"list_item","d":4,"p":{"lines":[366,367]},"v":"synchronized","c":[{"t":"list_item","d":6,"p":{"lines":[367,368]},"v":"3种使用方法","c":[{"t":"list_item","d":8,"p":{"lines":[368,369]},"v":"代码块","c":[{"t":"list_item","d":10,"p":{"lines":[369,370]},"v":"自己指定对象锁"},{"t":"list_item","d":10,"p":{"lines":[370,371]},"v":"底层原理：","c":[{"t":"list_item","d":12,"p":{"lines":[371,372]},"v":"monitorenter"},{"t":"list_item","d":12,"p":{"lines":[372,373]},"v":"monitorexit"},{"t":"list_item","d":12,"p":{"lines":[373,374]},"v":"程序计数器"}]}]},{"t":"list_item","d":8,"p":{"lines":[374,375]},"v":"成员方法","c":[{"t":"list_item","d":10,"p":{"lines":[375,376]},"v":"this对象锁"},{"t":"list_item","d":10,"p":{"lines":[376,377]},"v":"底层原理：ACC_SYNCHRONIZED"}]},{"t":"list_item","d":8,"p":{"lines":[377,378]},"v":"静态方法","c":[{"t":"list_item","d":10,"p":{"lines":[378,379]},"v":".class类锁"},{"t":"list_item","d":10,"p":{"lines":[379,380]},"v":"底层原理：ACC_SYNCHRONIZED，ACC_STATIC"}]},{"t":"list_item","d":8,"p":{"lines":[380,381]},"v":"注意：构造方法本身就属于线程安全的，不存在同步的构造方法一说。<br />不能加synchronized"}]},{"t":"list_item","d":6,"p":{"lines":[381,382]},"v":"锁的升级(不可逆)","c":[{"t":"list_item","d":8,"p":{"lines":[382,383]},"v":"无锁(CAS)"},{"t":"list_item","d":8,"p":{"lines":[383,384]},"v":"偏向锁","c":[{"t":"list_item","d":10,"p":{"lines":[384,385]},"v":"原理"},{"t":"list_item","d":10,"p":{"lines":[385,386]},"v":"锁的性质"},{"t":"list_item","d":10,"p":{"lines":[386,387]},"v":"对象头中的内容"},{"t":"list_item","d":10,"p":{"lines":[387,388]},"v":"升级过程"}]},{"t":"list_item","d":8,"p":{"lines":[388,389]},"v":"轻量锁","c":[{"t":"list_item","d":10,"p":{"lines":[389,390]},"v":"原理"},{"t":"list_item","d":10,"p":{"lines":[390,391]},"v":"锁的性质"},{"t":"list_item","d":10,"p":{"lines":[391,392]},"v":"对象头中的内容"},{"t":"list_item","d":10,"p":{"lines":[392,393]},"v":"升级过程"}]},{"t":"list_item","d":8,"p":{"lines":[393,394]},"v":"重量锁","c":[{"t":"list_item","d":10,"p":{"lines":[394,395]},"v":"原理"},{"t":"list_item","d":10,"p":{"lines":[395,396]},"v":"锁的性质"},{"t":"list_item","d":10,"p":{"lines":[396,397]},"v":"对象头中的内容"},{"t":"list_item","d":10,"p":{"lines":[397,398]},"v":"阻塞的好处(cpu)与代价(内核态)"}]}]},{"t":"list_item","d":6,"p":{"lines":[398,399]},"v":"synchronized 和 ReentrantLock 的区别","c":[{"t":"list_item","d":8,"p":{"lines":[399,400]},"v":"jvm-api层面"},{"t":"list_item","d":8,"p":{"lines":[400,401]},"v":"是否可中断"},{"t":"list_item","d":8,"p":{"lines":[401,402]},"v":"公平非公平"},{"t":"list_item","d":8,"p":{"lines":[402,403]},"v":"锁绑定多个条件"}]},{"t":"list_item","d":6,"p":{"lines":[403,404]},"v":"synchronized 和 volatile 的区别"},{"t":"list_item","d":6,"p":{"lines":[404,405],"f":true},"v":"synchronized如何保证可见性 ","c":[{"t":"list_item","d":8,"p":{"lines":[405,406]},"v":"获得锁，清空工作内存"},{"t":"list_item","d":8,"p":{"lines":[406,407]},"v":"从主内存拷贝共享变量最新的值到工作内存成为副本"},{"t":"list_item","d":8,"p":{"lines":[407,408]},"v":"执行代码，将修改后的副本的值刷新回主内存中，线程释放锁"},{"t":"list_item","d":8,"p":{"lines":[408,409]},"v":"而获取不到锁的线程会阻塞等待，所以变量的值肯定一直都是最新的。"}]}]}]},{"t":"bullet_list","d":3,"p":{"lines":[411,625]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[411,412]},"v":"CAS","c":[{"t":"list_item","d":6,"p":{"lines":[412,413]},"v":"乐观锁与悲观锁"},{"t":"list_item","d":6,"p":{"lines":[413,414]},"v":"概念"},{"t":"list_item","d":6,"p":{"lines":[414,415]},"v":"底层原理"},{"t":"list_item","d":6,"p":{"lines":[415,416]},"v":"CAS的应用：UnSafe和Atomic"},{"t":"list_item","d":6,"p":{"lines":[416,417]},"v":"问题","c":[{"t":"list_item","d":8,"p":{"lines":[417,418]},"v":"ABA问题","c":[{"t":"list_item","d":10,"p":{"lines":[418,419]},"v":"AtomicStampedReference"},{"t":"list_item","d":10,"p":{"lines":[419,420]},"v":"AtomicMarkableReference"}]},{"t":"list_item","d":8,"p":{"lines":[420,421]},"v":"循环时间长开销大","c":[{"t":"list_item","d":10,"p":{"lines":[421,422]},"v":"解决思路是让JVM支持处理器提供的pause指令"}]},{"t":"list_item","d":8,"p":{"lines":[422,423]},"v":"只能保证一个共享变量的原子操作","c":[{"t":"list_item","d":10,"p":{"lines":[423,424]},"v":"使用JDK 1.5开始就提供的AtomicReference类保证对象之间的原子性，<br />把多个变量放到一个对象里面进行CAS操作；"},{"t":"list_item","d":10,"p":{"lines":[424,425]},"v":"使用锁。锁内的临界区代码可以保证只有当前线程能操作。"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[426,427]},"v":"AQS","c":[{"t":"list_item","d":6,"p":{"lines":[427,428]},"v":"概念"},{"t":"list_item","d":6,"p":{"lines":[428,429]},"v":"底层","c":[{"t":"list_item","d":8,"p":{"lines":[429,430]},"v":"Unsafe(提供CAS操作)"},{"t":"list_item","d":8,"p":{"lines":[430,431]},"v":"LockSupport(提供park/unpark操作)"}]},{"t":"list_item","d":6,"p":{"lines":[431,432]},"v":"CLH数据结构"},{"t":"list_item","d":6,"p":{"lines":[432,433]},"v":"资源共享模式/同步方式"},{"t":"list_item","d":6,"p":{"lines":[433,434]},"v":"<strong>模版设计模式</strong>"},{"t":"list_item","d":6,"p":{"lines":[434,435]},"v":"源码分析","c":[{"t":"list_item","d":8,"p":{"lines":[435,436]},"v":"获取资源流程","c":[{"t":"list_item","d":10,"p":{"lines":[436,437]},"v":"acquire"},{"t":"list_item","d":10,"p":{"lines":[437,438]},"v":"acquireShared"}]},{"t":"list_item","d":8,"p":{"lines":[438,439]},"v":"释放资源流程","c":[{"t":"list_item","d":10,"p":{"lines":[439,440]},"v":"release"},{"t":"list_item","d":10,"p":{"lines":[440,441]},"v":"releaseShared"}]}]},{"t":"list_item","d":6,"p":{"lines":[441,442]},"v":"两个队列","c":[{"t":"list_item","d":8,"p":{"lines":[442,443]},"v":"CLH队列"},{"t":"list_item","d":8,"p":{"lines":[443,444]},"v":"条件队列"}]},{"t":"list_item","d":6,"p":{"lines":[444,445]},"v":"AQS组件","c":[{"t":"list_item","d":8,"p":{"lines":[445,446]},"v":"AQS实现的锁(实现Lock接口)","c":[{"t":"list_item","d":10,"p":{"lines":[446,447]},"v":"ReentrantLock","c":[{"t":"list_item","d":12,"p":{"lines":[447,448]},"v":"内部类Sync继承AQS"},{"t":"list_item","d":12,"p":{"lines":[448,449]},"v":"Condition底层使用LockSupport"}]},{"t":"list_item","d":10,"p":{"lines":[449,450]},"v":"ReentrantReadWriteLock","c":[{"t":"list_item","d":12,"p":{"lines":[450,451]},"v":"读锁和写锁都有继承AQS的内部类Sync"}]}]},{"t":"list_item","d":8,"p":{"lines":[451,452]},"v":"AQS通信工具类","c":[{"t":"list_item","d":10,"p":{"lines":[452,453]},"v":"Semaphore","c":[{"t":"list_item","d":12,"p":{"lines":[453,454]},"v":"内部有一个继承了AQS的同步器Sync"}]},{"t":"list_item","d":10,"p":{"lines":[454,455]},"v":"CountDownLatch","c":[{"t":"list_item","d":12,"p":{"lines":[455,456]},"v":"内部有一个继承了AQS的同步器Sync"}]},{"t":"list_item","d":10,"p":{"lines":[456,457]},"v":"CyclicBarrier","c":[{"t":"list_item","d":12,"p":{"lines":[457,458]},"v":"内部使用ReentrantLock"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[458,459]},"v":"其他","c":[{"t":"list_item","d":8,"p":{"lines":[459,460]},"v":"AOS"},{"t":"list_item","d":8,"p":{"lines":[460,461]},"v":"AQLS"}]}]},{"t":"list_item","d":4,"p":{"lines":[462,463]},"v":"Atomic","c":[{"t":"list_item","d":6,"p":{"lines":[463,464]},"v":"组成","c":[{"t":"list_item","d":8,"p":{"lines":[464,465]},"v":"基本类型"},{"t":"list_item","d":8,"p":{"lines":[465,466]},"v":"数组类型"},{"t":"list_item","d":8,"p":{"lines":[466,467]},"v":"引用类型"},{"t":"list_item","d":8,"p":{"lines":[467,468]},"v":"对象的属性修改类型"}]},{"t":"list_item","d":6,"p":{"lines":[468,469]},"v":"AtomicInteger","c":[{"t":"list_item","d":8,"p":{"lines":[469,470]},"v":"示例"},{"t":"list_item","d":8,"p":{"lines":[470,471]},"v":"基本原理"}]}]},{"t":"list_item","d":4,"p":{"lines":[472,473]},"v":"LockSupport","c":[{"t":"list_item","d":6,"p":{"lines":[473,474]},"v":"是什么"},{"t":"list_item","d":6,"p":{"lines":[474,475]},"v":"使用原理"},{"t":"list_item","d":6,"p":{"lines":[475,476]},"v":"<a href=\"https://blog.csdn.net/saintyyu/article/details/107426428\">底层原理</a>"},{"t":"list_item","d":6,"p":{"lines":[476,477]},"v":"<a href=\"https://www.pdai.tech/md/java/thread/java-thread-x-lock-LockSupport.html\">常见问题</a>","c":[{"t":"list_item","d":8,"p":{"lines":[477,478]},"v":"park底层使用的是<code>UNSAFE.park</code>"},{"t":"list_item","d":8,"p":{"lines":[478,479]},"v":"为什么LockSupport也是核心基础类? AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park/unpark操作)"},{"t":"list_item","d":8,"p":{"lines":[479,480]},"v":"写出分别通过wait/notify和LockSupport的park/unpark实现同步?"},{"t":"list_item","d":8,"p":{"lines":[480,481]},"v":"LockSupport.park()会释放锁资源吗? 那么Condition.await()呢?"},{"t":"list_item","d":8,"p":{"lines":[481,482]},"v":"Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别? <strong>重点</strong>"},{"t":"list_item","d":8,"p":{"lines":[482,483]},"v":"如果在wait()之前执行了notify()会怎样? 如果在park()之前执行了unpark()会怎样?"}]}]},{"t":"list_item","d":4,"p":{"lines":[484,485]},"v":"锁、通信工具类<br />和底层使用","c":[{"t":"list_item","d":6,"p":{"lines":[485,486]},"v":"AQS实现的锁(实现Lock接口)","c":[{"t":"list_item","d":8,"p":{"lines":[486,487]},"v":"ReentrantLock","c":[{"t":"list_item","d":10,"p":{"lines":[487,488]},"v":"内部类Sync继承AQS"},{"t":"list_item","d":10,"p":{"lines":[488,489]},"v":"Condition底层使用LockSupport"}]},{"t":"list_item","d":8,"p":{"lines":[489,490]},"v":"ReentrantReadWriteLock","c":[{"t":"list_item","d":10,"p":{"lines":[490,491]},"v":"读锁和写锁都有继承AQS的内部类Sync"}]}]},{"t":"list_item","d":6,"p":{"lines":[491,492]},"v":"AQS通信工具类","c":[{"t":"list_item","d":8,"p":{"lines":[492,493]},"v":"Semaphore","c":[{"t":"list_item","d":10,"p":{"lines":[493,494]},"v":"内部有一个继承了AQS的同步器Sync"}]},{"t":"list_item","d":8,"p":{"lines":[494,495]},"v":"CountDownLatch","c":[{"t":"list_item","d":10,"p":{"lines":[495,496]},"v":"内部有一个继承了AQS的同步器Sync"}]},{"t":"list_item","d":8,"p":{"lines":[496,497]},"v":"CyclicBarrier","c":[{"t":"list_item","d":10,"p":{"lines":[497,498]},"v":"内部使用ReentrantLock"}]}]},{"t":"list_item","d":6,"p":{"lines":[498,499]},"v":"非AQS的通信工具类","c":[{"t":"list_item","d":8,"p":{"lines":[499,500]},"v":"Exchanger","c":[{"t":"list_item","d":10,"p":{"lines":[500,501]},"v":"LockSupport"},{"t":"list_item","d":10,"p":{"lines":[501,502]},"v":"CAS(Atomic)"}]},{"t":"list_item","d":8,"p":{"lines":[502,503]},"v":"Phaser","c":[{"t":"list_item","d":10,"p":{"lines":[503,504]},"v":"有使用LockSupport"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[505,506]},"v":"锁的种类","c":[{"t":"list_item","d":6,"p":{"lines":[506,507]},"v":"锁的有无","c":[{"t":"list_item","d":8,"p":{"lines":[507,508]},"v":"乐观锁"},{"t":"list_item","d":8,"p":{"lines":[508,509]},"v":"悲观锁"}]},{"t":"list_item","d":6,"p":{"lines":[509,510]},"v":"synchronized的锁","c":[{"t":"list_item","d":8,"p":{"lines":[510,511]},"v":"无锁"},{"t":"list_item","d":8,"p":{"lines":[511,512]},"v":"偏向锁"},{"t":"list_item","d":8,"p":{"lines":[512,513]},"v":"轻量锁"},{"t":"list_item","d":8,"p":{"lines":[513,514]},"v":"重量锁"}]},{"t":"list_item","d":6,"p":{"lines":[514,515]},"v":"锁的性质分类","c":[{"t":"list_item","d":8,"p":{"lines":[515,516]},"v":"可重入锁和非可重入锁","c":[{"t":"list_item","d":10,"p":{"lines":[516,517]},"v":"表现"},{"t":"list_item","d":10,"p":{"lines":[517,518]},"v":"原理：粒度（加锁范围）"},{"t":"list_item","d":10,"p":{"lines":[518,519]},"v":"实例","c":[{"t":"list_item","d":12,"p":{"lines":[519,520]},"v":"可重入锁"},{"t":"list_item","d":12,"p":{"lines":[520,521]},"v":"不可重入锁"},{"t":"list_item","d":12,"p":{"lines":[521,522]},"v":"可以切换"}]}]},{"t":"list_item","d":8,"p":{"lines":[522,523]},"v":"公平锁与非公平锁","c":[{"t":"list_item","d":10,"p":{"lines":[523,524]},"v":"表现"},{"t":"list_item","d":10,"p":{"lines":[524,525]},"v":"原理"},{"t":"list_item","d":10,"p":{"lines":[525,526]},"v":"实例","c":[{"t":"list_item","d":12,"p":{"lines":[526,527]},"v":"公平锁"},{"t":"list_item","d":12,"p":{"lines":[527,528]},"v":"非公平锁"},{"t":"list_item","d":12,"p":{"lines":[528,529]},"v":"可以切换"}]}]},{"t":"list_item","d":8,"p":{"lines":[529,530]},"v":"读写锁和排它锁","c":[{"t":"list_item","d":10,"p":{"lines":[530,531]},"v":"表现"},{"t":"list_item","d":10,"p":{"lines":[531,532]},"v":"原理"},{"t":"list_item","d":10,"p":{"lines":[532,533]},"v":"实例","c":[{"t":"list_item","d":12,"p":{"lines":[533,534]},"v":"读写锁"},{"t":"list_item","d":12,"p":{"lines":[534,535]},"v":"排它锁"},{"t":"list_item","d":12,"p":{"lines":[535,536]},"v":"可以切换"}]}]},{"t":"list_item","d":8,"p":{"lines":[536,537]},"v":"是否可中断"}]}]},{"t":"list_item","d":4,"p":{"lines":[538,539]},"v":"并发集合容器","c":[{"t":"list_item","d":6,"p":{"lines":[539,540]},"v":"<a href=\"https://juejin.cn/post/6844903954719965192\">什么是同步容器和并发容器</a>","c":[{"t":"list_item","d":8,"p":{"lines":[540,541]},"v":"同步容器：synchronized"},{"t":"list_item","d":8,"p":{"lines":[541,542]},"v":"并发容器：AQS锁、CAS、COW、分段锁"}]},{"t":"list_item","d":6,"p":{"lines":[542,543]},"v":"同步容器","c":[{"t":"list_item","d":8,"p":{"lines":[543,544]},"v":"vector:在面对多线程下的复合操作的时候也是需要通过客户端加锁的方式保证原子性"},{"t":"list_item","d":8,"p":{"lines":[544,545]},"v":"HashTable"},{"t":"list_item","d":8,"p":{"lines":[545,546]},"v":"Collections下的各种 SynchronizedXXX"}]},{"t":"list_item","d":6,"p":{"lines":[546,547]},"v":"并发容器","c":[{"t":"list_item","d":8,"p":{"lines":[547,548]},"v":"Queue","c":[{"t":"list_item","d":10,"p":{"lines":[548,549]},"v":"BlockingQueue","c":[{"t":"list_item","d":12,"p":{"lines":[549,550]},"v":"ArrayBlockingQueue"},{"t":"list_item","d":12,"p":{"lines":[550,551]},"v":"LinkedBlockingQueue"},{"t":"list_item","d":12,"p":{"lines":[551,552]},"v":"DelayQueue"},{"t":"list_item","d":12,"p":{"lines":[552,553]},"v":"Priority BlockingQueue"},{"t":"list_item","d":12,"p":{"lines":[553,554]},"v":"SynchronousQueue"},{"t":"list_item","d":12,"p":{"lines":[554,555]},"v":"LinkedBlockingDeque"},{"t":"list_item","d":12,"p":{"lines":[555,556]},"v":"LinkedTransferQueue"}]},{"t":"list_item","d":10,"p":{"lines":[556,557]},"v":"ConcurrenLinkedQueue","c":[{"t":"list_item","d":12,"p":{"lines":[557,558]},"v":"Unsafe:CAS"},{"t":"list_item","d":12,"p":{"lines":[558,559]},"v":"<a href=\"https://blog.csdn.net/lzxlfly/article/details/86710382\">LinkedBlockingQueue与ConcurrentLinkedQueue的区别</a>"}]}]},{"t":"list_item","d":8,"p":{"lines":[559,560]},"v":"ConcurrentMap","c":[{"t":"list_item","d":10,"p":{"lines":[560,561]},"v":"ConcurrentHashMap","c":[{"t":"list_item","d":12,"p":{"lines":[561,562]},"v":"看HashMap那里"}]},{"t":"list_item","d":10,"p":{"lines":[562,563]},"v":"ConcurrentNavigableMap"},{"t":"list_item","d":10,"p":{"lines":[563,564]},"v":"ConcurrentSkipListMap"}]},{"t":"list_item","d":8,"p":{"lines":[564,565]},"v":"CopyOnWrite","c":[{"t":"list_item","d":10,"p":{"lines":[565,566]},"v":"CopyOnWriteArrayList","c":[{"t":"list_item","d":12,"p":{"lines":[566,567]},"v":"ReentrantLock加锁"}]},{"t":"list_item","d":10,"p":{"lines":[567,568]},"v":"CopyOnWriteArrayMap"},{"t":"list_item","d":10,"p":{"lines":[568,569]},"v":"CopyOnWriteArraySet"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[570,571]},"v":"线程池","c":[{"t":"list_item","d":6,"p":{"lines":[571,572]},"v":"结构","c":[{"t":"list_item","d":8,"p":{"lines":[572,573]},"v":"任务(Runnable /Callable)"},{"t":"list_item","d":8,"p":{"lines":[573,574]},"v":"任务的执行(Executor)"},{"t":"list_item","d":8,"p":{"lines":[574,575]},"v":"异步计算的结果(Future)"}]},{"t":"list_item","d":6,"p":{"lines":[575,576]},"v":"创建","c":[{"t":"list_item","d":8,"p":{"lines":[576,577]},"v":"ThreadPoolExecutor构造方法参数的含义","c":[{"t":"list_item","d":10,"p":{"lines":[577,578]},"v":"int corePoolSize：该线程池中核心线程数最大值"},{"t":"list_item","d":10,"p":{"lines":[578,579]},"v":"int maximumPoolSize：该线程池中线程总数最大值 。"},{"t":"list_item","d":10,"p":{"lines":[579,580]},"v":"long keepAliveTime：非核心线程闲置超时时长。"},{"t":"list_item","d":10,"p":{"lines":[580,581]},"v":"TimeUnit unit：keepAliveTime的单位。"},{"t":"list_item","d":10,"p":{"lines":[581,582]},"v":"BlockingQueue workQueue：阻塞队列，维护着等待执行的Runnable任务对象。"},{"t":"list_item","d":10,"p":{"lines":[582,583]},"v":"ThreadFactory threadFactory：<br />创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，<br/>如是否守护线程、线程的优先级等。<br />如果不指定，会新建一个默认的线程工厂。"},{"t":"list_item","d":10,"p":{"lines":[583,584]},"v":"RejectedExecutionHandler handler 拒绝策略","c":[{"t":"list_item","d":12,"p":{"lines":[584,585]},"v":"AbortPolicy：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。"},{"t":"list_item","d":12,"p":{"lines":[585,586]},"v":"DiscardPolicy：丢弃新来的任务，但是不抛出异常。"},{"t":"list_item","d":12,"p":{"lines":[586,587]},"v":"DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。"},{"t":"list_item","d":12,"p":{"lines":[587,588]},"v":"CallerRunsPolicy：由调用线程处理该任务。"}]}]},{"t":"list_item","d":8,"p":{"lines":[588,589]},"v":"Executors默认实现(底层使用ThreadPoolExecutor)","c":[{"t":"list_item","d":10,"p":{"lines":[589,590]},"v":"FixedThreadPool","c":[{"t":"list_item","d":12,"p":{"lines":[590,591]},"v":"参数设置"},{"t":"list_item","d":12,"p":{"lines":[591,592]},"v":"执行过程"},{"t":"list_item","d":12,"p":{"lines":[592,593]},"v":"弊端"}]},{"t":"list_item","d":10,"p":{"lines":[593,594]},"v":"CachedThreadPool","c":[{"t":"list_item","d":12,"p":{"lines":[594,595]},"v":"参数设置"},{"t":"list_item","d":12,"p":{"lines":[595,596]},"v":"执行过程"},{"t":"list_item","d":12,"p":{"lines":[596,597]},"v":"弊端"}]},{"t":"list_item","d":10,"p":{"lines":[597,598]},"v":"SingleThreadExecutor","c":[{"t":"list_item","d":12,"p":{"lines":[598,599]},"v":"参数设置"},{"t":"list_item","d":12,"p":{"lines":[599,600]},"v":"执行过程"},{"t":"list_item","d":12,"p":{"lines":[600,601]},"v":"弊端"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[601,602]},"v":"<strong>线程池工作流程</strong>"},{"t":"list_item","d":6,"p":{"lines":[602,603]},"v":"ThreadPool状态转换","c":[{"t":"list_item","d":8,"p":{"lines":[603,604]},"v":"RUNNING"},{"t":"list_item","d":8,"p":{"lines":[604,605]},"v":"SHUTDOWN"},{"t":"list_item","d":8,"p":{"lines":[605,606]},"v":"STOP"},{"t":"list_item","d":8,"p":{"lines":[606,607]},"v":"TIDYING"},{"t":"list_item","d":8,"p":{"lines":[607,608]},"v":"TERMINATED"}]},{"t":"list_item","d":6,"p":{"lines":[608,609]},"v":"ScheduledThreadPool:","c":[{"t":"list_item","d":8,"p":{"lines":[609,610]},"v":"继承了ThreadPoolExecutor"},{"t":"list_item","d":8,"p":{"lines":[610,611]},"v":"主要用来在给定的延迟后运行任务，或者定期执行任务"},{"t":"list_item","d":8,"p":{"lines":[611,612]},"v":"实际项目中会使<code>用quartz</code>"}]},{"t":"list_item","d":6,"p":{"lines":[612,613]},"v":"<strong>为什么不要用默认实现</strong> <br/> (上面的默认实现有什么弊端)"},{"t":"list_item","d":6,"p":{"lines":[613,614]},"v":"参数如何设置(N+1,2N)"},{"t":"list_item","d":6,"p":{"lines":[614,615]},"v":"<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&amp;mid=2247505057&amp;idx=1&amp;sn=621ebc409b589478e2e05388e079d8c0&amp;source=41#wechat_redirect\">异常线程处理</a>"},{"t":"list_item","d":6,"p":{"lines":[615,616]},"v":"常见区别","c":[{"t":"list_item","d":8,"p":{"lines":[616,617]},"v":"sumbit() vs execute()","c":[{"t":"list_item","d":10,"p":{"lines":[617,618]},"v":"execute()方法不会返回结果"},{"t":"list_item","d":10,"p":{"lines":[618,619]},"v":"submit()会返回一个 FutureTask 对象，并可以获得结果"},{"t":"list_item","d":10,"p":{"lines":[619,620]},"v":"<a href=\"https://www.jianshu.com/p/29610984f1dd\">异常处理</a>"}]},{"t":"list_item","d":8,"p":{"lines":[620,621]},"v":"Runnable vs Callable"},{"t":"list_item","d":8,"p":{"lines":[621,622]},"v":"shutdown() vs shutdownNow()"}]}]},{"t":"list_item","d":4,"p":{"lines":[623,624]},"v":"<strong>ThreadLocal(待做)</strong>"}]}]},{"t":"heading","d":2,"p":{"lines":[625,626],"f":true},"v":"IO/NIO/AIO "}]},{"t":"heading","d":1,"p":{"lines":[627,628]},"v":"JVM","c":[{"t":"heading","d":2,"p":{"lines":[629,630],"f":true},"v":"基础知识 ","c":[{"t":"list_item","d":4,"p":{"lines":[631,632]},"v":"jvm发展"},{"t":"list_item","d":4,"p":{"lines":[632,633]},"v":"特点：","c":[{"t":"list_item","d":6,"p":{"lines":[633,634]},"v":"一次编译，到处运行"},{"t":"list_item","d":6,"p":{"lines":[634,635]},"v":"自动内存管理"},{"t":"list_item","d":6,"p":{"lines":[635,636]},"v":"自动垃圾回收"}]},{"t":"list_item","d":4,"p":{"lines":[636,637]},"v":"架构模型","c":[{"t":"list_item","d":6,"p":{"lines":[637,638]},"v":"基于栈式架构"},{"t":"list_item","d":6,"p":{"lines":[638,639]},"v":"基于寄存器架构"}]},{"t":"list_item","d":4,"p":{"lines":[639,640]},"v":"JVM生命周期","c":[{"t":"list_item","d":6,"p":{"lines":[640,641]},"v":"启动"},{"t":"list_item","d":6,"p":{"lines":[641,642]},"v":"执行"},{"t":"list_item","d":6,"p":{"lines":[642,643]},"v":"退出"}]}]},{"t":"heading","d":2,"p":{"lines":[644,645],"f":true},"v":"内存与垃圾回收 ","c":[{"t":"heading","d":3,"p":{"lines":[646,647]},"v":"上层","c":[{"t":"list_item","d":5,"p":{"lines":[648,649]},"v":"画出详细架构"},{"t":"list_item","d":5,"p":{"lines":[649,650]},"v":"类加载过程","c":[{"t":"list_item","d":7,"p":{"lines":[650,651]},"v":"loading 加载(加载和链接交叉进行)","c":[{"t":"list_item","d":9,"p":{"lines":[651,652]},"v":"目的"}]},{"t":"list_item","d":7,"p":{"lines":[652,653]},"v":"linking 链接(加载和链接交叉进行)","c":[{"t":"list_item","d":9,"p":{"lines":[653,654]},"v":"verify 验证","c":[{"t":"list_item","d":11,"p":{"lines":[654,655]},"v":"目的"}]},{"t":"list_item","d":9,"p":{"lines":[655,656]},"v":"prepare 准备","c":[{"t":"list_item","d":11,"p":{"lines":[656,657]},"v":"目的"}]},{"t":"list_item","d":9,"p":{"lines":[657,658]},"v":"Resolve 解析","c":[{"t":"list_item","d":11,"p":{"lines":[658,659]},"v":"目的"},{"t":"list_item","d":11,"p":{"lines":[659,660]},"v":"执行时机"}]}]},{"t":"list_item","d":7,"p":{"lines":[660,661]},"v":"initialization 初始化","c":[{"t":"list_item","d":9,"p":{"lines":[661,662]},"v":"目的"},{"t":"list_item","d":9,"p":{"lines":[662,663]},"v":"特点","c":[{"t":"list_item","d":11,"p":{"lines":[663,664]},"v":"顺序执行"},{"t":"list_item","d":11,"p":{"lines":[664,665]},"v":"父类先与子类"},{"t":"list_item","d":11,"p":{"lines":[665,666]},"v":"<code>&lt;clint&gt;</code>多线程同步加锁"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[666,667]},"v":"类加载器","c":[{"t":"list_item","d":7,"p":{"lines":[667,668]},"v":"分清关系","c":[{"t":"list_item","d":9,"p":{"lines":[668,669]},"v":"继承关系"},{"t":"list_item","d":9,"p":{"lines":[669,670]},"v":"上下层关系<br />(涉及双亲委派)"},{"t":"list_item","d":9,"p":{"lines":[670,671]},"v":"包含关系<br />(自定义类加载器包含其他java编写类加载器)"}]},{"t":"list_item","d":7,"p":{"lines":[671,672]},"v":"通常分类","c":[{"t":"list_item","d":9,"p":{"lines":[672,673]},"v":"BootStrap ClassLoader","c":[{"t":"list_item","d":11,"p":{"lines":[673,674]},"v":"目的"},{"t":"list_item","d":11,"p":{"lines":[674,675]},"v":"父类"},{"t":"list_item","d":11,"p":{"lines":[675,676]},"v":"加载库"}]},{"t":"list_item","d":9,"p":{"lines":[676,677]},"v":"Extension ClassLoader","c":[{"t":"list_item","d":11,"p":{"lines":[677,678]},"v":"目的"},{"t":"list_item","d":11,"p":{"lines":[678,679]},"v":"父类"},{"t":"list_item","d":11,"p":{"lines":[679,680]},"v":"加载库"}]},{"t":"list_item","d":9,"p":{"lines":[680,681]},"v":"AppClassLoader ClassLoader","c":[{"t":"list_item","d":11,"p":{"lines":[681,682]},"v":"目的"},{"t":"list_item","d":11,"p":{"lines":[682,683]},"v":"父类"},{"t":"list_item","d":11,"p":{"lines":[683,684]},"v":"加载库"}]}]},{"t":"list_item","d":7,"p":{"lines":[684,685]},"v":"按照规范","c":[{"t":"list_item","d":9,"p":{"lines":[685,686]},"v":"引导类加载器（Bootstrap ClassLoader） c/c++编写"},{"t":"list_item","d":9,"p":{"lines":[686,687]},"v":"自定义类加载器（User-Defined ClassLoader） java编写","c":[{"t":"list_item","d":11,"p":{"lines":[687,688]},"v":"为何要自定义类加载器"}]}]},{"t":"list_item","d":7,"p":{"lines":[688,689]},"v":"抽象类ClassLoader","c":[{"t":"list_item","d":9,"p":{"lines":[689,690]},"v":"继承结构"},{"t":"list_item","d":9,"p":{"lines":[690,691]},"v":"虚拟机的入口应用:<code>sun.misc.Launcher</code>"},{"t":"list_item","d":9,"p":{"lines":[691,692]},"v":"获取classloader的方式"}]},{"t":"list_item","d":7,"p":{"lines":[692,693]},"v":"<strong>双亲委派机制</strong>","c":[{"t":"list_item","d":9,"p":{"lines":[693,694]},"v":"<strong>原理</strong>"},{"t":"list_item","d":9,"p":{"lines":[694,695]},"v":"自定义java.lang.String是否会加载"},{"t":"list_item","d":9,"p":{"lines":[695,696]},"v":"优势","c":[{"t":"list_item","d":11,"p":{"lines":[696,697]},"v":"避免类的重复加载"},{"t":"list_item","d":11,"p":{"lines":[697,698]},"v":"保护程序安全，防止核心api被随意篡改"}]},{"t":"list_item","d":9,"p":{"lines":[698,699]},"v":"例外案例"}]},{"t":"list_item","d":7,"p":{"lines":[699,700]},"v":"沙箱安全机制"},{"t":"list_item","d":7,"p":{"lines":[700,701]},"v":"其他","c":[{"t":"list_item","d":9,"p":{"lines":[701,702]},"v":"jvm 中判断两个class对象是否为同一个类2个判断条件"},{"t":"list_item","d":9,"p":{"lines":[702,703]},"v":"类加载器引用哦作为类型信息存于方法区"},{"t":"list_item","d":9,"p":{"lines":[703,704]},"v":"引用类型转换时，要保证两个类加载器相同"}]}]}]},{"t":"heading","d":3,"p":{"lines":[705,706]},"v":"中层","c":[{"t":"list_item","d":5,"p":{"lines":[707,708]},"v":"<strong>Java内存区域布局说明</strong>"},{"t":"list_item","d":5,"p":{"lines":[708,709]},"v":"程序计数器","c":[{"t":"list_item","d":7,"p":{"lines":[709,710]},"v":"是什么","c":[{"t":"list_item","d":9,"p":{"lines":[710,711]},"v":"线程私有"},{"t":"list_item","d":9,"p":{"lines":[711,712]},"v":"取值"},{"t":"list_item","d":9,"p":{"lines":[712,713]},"v":"作用"},{"t":"list_item","d":9,"p":{"lines":[713,714]},"v":"没有OOM"},{"t":"list_item","d":9,"p":{"lines":[714,715]},"v":"生命周期"}]},{"t":"list_item","d":7,"p":{"lines":[715,716]},"v":"问题","c":[{"t":"list_item","d":9,"p":{"lines":[716,717]},"v":"为什么使用PC寄存字器记录当当前线程的执行地址"},{"t":"list_item","d":9,"p":{"lines":[717,718]},"v":"pc寄存器为什么被设定为线程私有"}]}]},{"t":"list_item","d":5,"p":{"lines":[718,719]},"v":"虚拟机栈","c":[{"t":"list_item","d":7,"p":{"lines":[719,720]},"v":"是什么","c":[{"t":"list_item","d":9,"p":{"lines":[720,721]},"v":"线程私有"},{"t":"list_item","d":9,"p":{"lines":[721,722]},"v":"对应方法调用，入栈，出栈"},{"t":"list_item","d":9,"p":{"lines":[722,723]},"v":"作用"},{"t":"list_item","d":9,"p":{"lines":[723,724]},"v":"没有垃圾回收"},{"t":"list_item","d":9,"p":{"lines":[724,725]},"v":"异常"}]},{"t":"list_item","d":7,"p":{"lines":[725,726]},"v":"参数设置","c":[{"t":"list_item","d":9,"p":{"lines":[726,727]},"v":"<code>-Xss</code>"}]},{"t":"list_item","d":7,"p":{"lines":[727,728]},"v":"栈帧","c":[{"t":"list_item","d":9,"p":{"lines":[728,729]},"v":"是什么","c":[{"t":"list_item","d":11,"p":{"lines":[729,730]},"v":"Java虚拟机栈（Java Virtual Machine Stack),早期也叫Java栈。"},{"t":"list_item","d":11,"p":{"lines":[730,731]},"v":"每个线程在创建时都会创建一个虚拟机栈，<br />其内部保存一个个的栈帧 (Stack Frame),对应着一次次的Java方法调用。"},{"t":"list_item","d":11,"p":{"lines":[731,732]},"v":"是线程私有的"}]},{"t":"list_item","d":9,"p":{"lines":[732,733]},"v":"运行原理-栈帧弹出"},{"t":"list_item","d":9,"p":{"lines":[733,734]},"v":"内部组成","c":[{"t":"list_item","d":11,"p":{"lines":[734,735]},"v":"局部变量表","c":[{"t":"list_item","d":13,"p":{"lines":[735,736]},"v":"作用"},{"t":"list_item","d":13,"p":{"lines":[736,737]},"v":"生命周期"},{"t":"list_item","d":13,"p":{"lines":[737,738]},"v":"slot","c":[{"t":"list_item","d":15,"p":{"lines":[738,739]},"v":"概念/作用"},{"t":"list_item","d":15,"p":{"lines":[739,740]},"v":"32位,64位占用"},{"t":"list_item","d":15,"p":{"lines":[740,741]},"v":"存储数据类型"},{"t":"list_item","d":15,"p":{"lines":[741,742]},"v":"存储内容与顺序"},{"t":"list_item","d":15,"p":{"lines":[742,743]},"v":"槽的重用"}]},{"t":"list_item","d":13,"p":{"lines":[743,744]},"v":"内存分配(<strong>编译期间</strong>完成分配)"},{"t":"list_item","d":13,"p":{"lines":[744,745]},"v":"线程私有不存在数据安全问题"},{"t":"list_item","d":13,"p":{"lines":[745,746]},"v":"垃圾回收：局部变量表中的变量也是重要的垃圾回收根节点"}]},{"t":"list_item","d":11,"p":{"lines":[746,747]},"v":"操作数栈","c":[{"t":"list_item","d":13,"p":{"lines":[747,748]},"v":"编译时就已经确定深度<code>max_stacks</code>"},{"t":"list_item","d":13,"p":{"lines":[748,749]},"v":"操作：出栈入栈"},{"t":"list_item","d":13,"p":{"lines":[749,750]},"v":"具体流程示例"},{"t":"list_item","d":13,"p":{"lines":[750,751]},"v":"栈顶缓存技术"}]},{"t":"list_item","d":11,"p":{"lines":[751,752]},"v":"帧数据区","c":[{"t":"list_item","d":13,"p":{"lines":[752,753]},"v":"动态链接","c":[{"t":"list_item","d":15,"p":{"lines":[753,754]},"v":"什么是动态链接"},{"t":"list_item","d":15,"p":{"lines":[754,755]},"v":"<strong>深入</strong>：方法的调用：解析和分派","c":[{"t":"list_item","d":17,"p":{"lines":[755,756]},"v":"绑定与链接","c":[{"t":"list_item","d":19,"p":{"lines":[756,757]},"v":"早期绑定"},{"t":"list_item","d":19,"p":{"lines":[757,758]},"v":"晚期绑定"},{"t":"list_item","d":19,"p":{"lines":[758,759]},"v":"静态连接"},{"t":"list_item","d":19,"p":{"lines":[759,760]},"v":"动态链接"}]},{"t":"list_item","d":17,"p":{"lines":[760,761]},"v":"<strong>非虚方法与虚方法</strong>","c":[{"t":"list_item","d":19,"p":{"lines":[761,762],"f":true},"v":"什么是非虚方法 ","c":[{"t":"list_item","d":21,"p":{"lines":[762,763]},"v":"静态方法"},{"t":"list_item","d":21,"p":{"lines":[763,764]},"v":"私有方法"},{"t":"list_item","d":21,"p":{"lines":[764,765]},"v":"final方法"},{"t":"list_item","d":21,"p":{"lines":[765,766]},"v":"构造器"},{"t":"list_item","d":21,"p":{"lines":[766,767]},"v":"父类方法(使用super显式调用)"}]},{"t":"list_item","d":19,"p":{"lines":[767,768],"f":true},"v":"什么是虚方法 ","c":[{"t":"list_item","d":21,"p":{"lines":[768,769]},"v":"非虚方法之外的方法"}]},{"t":"list_item","d":19,"p":{"lines":[769,770],"f":true},"v":"无个调用指令 ","c":[{"t":"list_item","d":21,"p":{"lines":[770,771]},"v":"invokespecial"},{"t":"list_item","d":21,"p":{"lines":[771,772]},"v":"invokestatic"},{"t":"list_item","d":21,"p":{"lines":[772,773]},"v":"invokevirtual"},{"t":"list_item","d":21,"p":{"lines":[773,774]},"v":"invokeinterface"},{"t":"list_item","d":21,"p":{"lines":[774,775]},"v":"invokedynamic"}]},{"t":"list_item","d":19,"p":{"lines":[775,776]},"v":"方法重写本质"},{"t":"list_item","d":19,"p":{"lines":[776,777]},"v":"虚方法表","c":[{"t":"list_item","d":21,"p":{"lines":[777,778]},"v":"出现原因"},{"t":"list_item","d":21,"p":{"lines":[778,779]},"v":"作用"},{"t":"list_item","d":21,"p":{"lines":[779,780]},"v":"内存位置"},{"t":"list_item","d":21,"p":{"lines":[780,781]},"v":"建立时期"},{"t":"list_item","d":21,"p":{"lines":[781,782]},"v":"插入条目<br />(需要解释这些信息)","c":[{"t":"list_item","d":23,"p":{"lines":[782,783]},"v":"符号引用"},{"t":"list_item","d":23,"p":{"lines":[783,784]},"v":"直接引用"},{"t":"list_item","d":23,"p":{"lines":[784,785]},"v":"解析时机"}]}]}]}]}]},{"t":"list_item","d":13,"p":{"lines":[785,786]},"v":"方法返回地址","c":[{"t":"list_item","d":15,"p":{"lines":[786,787]},"v":"栈帧退出方式"},{"t":"list_item","d":15,"p":{"lines":[787,788]},"v":"作用"}]},{"t":"list_item","d":13,"p":{"lines":[788,789]},"v":"一些附加信息"}]}]}]},{"t":"list_item","d":7,"p":{"lines":[789,790],"f":true},"v":"问题 ","c":[{"t":"list_item","d":9,"p":{"lines":[790,791]},"v":"栈中可能出现的异常"},{"t":"list_item","d":9,"p":{"lines":[791,792]},"v":"i++和++i的区别。<br />从字节码，局部变量表，操作数栈层面解释"},{"t":"list_item","d":9,"p":{"lines":[792,793]},"v":"举例栈溢出的情况？(StackOverflowError)"},{"t":"list_item","d":9,"p":{"lines":[793,794]},"v":"调整栈大小，就能保证不出现溢出吗？"},{"t":"list_item","d":9,"p":{"lines":[794,795]},"v":"分配的栈内存越大越好吗？"},{"t":"list_item","d":9,"p":{"lines":[795,796]},"v":"垃圾回收是否会涉及到虚拟机栈？"},{"t":"list_item","d":9,"p":{"lines":[796,797]},"v":"方法中定义的局部变量是否线程安全？"}]}]},{"t":"list_item","d":5,"p":{"lines":[797,798]},"v":"本地方法接口+库(非运行时数据区结构)","c":[{"t":"list_item","d":7,"p":{"lines":[798,799]},"v":"定义:一个Native Method就是一个Java调用非Java代码的接口。"},{"t":"list_item","d":7,"p":{"lines":[799,800]},"v":"特点:该方法的实现由非Java语言实现，比如 C。"},{"t":"list_item","d":7,"p":{"lines":[800,801]},"v":"目的:","c":[{"t":"list_item","d":9,"p":{"lines":[801,802]},"v":"与java环境外交互"},{"t":"list_item","d":9,"p":{"lines":[802,803]},"v":"与操作系统交互"},{"t":"list_item","d":9,"p":{"lines":[803,804]},"v":"Sun's java"}]}]},{"t":"list_item","d":5,"p":{"lines":[804,805]},"v":"本地方法栈","c":[{"t":"list_item","d":7,"p":{"lines":[805,806]},"v":"目的"},{"t":"list_item","d":7,"p":{"lines":[806,807]},"v":"在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。"}]},{"t":"list_item","d":5,"p":{"lines":[808,809]},"v":"堆","c":[{"t":"list_item","d":7,"p":{"lines":[809,810]},"v":"空间划分与比例<code>1:2</code> <code>6:1:1</code>"},{"t":"list_item","d":7,"p":{"lines":[810,811]},"v":"自适应调节策略"},{"t":"list_item","d":7,"p":{"lines":[811,812]},"v":"堆大小设置参数<code>-Xms</code> <code>-Xmx</code>","c":[{"t":"list_item","d":9,"p":{"lines":[812,813]},"v":"默认 1/64,1/4"}]},{"t":"list_item","d":7,"p":{"lines":[813,814]},"v":"对象分配","c":[{"t":"list_item","d":9,"p":{"lines":[814,815]},"v":"一般过程"},{"t":"list_item","d":9,"p":{"lines":[815,816]},"v":"特殊情况"}]},{"t":"list_item","d":7,"p":{"lines":[816,817]},"v":"四种GC","c":[{"t":"list_item","d":9,"p":{"lines":[817,818]},"v":"Minor GC","c":[{"t":"list_item","d":11,"p":{"lines":[818,819]},"v":"回收区域"},{"t":"list_item","d":11,"p":{"lines":[819,820]},"v":"触发机制"},{"t":"list_item","d":11,"p":{"lines":[820,821]},"v":"耗时代价"},{"t":"list_item","d":11,"p":{"lines":[821,822]},"v":"Survivor的被动收集"}]},{"t":"list_item","d":9,"p":{"lines":[822,823]},"v":"Major GC","c":[{"t":"list_item","d":11,"p":{"lines":[823,824]},"v":"回收区域"},{"t":"list_item","d":11,"p":{"lines":[824,825]},"v":"触发机制"},{"t":"list_item","d":11,"p":{"lines":[825,826]},"v":"耗时代价"}]},{"t":"list_item","d":9,"p":{"lines":[826,827]},"v":"Mixed GC","c":[{"t":"list_item","d":11,"p":{"lines":[827,828]},"v":"回收区域"},{"t":"list_item","d":11,"p":{"lines":[828,829]},"v":"只有G1回收器有该GC"}]},{"t":"list_item","d":9,"p":{"lines":[829,830]},"v":"Full GC","c":[{"t":"list_item","d":11,"p":{"lines":[830,831]},"v":"回收区域"},{"t":"list_item","d":11,"p":{"lines":[831,832]},"v":"触发机制"},{"t":"list_item","d":11,"p":{"lines":[832,833]},"v":"耗时代价"}]}]},{"t":"list_item","d":7,"p":{"lines":[833,834]},"v":"TLAB:快速分配策略。","c":[{"t":"list_item","d":9,"p":{"lines":[834,835]},"v":"作用"},{"t":"list_item","d":9,"p":{"lines":[835,836]},"v":"分配流程：","c":[{"t":"list_item","d":11,"p":{"lines":[836,837]},"v":"JVM确实是将TLAB作为内存分配的首选"},{"t":"list_item","d":11,"p":{"lines":[837,838]},"v":"失败后，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，<br />从而直接在Eden空间中分配内存。"}]},{"t":"list_item","d":9,"p":{"lines":[838,839]},"v":"大小：默认整个Eden空间的1%<br /> <code>-XX:TLABWasteTargetPercent</code>设置"}]},{"t":"list_item","d":7,"p":{"lines":[839,840]},"v":"逃逸分析<br />( <strong>十分不成熟，Hotspot也没用</strong> )","c":[{"t":"list_item","d":9,"p":{"lines":[840,841]},"v":"种类：","c":[{"t":"list_item","d":11,"p":{"lines":[841,842]},"v":"方法逃逸"},{"t":"list_item","d":11,"p":{"lines":[842,843]},"v":"线程逃逸"}]},{"t":"list_item","d":9,"p":{"lines":[843,844]},"v":"基于逃逸分析的优化","c":[{"t":"list_item","d":11,"p":{"lines":[844,845]},"v":"栈上分配(就没实现)"},{"t":"list_item","d":11,"p":{"lines":[845,846]},"v":"同步省略"},{"t":"list_item","d":11,"p":{"lines":[846,847]},"v":"标量替换"}]}]},{"t":"list_item","d":7,"p":{"lines":[847,848]},"v":"堆是分配对象的唯一选择:否定-&gt;肯定"}]},{"t":"list_item","d":5,"p":{"lines":[849,850]},"v":"方法区","c":[{"t":"list_item","d":7,"p":{"lines":[850,851]},"v":"特点","c":[{"t":"list_item","d":9,"p":{"lines":[851,852]},"v":"线程共享"},{"t":"list_item","d":9,"p":{"lines":[852,853]},"v":"本地内存"}]},{"t":"list_item","d":7,"p":{"lines":[853,854]},"v":"存储内容：具体看 <strong>细节演进</strong>"},{"t":"list_item","d":7,"p":{"lines":[854,855]},"v":"大小设置","c":[{"t":"list_item","d":9,"p":{"lines":[855,856]},"v":"1.7","c":[{"t":"list_item","d":11,"p":{"lines":[856,857]},"v":"<code>-XX:PermSize</code>"},{"t":"list_item","d":11,"p":{"lines":[857,858]},"v":"<code>-XX:MaxPermSize</code>"}]},{"t":"list_item","d":9,"p":{"lines":[858,859]},"v":"1.8","c":[{"t":"list_item","d":11,"p":{"lines":[859,860]},"v":"<code>-XX:MetaspaceSize</code><br />初始分配空间大小，<br />同时也是水位线大小"},{"t":"list_item","d":11,"p":{"lines":[860,861]},"v":"<code>-XX:MaxMetaspaceSize</code>方法区最大大小，默认-1"},{"t":"list_item","d":11,"p":{"lines":[861,862]},"v":"水位线--full GC--自动调整"}]}]},{"t":"list_item","d":7,"p":{"lines":[862,863]},"v":"<strong>内部结构演进变迁</strong>:看图去"},{"t":"list_item","d":7,"p":{"lines":[863,864]},"v":"为什么要移除永久代"},{"t":"list_item","d":7,"p":{"lines":[864,865]},"v":"常量池和运行时常量池"},{"t":"list_item","d":7,"p":{"lines":[865,866]},"v":"为何要移除永久代"},{"t":"list_item","d":7,"p":{"lines":[866,867]},"v":"<strong>什么是符号引用</strong><br />","c":[{"t":"list_item","d":9,"p":{"lines":[867,868]},"v":"说明：","c":[{"t":"list_item","d":11,"p":{"lines":[868,869]},"v":"以元祖JVM:Sun JDK 1.0.2的32位x86为例"},{"t":"list_item","d":11,"p":{"lines":[869,870]},"v":"整体原理类似"}]},{"t":"list_item","d":9,"p":{"lines":[870,871]},"v":"符号引用","c":[{"t":"list_item","d":11,"p":{"lines":[871,872],"f":true},"v":"说明 ","c":[{"t":"list_item","d":13,"p":{"lines":[872,873]},"v":"通常是设计字符串的，是用文本形式来表示引用关系"},{"t":"list_item","d":13,"p":{"lines":[873,874]},"v":"实际使用时可以藉此找到相应的位置"}]}]},{"t":"list_item","d":9,"p":{"lines":[874,875]},"v":"直接引用","c":[{"t":"list_item","d":11,"p":{"lines":[875,876],"f":true},"v":"表现形式 ","c":[{"t":"list_item","d":13,"p":{"lines":[876,877]},"v":"指向methodblock的指针"},{"t":"list_item","d":13,"p":{"lines":[877,878]},"v":"虚方法表下标"}]},{"t":"list_item","d":11,"p":{"lines":[878,879]},"v":"说明"}]},{"t":"list_item","d":9,"p":{"lines":[879,880]},"v":"解析时机"}]},{"t":"list_item","d":7,"p":{"lines":[880,881]},"v":"垃圾回收","c":[{"t":"list_item","d":9,"p":{"lines":[881,882]},"v":"是否要回收","c":[{"t":"list_item","d":11,"p":{"lines":[882,883]},"v":"《规范》提到过可以不要求虚拟机在方法区中实现垃圾收集"},{"t":"list_item","d":11,"p":{"lines":[883,884]},"v":"回收条件苛刻，效果比较难令人满意。"}]},{"t":"list_item","d":9,"p":{"lines":[884,885]},"v":"回收内容","c":[{"t":"list_item","d":11,"p":{"lines":[885,886]},"v":"常量池中废弃的常量","c":[{"t":"list_item","d":13,"p":{"lines":[886,887]},"v":"回收策略"},{"t":"list_item","d":13,"p":{"lines":[887,888],"f":true},"v":"组成 ","c":[{"t":"list_item","d":15,"p":{"lines":[888,889]},"v":"字面量常量"},{"t":"list_item","d":15,"p":{"lines":[889,890]},"v":"符号引用"}]}]},{"t":"list_item","d":11,"p":{"lines":[890,891]},"v":"不再使用的类","c":[{"t":"list_item","d":13,"p":{"lines":[891,892],"f":true},"v":"回收策略 ","c":[{"t":"list_item","d":15,"p":{"lines":[892,893]},"v":"该类所有的实例都已经被回收"},{"t":"list_item","d":15,"p":{"lines":[893,894]},"v":"加载该类的类加载器已经被回收"}]}]}]}]}]},{"t":"list_item","d":5,"p":{"lines":[894,895],"f":true},"v":"问题 ","c":[{"t":"list_item","d":7,"p":{"lines":[895,896]},"v":"说一下JVM内存模型吧，有哪些区？分别干什么的？"},{"t":"list_item","d":7,"p":{"lines":[896,897]},"v":"Java8的内存分代改进"},{"t":"list_item","d":7,"p":{"lines":[897,898]},"v":"JVM内存分哪几个区，每个区的作用是什么？"},{"t":"list_item","d":7,"p":{"lines":[898,899]},"v":"JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？"},{"t":"list_item","d":7,"p":{"lines":[899,900]},"v":"Eden和Survior的比例分配"},{"t":"list_item","d":7,"p":{"lines":[900,901]},"v":"jvm内存分区，为什么要有新生代和老年代"},{"t":"list_item","d":7,"p":{"lines":[901,902]},"v":"Java的内存分区"},{"t":"list_item","d":7,"p":{"lines":[902,903]},"v":"讲讲jvm运行时数据库区"},{"t":"list_item","d":7,"p":{"lines":[903,904]},"v":"什么时候对象会进入老年代？"},{"t":"list_item","d":7,"p":{"lines":[904,905]},"v":"JVM内存为什么要分成新生代，老年代，持久代。<br />新生代中为什么要分为Eden和Survivor。"},{"t":"list_item","d":7,"p":{"lines":[905,906]},"v":"Jvm内存模型以及分区，需要详细到每个区放什么。"},{"t":"list_item","d":7,"p":{"lines":[906,907]},"v":"JVM的内存模型，Java8做了什么修改"},{"t":"list_item","d":7,"p":{"lines":[907,908]},"v":"JVM内存分哪几个区，每个区的作用是什么？"},{"t":"list_item","d":7,"p":{"lines":[908,909]},"v":"java内存分配"},{"t":"list_item","d":7,"p":{"lines":[909,910]},"v":"jvm的永久代中会发生垃圾回收吗？"},{"t":"list_item","d":7,"p":{"lines":[910,911]},"v":"jvm内存分区，为什么要有新生代和老年代？"}]},{"t":"list_item","d":5,"p":{"lines":[912,913]},"v":"<strong>对象的实例化内存布局和访问定位</strong>","c":[{"t":"list_item","d":7,"p":{"lines":[913,914]},"v":"创建对象的方式"},{"t":"list_item","d":7,"p":{"lines":[914,915],"f":true},"v":"创建对象的步骤（六步） ","c":[{"t":"list_item","d":9,"p":{"lines":[915,916]},"v":"判断对象对应的类是否加载，链接，初始化。（加载类元信息）"},{"t":"list_item","d":9,"p":{"lines":[916,917]},"v":"为对象分配内存","c":[{"t":"list_item","d":11,"p":{"lines":[917,918]},"v":"指针碰撞","c":[{"t":"list_item","d":13,"p":{"lines":[918,919]},"v":"原理"},{"t":"list_item","d":13,"p":{"lines":[919,920]},"v":"对应算法"}]},{"t":"list_item","d":11,"p":{"lines":[920,921]},"v":"空闲列表分配","c":[{"t":"list_item","d":13,"p":{"lines":[921,922]},"v":"原理"},{"t":"list_item","d":13,"p":{"lines":[922,923]},"v":"对应算法"}]}]},{"t":"list_item","d":9,"p":{"lines":[923,924]},"v":"处理并发安全问题","c":[{"t":"list_item","d":11,"p":{"lines":[924,925]},"v":"CAS"},{"t":"list_item","d":11,"p":{"lines":[925,926]},"v":"TLAB"}]},{"t":"list_item","d":9,"p":{"lines":[926,927]},"v":"初始化分配到的空间"},{"t":"list_item","d":9,"p":{"lines":[927,928]},"v":"设置对象的对象头"},{"t":"list_item","d":9,"p":{"lines":[928,929]},"v":"执行init方法进行初始化","c":[{"t":"list_item","d":11,"p":{"lines":[929,930]},"v":"属性初始化方式","c":[{"t":"list_item","d":13,"p":{"lines":[930,931]},"v":"1.默认初始化"},{"t":"list_item","d":13,"p":{"lines":[931,932]},"v":"2.显式初始化"},{"t":"list_item","d":13,"p":{"lines":[932,933]},"v":"3.代码块中初始化"},{"t":"list_item","d":13,"p":{"lines":[933,934]},"v":"4.构造器中初始化"},{"t":"list_item","d":13,"p":{"lines":[934,935]},"v":"5.对象.属性 初始化"}]},{"t":"list_item","d":11,"p":{"lines":[935,936]},"v":"init中包括2,3,4"}]}]},{"t":"list_item","d":7,"p":{"lines":[936,937]},"v":"内部布局","c":[{"t":"list_item","d":9,"p":{"lines":[937,938]},"v":"对象头(下面3项都是一字宽)","c":[{"t":"list_item","d":11,"p":{"lines":[938,939]},"v":"Mark Word--存储对象的hashCode或锁信息等","c":[{"t":"list_item","d":13,"p":{"lines":[939,940]},"v":"不同锁状态内容不同"}]},{"t":"list_item","d":11,"p":{"lines":[940,941]},"v":"Class Metadata Address--存储到对象类型数据的指针"},{"t":"list_item","d":11,"p":{"lines":[941,942]},"v":"Array length--数组的长度（如果是数组）"}]},{"t":"list_item","d":9,"p":{"lines":[942,943]},"v":"实例数据"},{"t":"list_item","d":9,"p":{"lines":[943,944]},"v":"对齐填充:占位符"}]},{"t":"list_item","d":7,"p":{"lines":[944,945]},"v":"定位访问","c":[{"t":"list_item","d":9,"p":{"lines":[945,946]},"v":"句柄访问","c":[{"t":"list_item","d":11,"p":{"lines":[946,947]},"v":"说明"},{"t":"list_item","d":11,"p":{"lines":[947,948]},"v":"优点"},{"t":"list_item","d":11,"p":{"lines":[948,949]},"v":"缺点"}]},{"t":"list_item","d":9,"p":{"lines":[949,950]},"v":"直接指针","c":[{"t":"list_item","d":11,"p":{"lines":[950,951]},"v":"说明"},{"t":"list_item","d":11,"p":{"lines":[951,952]},"v":"优点"},{"t":"list_item","d":11,"p":{"lines":[952,953]},"v":"缺点"}]}]},{"t":"list_item","d":7,"p":{"lines":[953,954],"f":true},"v":"问题 ","c":[{"t":"list_item","d":9,"p":{"lines":[954,955]},"v":"对象在JVM中是怎么存储的？"},{"t":"list_item","d":9,"p":{"lines":[955,956]},"v":"对象头信息里面有哪些东西？"},{"t":"list_item","d":9,"p":{"lines":[956,957]},"v":"java对象头里有什么"}]}]},{"t":"list_item","d":5,"p":{"lines":[957,958]},"v":"直接内存"}]},{"t":"heading","d":3,"p":{"lines":[959,960]},"v":"下层","c":[{"t":"list_item","d":5,"p":{"lines":[961,962]},"v":"执行引擎","c":[{"t":"list_item","d":7,"p":{"lines":[962,963]},"v":"作用"},{"t":"list_item","d":7,"p":{"lines":[963,964]},"v":"相关概念","c":[{"t":"list_item","d":9,"p":{"lines":[964,965]},"v":"编译原理"},{"t":"list_item","d":9,"p":{"lines":[965,966]},"v":"机器码"},{"t":"list_item","d":9,"p":{"lines":[966,967]},"v":"指令"},{"t":"list_item","d":9,"p":{"lines":[967,968]},"v":"指令集"},{"t":"list_item","d":9,"p":{"lines":[968,969]},"v":"汇编"},{"t":"list_item","d":9,"p":{"lines":[969,970]},"v":"高级语言"}]},{"t":"list_item","d":7,"p":{"lines":[970,971]},"v":"编译器分类","c":[{"t":"list_item","d":9,"p":{"lines":[971,972]},"v":"前端编译器<br />java--&gt;.class"},{"t":"list_item","d":9,"p":{"lines":[972,973]},"v":"后端运行期编译器：JIT<br /> .class--&gt;机器码"},{"t":"list_item","d":9,"p":{"lines":[973,974]},"v":"静态提前编译器：AOT(Ahead of Time Compiler)编译器，<br /> .java--&gt;机器码"}]},{"t":"list_item","d":7,"p":{"lines":[974,975]},"v":"Java代码执行方式分类","c":[{"t":"list_item","d":9,"p":{"lines":[975,976]},"v":"种类","c":[{"t":"list_item","d":11,"p":{"lines":[976,977]},"v":"源代码编译成字节码文件，<br />然后在运行时通过解释器将字节码文件转为机器码执行"},{"t":"list_item","d":11,"p":{"lines":[977,978]},"v":"直接编译成机器码"}]},{"t":"list_item","d":9,"p":{"lines":[978,979]},"v":"HotSpot执行方式","c":[{"t":"list_item","d":11,"p":{"lines":[979,980]},"v":"<code>-Xint</code>:完全采用解释器模式执行程序；"},{"t":"list_item","d":11,"p":{"lines":[980,981]},"v":"<code>-Xcomp</code>:完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。"},{"t":"list_item","d":11,"p":{"lines":[981,982]},"v":"<code>-Xmixed</code>(默认):采用解释器+即时编译器的混合模式共同执行程序。"}]}]},{"t":"list_item","d":7,"p":{"lines":[982,983]},"v":"Java执行引擎组成","c":[{"t":"list_item","d":9,"p":{"lines":[983,984]},"v":"解释器","c":[{"t":"list_item","d":11,"p":{"lines":[984,985]},"v":"为什么java源码到机器语言中间要有个字节码"},{"t":"list_item","d":11,"p":{"lines":[985,986]},"v":"工作机制"},{"t":"list_item","d":11,"p":{"lines":[986,987]},"v":"种类","c":[{"t":"list_item","d":13,"p":{"lines":[987,988]},"v":"字节码解释器"},{"t":"list_item","d":13,"p":{"lines":[988,989]},"v":"模板解释器"}]}]},{"t":"list_item","d":9,"p":{"lines":[989,990]},"v":"即时编译器","c":[{"t":"list_item","d":11,"p":{"lines":[990,991]},"v":"工作机制"},{"t":"list_item","d":11,"p":{"lines":[991,992]},"v":"热点代码","c":[{"t":"list_item","d":13,"p":{"lines":[992,993]},"v":"概念"},{"t":"list_item","d":13,"p":{"lines":[993,994]},"v":"热点探测","c":[{"t":"list_item","d":15,"p":{"lines":[994,995]},"v":"方法调用计数器","c":[{"t":"list_item","d":17,"p":{"lines":[995,996]},"v":"工作机制"},{"t":"list_item","d":17,"p":{"lines":[996,997]},"v":"单位：方法"},{"t":"list_item","d":17,"p":{"lines":[997,998]},"v":"默认使用相对频率<br />关闭热度衰减使用绝对次数"},{"t":"list_item","d":17,"p":{"lines":[998,999]},"v":"阀值"},{"t":"list_item","d":17,"p":{"lines":[999,1000]},"v":"设置阀值<code>-XX:CompileThreshold</code>"},{"t":"list_item","d":17,"p":{"lines":[1000,1001]},"v":"执行逻辑"},{"t":"list_item","d":17,"p":{"lines":[1001,1002]},"v":"热度衰减","c":[{"t":"list_item","d":19,"p":{"lines":[1002,1003]},"v":"半衰期：<code>-XX:CounterHalfLifeTime</code>"},{"t":"list_item","d":19,"p":{"lines":[1003,1004]},"v":"关闭：<code>-XX:-UseCounterDecay</code>"}]}]},{"t":"list_item","d":15,"p":{"lines":[1004,1005]},"v":"回边计数器","c":[{"t":"list_item","d":17,"p":{"lines":[1005,1006]},"v":"工作机制"},{"t":"list_item","d":17,"p":{"lines":[1006,1007]},"v":"栈上替换(OSR)"}]}]}]},{"t":"list_item","d":11,"p":{"lines":[1007,1008]},"v":"Java内置JIT编译器","c":[{"t":"list_item","d":13,"p":{"lines":[1008,1009]},"v":"C1","c":[{"t":"list_item","d":15,"p":{"lines":[1009,1010]},"v":"client模式下运行"},{"t":"list_item","d":15,"p":{"lines":[1010,1011]},"v":"简单和可靠的优化，耗时短"},{"t":"list_item","d":15,"p":{"lines":[1011,1012],"f":true},"v":"优化策略 ","c":[{"t":"list_item","d":17,"p":{"lines":[1012,1013]},"v":"方法内联：将引用的函数代码编译到引用点处，<br />这样可以减少栈帧的生成，减少参数传递以及跳转过程"},{"t":"list_item","d":17,"p":{"lines":[1013,1014]},"v":"去虚拟化：对唯一的实现类进行内联"},{"t":"list_item","d":17,"p":{"lines":[1014,1015]},"v":"沉余消除：在运行期间把一些不会执行的代码折叠掉"}]}]},{"t":"list_item","d":13,"p":{"lines":[1015,1016]},"v":"C2","c":[{"t":"list_item","d":15,"p":{"lines":[1016,1017]},"v":"server模式下运行"},{"t":"list_item","d":15,"p":{"lines":[1017,1018]},"v":"耗时较长的优化，以及激进优化"},{"t":"list_item","d":15,"p":{"lines":[1018,1019],"f":true},"v":"优化策略 ","c":[{"t":"list_item","d":17,"p":{"lines":[1019,1020]},"v":"标量替换：用标量值代替聚合对象的属性值"},{"t":"list_item","d":17,"p":{"lines":[1020,1021]},"v":"栈上分配：对于未逃逸的对象分配对象在栈而不是堆"},{"t":"list_item","d":17,"p":{"lines":[1021,1022]},"v":"同步消除：清除同步操作，通常指synchronized"}]}]}]},{"t":"list_item","d":11,"p":{"lines":[1022,1023]},"v":"java中的实际优化策略：<a href=\"http://zhongmingmao.me/2019/01/02/jvm-advanced-jit/\">分层编译(1.7引入,1.8默认开启)</a>"}]}]},{"t":"list_item","d":7,"p":{"lines":[1023,1024]},"v":"其他编译器：","c":[{"t":"list_item","d":9,"p":{"lines":[1024,1025]},"v":"Graa1"},{"t":"list_item","d":9,"p":{"lines":[1025,1026]},"v":"AOT"}]}]},{"t":"list_item","d":5,"p":{"lines":[1027,1028]},"v":"String与StringTable(中间插曲)","c":[{"t":"list_item","d":7,"p":{"lines":[1028,1029]},"v":"创建String","c":[{"t":"list_item","d":9,"p":{"lines":[1029,1030]},"v":"字面量","c":[{"t":"list_item","d":11,"p":{"lines":[1030,1031]},"v":"一个对象"},{"t":"list_item","d":11,"p":{"lines":[1031,1032]},"v":"返回的索引指向"}]},{"t":"list_item","d":9,"p":{"lines":[1032,1033]},"v":"new","c":[{"t":"list_item","d":11,"p":{"lines":[1033,1034]},"v":"两个对象"},{"t":"list_item","d":11,"p":{"lines":[1034,1035]},"v":"返回的索引指向"}]},{"t":"list_item","d":9,"p":{"lines":[1035,1036]},"v":"<strong>StringBuilder和StringBuffer的toString</strong>"},{"t":"list_item","d":9,"p":{"lines":[1036,1037]},"v":"(本质同上)new String(&quot;a&quot;)+new String(&quot;b&quot;)"}]},{"t":"list_item","d":7,"p":{"lines":[1037,1038]},"v":"String的不可变性"},{"t":"list_item","d":7,"p":{"lines":[1038,1039]},"v":"String底层存储结构","c":[{"t":"list_item","d":9,"p":{"lines":[1039,1040]},"v":"jdk8:final char[]"},{"t":"list_item","d":9,"p":{"lines":[1040,1041]},"v":"jdk9:final byte[]"}]},{"t":"list_item","d":7,"p":{"lines":[1041,1042]},"v":"String Table相关","c":[{"t":"list_item","d":9,"p":{"lines":[1042,1043]},"v":"特点"},{"t":"list_item","d":9,"p":{"lines":[1043,1044]},"v":"长度","c":[{"t":"list_item","d":11,"p":{"lines":[1044,1045]},"v":"默认长度","c":[{"t":"list_item","d":13,"p":{"lines":[1045,1046]},"v":"jdk6"},{"t":"list_item","d":13,"p":{"lines":[1046,1047]},"v":"jdk7"},{"t":"list_item","d":13,"p":{"lines":[1047,1048]},"v":"jdk8"}]},{"t":"list_item","d":11,"p":{"lines":[1048,1049]},"v":"长度设置"}]},{"t":"list_item","d":9,"p":{"lines":[1049,1050]},"v":"内存分配变迁","c":[{"t":"list_item","d":11,"p":{"lines":[1050,1051]},"v":"jdk6"},{"t":"list_item","d":11,"p":{"lines":[1051,1052]},"v":"jdk7"},{"t":"list_item","d":11,"p":{"lines":[1052,1053]},"v":"jdk8"}]}]},{"t":"list_item","d":7,"p":{"lines":[1053,1054]},"v":"<strong>inter()的使用</strong>","c":[{"t":"list_item","d":9,"p":{"lines":[1054,1055]},"v":"1.7之前"},{"t":"list_item","d":9,"p":{"lines":[1055,1056]},"v":"1.7及之后"}]},{"t":"list_item","d":7,"p":{"lines":[1056,1057]},"v":"StringTable垃圾回收:<br />GC时也会对StringTable进行垃圾回收"},{"t":"list_item","d":7,"p":{"lines":[1057,1058]},"v":"G1中的String去重操作(了解)"},{"t":"list_item","d":7,"p":{"lines":[1058,1059]},"v":"<strong>面试题</strong>"}]},{"t":"list_item","d":5,"p":{"lines":[1060,1061]},"v":"垃圾回收器","c":[{"t":"list_item","d":7,"p":{"lines":[1061,1062]},"v":"整体概述"},{"t":"list_item","d":7,"p":{"lines":[1062,1063]},"v":"垃圾回收相关算法","c":[{"t":"list_item","d":9,"p":{"lines":[1063,1064]},"v":"标记阶段","c":[{"t":"list_item","d":11,"p":{"lines":[1064,1065]},"v":"说明"},{"t":"list_item","d":11,"p":{"lines":[1065,1066]},"v":"算法","c":[{"t":"list_item","d":13,"p":{"lines":[1066,1067]},"v":"引用计数算法"},{"t":"list_item","d":13,"p":{"lines":[1067,1068]},"v":"可达性分析算法"}]}]},{"t":"list_item","d":9,"p":{"lines":[1068,1069]},"v":"清除阶段","c":[{"t":"list_item","d":11,"p":{"lines":[1069,1070]},"v":"说明"},{"t":"list_item","d":11,"p":{"lines":[1070,1071]},"v":"算法","c":[{"t":"list_item","d":13,"p":{"lines":[1071,1072]},"v":"分代收集算法","c":[{"t":"list_item","d":15,"p":{"lines":[1072,1073]},"v":"标记一清除算法（Mark-Sweep)"},{"t":"list_item","d":15,"p":{"lines":[1073,1074]},"v":"复制算法（Copying)"},{"t":"list_item","d":15,"p":{"lines":[1074,1075]},"v":"标记-压缩算法（Mark-Compact )"}]},{"t":"list_item","d":13,"p":{"lines":[1075,1076]},"v":"增量收集算法"},{"t":"list_item","d":13,"p":{"lines":[1076,1077]},"v":"分区算法(G1)"}]}]},{"t":"list_item","d":9,"p":{"lines":[1077,1078]},"v":"对象的finalization机制"},{"t":"list_item","d":9,"p":{"lines":[1078,1079]},"v":"对象的三种状态"}]},{"t":"list_item","d":7,"p":{"lines":[1079,1080]},"v":"垃圾回收相关概念","c":[{"t":"list_item","d":9,"p":{"lines":[1080,1081]},"v":"<code>System.gc()</code>"},{"t":"list_item","d":9,"p":{"lines":[1081,1082]},"v":"内存溢出"},{"t":"list_item","d":9,"p":{"lines":[1082,1083]},"v":"内存泄漏"},{"t":"list_item","d":9,"p":{"lines":[1083,1084]},"v":"Stop the world"},{"t":"list_item","d":9,"p":{"lines":[1084,1085]},"v":"垃圾回收的串行，并发与并行"},{"t":"list_item","d":9,"p":{"lines":[1085,1086]},"v":"安全点与安全区域"},{"t":"list_item","d":9,"p":{"lines":[1086,1087]},"v":"<strong>java中的引用</strong>","c":[{"t":"list_item","d":11,"p":{"lines":[1087,1088]},"v":"强引用"},{"t":"list_item","d":11,"p":{"lines":[1088,1089]},"v":"软引用"},{"t":"list_item","d":11,"p":{"lines":[1089,1090]},"v":"弱引用"},{"t":"list_item","d":11,"p":{"lines":[1090,1091]},"v":"虚引用"},{"t":"list_item","d":11,"p":{"lines":[1091,1092]},"v":"<code>-------------------</code>"},{"t":"list_item","d":11,"p":{"lines":[1092,1093]},"v":"终结器引用"}]}]},{"t":"list_item","d":7,"p":{"lines":[1093,1094]},"v":"垃圾回收器","c":[{"t":"list_item","d":9,"p":{"lines":[1094,1095]},"v":"分类","c":[{"t":"list_item","d":11,"p":{"lines":[1095,1096]},"v":"按线程数","c":[{"t":"list_item","d":13,"p":{"lines":[1096,1097]},"v":"串行"},{"t":"list_item","d":13,"p":{"lines":[1097,1098]},"v":"并行"}]},{"t":"list_item","d":11,"p":{"lines":[1098,1099]},"v":"按工作模式","c":[{"t":"list_item","d":13,"p":{"lines":[1099,1100]},"v":"并发"},{"t":"list_item","d":13,"p":{"lines":[1100,1101]},"v":"独占"}]},{"t":"list_item","d":11,"p":{"lines":[1101,1102]},"v":"按碎片处理方式分","c":[{"t":"list_item","d":13,"p":{"lines":[1102,1103]},"v":"压缩整理"},{"t":"list_item","d":13,"p":{"lines":[1103,1104]},"v":"非压缩整理，空闲列表"}]},{"t":"list_item","d":11,"p":{"lines":[1104,1105]},"v":"按工作的区间分","c":[{"t":"list_item","d":13,"p":{"lines":[1105,1106]},"v":"新生代"},{"t":"list_item","d":13,"p":{"lines":[1106,1107]},"v":"老年代"},{"t":"list_item","d":13,"p":{"lines":[1107,1108]},"v":"混合"},{"t":"list_item","d":13,"p":{"lines":[1108,1109]},"v":"Full"}]}]},{"t":"list_item","d":9,"p":{"lines":[1109,1110]},"v":"性能指标","c":[{"t":"list_item","d":11,"p":{"lines":[1110,1111]},"v":"主要的三个：","c":[{"t":"list_item","d":13,"p":{"lines":[1111,1112]},"v":"<strong>吞吐量</strong>"},{"t":"list_item","d":13,"p":{"lines":[1112,1113]},"v":"垃圾收集开销"},{"t":"list_item","d":13,"p":{"lines":[1113,1114]},"v":"<strong>暂停时间</strong>"},{"t":"list_item","d":13,"p":{"lines":[1114,1115]},"v":"收集频率"},{"t":"list_item","d":13,"p":{"lines":[1115,1116]},"v":"<strong>内存占用</strong>"},{"t":"list_item","d":13,"p":{"lines":[1116,1117]},"v":"快速"}]},{"t":"list_item","d":11,"p":{"lines":[1117,1118]},"v":"吞吐量，暂停时间的相互限制"}]},{"t":"list_item","d":9,"p":{"lines":[1118,1119]},"v":"为什么要有多种垃圾回收器"},{"t":"list_item","d":9,"p":{"lines":[1119,1120]},"v":"7中经典垃圾回收器","c":[{"t":"list_item","d":11,"p":{"lines":[1120,1121]},"v":"时间顺序：","c":[{"t":"list_item","d":13,"p":{"lines":[1121,1122]},"v":"serial<br />parNew(是serial多线程版本)"},{"t":"list_item","d":13,"p":{"lines":[1122,1123]},"v":"Parallel<br />CMS"},{"t":"list_item","d":13,"p":{"lines":[1123,1124]},"v":"G1"}]},{"t":"list_item","d":11,"p":{"lines":[1124,1125]},"v":"<strong>组合关系</strong>"},{"t":"list_item","d":11,"p":{"lines":[1125,1126]},"v":"<strong>详细说明</strong> <br />","c":[{"t":"list_item","d":13,"p":{"lines":[1126,1127]},"v":"Serial","c":[{"t":"list_item","d":15,"p":{"lines":[1127,1128]},"v":"说明","c":[{"t":"list_item","d":17,"p":{"lines":[1128,1129]},"v":"分类"},{"t":"list_item","d":17,"p":{"lines":[1129,1130]},"v":"作用位置"},{"t":"list_item","d":17,"p":{"lines":[1130,1131]},"v":"使用算法"},{"t":"list_item","d":17,"p":{"lines":[1131,1132]},"v":"吞吐/响应 优先"},{"t":"list_item","d":17,"p":{"lines":[1132,1133]},"v":"适用场景"}]},{"t":"list_item","d":15,"p":{"lines":[1133,1134]},"v":"工作流程"}]},{"t":"list_item","d":13,"p":{"lines":[1134,1135]},"v":"Serial Old","c":[{"t":"list_item","d":15,"p":{"lines":[1135,1136]},"v":"说明","c":[{"t":"list_item","d":17,"p":{"lines":[1136,1137]},"v":"分类"},{"t":"list_item","d":17,"p":{"lines":[1137,1138]},"v":"作用位置"},{"t":"list_item","d":17,"p":{"lines":[1138,1139]},"v":"使用算法"},{"t":"list_item","d":17,"p":{"lines":[1139,1140]},"v":"吞吐/响应 优先"},{"t":"list_item","d":17,"p":{"lines":[1140,1141]},"v":"适用场景"}]},{"t":"list_item","d":15,"p":{"lines":[1141,1142]},"v":"工作流程"}]},{"t":"list_item","d":13,"p":{"lines":[1142,1143]},"v":"ParNew","c":[{"t":"list_item","d":15,"p":{"lines":[1143,1144]},"v":"说明","c":[{"t":"list_item","d":17,"p":{"lines":[1144,1145]},"v":"分类"},{"t":"list_item","d":17,"p":{"lines":[1145,1146]},"v":"作用位置"},{"t":"list_item","d":17,"p":{"lines":[1146,1147]},"v":"使用算法"},{"t":"list_item","d":17,"p":{"lines":[1147,1148]},"v":"吞吐/响应 优先"},{"t":"list_item","d":17,"p":{"lines":[1148,1149]},"v":"适用场景"}]},{"t":"list_item","d":15,"p":{"lines":[1149,1150]},"v":"工作流程"},{"t":"list_item","d":15,"p":{"lines":[1150,1151]},"v":"背景：Serial多线程版本"},{"t":"list_item","d":15,"p":{"lines":[1151,1152]},"v":"<code>单核/多核</code> <code>serial/parnew</code>"}]},{"t":"list_item","d":13,"p":{"lines":[1152,1153]},"v":"Parallel Scavenge","c":[{"t":"list_item","d":15,"p":{"lines":[1153,1154]},"v":"说明","c":[{"t":"list_item","d":17,"p":{"lines":[1154,1155]},"v":"分类"},{"t":"list_item","d":17,"p":{"lines":[1155,1156]},"v":"作用位置"},{"t":"list_item","d":17,"p":{"lines":[1156,1157]},"v":"使用算法"},{"t":"list_item","d":17,"p":{"lines":[1157,1158]},"v":"吞吐/响应 优先"},{"t":"list_item","d":17,"p":{"lines":[1158,1159]},"v":"适用场景"}]},{"t":"list_item","d":15,"p":{"lines":[1159,1160]},"v":"工作流程"},{"t":"list_item","d":15,"p":{"lines":[1160,1161]},"v":"与parNew区别"}]},{"t":"list_item","d":13,"p":{"lines":[1161,1162]},"v":"Parallel Old","c":[{"t":"list_item","d":15,"p":{"lines":[1162,1163]},"v":"说明","c":[{"t":"list_item","d":17,"p":{"lines":[1163,1164]},"v":"分类"},{"t":"list_item","d":17,"p":{"lines":[1164,1165]},"v":"作用位置"},{"t":"list_item","d":17,"p":{"lines":[1165,1166]},"v":"使用算法"},{"t":"list_item","d":17,"p":{"lines":[1166,1167]},"v":"吞吐/响应 优先"},{"t":"list_item","d":17,"p":{"lines":[1167,1168]},"v":"适用场景"}]},{"t":"list_item","d":15,"p":{"lines":[1168,1169]},"v":"工作流程"}]},{"t":"list_item","d":13,"p":{"lines":[1169,1170]},"v":"CMS","c":[{"t":"list_item","d":15,"p":{"lines":[1170,1171]},"v":"概述","c":[{"t":"list_item","d":17,"p":{"lines":[1171,1172]},"v":"分类"},{"t":"list_item","d":17,"p":{"lines":[1172,1173]},"v":"作用位置"},{"t":"list_item","d":17,"p":{"lines":[1173,1174]},"v":"使用算法"},{"t":"list_item","d":17,"p":{"lines":[1174,1175]},"v":"吞吐/响应 优先"},{"t":"list_item","d":17,"p":{"lines":[1175,1176]},"v":"适用场景"}]},{"t":"list_item","d":15,"p":{"lines":[1176,1177]},"v":"垃圾回收机制","c":[{"t":"list_item","d":17,"p":{"lines":[1177,1178]},"v":"回收时机：","c":[{"t":"list_item","d":19,"p":{"lines":[1178,1179]},"v":"<strong>达到阀值，而不是满了</strong>"}]},{"t":"list_item","d":17,"p":{"lines":[1179,1180],"f":true},"v":"回收流程 ","c":[{"t":"list_item","d":19,"p":{"lines":[1180,1181]},"v":"初始标记(STW):仅仅只是标记出GC Roots能直接关联到的对象。"},{"t":"list_item","d":19,"p":{"lines":[1181,1182]},"v":"并发标记(不STW):从GC Roots的直接关联对象开始遍历整个对象图的过程"},{"t":"list_item","d":19,"p":{"lines":[1182,1183]},"v":"重新标记(STW):为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录"},{"t":"list_item","d":19,"p":{"lines":[1183,1184]},"v":"并发清楚(不STW):此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间"}]},{"t":"list_item","d":17,"p":{"lines":[1184,1185]},"v":"后备方案","c":[{"t":"list_item","d":19,"p":{"lines":[1185,1186]},"v":"情况：比如大对象导致空间不足"},{"t":"list_item","d":19,"p":{"lines":[1186,1187]},"v":"错误：Concurrent Mode Failure"},{"t":"list_item","d":19,"p":{"lines":[1187,1188]},"v":"解决：serial old fullGC"}]}]},{"t":"list_item","d":15,"p":{"lines":[1188,1189],"f":true},"v":"搭配问题 ","c":[{"t":"list_item","d":17,"p":{"lines":[1189,1190]},"v":"无法与Parallel Old搭配"}]},{"t":"list_item","d":15,"p":{"lines":[1190,1191],"f":true},"v":"废弃原因 ","c":[{"t":"list_item","d":17,"p":{"lines":[1191,1192]},"v":"内存碎片，大对象无法分配"},{"t":"list_item","d":17,"p":{"lines":[1192,1193]},"v":"后备serial old效率过低"},{"t":"list_item","d":17,"p":{"lines":[1193,1194]},"v":"并发导致程序变慢"},{"t":"list_item","d":17,"p":{"lines":[1194,1195]},"v":"浮动垃圾无法处理"}]}]},{"t":"list_item","d":13,"p":{"lines":[1195,1196]},"v":"G1","c":[{"t":"list_item","d":15,"p":{"lines":[1196,1197]},"v":"概述","c":[{"t":"list_item","d":17,"p":{"lines":[1197,1198]},"v":"分类"},{"t":"list_item","d":17,"p":{"lines":[1198,1199]},"v":"作用位置"},{"t":"list_item","d":17,"p":{"lines":[1199,1200]},"v":"吞吐/响应 优先"},{"t":"list_item","d":17,"p":{"lines":[1200,1201],"f":true},"v":"使用算法 ","c":[{"t":"list_item","d":19,"p":{"lines":[1201,1202]},"v":"局部复制"},{"t":"list_item","d":19,"p":{"lines":[1202,1203]},"v":"整体标记压缩"}]},{"t":"list_item","d":17,"p":{"lines":[1203,1204]},"v":"适用场景"}]},{"t":"list_item","d":15,"p":{"lines":[1204,1205]},"v":"出现原因"},{"t":"list_item","d":15,"p":{"lines":[1205,1206],"f":true},"v":"缺点 ","c":[{"t":"list_item","d":17,"p":{"lines":[1206,1207]},"v":"额外内存占用:Remember Set"}]},{"t":"list_item","d":15,"p":{"lines":[1207,1208]},"v":"分区算法，分代收集","c":[{"t":"list_item","d":17,"p":{"lines":[1208,1209]},"v":"region组成"},{"t":"list_item","d":17,"p":{"lines":[1209,1210]},"v":"region角色变换"},{"t":"list_item","d":17,"p":{"lines":[1210,1211]},"v":"Humongous region"},{"t":"list_item","d":17,"p":{"lines":[1211,1212]},"v":"region分段(默认8)"}]},{"t":"list_item","d":15,"p":{"lines":[1212,1213]},"v":"参数调优"},{"t":"list_item","d":15,"p":{"lines":[1213,1214]},"v":"垃圾回收机制","c":[{"t":"list_item","d":17,"p":{"lines":[1214,1215]},"v":"预备知识","c":[{"t":"list_item","d":19,"p":{"lines":[1215,1216]},"v":"dirty card queue"},{"t":"list_item","d":19,"p":{"lines":[1216,1217]},"v":"Remember Set"}]},{"t":"list_item","d":17,"p":{"lines":[1217,1218]},"v":"回收种类","c":[{"t":"list_item","d":19,"p":{"lines":[1218,1219]},"v":"minorGC","c":[{"t":"list_item","d":21,"p":{"lines":[1219,1220]},"v":"触发"},{"t":"list_item","d":21,"p":{"lines":[1220,1221]},"v":"回收区域"},{"t":"list_item","d":21,"p":{"lines":[1221,1222],"f":true},"v":"详细过程 ","c":[{"t":"list_item","d":23,"p":{"lines":[1222,1223]},"v":"第一阶段，扫描根。"},{"t":"list_item","d":23,"p":{"lines":[1223,1224]},"v":"第二阶段，更新RSet。"},{"t":"list_item","d":23,"p":{"lines":[1224,1225]},"v":"第三阶段，处理RSet。"},{"t":"list_item","d":23,"p":{"lines":[1225,1226]},"v":"第四阶段，复制对象。"},{"t":"list_item","d":23,"p":{"lines":[1226,1227]},"v":"第五阶段，处理引用。"}]}]},{"t":"list_item","d":19,"p":{"lines":[1227,1228]},"v":"老年代并发标记过程","c":[{"t":"list_item","d":21,"p":{"lines":[1228,1229]},"v":"触发"},{"t":"list_item","d":21,"p":{"lines":[1229,1230]},"v":"回收区域"},{"t":"list_item","d":21,"p":{"lines":[1230,1231],"f":true},"v":"详细过程 ","c":[{"t":"list_item","d":23,"p":{"lines":[1231,1232]},"v":"1.初始标记阶段"},{"t":"list_item","d":23,"p":{"lines":[1232,1233]},"v":"2.根区域扫描（Root Region Scanning)"},{"t":"list_item","d":23,"p":{"lines":[1233,1234]},"v":"3.并发标记（Concurrent Marking)"},{"t":"list_item","d":23,"p":{"lines":[1234,1235]},"v":"4.再次标记（Remark)"},{"t":"list_item","d":23,"p":{"lines":[1235,1236]},"v":"5.独占清理（cleanup,STW)"},{"t":"list_item","d":23,"p":{"lines":[1236,1237]},"v":"6.并发清理阶段"}]},{"t":"list_item","d":21,"p":{"lines":[1237,1238],"f":true},"v":"回收结果 ","c":[{"t":"list_item","d":23,"p":{"lines":[1238,1239]},"v":"百分百为垃圾的内存分段被回收"},{"t":"list_item","d":23,"p":{"lines":[1239,1240]},"v":"部分为垃圾的内存分段被计算"}]}]},{"t":"list_item","d":19,"p":{"lines":[1240,1241]},"v":"mixedGC","c":[{"t":"list_item","d":21,"p":{"lines":[1241,1242]},"v":"触发"},{"t":"list_item","d":21,"p":{"lines":[1242,1243]},"v":"回收区域"},{"t":"list_item","d":21,"p":{"lines":[1243,1244]},"v":"<strong>可预测时间模型(重要)</strong>"}]},{"t":"list_item","d":19,"p":{"lines":[1244,1245]},"v":"full GC(失败保护)","c":[{"t":"list_item","d":21,"p":{"lines":[1245,1246]},"v":"触发"},{"t":"list_item","d":21,"p":{"lines":[1246,1247],"f":true},"v":"性能 ","c":[{"t":"list_item","d":23,"p":{"lines":[1247,1248]},"v":"单线程"},{"t":"list_item","d":23,"p":{"lines":[1248,1249]},"v":"独占式"},{"t":"list_item","d":23,"p":{"lines":[1249,1250]},"v":"高强度"},{"t":"list_item","d":23,"p":{"lines":[1250,1251]},"v":"总之很差"}]}]}]}]}]}]},{"t":"list_item","d":11,"p":{"lines":[1251,1252]},"v":"垃圾回收器的选择"}]}]},{"t":"list_item","d":7,"p":{"lines":[1253,1254],"f":true},"v":"问题 ","c":[{"t":"list_item","d":9,"p":{"lines":[1254,1255]},"v":"垃圾收集的算法有哪些？如何判断一个对象是否可以回收？"},{"t":"list_item","d":9,"p":{"lines":[1255,1256]},"v":"垃圾收集器工作的基本流程。"},{"t":"list_item","d":9,"p":{"lines":[1256,1257]},"v":"JVMGC算法有哪些，目前的JDK版本采用什么回收算法"},{"t":"list_item","d":9,"p":{"lines":[1257,1258]},"v":"G1回收器讲下回收过程"},{"t":"list_item","d":9,"p":{"lines":[1258,1259]},"v":"GC是什么？为什么要有GC?"},{"t":"list_item","d":9,"p":{"lines":[1259,1260]},"v":"GC的两种判定方法？CMS收集器与G1收集器的特点。"},{"t":"list_item","d":9,"p":{"lines":[1260,1261]},"v":"说一下GC算法，分代回收说下"},{"t":"list_item","d":9,"p":{"lines":[1261,1262]},"v":"垃圾收集策略和算法"},{"t":"list_item","d":9,"p":{"lines":[1262,1263]},"v":"jvm GC原理，JVM怎么回收内存"},{"t":"list_item","d":9,"p":{"lines":[1263,1264]},"v":"CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？"},{"t":"list_item","d":9,"p":{"lines":[1264,1265]},"v":"java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的"},{"t":"list_item","d":9,"p":{"lines":[1265,1266]},"v":"你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1,包括原理，流程，优缺点。"},{"t":"list_item","d":9,"p":{"lines":[1266,1267]},"v":"垃圾回收算法的实现原理。"},{"t":"list_item","d":9,"p":{"lines":[1267,1268]},"v":"讲一讲垃圾回收算法。"},{"t":"list_item","d":9,"p":{"lines":[1268,1269]},"v":"什么情况下触发垃圾回收？"},{"t":"list_item","d":9,"p":{"lines":[1269,1270]},"v":"如何选择合适的垃圾收集算法？"},{"t":"list_item","d":9,"p":{"lines":[1270,1271]},"v":"JVM有哪三种垃圾回收器？"},{"t":"list_item","d":9,"p":{"lines":[1271,1272]},"v":"常见的垃圾回收器算法有哪些，各有什么优劣？"},{"t":"list_item","d":9,"p":{"lines":[1272,1273]},"v":"system.gc()和runtime.gc()会做什么事情？"},{"t":"list_item","d":9,"p":{"lines":[1273,1274]},"v":"Java GC机制？GC Roots有哪些？"},{"t":"list_item","d":9,"p":{"lines":[1274,1275]},"v":"Java对象的回收方式，回收算法。"},{"t":"list_item","d":9,"p":{"lines":[1275,1276]},"v":"CMS和G1了解么，CMS解决什么问题，说一下回收的过程。"},{"t":"list_item","d":9,"p":{"lines":[1276,1277]},"v":"CMS回收停顿了几次，为什么要停顿两次。"}]}]}]}]},{"t":"heading","d":2,"p":{"lines":[1278,1279],"f":true},"v":"字节码与类加载子系统 "},{"t":"heading","d":2,"p":{"lines":[1280,1281],"f":true},"v":"jvm调优 "}]},{"t":"heading","d":1,"p":{"lines":[1282,1283]},"v":"常用框架","c":[{"t":"heading","d":2,"p":{"lines":[1284,1285],"f":true},"v":"Spring","c":[{"t":"heading","d":3,"p":{"lines":[1286,1287]},"v":"基础","c":[{"t":"list_item","d":5,"p":{"lines":[1288,1289]},"v":"什么是Spring框架"},{"t":"list_item","d":5,"p":{"lines":[1289,1290]},"v":"Spring框架的重要模块"},{"t":"list_item","d":5,"p":{"lines":[1290,1291]},"v":"为什么要使用Spring框架"},{"t":"list_item","d":5,"p":{"lines":[1291,1292]},"v":"Spring框架的两大核心","c":[{"t":"list_item","d":7,"p":{"lines":[1292,1293]},"v":"IOC"},{"t":"list_item","d":7,"p":{"lines":[1293,1294]},"v":"AOP"}]},{"t":"list_item","d":5,"p":{"lines":[1294,1295]},"v":"BeanFactory和ApplicationContextSpring"}]},{"t":"heading","d":3,"p":{"lines":[1296,1297]},"v":"IOC","c":[{"t":"list_item","d":5,"p":{"lines":[1298,1299]},"v":"概念"},{"t":"list_item","d":5,"p":{"lines":[1299,1300]},"v":"<a href=\"https://javadoop.com/post/spring-ioc\">IOC容器初始化过程</a>"},{"t":"list_item","d":5,"p":{"lines":[1301,1302]},"v":"基于xml的IOC","c":[{"t":"list_item","d":7,"p":{"lines":[1302,1303]},"v":"存入容器方式","c":[{"t":"list_item","d":9,"p":{"lines":[1303,1304]},"v":"Bean标签(各种属性可以进行配置)"}]},{"t":"list_item","d":7,"p":{"lines":[1304,1305]},"v":"依赖注入方式","c":[{"t":"list_item","d":9,"p":{"lines":[1305,1306]},"v":"注入Bean类型","c":[{"t":"list_item","d":11,"p":{"lines":[1306,1307]},"v":"使用构造函数(一般不用)"},{"t":"list_item","d":11,"p":{"lines":[1307,1308]},"v":"使用set方法(常用)"},{"t":"list_item","d":11,"p":{"lines":[1308,1309]},"v":"使用注解"}]},{"t":"list_item","d":9,"p":{"lines":[1309,1310]},"v":"注入基本类型和集合类型","c":[{"t":"list_item","d":11,"p":{"lines":[1310,1311]},"v":"通过xml"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[1312,1313]},"v":"基于注解的IOC","c":[{"t":"list_item","d":7,"p":{"lines":[1313,1314]},"v":"存入容器的注解","c":[{"t":"list_item","d":9,"p":{"lines":[1314,1315]},"v":"@Component"},{"t":"list_item","d":9,"p":{"lines":[1315,1316]},"v":"@Controller"},{"t":"list_item","d":9,"p":{"lines":[1316,1317]},"v":"@Service"},{"t":"list_item","d":9,"p":{"lines":[1317,1318]},"v":"@Repository"}]},{"t":"list_item","d":7,"p":{"lines":[1318,1319]},"v":"依赖注入的注解","c":[{"t":"list_item","d":9,"p":{"lines":[1319,1320]},"v":"注入Bean类型","c":[{"t":"list_item","d":11,"p":{"lines":[1320,1321]},"v":"@AutoWired"},{"t":"list_item","d":11,"p":{"lines":[1321,1322]},"v":"@Qualifier"},{"t":"list_item","d":11,"p":{"lines":[1322,1323]},"v":"@Reasource"}]},{"t":"list_item","d":9,"p":{"lines":[1323,1324]},"v":"注入基本类型","c":[{"t":"list_item","d":11,"p":{"lines":[1324,1325]},"v":"@Value"}]}]},{"t":"list_item","d":7,"p":{"lines":[1325,1326]},"v":"改变作用范围(和存入容器的注解搭配使用)","c":[{"t":"list_item","d":9,"p":{"lines":[1326,1327]},"v":"@Scope"}]},{"t":"list_item","d":7,"p":{"lines":[1327,1328]},"v":"生命周期相关注解","c":[{"t":"list_item","d":9,"p":{"lines":[1328,1329]},"v":"@PostConstruct"},{"t":"list_item","d":9,"p":{"lines":[1329,1330]},"v":"@PreDestroy"}]}]},{"t":"list_item","d":5,"p":{"lines":[1331,1332]},"v":"注意：对于无法添加注解<br />如导入的第三方依赖<br />可以通过xml将其存入或者向其注入<br />或者使用下面的<code>@Bean</code>"}]},{"t":"heading","d":3,"p":{"lines":[1333,1334]},"v":"摆脱xml的注解","c":[{"t":"list_item","d":5,"p":{"lines":[1335,1336]},"v":"@Configuration"},{"t":"list_item","d":5,"p":{"lines":[1336,1337]},"v":"@ComponentScan","c":[{"t":"list_item","d":7,"p":{"lines":[1337,1338]},"v":"对应<code>component:scan</code>"}]},{"t":"list_item","d":5,"p":{"lines":[1338,1339]},"v":"@Bean","c":[{"t":"list_item","d":7,"p":{"lines":[1339,1340]},"v":"对应xml中的工厂方法"},{"t":"list_item","d":7,"p":{"lines":[1340,1341]},"v":"通常配置在Config类<br />返回指定对象的上方"}]},{"t":"list_item","d":5,"p":{"lines":[1341,1342]},"v":"@Import"},{"t":"list_item","d":5,"p":{"lines":[1342,1343]},"v":"@PropertySource"}]},{"t":"heading","d":3,"p":{"lines":[1344,1345]},"v":"AOP","c":[{"t":"list_item","d":5,"p":{"lines":[1346,1347]},"v":"说明"},{"t":"list_item","d":5,"p":{"lines":[1347,1348]},"v":"相关概念","c":[{"t":"list_item","d":7,"p":{"lines":[1348,1349]},"v":"Joinpoint"},{"t":"list_item","d":7,"p":{"lines":[1349,1350]},"v":"Pointcut"},{"t":"list_item","d":7,"p":{"lines":[1350,1351]},"v":"Advice","c":[{"t":"list_item","d":9,"p":{"lines":[1351,1352]},"v":"前置通知"},{"t":"list_item","d":9,"p":{"lines":[1352,1353]},"v":"后置通知"},{"t":"list_item","d":9,"p":{"lines":[1353,1354]},"v":"异常通知"},{"t":"list_item","d":9,"p":{"lines":[1354,1355]},"v":"最终通知"},{"t":"list_item","d":9,"p":{"lines":[1355,1356]},"v":"环绕通知"}]},{"t":"list_item","d":7,"p":{"lines":[1356,1357]},"v":"Introduction"},{"t":"list_item","d":7,"p":{"lines":[1357,1358]},"v":"Target"},{"t":"list_item","d":7,"p":{"lines":[1358,1359]},"v":"Weaving"},{"t":"list_item","d":7,"p":{"lines":[1359,1360]},"v":"Proxy"},{"t":"list_item","d":7,"p":{"lines":[1360,1361]},"v":"Aspect"}]},{"t":"list_item","d":5,"p":{"lines":[1362,1363]},"v":"实现原理","c":[{"t":"list_item","d":7,"p":{"lines":[1363,1364]},"v":"静态代理AspectJ"},{"t":"list_item","d":7,"p":{"lines":[1364,1365]},"v":"动态代理","c":[{"t":"list_item","d":9,"p":{"lines":[1365,1366]},"v":"JDK"},{"t":"list_item","d":9,"p":{"lines":[1366,1367]},"v":"GBLib"},{"t":"list_item","d":9,"p":{"lines":[1367,1368]},"v":"两者对比"}]},{"t":"list_item","d":7,"p":{"lines":[1368,1369]},"v":"动态和静态对比"}]},{"t":"list_item","d":5,"p":{"lines":[1370,1371]},"v":"使用","c":[{"t":"list_item","d":7,"p":{"lines":[1371,1372]},"v":"xml","c":[{"t":"list_item","d":9,"p":{"lines":[1372,1373]},"v":"配置步骤"},{"t":"list_item","d":9,"p":{"lines":[1373,1374]},"v":"切入点表达式"}]},{"t":"list_item","d":7,"p":{"lines":[1374,1375]},"v":"注解","c":[{"t":"list_item","d":9,"p":{"lines":[1375,1376]},"v":"开启支持","c":[{"t":"list_item","d":11,"p":{"lines":[1376,1377]},"v":"xml：<code>aop:aspectj-autoproxy</code>"},{"t":"list_item","d":11,"p":{"lines":[1377,1378]},"v":"注解：<code>@EnableAspectJAutoProxy</code>"}]},{"t":"list_item","d":9,"p":{"lines":[1378,1379]},"v":"配置步骤"},{"t":"list_item","d":9,"p":{"lines":[1379,1380]},"v":"切入点表达式"}]}]}]},{"t":"heading","d":3,"p":{"lines":[1381,1382]},"v":"Bean","c":[{"t":"list_item","d":5,"p":{"lines":[1383,1384]},"v":"创建Bean的方式","c":[{"t":"list_item","d":7,"p":{"lines":[1384,1385]},"v":"默认构造函数"},{"t":"list_item","d":7,"p":{"lines":[1385,1386]},"v":"工厂类"},{"t":"list_item","d":7,"p":{"lines":[1386,1387]},"v":"静态工厂"}]},{"t":"list_item","d":5,"p":{"lines":[1388,1389]},"v":"Scope作用范围","c":[{"t":"list_item","d":7,"p":{"lines":[1389,1390]},"v":"singleton：单例的（默认值）"},{"t":"list_item","d":7,"p":{"lines":[1390,1391]},"v":"prototype：多例的"},{"t":"list_item","d":7,"p":{"lines":[1391,1392]},"v":"request：作用于web应用的请求范围"},{"t":"list_item","d":7,"p":{"lines":[1392,1393]},"v":"session：作用于web应用的会话范围"},{"t":"list_item","d":7,"p":{"lines":[1393,1394]},"v":"global-session：Spring5中已经没有了"}]},{"t":"list_item","d":5,"p":{"lines":[1395,1396]},"v":"生命周期"},{"t":"list_item","d":5,"p":{"lines":[1397,1398]},"v":"线程安全问题"}]},{"t":"heading","d":3,"p":{"lines":[1399,1400]},"v":"事务","c":[{"t":"list_item","d":5,"p":{"lines":[1401,1402]},"v":"Spring对事务的支持","c":[{"t":"list_item","d":7,"p":{"lines":[1402,1403]},"v":"取决于数据库"}]},{"t":"list_item","d":5,"p":{"lines":[1404,1405]},"v":"Spring事务相关API","c":[{"t":"list_item","d":7,"p":{"lines":[1405,1406]},"v":"PlatformTransactionManager"},{"t":"list_item","d":7,"p":{"lines":[1406,1407]},"v":"TransactionDefinition"},{"t":"list_item","d":7,"p":{"lines":[1407,1408]},"v":"TransactionStatus"}]},{"t":"list_item","d":5,"p":{"lines":[1409,1410]},"v":"事务管理方式","c":[{"t":"list_item","d":7,"p":{"lines":[1410,1411]},"v":"编程式（基本不用，仅仅为了了解原理）"},{"t":"list_item","d":7,"p":{"lines":[1411,1412]},"v":"声明式（基于AOP）","c":[{"t":"list_item","d":9,"p":{"lines":[1412,1413]},"v":"基于xml","c":[{"t":"list_item","d":11,"p":{"lines":[1413,1414]},"v":"配置流程"}]},{"t":"list_item","d":9,"p":{"lines":[1414,1415]},"v":"xml开启支持+注解配置","c":[{"t":"list_item","d":11,"p":{"lines":[1415,1416]},"v":"配置流程"}]},{"t":"list_item","d":9,"p":{"lines":[1416,1417]},"v":"纯注解配置","c":[{"t":"list_item","d":11,"p":{"lines":[1417,1418]},"v":"配置流程"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[1419,1420]},"v":"<strong>事务属性</strong><br />tx:advice标签内部可以配置<br />也可以使用注解配置","c":[{"t":"list_item","d":7,"p":{"lines":[1420,1421]},"v":"propagation(传播行为):(7)","c":[{"t":"list_item","d":9,"p":{"lines":[1421,1422]},"v":"支持当前事务的情况(3)","c":[{"t":"list_item","d":11,"p":{"lines":[1422,1423]},"v":"required(默认)"},{"t":"list_item","d":11,"p":{"lines":[1423,1424]},"v":"supports"},{"t":"list_item","d":11,"p":{"lines":[1424,1425]},"v":"mandatory"}]},{"t":"list_item","d":9,"p":{"lines":[1425,1426]},"v":"不支持当前事务的情况(3)","c":[{"t":"list_item","d":11,"p":{"lines":[1426,1427]},"v":"requires_new"},{"t":"list_item","d":11,"p":{"lines":[1427,1428]},"v":"not_supported"},{"t":"list_item","d":11,"p":{"lines":[1428,1429]},"v":"never"}]},{"t":"list_item","d":9,"p":{"lines":[1429,1430]},"v":"其他情况(1)","c":[{"t":"list_item","d":11,"p":{"lines":[1430,1431]},"v":"nested"}]}]},{"t":"list_item","d":7,"p":{"lines":[1431,1432]},"v":"isolation(隔离级别)(5)","c":[{"t":"list_item","d":9,"p":{"lines":[1432,1433]},"v":"default"},{"t":"list_item","d":9,"p":{"lines":[1433,1434]},"v":"read_uncommitted"},{"t":"list_item","d":9,"p":{"lines":[1434,1435]},"v":"read_committed"},{"t":"list_item","d":9,"p":{"lines":[1435,1436]},"v":"repeatable_read"},{"t":"list_item","d":9,"p":{"lines":[1436,1437]},"v":"serializable"}]},{"t":"list_item","d":7,"p":{"lines":[1437,1438]},"v":"timeout(超时属性)","c":[{"t":"list_item","d":9,"p":{"lines":[1438,1439]},"v":"用于指定事务的超时时间"},{"t":"list_item","d":9,"p":{"lines":[1439,1440]},"v":"默认值是-1"}]},{"t":"list_item","d":7,"p":{"lines":[1440,1441]},"v":"read-only(只读属性)","c":[{"t":"list_item","d":9,"p":{"lines":[1441,1442]},"v":"用于指定事务是否只读"},{"t":"list_item","d":9,"p":{"lines":[1442,1443]},"v":"默认false"}]},{"t":"list_item","d":7,"p":{"lines":[1443,1444]},"v":"回滚规则","c":[{"t":"list_item","d":9,"p":{"lines":[1444,1445]},"v":"rollback-for"},{"t":"list_item","d":9,"p":{"lines":[1445,1446]},"v":"no-rollback-for"}]}]}]},{"t":"heading","d":3,"p":{"lines":[1448,1449]},"v":"设计模式","c":[{"t":"list_item","d":5,"p":{"lines":[1450,1451]},"v":"工厂设计模式","c":[{"t":"list_item","d":7,"p":{"lines":[1451,1452]},"v":"BeanFactory"},{"t":"list_item","d":7,"p":{"lines":[1452,1453]},"v":"ApplicationContext"}]},{"t":"list_item","d":5,"p":{"lines":[1453,1454]},"v":"单例设计模式","c":[{"t":"list_item","d":7,"p":{"lines":[1454,1455]},"v":"bean默认作用域"},{"t":"list_item","d":7,"p":{"lines":[1455,1456]},"v":"实现：ConcurrentHashMap 实现单例注册表的特殊方式"}]},{"t":"list_item","d":5,"p":{"lines":[1456,1457]},"v":"代理设计模式","c":[{"t":"list_item","d":7,"p":{"lines":[1457,1458]},"v":"代理模式在 AOP 中的应用"},{"t":"list_item","d":7,"p":{"lines":[1458,1459]},"v":"代理模式的实现","c":[{"t":"list_item","d":9,"p":{"lines":[1459,1460]},"v":"静态代理AspectJ"},{"t":"list_item","d":9,"p":{"lines":[1460,1461]},"v":"动态代理","c":[{"t":"list_item","d":11,"p":{"lines":[1461,1462]},"v":"JDK"},{"t":"list_item","d":11,"p":{"lines":[1462,1463]},"v":"GBLib"},{"t":"list_item","d":11,"p":{"lines":[1463,1464]},"v":"两者对比"}]},{"t":"list_item","d":9,"p":{"lines":[1464,1465]},"v":"动态和静态对比"}]}]},{"t":"list_item","d":5,"p":{"lines":[1465,1466]},"v":"模板方法","c":[{"t":"list_item","d":7,"p":{"lines":[1466,1467]},"v":"jdbcTemplate"},{"t":"list_item","d":7,"p":{"lines":[1467,1468]},"v":"hibernateTemplate"},{"t":"list_item","d":7,"p":{"lines":[1468,1469]},"v":"RedisTemplate"}]},{"t":"list_item","d":5,"p":{"lines":[1469,1470]},"v":"观察者模式","c":[{"t":"list_item","d":7,"p":{"lines":[1470,1471]},"v":"Spring 事件驱动模型中的三种角色","c":[{"t":"list_item","d":9,"p":{"lines":[1471,1472]},"v":"事件角色"},{"t":"list_item","d":9,"p":{"lines":[1472,1473]},"v":"事件监听者角色"},{"t":"list_item","d":9,"p":{"lines":[1473,1474]},"v":"事件发布者角色"}]},{"t":"list_item","d":7,"p":{"lines":[1474,1475]},"v":"Spring 的事件流程总结"}]},{"t":"list_item","d":5,"p":{"lines":[1475,1476]},"v":"适配器模式","c":[{"t":"list_item","d":7,"p":{"lines":[1476,1477]},"v":"spring AOP中的适配器模式"},{"t":"list_item","d":7,"p":{"lines":[1477,1478]},"v":"spring MVC中的适配器模式"}]},{"t":"list_item","d":5,"p":{"lines":[1478,1479]},"v":"装饰者模式"}]}]},{"t":"heading","d":2,"p":{"lines":[1480,1481],"f":true},"v":"SpringMVC "},{"t":"heading","d":2,"p":{"lines":[1482,1483],"f":true},"v":"SpringBoot "},{"t":"heading","d":2,"p":{"lines":[1484,1485],"f":true},"v":"Mybatis ","c":[{"t":"bullet_list","d":3,"p":{"lines":[1486,1528]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[1486,1487]},"v":"基本使用","c":[{"t":"list_item","d":6,"p":{"lines":[1487,1488]},"v":"xml","c":[{"t":"list_item","d":8,"p":{"lines":[1488,1489]},"v":"常见标签","c":[{"t":"list_item","d":10,"p":{"lines":[1489,1490]},"v":"select"},{"t":"list_item","d":10,"p":{"lines":[1490,1491]},"v":"insert","c":[{"t":"list_item","d":12,"p":{"lines":[1491,1492]},"v":"selectKey(获取插入数据的主键)"}]},{"t":"list_item","d":10,"p":{"lines":[1492,1493]},"v":"update"},{"t":"list_item","d":10,"p":{"lines":[1493,1494]},"v":"delete"}]},{"t":"list_item","d":8,"p":{"lines":[1494,1495]},"v":"配置标签","c":[{"t":"list_item","d":10,"p":{"lines":[1495,1496]},"v":"typeAliases","c":[{"t":"list_item","d":12,"p":{"lines":[1496,1497]},"v":"package<br />(指定<strong>实体类</strong>包，用于起别名)"}]},{"t":"list_item","d":10,"p":{"lines":[1497,1498]},"v":"mapper","c":[{"t":"list_item","d":12,"p":{"lines":[1498,1499]},"v":"package<br />(指定<strong>dao类</strong>包，避免往SqlConfig文件中的<br />mappers中添加mapper标签)"}]}]},{"t":"list_item","d":8,"p":{"lines":[1499,1500]},"v":"其他标签","c":[{"t":"list_item","d":10,"p":{"lines":[1500,1501]},"v":"resultMap"},{"t":"list_item","d":10,"p":{"lines":[1501,1502]},"v":"parameterMap"},{"t":"list_item","d":10,"p":{"lines":[1502,1503]},"v":"include"},{"t":"list_item","d":10,"p":{"lines":[1503,1504]},"v":"sql"},{"t":"list_item","d":10,"p":{"lines":[1504,1505]},"v":"selectKey"}]},{"t":"list_item","d":8,"p":{"lines":[1505,1506]},"v":"动态sql标签","c":[{"t":"list_item","d":10,"p":{"lines":[1506,1507]},"v":"trim"},{"t":"list_item","d":10,"p":{"lines":[1507,1508]},"v":"where"},{"t":"list_item","d":10,"p":{"lines":[1508,1509]},"v":"set"},{"t":"list_item","d":10,"p":{"lines":[1509,1510]},"v":"foreach"},{"t":"list_item","d":10,"p":{"lines":[1510,1511]},"v":"if"},{"t":"list_item","d":10,"p":{"lines":[1511,1512]},"v":"choose"},{"t":"list_item","d":10,"p":{"lines":[1512,1513]},"v":"when"},{"t":"list_item","d":10,"p":{"lines":[1513,1514]},"v":"otherwise"},{"t":"list_item","d":10,"p":{"lines":[1514,1515]},"v":"bind"},{"t":"list_item","d":10,"p":{"lines":[1515,1516]},"v":"include","c":[{"t":"list_item","d":12,"p":{"lines":[1516,1517]},"v":"搭配<code>sql</code>标签"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[1517,1518]},"v":"注解","c":[{"t":"list_item","d":8,"p":{"lines":[1518,1519]},"v":"常见标签","c":[{"t":"list_item","d":10,"p":{"lines":[1519,1520]},"v":"@Select"},{"t":"list_item","d":10,"p":{"lines":[1520,1521]},"v":"@Insert"},{"t":"list_item","d":10,"p":{"lines":[1521,1522]},"v":"@Update"},{"t":"list_item","d":10,"p":{"lines":[1522,1523]},"v":"@Delete"}]},{"t":"list_item","d":8,"p":{"lines":[1523,1524]},"v":"其他标签","c":[{"t":"list_item","d":10,"p":{"lines":[1524,1525]},"v":"@Results","c":[{"t":"list_item","d":12,"p":{"lines":[1525,1526]},"v":"定义并使用"}]},{"t":"list_item","d":10,"p":{"lines":[1526,1527]},"v":"@ResultMap","c":[{"t":"list_item","d":12,"p":{"lines":[1527,1528]},"v":"使用已定义的"}]}]}]}]}]},{"t":"bullet_list","d":3,"p":{"lines":[1530,1565]},"v":"","c":[{"t":"list_item","d":4,"p":{"lines":[1530,1531]},"v":"<strong>执行流程</strong>"},{"t":"list_item","d":4,"p":{"lines":[1532,1533]},"v":"动态sql"},{"t":"list_item","d":4,"p":{"lines":[1534,1535]},"v":"多表查询","c":[{"t":"list_item","d":6,"p":{"lines":[1535,1536]},"v":"一对一(多对一)"},{"t":"list_item","d":6,"p":{"lines":[1536,1537]},"v":"一对多"},{"t":"list_item","d":6,"p":{"lines":[1537,1538]},"v":"多对多"}]},{"t":"list_item","d":4,"p":{"lines":[1539,1540]},"v":"加载","c":[{"t":"list_item","d":6,"p":{"lines":[1540,1541]},"v":"立即加载","c":[{"t":"list_item","d":8,"p":{"lines":[1541,1542]},"v":"使用场景"},{"t":"list_item","d":8,"p":{"lines":[1542,1543]},"v":"说明"}]},{"t":"list_item","d":6,"p":{"lines":[1543,1544]},"v":"延迟加载","c":[{"t":"list_item","d":8,"p":{"lines":[1544,1545]},"v":"使用场景"},{"t":"list_item","d":8,"p":{"lines":[1545,1546]},"v":"说明"},{"t":"list_item","d":8,"p":{"lines":[1546,1547]},"v":"配置"}]}]},{"t":"list_item","d":4,"p":{"lines":[1547,1548]},"v":"缓存","c":[{"t":"list_item","d":6,"p":{"lines":[1548,1549]},"v":"说明"},{"t":"list_item","d":6,"p":{"lines":[1549,1550]},"v":"种类","c":[{"t":"list_item","d":8,"p":{"lines":[1550,1551]},"v":"一级缓存","c":[{"t":"list_item","d":10,"p":{"lines":[1551,1552]},"v":"概念"},{"t":"list_item","d":10,"p":{"lines":[1552,1553]},"v":"触发"}]},{"t":"list_item","d":8,"p":{"lines":[1553,1554]},"v":"二级缓存","c":[{"t":"list_item","d":10,"p":{"lines":[1554,1555]},"v":"概念"},{"t":"list_item","d":10,"p":{"lines":[1555,1556]},"v":"配置开启","c":[{"t":"list_item","d":12,"p":{"lines":[1556,1557]},"v":"xml","c":[{"t":"list_item","d":14,"p":{"lines":[1557,1558]},"v":"config.xml"},{"t":"list_item","d":14,"p":{"lines":[1558,1559]},"v":"dao.xml"},{"t":"list_item","d":14,"p":{"lines":[1559,1560]},"v":"<code>&lt;select&gt;</code>"}]},{"t":"list_item","d":12,"p":{"lines":[1560,1561]},"v":"注解","c":[{"t":"list_item","d":14,"p":{"lines":[1561,1562]},"v":"SqlMapConfig.xml"},{"t":"list_item","d":14,"p":{"lines":[1562,1563]},"v":"@CacheNamespace(blocking=true)"}]}]},{"t":"list_item","d":10,"p":{"lines":[1563,1564]},"v":"触发"}]}]}]}]}]},{"t":"heading","d":2,"p":{"lines":[1565,1566],"f":true},"v":"Netty "},{"t":"heading","d":2,"p":{"lines":[1567,1568],"f":true},"v":"quartz "}]},{"t":"heading","d":1,"p":{"lines":[1569,1570]},"v":"数据库","c":[{"t":"heading","d":2,"p":{"lines":[1571,1572]},"v":"关系型数据库","c":[{"t":"heading","d":3,"p":{"lines":[1573,1574],"f":true},"v":"Mysql","c":[{"t":"heading","d":4,"p":{"lines":[1575,1576]},"v":"<a href=\"https://blog.csdn.net/weixin_43649997/article/details/105835007\">三大范式</a>","c":[{"t":"list_item","d":6,"p":{"lines":[1577,1578]},"v":"第一范式"},{"t":"list_item","d":6,"p":{"lines":[1578,1579]},"v":"第二范式"},{"t":"list_item","d":6,"p":{"lines":[1579,1580]},"v":"第三范式"}]},{"t":"heading","d":4,"p":{"lines":[1581,1582]},"v":"事务","c":[{"t":"list_item","d":6,"p":{"lines":[1583,1584]},"v":"四大特征","c":[{"t":"list_item","d":8,"p":{"lines":[1584,1585]},"v":"A原子性","c":[{"t":"list_item","d":10,"p":{"lines":[1585,1586]},"v":"概述"},{"t":"list_item","d":10,"p":{"lines":[1586,1587]},"v":"原理","c":[{"t":"list_item","d":12,"p":{"lines":[1587,1588]},"v":"undo log"},{"t":"list_item","d":12,"p":{"lines":[1588,1589]},"v":"回滚"}]}]},{"t":"list_item","d":8,"p":{"lines":[1589,1590]},"v":"C持久性","c":[{"t":"list_item","d":10,"p":{"lines":[1590,1591]},"v":"概述"},{"t":"list_item","d":10,"p":{"lines":[1591,1592]},"v":"原理:其他三个"}]},{"t":"list_item","d":8,"p":{"lines":[1592,1593]},"v":"I隔离性","c":[{"t":"list_item","d":10,"p":{"lines":[1593,1594]},"v":"概述"},{"t":"list_item","d":10,"p":{"lines":[1594,1595]},"v":"原理","c":[{"t":"list_item","d":12,"p":{"lines":[1595,1596]},"v":"MVCC"},{"t":"list_item","d":12,"p":{"lines":[1596,1597]},"v":"锁"}]}]},{"t":"list_item","d":8,"p":{"lines":[1597,1598]},"v":"D一致性","c":[{"t":"list_item","d":10,"p":{"lines":[1598,1599]},"v":"概述"},{"t":"list_item","d":10,"p":{"lines":[1599,1600]},"v":"原理(双写缓冲)","c":[{"t":"list_item","d":12,"p":{"lines":[1600,1601]},"v":"buffer pool"},{"t":"list_item","d":12,"p":{"lines":[1601,1602]},"v":"redo log"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[1603,1604]},"v":"并发事务的问题","c":[{"t":"list_item","d":8,"p":{"lines":[1604,1605]},"v":"脏读"},{"t":"list_item","d":8,"p":{"lines":[1605,1606]},"v":"不可重复读（虚读）"},{"t":"list_item","d":8,"p":{"lines":[1606,1607]},"v":"幻读"}]},{"t":"list_item","d":6,"p":{"lines":[1608,1609]},"v":"隔离级别","c":[{"t":"list_item","d":8,"p":{"lines":[1609,1610]},"v":"read uncommitted:","c":[{"t":"list_item","d":10,"p":{"lines":[1610,1611]},"v":"说明"},{"t":"list_item","d":10,"p":{"lines":[1611,1612]},"v":"产生问题"}]},{"t":"list_item","d":8,"p":{"lines":[1612,1613]},"v":"read committed:","c":[{"t":"list_item","d":10,"p":{"lines":[1613,1614]},"v":"说明"},{"t":"list_item","d":10,"p":{"lines":[1614,1615]},"v":"产生问题"}]},{"t":"list_item","d":8,"p":{"lines":[1615,1616]},"v":"repeatalbe read:","c":[{"t":"list_item","d":10,"p":{"lines":[1616,1617]},"v":"说明"},{"t":"list_item","d":10,"p":{"lines":[1617,1618]},"v":"产生问题"}]},{"t":"list_item","d":8,"p":{"lines":[1618,1619]},"v":"serializable","c":[{"t":"list_item","d":10,"p":{"lines":[1619,1620]},"v":"说明"},{"t":"list_item","d":10,"p":{"lines":[1620,1621]},"v":"可以解决所有问题"}]}]}]},{"t":"heading","d":4,"p":{"lines":[1622,1623]},"v":"索引","c":[{"t":"list_item","d":6,"p":{"lines":[1624,1625]},"v":"概述","c":[{"t":"list_item","d":8,"p":{"lines":[1625,1626]},"v":"索引是什么"},{"t":"list_item","d":8,"p":{"lines":[1626,1627],"f":true},"v":"什么时候需要建索引 ","c":[{"t":"list_item","d":10,"p":{"lines":[1627,1628]},"v":"不修改"},{"t":"list_item","d":10,"p":{"lines":[1628,1629]},"v":"经常作为条件查询，排序，分组"},{"t":"list_item","d":10,"p":{"lines":[1629,1630]},"v":"外键"}]},{"t":"list_item","d":8,"p":{"lines":[1630,1631],"f":true},"v":"什么时候不要建索引 ","c":[{"t":"list_item","d":10,"p":{"lines":[1631,1632]},"v":"用不到"},{"t":"list_item","d":10,"p":{"lines":[1632,1633]},"v":"记录少"},{"t":"list_item","d":10,"p":{"lines":[1633,1634]},"v":"频繁更新"},{"t":"list_item","d":10,"p":{"lines":[1634,1635]},"v":"经常增删"},{"t":"list_item","d":10,"p":{"lines":[1635,1636]},"v":"数据重复且分布平均的表字段"}]},{"t":"list_item","d":8,"p":{"lines":[1636,1637],"f":true},"v":"什么时候创建复合索引 ","c":[{"t":"list_item","d":10,"p":{"lines":[1637,1638]},"v":"用得到"},{"t":"list_item","d":10,"p":{"lines":[1638,1639]},"v":"高并发"},{"t":"list_item","d":10,"p":{"lines":[1639,1640]},"v":"一个索引当几个用"}]},{"t":"list_item","d":8,"p":{"lines":[1640,1641]},"v":"索引优点","c":[{"t":"list_item","d":10,"p":{"lines":[1641,1642]},"v":"查询速度"},{"t":"list_item","d":10,"p":{"lines":[1642,1643]},"v":"优化使用(MRR,ICP)"},{"t":"list_item","d":10,"p":{"lines":[1643,1644]},"v":"创建维护消耗"},{"t":"list_item","d":10,"p":{"lines":[1644,1645]},"v":"磁盘占用"}]}]},{"t":"list_item","d":6,"p":{"lines":[1646,1647]},"v":"索引分类","c":[{"t":"list_item","d":8,"p":{"lines":[1647,1648]},"v":"按属性/作用分类","c":[{"t":"list_item","d":10,"p":{"lines":[1648,1649]},"v":"普通索引"},{"t":"list_item","d":10,"p":{"lines":[1649,1650]},"v":"唯一索引"},{"t":"list_item","d":10,"p":{"lines":[1650,1651]},"v":"主键索引"},{"t":"list_item","d":10,"p":{"lines":[1651,1652]},"v":"复合索引"},{"t":"list_item","d":10,"p":{"lines":[1652,1653]},"v":"全文索引"}]},{"t":"list_item","d":8,"p":{"lines":[1653,1654]},"v":"按引擎分类","c":[{"t":"list_item","d":10,"p":{"lines":[1654,1655]},"v":"B+"},{"t":"list_item","d":10,"p":{"lines":[1655,1656]},"v":"Hash"},{"t":"list_item","d":10,"p":{"lines":[1656,1657]},"v":"全文"},{"t":"list_item","d":10,"p":{"lines":[1657,1658]},"v":"R-Tree"}]},{"t":"list_item","d":8,"p":{"lines":[1658,1659]},"v":"按是否聚簇分类","c":[{"t":"list_item","d":10,"p":{"lines":[1659,1660]},"v":"聚簇索引"},{"t":"list_item","d":10,"p":{"lines":[1660,1661]},"v":"二级索引"}]}]},{"t":"list_item","d":6,"p":{"lines":[1662,1663]},"v":"索引语法","c":[{"t":"list_item","d":8,"p":{"lines":[1663,1664]},"v":"创建"},{"t":"list_item","d":8,"p":{"lines":[1664,1665]},"v":"删除"},{"t":"list_item","d":8,"p":{"lines":[1665,1666]},"v":"查看"}]},{"t":"list_item","d":6,"p":{"lines":[1667,1668]},"v":"索引添加与Cardinality","c":[{"t":"list_item","d":8,"p":{"lines":[1668,1669]},"v":"fast index creation"},{"t":"list_item","d":8,"p":{"lines":[1669,1670]},"v":"Cardinality"}]}]},{"t":"heading","d":4,"p":{"lines":[1671,1672]},"v":"存储引擎","c":[{"t":"list_item","d":6,"p":{"lines":[1673,1674]},"v":"MyISAM","c":[{"t":"list_item","d":8,"p":{"lines":[1674,1675]},"v":"索引树结构"},{"t":"list_item","d":8,"p":{"lines":[1675,1676]},"v":"聚簇索引的选择"},{"t":"list_item","d":8,"p":{"lines":[1676,1677]},"v":"二级索引检索过程"}]},{"t":"list_item","d":6,"p":{"lines":[1677,1678]},"v":"Innodb","c":[{"t":"list_item","d":8,"p":{"lines":[1678,1679]},"v":"索引树结构"},{"t":"list_item","d":8,"p":{"lines":[1679,1680]},"v":"二级索引检索过程"}]},{"t":"list_item","d":6,"p":{"lines":[1680,1681]},"v":"常见问题","c":[{"t":"list_item","d":8,"p":{"lines":[1681,1682],"f":true},"v":"M和I两者区别 ","c":[{"t":"list_item","d":10,"p":{"lines":[1682,1683]},"v":"事务"},{"t":"list_item","d":10,"p":{"lines":[1683,1684]},"v":"主键"},{"t":"list_item","d":10,"p":{"lines":[1684,1685]},"v":"外键"},{"t":"list_item","d":10,"p":{"lines":[1685,1686]},"v":"锁"},{"t":"list_item","d":10,"p":{"lines":[1686,1687]},"v":"索引"},{"t":"list_item","d":10,"p":{"lines":[1687,1688]},"v":"count(*)"}]},{"t":"list_item","d":8,"p":{"lines":[1688,1689]},"v":"为什么使用B+树，不使用：","c":[{"t":"list_item","d":10,"p":{"lines":[1689,1690]},"v":"B树"},{"t":"list_item","d":10,"p":{"lines":[1690,1691]},"v":"红黑树"}]}]}]},{"t":"heading","d":4,"p":{"lines":[1692,1693]},"v":"调优","c":[{"t":"list_item","d":6,"p":{"lines":[1694,1695]},"v":"explain使用与分析","c":[{"t":"list_item","d":8,"p":{"lines":[1695,1696]},"v":"<strong>id</strong>"},{"t":"list_item","d":8,"p":{"lines":[1696,1697]},"v":"select_type"},{"t":"list_item","d":8,"p":{"lines":[1697,1698]},"v":"table"},{"t":"list_item","d":8,"p":{"lines":[1698,1699]},"v":"<strong>type</strong>"},{"t":"list_item","d":8,"p":{"lines":[1699,1700]},"v":"possible_keys"},{"t":"list_item","d":8,"p":{"lines":[1700,1701]},"v":"<strong>key</strong>"},{"t":"list_item","d":8,"p":{"lines":[1701,1702]},"v":"<strong>key_len</strong>"},{"t":"list_item","d":8,"p":{"lines":[1702,1703]},"v":"<strong>ref</strong>"},{"t":"list_item","d":8,"p":{"lines":[1703,1704]},"v":"<strong>rows</strong>"},{"t":"list_item","d":8,"p":{"lines":[1704,1705]},"v":"<strong>extra</strong>","c":[{"t":"list_item","d":10,"p":{"lines":[1705,1706]},"v":"using filesort(危险)"},{"t":"list_item","d":10,"p":{"lines":[1706,1707]},"v":"using temporary(非常危险)"},{"t":"list_item","d":10,"p":{"lines":[1707,1708]},"v":"using index"},{"t":"list_item","d":10,"p":{"lines":[1708,1709]},"v":"using where"},{"t":"list_item","d":10,"p":{"lines":[1709,1710]},"v":"using join buffer"},{"t":"list_item","d":10,"p":{"lines":[1710,1711]},"v":"impossible where"}]}]},{"t":"list_item","d":6,"p":{"lines":[1712,1713]},"v":"最左前缀原则"},{"t":"list_item","d":6,"p":{"lines":[1714,1715]},"v":"索引失效原因","c":[{"t":"list_item","d":8,"p":{"lines":[1715,1716]},"v":"不遵循最左前缀"},{"t":"list_item","d":8,"p":{"lines":[1716,1717]},"v":"索引列上的任何操作","c":[{"t":"list_item","d":10,"p":{"lines":[1717,1718]},"v":"计算"},{"t":"list_item","d":10,"p":{"lines":[1718,1719]},"v":"函数"},{"t":"list_item","d":10,"p":{"lines":[1719,1720]},"v":"（自动or手动）类型转换"}]},{"t":"list_item","d":8,"p":{"lines":[1720,1721]},"v":"范围查询","c":[{"t":"list_item","d":10,"p":{"lines":[1721,1722]},"v":"<code>between and;in</code>"},{"t":"list_item","d":10,"p":{"lines":[1722,1723]},"v":"<code>or</code>"},{"t":"list_item","d":10,"p":{"lines":[1723,1724]},"v":"<code>%...</code>(覆盖索引有奇效)"},{"t":"list_item","d":10,"p":{"lines":[1724,1725]},"v":"<code>is null;is not null</code>"},{"t":"list_item","d":10,"p":{"lines":[1725,1726]},"v":"<code>!=;&lt;&gt;</code>"}]}]},{"t":"list_item","d":6,"p":{"lines":[1727,1728]},"v":"小标驱动大表","c":[{"t":"list_item","d":8,"p":{"lines":[1728,1729]},"v":"左表驱动右表","c":[{"t":"list_item","d":10,"p":{"lines":[1729,1730]},"v":"left join"},{"t":"list_item","d":10,"p":{"lines":[1730,1731]},"v":"exist"}]},{"t":"list_item","d":8,"p":{"lines":[1731,1732]},"v":"右表驱动左表","c":[{"t":"list_item","d":10,"p":{"lines":[1732,1733]},"v":"right join"},{"t":"list_item","d":10,"p":{"lines":[1733,1734]},"v":"in"}]}]},{"t":"list_item","d":6,"p":{"lines":[1735,1736]},"v":"排序优化","c":[{"t":"list_item","d":8,"p":{"lines":[1736,1737]},"v":"mysql排序方式","c":[{"t":"list_item","d":10,"p":{"lines":[1737,1738]},"v":"index sort"},{"t":"list_item","d":10,"p":{"lines":[1738,1739]},"v":"file sort","c":[{"t":"list_item","d":12,"p":{"lines":[1739,1740]},"v":"单路","c":[{"t":"list_item","d":14,"p":{"lines":[1740,1741]},"v":"io次数:2"},{"t":"list_item","d":14,"p":{"lines":[1741,1742]},"v":"第二次随机io"}]},{"t":"list_item","d":12,"p":{"lines":[1742,1743]},"v":"双路","c":[{"t":"list_item","d":14,"p":{"lines":[1743,1744]},"v":"io次数:1"},{"t":"list_item","d":14,"p":{"lines":[1744,1745]},"v":"一次顺序io"},{"t":"list_item","d":14,"p":{"lines":[1745,1746]},"v":"buffer不够：多次io"}]},{"t":"list_item","d":12,"p":{"lines":[1746,1747]},"v":"<strong>参数优化策略</strong>"}]}]},{"t":"list_item","d":8,"p":{"lines":[1747,1748]},"v":"order by优化","c":[{"t":"list_item","d":10,"p":{"lines":[1748,1749]},"v":"遵循最左前缀进行排序","c":[{"t":"list_item","d":12,"p":{"lines":[1749,1750]},"v":"order"},{"t":"list_item","d":12,"p":{"lines":[1750,1751]},"v":"where(const)+order"}]},{"t":"list_item","d":10,"p":{"lines":[1751,1752]},"v":"不让索引失效"},{"t":"list_item","d":10,"p":{"lines":[1752,1753]},"v":"不能一升一降"}]},{"t":"list_item","d":8,"p":{"lines":[1753,1754]},"v":"group by优化","c":[{"t":"list_item","d":10,"p":{"lines":[1754,1755]},"v":"实质是先排序后进行分组"},{"t":"list_item","d":10,"p":{"lines":[1755,1756]},"v":"能写在where限定的条件就不要去having限定了"}]}]},{"t":"list_item","d":6,"p":{"lines":[1757,1758]},"v":"慢查询日志"}]},{"t":"heading","d":4,"p":{"lines":[1759,1760]},"v":"锁","c":[{"t":"list_item","d":6,"p":{"lines":[1761,1762]},"v":"Mysql锁底层","c":[{"t":"list_item","d":8,"p":{"lines":[1762,1763]},"v":"latch"},{"t":"list_item","d":8,"p":{"lines":[1763,1764]},"v":"lock"}]},{"t":"list_item","d":6,"p":{"lines":[1765,1766]},"v":"锁的分类","c":[{"t":"list_item","d":8,"p":{"lines":[1766,1767]},"v":"<a href=\"https://www.cnblogs.com/laoyeye/p/8097684.html\">乐观锁</a>","c":[{"t":"list_item","d":10,"p":{"lines":[1767,1768]},"v":"时间戳"},{"t":"list_item","d":10,"p":{"lines":[1768,1769]},"v":"版本号"},{"t":"list_item","d":10,"p":{"lines":[1769,1770]},"v":"条件限制"}]},{"t":"list_item","d":8,"p":{"lines":[1770,1771]},"v":"悲观锁","c":[{"t":"list_item","d":10,"p":{"lines":[1771,1772]},"v":"Myisam表锁","c":[{"t":"list_item","d":12,"p":{"lines":[1772,1773]},"v":"读锁"},{"t":"list_item","d":12,"p":{"lines":[1773,1774]},"v":"写锁"}]},{"t":"list_item","d":10,"p":{"lines":[1774,1775]},"v":"Innodb锁","c":[{"t":"list_item","d":12,"p":{"lines":[1775,1776]},"v":"意向表锁","c":[{"t":"list_item","d":14,"p":{"lines":[1776,1777]},"v":"意向共享锁"},{"t":"list_item","d":14,"p":{"lines":[1777,1778]},"v":"意向排他锁"}]},{"t":"list_item","d":12,"p":{"lines":[1778,1779]},"v":"普通行锁","c":[{"t":"list_item","d":14,"p":{"lines":[1779,1780]},"v":"共享锁"},{"t":"list_item","d":14,"p":{"lines":[1780,1781]},"v":"排它锁"}]},{"t":"list_item","d":12,"p":{"lines":[1781,1782]},"v":"锁算法","c":[{"t":"list_item","d":14,"p":{"lines":[1782,1783]},"v":"记录锁"},{"t":"list_item","d":14,"p":{"lines":[1783,1784]},"v":"间隙锁"},{"t":"list_item","d":14,"p":{"lines":[1784,1785]},"v":"临键锁"}]},{"t":"list_item","d":12,"p":{"lines":[1785,1786]},"v":"插入意向锁"},{"t":"list_item","d":12,"p":{"lines":[1786,1787]},"v":"自增锁"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[1788,1789]},"v":"<strong><a href=\"https://blog.csdn.net/geekjoker/article/details/79444076\">加锁流程</a></strong>","c":[{"t":"list_item","d":8,"p":{"lines":[1789,1790]},"v":"需要了解","c":[{"t":"list_item","d":10,"p":{"lines":[1790,1791]},"v":"聚集索引和二级索引"},{"t":"list_item","d":10,"p":{"lines":[1791,1792]},"v":"innodb二级索引查询流程"},{"t":"list_item","d":10,"p":{"lines":[1792,1793]},"v":"innodb的锁算法"}]},{"t":"list_item","d":8,"p":{"lines":[1793,1794]},"v":"不同情景 <br />(<strong>下列条件相互组合</strong>)","c":[{"t":"list_item","d":10,"p":{"lines":[1794,1795]},"v":"查询方式","c":[{"t":"list_item","d":12,"p":{"lines":[1795,1796]},"v":"等值查询"},{"t":"list_item","d":12,"p":{"lines":[1796,1797]},"v":"范围查询"}]},{"t":"list_item","d":10,"p":{"lines":[1797,1798]},"v":"隔离级别","c":[{"t":"list_item","d":12,"p":{"lines":[1798,1799]},"v":"RC"},{"t":"list_item","d":12,"p":{"lines":[1799,1800]},"v":"RR"},{"t":"list_item","d":12,"p":{"lines":[1800,1801]},"v":"serializable"}]},{"t":"list_item","d":10,"p":{"lines":[1801,1802]},"v":"操作","c":[{"t":"list_item","d":12,"p":{"lines":[1802,1803]},"v":"<code>select</code>(只用在serializable下考虑)"},{"t":"list_item","d":12,"p":{"lines":[1803,1804]},"v":"<code>delete</code>/<code>select...for update</code>"}]},{"t":"list_item","d":10,"p":{"lines":[1804,1805]},"v":"使用索引","c":[{"t":"list_item","d":12,"p":{"lines":[1805,1806]},"v":"主键索引<br />(注意临键锁会不会加在主键)"},{"t":"list_item","d":12,"p":{"lines":[1806,1807]},"v":"唯一索引"},{"t":"list_item","d":12,"p":{"lines":[1807,1808]},"v":"非唯一索引<br />(注意临键锁会不会加在主键)"},{"t":"list_item","d":12,"p":{"lines":[1808,1809]},"v":"无索引"}]}]}]}]},{"t":"heading","d":4,"p":{"lines":[1810,1811]},"v":"MVCC","c":[{"t":"list_item","d":6,"p":{"lines":[1812,1813]},"v":"快照读与当前读"},{"t":"list_item","d":6,"p":{"lines":[1813,1814]},"v":"原理","c":[{"t":"list_item","d":8,"p":{"lines":[1814,1815]},"v":"版本链","c":[{"t":"list_item","d":10,"p":{"lines":[1815,1816]},"v":"隐藏字段"},{"t":"list_item","d":10,"p":{"lines":[1816,1817]},"v":"undo log"}]},{"t":"list_item","d":8,"p":{"lines":[1817,1818]},"v":"readview"}]}]},{"t":"heading","d":4,"p":{"lines":[1820,1821]},"v":"主从复制","c":[{"t":"list_item","d":6,"p":{"lines":[1822,1823]},"v":"主从复制","c":[{"t":"list_item","d":8,"p":{"lines":[1823,1824]},"v":"原理"}]},{"t":"list_item","d":6,"p":{"lines":[1824,1825]},"v":"读写分离"}]},{"t":"heading","d":4,"p":{"lines":[1826,1827]},"v":"底层优化","c":[{"t":"list_item","d":6,"p":{"lines":[1828,1829]},"v":"MRR"},{"t":"list_item","d":6,"p":{"lines":[1829,1830]},"v":"ICP"}]},{"t":"heading","d":4,"p":{"lines":[1831,1832]},"v":"大表调优"}]},{"t":"heading","d":3,"p":{"lines":[1833,1834],"f":true},"v":"oracle"}]},{"t":"heading","d":2,"p":{"lines":[1835,1836]},"v":"nosql","c":[{"t":"heading","d":3,"p":{"lines":[1837,1838],"f":true},"v":"Redis","c":[{"t":"list_item","d":5,"p":{"lines":[1839,1840]},"v":"基本数据类型","c":[{"t":"list_item","d":7,"p":{"lines":[1840,1841]},"v":"String","c":[{"t":"list_item","d":9,"p":{"lines":[1841,1842]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1842,1843]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1843,1844]},"v":"数据结构"}]},{"t":"list_item","d":7,"p":{"lines":[1844,1845]},"v":"Hash","c":[{"t":"list_item","d":9,"p":{"lines":[1845,1846]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1846,1847]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1847,1848]},"v":"数据结构"}]},{"t":"list_item","d":7,"p":{"lines":[1848,1849]},"v":"List","c":[{"t":"list_item","d":9,"p":{"lines":[1849,1850]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1850,1851]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1851,1852]},"v":"数据结构"}]},{"t":"list_item","d":7,"p":{"lines":[1852,1853]},"v":"Set","c":[{"t":"list_item","d":9,"p":{"lines":[1853,1854]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1854,1855]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1855,1856]},"v":"数据结构"}]},{"t":"list_item","d":7,"p":{"lines":[1856,1857]},"v":"ZSet","c":[{"t":"list_item","d":9,"p":{"lines":[1857,1858]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1858,1859]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1859,1860]},"v":"数据结构"}]},{"t":"list_item","d":7,"p":{"lines":[1860,1861]},"v":"HyperLogLog","c":[{"t":"list_item","d":9,"p":{"lines":[1861,1862]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1862,1863]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1863,1864]},"v":"数据结构"}]}]},{"t":"list_item","d":5,"p":{"lines":[1865,1866]},"v":"高级算法","c":[{"t":"list_item","d":7,"p":{"lines":[1866,1867]},"v":"scan"},{"t":"list_item","d":7,"p":{"lines":[1867,1868]},"v":"GeoHash"}]},{"t":"list_item","d":5,"p":{"lines":[1869,1870]},"v":"过期淘汰","c":[{"t":"list_item","d":7,"p":{"lines":[1870,1871]},"v":"过期删除策略","c":[{"t":"list_item","d":9,"p":{"lines":[1871,1872]},"v":"定时删除"},{"t":"list_item","d":9,"p":{"lines":[1872,1873]},"v":"惰性删除"},{"t":"list_item","d":9,"p":{"lines":[1873,1874]},"v":"定期删除"}]},{"t":"list_item","d":7,"p":{"lines":[1874,1875]},"v":"内存淘汰策略","c":[{"t":"list_item","d":9,"p":{"lines":[1875,1876]},"v":"no-eviction"},{"t":"list_item","d":9,"p":{"lines":[1876,1877]},"v":"allkeys","c":[{"t":"list_item","d":11,"p":{"lines":[1877,1878]},"v":"random"},{"t":"list_item","d":11,"p":{"lines":[1878,1879]},"v":"lru"},{"t":"list_item","d":11,"p":{"lines":[1879,1880]},"v":"lfu"}]},{"t":"list_item","d":9,"p":{"lines":[1880,1881]},"v":"volatile","c":[{"t":"list_item","d":11,"p":{"lines":[1881,1882]},"v":"ttl"},{"t":"list_item","d":11,"p":{"lines":[1882,1883]},"v":"random"},{"t":"list_item","d":11,"p":{"lines":[1883,1884]},"v":"lru"},{"t":"list_item","d":11,"p":{"lines":[1884,1885]},"v":"lfu"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[1885,1886]},"v":"持久化","c":[{"t":"list_item","d":7,"p":{"lines":[1886,1887]},"v":"RDB","c":[{"t":"list_item","d":9,"p":{"lines":[1887,1888]},"v":"持久化原理/过程"},{"t":"list_item","d":9,"p":{"lines":[1888,1889]},"v":"配置"},{"t":"list_item","d":9,"p":{"lines":[1889,1890]},"v":"触发","c":[{"t":"list_item","d":11,"p":{"lines":[1890,1891]},"v":"自动","c":[{"t":"list_item","d":13,"p":{"lines":[1891,1892]},"v":"默认的三个"},{"t":"list_item","d":13,"p":{"lines":[1892,1893]},"v":"原理"}]},{"t":"list_item","d":11,"p":{"lines":[1893,1894]},"v":"手动(4种)"}]},{"t":"list_item","d":9,"p":{"lines":[1894,1895]},"v":"check检查"},{"t":"list_item","d":9,"p":{"lines":[1895,1896]},"v":"优缺点"}]},{"t":"list_item","d":7,"p":{"lines":[1896,1897]},"v":"AOF","c":[{"t":"list_item","d":9,"p":{"lines":[1897,1898]},"v":"持久化原理/过程"},{"t":"list_item","d":9,"p":{"lines":[1898,1899]},"v":"配置"},{"t":"list_item","d":9,"p":{"lines":[1899,1900]},"v":"触发","c":[{"t":"list_item","d":11,"p":{"lines":[1900,1901]},"v":"开启后自动"},{"t":"list_item","d":11,"p":{"lines":[1901,1902]},"v":"手动<code>bgrewriteaof</code>"}]},{"t":"list_item","d":9,"p":{"lines":[1902,1903]},"v":"check检查"},{"t":"list_item","d":9,"p":{"lines":[1903,1904]},"v":"AOF重写","c":[{"t":"list_item","d":11,"p":{"lines":[1904,1905]},"v":"原理","c":[{"t":"list_item","d":13,"p":{"lines":[1905,1906]},"v":"读取服务器现有KV"},{"t":"list_item","d":13,"p":{"lines":[1906,1907]},"v":"fork子<strong>进程</strong>"}]},{"t":"list_item","d":11,"p":{"lines":[1907,1908]},"v":"触发"},{"t":"list_item","d":11,"p":{"lines":[1908,1909]},"v":"重写数据不一致问题"},{"t":"list_item","d":11,"p":{"lines":[1909,1910]},"v":"重写数据不一致问题解决"}]},{"t":"list_item","d":9,"p":{"lines":[1910,1911]},"v":"优缺点"},{"t":"list_item","d":9,"p":{"lines":[1911,1912]},"v":"(总结)AOF的两个缓冲区"}]},{"t":"list_item","d":7,"p":{"lines":[1912,1913]},"v":"AOF+RDB混合"}]},{"t":"list_item","d":5,"p":{"lines":[1914,1915]},"v":"事务","c":[{"t":"list_item","d":7,"p":{"lines":[1915,1916]},"v":"基本命令"},{"t":"list_item","d":7,"p":{"lines":[1916,1917]},"v":"乐观锁"},{"t":"list_item","d":7,"p":{"lines":[1917,1918]},"v":"两种异常情况：","c":[{"t":"list_item","d":9,"p":{"lines":[1918,1919]},"v":"全都不执行"},{"t":"list_item","d":9,"p":{"lines":[1919,1920]},"v":"执行可以执行的"}]}]},{"t":"list_item","d":5,"p":{"lines":[1921,1922]},"v":"并发问题解决","c":[{"t":"list_item","d":7,"p":{"lines":[1922,1923]},"v":"乐观锁"},{"t":"list_item","d":7,"p":{"lines":[1923,1924]},"v":"分布式锁"},{"t":"list_item","d":7,"p":{"lines":[1924,1925]},"v":"消息队列"},{"t":"list_item","d":7,"p":{"lines":[1925,1926]},"v":"时间戳"}]},{"t":"list_item","d":5,"p":{"lines":[1927,1928]},"v":"消息发布订阅"},{"t":"list_item","d":5,"p":{"lines":[1929,1930]},"v":"集群","c":[{"t":"list_item","d":7,"p":{"lines":[1930,1931]},"v":"主从复制","c":[{"t":"list_item","d":9,"p":{"lines":[1931,1932]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1932,1933]},"v":"配置"},{"t":"list_item","d":9,"p":{"lines":[1933,1934]},"v":"master宕机"}]},{"t":"list_item","d":7,"p":{"lines":[1934,1935]},"v":"哨兵模式","c":[{"t":"list_item","d":9,"p":{"lines":[1935,1936]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1936,1937]},"v":"配置"},{"t":"list_item","d":9,"p":{"lines":[1937,1938]},"v":"master宕机"}]},{"t":"list_item","d":7,"p":{"lines":[1938,1939]},"v":"分片cluster","c":[{"t":"list_item","d":9,"p":{"lines":[1939,1940]},"v":"说明","c":[{"t":"list_item","d":11,"p":{"lines":[1940,1941]},"v":"两个端口"},{"t":"list_item","d":11,"p":{"lines":[1941,1942]},"v":"集群总线"},{"t":"list_item","d":11,"p":{"lines":[1942,1943],"f":true},"v":"数据存取 ","c":[{"t":"list_item","d":13,"p":{"lines":[1943,1944]},"v":"CRC16"},{"t":"list_item","d":13,"p":{"lines":[1944,1945]},"v":"hash槽"},{"t":"list_item","d":13,"p":{"lines":[1945,1946]},"v":"重定向"}]},{"t":"list_item","d":11,"p":{"lines":[1946,1947]},"v":"主从复制模型"}]},{"t":"list_item","d":9,"p":{"lines":[1947,1948]},"v":"配置"},{"t":"list_item","d":9,"p":{"lines":[1948,1949]},"v":"master宕机"}]}]},{"t":"list_item","d":5,"p":{"lines":[1950,1951]},"v":"缓存失效/更新问题","c":[{"t":"list_item","d":7,"p":{"lines":[1951,1952]},"v":"缓存雪崩","c":[{"t":"list_item","d":9,"p":{"lines":[1952,1953]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1953,1954]},"v":"解决方案"}]},{"t":"list_item","d":7,"p":{"lines":[1954,1955]},"v":"缓存穿透","c":[{"t":"list_item","d":9,"p":{"lines":[1955,1956]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1956,1957]},"v":"解决方案"}]},{"t":"list_item","d":7,"p":{"lines":[1957,1958]},"v":"缓存击穿","c":[{"t":"list_item","d":9,"p":{"lines":[1958,1959]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1959,1960]},"v":"解决方案"}]},{"t":"list_item","d":7,"p":{"lines":[1960,1961]},"v":"双写一致","c":[{"t":"list_item","d":9,"p":{"lines":[1961,1962]},"v":"分析问题","c":[{"t":"list_item","d":11,"p":{"lines":[1962,1963]},"v":"先更新数据库，<br />再删除缓存","c":[{"t":"list_item","d":13,"p":{"lines":[1963,1964]},"v":"正常"},{"t":"list_item","d":13,"p":{"lines":[1964,1965]},"v":"失败"},{"t":"list_item","d":13,"p":{"lines":[1965,1966]},"v":"并发"}]},{"t":"list_item","d":11,"p":{"lines":[1966,1967]},"v":"先删除缓存，<br />再更新数据库","c":[{"t":"list_item","d":13,"p":{"lines":[1967,1968]},"v":"正常"},{"t":"list_item","d":13,"p":{"lines":[1968,1969]},"v":"失败"},{"t":"list_item","d":13,"p":{"lines":[1969,1970]},"v":"并发"},{"t":"list_item","d":13,"p":{"lines":[1970,1971]},"v":"<code>关联：缓存读写策略中的旁路缓存</code>"}]}]},{"t":"list_item","d":9,"p":{"lines":[1971,1972]},"v":"解决方案"}]}]},{"t":"list_item","d":5,"p":{"lines":[1973,1974]},"v":"线程模型","c":[{"t":"list_item","d":7,"p":{"lines":[1974,1975],"f":true},"v":"为什么使用单线程 ","c":[{"t":"list_item","d":9,"p":{"lines":[1975,1976]},"v":"可维护性，方便开发和调试"},{"t":"list_item","d":9,"p":{"lines":[1976,1977]},"v":"单线程也能处理并发请求(多路复用)"},{"t":"list_item","d":9,"p":{"lines":[1977,1978]},"v":"性能瓶颈不是cpu，而是内存和网络"}]},{"t":"list_item","d":7,"p":{"lines":[1978,1979],"f":true},"v":"为什么能单线程处理那么多客户端 ","c":[{"t":"list_item","d":9,"p":{"lines":[1979,1980]},"v":"纯内存"},{"t":"list_item","d":9,"p":{"lines":[1980,1981]},"v":"单线程，无锁"},{"t":"list_item","d":9,"p":{"lines":[1981,1982]},"v":"多路复用"},{"t":"list_item","d":9,"p":{"lines":[1982,1983]},"v":"高效底层数据结构优化"}]},{"t":"list_item","d":7,"p":{"lines":[1983,1984]},"v":"为什么6.0前不使用多线程"},{"t":"list_item","d":7,"p":{"lines":[1984,1985],"f":true},"v":"Redis 6.0为什么使用多线程 ","c":[{"t":"list_item","d":9,"p":{"lines":[1985,1986]},"v":"提高网络io读写性能"},{"t":"list_item","d":9,"p":{"lines":[1986,1987]},"v":"<code>默认禁用</code>"}]}]},{"t":"list_item","d":5,"p":{"lines":[1988,1989]},"v":"redis应用","c":[{"t":"list_item","d":7,"p":{"lines":[1989,1990]},"v":"redis分布式锁","c":[{"t":"list_item","d":9,"p":{"lines":[1990,1991]},"v":"高效分布式锁条件","c":[{"t":"list_item","d":11,"p":{"lines":[1991,1992]},"v":"互斥"},{"t":"list_item","d":11,"p":{"lines":[1992,1993]},"v":"防止死锁"},{"t":"list_item","d":11,"p":{"lines":[1993,1994]},"v":"性能"},{"t":"list_item","d":11,"p":{"lines":[1994,1995]},"v":"可重入"}]},{"t":"list_item","d":9,"p":{"lines":[1995,1996]},"v":"两个问题及解决思路","c":[{"t":"list_item","d":11,"p":{"lines":[1996,1997]},"v":"setnx,expire原子性"},{"t":"list_item","d":11,"p":{"lines":[1997,1998]},"v":"锁提前失效"}]},{"t":"list_item","d":9,"p":{"lines":[1998,1999]},"v":"redisson锁","c":[{"t":"list_item","d":11,"p":{"lines":[1999,2000]},"v":"流程/原理"},{"t":"list_item","d":11,"p":{"lines":[2000,2001]},"v":"看门狗机制"},{"t":"list_item","d":11,"p":{"lines":[2001,2002]},"v":"lua脚本"},{"t":"list_item","d":11,"p":{"lines":[2002,2003]},"v":"实现可重入:Hash"},{"t":"list_item","d":11,"p":{"lines":[2003,2004]},"v":"缺陷"}]}]},{"t":"list_item","d":7,"p":{"lines":[2004,2005]},"v":"缓存","c":[{"t":"list_item","d":9,"p":{"lines":[2005,2006],"f":true},"v":"旁路缓存模式 ","c":[{"t":"list_item","d":11,"p":{"lines":[2006,2007]},"v":"关联：双写一致问题"}]},{"t":"list_item","d":9,"p":{"lines":[2007,2008]},"v":"读写穿透"},{"t":"list_item","d":9,"p":{"lines":[2008,2009]},"v":"异步缓存写入"}]},{"t":"list_item","d":7,"p":{"lines":[2009,2010]},"v":"布隆过滤器"},{"t":"list_item","d":7,"p":{"lines":[2010,2011]},"v":"布谷鸟过滤器"}]}]},{"t":"heading","d":3,"p":{"lines":[2013,2014],"f":true},"v":"MongoDB"}]}]},{"t":"heading","d":1,"p":{"lines":[2015,2016]},"v":"基础","c":[{"t":"heading","d":2,"p":{"lines":[2017,2018],"f":true},"v":"设计模式","c":[{"t":"heading","d":3,"p":{"lines":[2019,2020]},"v":"七大原则"},{"t":"heading","d":3,"p":{"lines":[2021,2022]},"v":"设计模式","c":[{"t":"heading","d":4,"p":{"lines":[2023,2024]},"v":"创建型模式"},{"t":"heading","d":4,"p":{"lines":[2025,2026]},"v":"结构型模式"},{"t":"heading","d":4,"p":{"lines":[2027,2028]},"v":"行为型模式"},{"t":"heading","d":4,"p":{"lines":[2029,2030]},"v":"J2EE型模式"}]}]},{"t":"heading","d":2,"p":{"lines":[2031,2032],"f":true},"v":"计算机网络","c":[{"t":"list_item","d":4,"p":{"lines":[2033,2034]},"v":"理论<br />(参考《计算机网络》谢希仁)","c":[{"t":"list_item","d":6,"p":{"lines":[2034,2035]},"v":"概述","c":[{"t":"list_item","d":8,"p":{"lines":[2035,2036]},"v":"基本概念","c":[{"t":"list_item","d":10,"p":{"lines":[2036,2037]},"v":"结点"},{"t":"list_item","d":10,"p":{"lines":[2037,2038]},"v":"链路"},{"t":"list_item","d":10,"p":{"lines":[2038,2039]},"v":"主机"},{"t":"list_item","d":10,"p":{"lines":[2039,2040]},"v":"internet和Internet"},{"t":"list_item","d":10,"p":{"lines":[2040,2041]},"v":"ISP和IXP"}]},{"t":"list_item","d":8,"p":{"lines":[2041,2042]},"v":"因特网组成","c":[{"t":"list_item","d":10,"p":{"lines":[2042,2043]},"v":"边缘部分","c":[{"t":"list_item","d":12,"p":{"lines":[2043,2044]},"v":"client-server"},{"t":"list_item","d":12,"p":{"lines":[2044,2045]},"v":"p2p"}]},{"t":"list_item","d":10,"p":{"lines":[2045,2046]},"v":"核心部分","c":[{"t":"list_item","d":12,"p":{"lines":[2046,2047]},"v":"电路交换"},{"t":"list_item","d":12,"p":{"lines":[2047,2048]},"v":"报文交换"},{"t":"list_item","d":12,"p":{"lines":[2048,2049]},"v":"分组交换"}]}]},{"t":"list_item","d":8,"p":{"lines":[2049,2050]},"v":"计算机网络类别","c":[{"t":"list_item","d":10,"p":{"lines":[2050,2051]},"v":"广域网WAN"},{"t":"list_item","d":10,"p":{"lines":[2051,2052]},"v":"区域网MAN"},{"t":"list_item","d":10,"p":{"lines":[2052,2053]},"v":"城域网LAN"},{"t":"list_item","d":10,"p":{"lines":[2053,2054]},"v":"个人区域网PAN"}]},{"t":"list_item","d":8,"p":{"lines":[2054,2055]},"v":"计算机网络性能指标","c":[{"t":"list_item","d":10,"p":{"lines":[2055,2056]},"v":"速率"},{"t":"list_item","d":10,"p":{"lines":[2056,2057]},"v":"管带"},{"t":"list_item","d":10,"p":{"lines":[2057,2058]},"v":"吞吐量"},{"t":"list_item","d":10,"p":{"lines":[2058,2059]},"v":"时延","c":[{"t":"list_item","d":12,"p":{"lines":[2059,2060]},"v":"发送"},{"t":"list_item","d":12,"p":{"lines":[2060,2061]},"v":"处理"},{"t":"list_item","d":12,"p":{"lines":[2061,2062]},"v":"传播"},{"t":"list_item","d":12,"p":{"lines":[2062,2063]},"v":"排队"}]},{"t":"list_item","d":10,"p":{"lines":[2063,2064]},"v":"时延带宽积"},{"t":"list_item","d":10,"p":{"lines":[2064,2065]},"v":"往返时间RRT"},{"t":"list_item","d":10,"p":{"lines":[2065,2066]},"v":"利用率"}]},{"t":"list_item","d":8,"p":{"lines":[2066,2067]},"v":"计算机网络体系结构","c":[{"t":"list_item","d":10,"p":{"lines":[2067,2068]},"v":"OSI七层"},{"t":"list_item","d":10,"p":{"lines":[2068,2069]},"v":"TCP/IP四层"},{"t":"list_item","d":10,"p":{"lines":[2069,2070]},"v":"课本按照五层"}]}]},{"t":"list_item","d":6,"p":{"lines":[2070,2071]},"v":"物理层"},{"t":"list_item","d":6,"p":{"lines":[2071,2072]},"v":"链路层","c":[{"t":"list_item","d":8,"p":{"lines":[2072,2073]},"v":"点对点信道","c":[{"t":"list_item","d":10,"p":{"lines":[2073,2074]},"v":"基本概念","c":[{"t":"list_item","d":12,"p":{"lines":[2074,2075]},"v":"链路"},{"t":"list_item","d":12,"p":{"lines":[2075,2076]},"v":"数据链路"},{"t":"list_item","d":12,"p":{"lines":[2076,2077]},"v":"网络适配器"}]},{"t":"list_item","d":10,"p":{"lines":[2077,2078]},"v":"三个基本问题","c":[{"t":"list_item","d":12,"p":{"lines":[2078,2079]},"v":"封装成帧:帧格式"},{"t":"list_item","d":12,"p":{"lines":[2079,2080]},"v":"透明传输:原理"},{"t":"list_item","d":12,"p":{"lines":[2080,2081]},"v":"差错检测","c":[{"t":"list_item","d":14,"p":{"lines":[2081,2082]},"v":"循环冗余检验CRC"},{"t":"list_item","d":14,"p":{"lines":[2082,2083]},"v":"帧检验序列FCS"}]}]},{"t":"list_item","d":10,"p":{"lines":[2083,2084]},"v":"ppp协议","c":[{"t":"list_item","d":12,"p":{"lines":[2084,2085]},"v":"协议特点"},{"t":"list_item","d":12,"p":{"lines":[2085,2086]},"v":"协议组成"},{"t":"list_item","d":12,"p":{"lines":[2086,2087]},"v":"PPP帧格式"},{"t":"list_item","d":12,"p":{"lines":[2087,2088]},"v":"透明传输","c":[{"t":"list_item","d":14,"p":{"lines":[2088,2089]},"v":"异步传输：字节填充"},{"t":"list_item","d":14,"p":{"lines":[2089,2090]},"v":"同步传输：零比特填充"}]},{"t":"list_item","d":12,"p":{"lines":[2090,2091]},"v":"确保边界：零比特填充"},{"t":"list_item","d":12,"p":{"lines":[2091,2092]},"v":"PPP工作状态"}]}]},{"t":"list_item","d":8,"p":{"lines":[2092,2093]},"v":"广播信道","c":[{"t":"list_item","d":10,"p":{"lines":[2093,2094]},"v":"适配器作用"},{"t":"list_item","d":10,"p":{"lines":[2094,2095]},"v":"三个基本问题","c":[{"t":"list_item","d":12,"p":{"lines":[2095,2096]},"v":"封装成帧:帧格式"},{"t":"list_item","d":12,"p":{"lines":[2096,2097]},"v":"透明传输:不需要"},{"t":"list_item","d":12,"p":{"lines":[2097,2098]},"v":"差错检测","c":[{"t":"list_item","d":14,"p":{"lines":[2098,2099]},"v":"循环冗余检验CRC"},{"t":"list_item","d":14,"p":{"lines":[2099,2100]},"v":"帧检验序列FCS"}]}]},{"t":"list_item","d":10,"p":{"lines":[2100,2101]},"v":"协议","c":[{"t":"list_item","d":12,"p":{"lines":[2101,2102]},"v":"<strong>CSMA/CD碰撞检测</strong>"},{"t":"list_item","d":12,"p":{"lines":[2102,2103]},"v":"TDMA"},{"t":"list_item","d":12,"p":{"lines":[2103,2104]},"v":"FDMA"},{"t":"list_item","d":12,"p":{"lines":[2104,2105]},"v":"slotted ALOHA"},{"t":"list_item","d":12,"p":{"lines":[2105,2106]},"v":"ALOHA"}]},{"t":"list_item","d":10,"p":{"lines":[2106,2107]},"v":"MAC地址","c":[{"t":"list_item","d":12,"p":{"lines":[2107,2108]},"v":"概念"},{"t":"list_item","d":12,"p":{"lines":[2108,2109]},"v":"作用"},{"t":"list_item","d":12,"p":{"lines":[2109,2110]},"v":"地址格式"},{"t":"list_item","d":12,"p":{"lines":[2110,2111]},"v":"MAC帧格式"}]}]},{"t":"list_item","d":8,"p":{"lines":[2111,2112]},"v":"扩展以太网","c":[{"t":"list_item","d":10,"p":{"lines":[2112,2113]},"v":"物理层","c":[{"t":"list_item","d":12,"p":{"lines":[2113,2114]},"v":"集线器"}]},{"t":"list_item","d":10,"p":{"lines":[2114,2115]},"v":"链路层","c":[{"t":"list_item","d":12,"p":{"lines":[2115,2116]},"v":"网桥","c":[{"t":"list_item","d":14,"p":{"lines":[2116,2117]},"v":"<strong>自学习和转发过程</strong>"},{"t":"list_item","d":14,"p":{"lines":[2117,2118]},"v":"生成树算法"}]},{"t":"list_item","d":12,"p":{"lines":[2118,2119]},"v":"交换机(多接口网桥)"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[2119,2120]},"v":"网络层","c":[{"t":"list_item","d":8,"p":{"lines":[2120,2121]},"v":"网络层提供的两种服务","c":[{"t":"list_item","d":10,"p":{"lines":[2121,2122]},"v":"面向连接：VC(虚电路)"},{"t":"list_item","d":10,"p":{"lines":[2122,2123]},"v":"无连接：数据报"}]}]},{"t":"list_item","d":6,"p":{"lines":[2123,2124]},"v":"运输层"},{"t":"list_item","d":6,"p":{"lines":[2124,2125]},"v":"应用层"}]},{"t":"list_item","d":4,"p":{"lines":[2125,2126]},"v":"问题","c":[{"t":"list_item","d":6,"p":{"lines":[2126,2127]},"v":"计算机网络体系结构"},{"t":"list_item","d":6,"p":{"lines":[2127,2128]},"v":"传输层：TCP和UDP","c":[{"t":"list_item","d":8,"p":{"lines":[2128,2129]},"v":"什么是三次握手？"},{"t":"list_item","d":8,"p":{"lines":[2129,2130]},"v":"什么是四次挥手？"},{"t":"list_item","d":8,"p":{"lines":[2130,2131]},"v":"TCP如何实现流量控制？"},{"t":"list_item","d":8,"p":{"lines":[2131,2132]},"v":"TCP的拥塞控制是怎么实现的？"},{"t":"list_item","d":8,"p":{"lines":[2132,2133]},"v":"TCP如何最大利用带宽？"},{"t":"list_item","d":8,"p":{"lines":[2133,2134]},"v":"TCP与UDP的区别"},{"t":"list_item","d":8,"p":{"lines":[2134,2135]},"v":"TCP如何保证传输的可靠性"},{"t":"list_item","d":8,"p":{"lines":[2135,2136]},"v":"什么是TCP粘包？"}]},{"t":"list_item","d":6,"p":{"lines":[2136,2137]},"v":"应用层：HTTP和HTTPS","c":[{"t":"list_item","d":8,"p":{"lines":[2137,2138]},"v":"HTTP和HTTPS有什么区别？"},{"t":"list_item","d":8,"p":{"lines":[2138,2139]},"v":"GET与POST的区别？"},{"t":"list_item","d":8,"p":{"lines":[2139,2140]},"v":"Session与Cookie的区别？"},{"t":"list_item","d":8,"p":{"lines":[2140,2141]},"v":"从输入网址到获得页面的过程 (越详细越好)？"},{"t":"list_item","d":8,"p":{"lines":[2141,2142]},"v":"HTTP请求有哪些常见状态码？"},{"t":"list_item","d":8,"p":{"lines":[2142,2143]},"v":"什么是RIP (距离矢量路由协议)?"}]},{"t":"list_item","d":6,"p":{"lines":[2143,2144]},"v":"网络层协议IP","c":[{"t":"list_item","d":8,"p":{"lines":[2144,2145]},"v":"IP地址的分类？"},{"t":"list_item","d":8,"p":{"lines":[2145,2146]},"v":"什么叫划分子网？"},{"t":"list_item","d":8,"p":{"lines":[2146,2147]},"v":"什么是ARP协议？"},{"t":"list_item","d":8,"p":{"lines":[2147,2148]},"v":"什么是NAT (网络地址转换)？"}]},{"t":"list_item","d":6,"p":{"lines":[2148,2149]},"v":"从 URL 输入到页面展现到底发生什么"}]}]},{"t":"heading","d":2,"p":{"lines":[2150,2151],"f":true},"v":"操作系统"},{"t":"heading","d":2,"p":{"lines":[2152,2153],"f":true},"v":"算法"}]},{"t":"heading","d":1,"p":{"lines":[2154,2155]},"v":"分布式相关","c":[{"t":"heading","d":2,"p":{"lines":[2156,2157],"f":true},"v":"分布式理论 ","c":[{"t":"heading","d":3,"p":{"lines":[2158,2159]},"v":"基础理论","c":[{"t":"heading","d":4,"p":{"lines":[2160,2161]},"v":"分布式"},{"t":"heading","d":4,"p":{"lines":[2162,2163]},"v":"分布式和集群"},{"t":"heading","d":4,"p":{"lines":[2164,2165]},"v":"微服务"}]},{"t":"heading","d":3,"p":{"lines":[2166,2167]},"v":"通信设计","c":[{"t":"heading","d":4,"p":{"lines":[2168,2169]},"v":"RPC"},{"t":"heading","d":4,"p":{"lines":[2170,2171]},"v":"REST"}]},{"t":"heading","d":3,"p":{"lines":[2172,2173]},"v":"分布式事务算法","c":[{"t":"heading","d":4,"p":{"lines":[2174,2175]},"v":"一致性问题"},{"t":"heading","d":4,"p":{"lines":[2176,2177]},"v":"2PC"},{"t":"heading","d":4,"p":{"lines":[2178,2179]},"v":"3PC"},{"t":"heading","d":4,"p":{"lines":[2180,2181]},"v":"paxos"},{"t":"heading","d":4,"p":{"lines":[2182,2183]},"v":"raft"}]}]},{"t":"heading","d":2,"p":{"lines":[2184,2185]},"v":"高可用"},{"t":"heading","d":2,"p":{"lines":[2186,2187]},"v":"分布式锁","c":[{"t":"heading","d":3,"p":{"lines":[2188,2189]},"v":"数据库"},{"t":"heading","d":3,"p":{"lines":[2190,2191]},"v":"redis"},{"t":"heading","d":3,"p":{"lines":[2192,2193]},"v":"zookeeper"},{"t":"heading","d":3,"p":{"lines":[2194,2195]},"v":"etcd"}]},{"t":"heading","d":2,"p":{"lines":[2196,2197]},"v":"分布式协调框架","c":[{"t":"heading","d":3,"p":{"lines":[2198,2199]},"v":"zookeeper"}]},{"t":"heading","d":2,"p":{"lines":[2200,2201]},"v":"RPC框架","c":[{"t":"heading","d":3,"p":{"lines":[2202,2203]},"v":"SpringCloud"},{"t":"heading","d":3,"p":{"lines":[2204,2205],"f":true},"v":"Dubbo"}]}]},{"t":"heading","d":1,"p":{"lines":[2206,2207]},"v":"消息队列","c":[{"t":"heading","d":2,"p":{"lines":[2208,2209],"f":true},"v":"Kafka"},{"t":"heading","d":2,"p":{"lines":[2210,2211],"f":true},"v":"RocketMQ"}]}],"p":{}})</script>
</body>
</html>
