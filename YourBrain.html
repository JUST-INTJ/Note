<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.1.6/dist/style.min.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@6.6.0"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.2.6"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.1.6/dist/index.umd.min.js"></script><script>(r => {
          setTimeout(r);
        })(() => {
  const {
    markmap,
    mm
  } = window;
  const toolbar = new markmap.Toolbar();
  toolbar.attach(mm);
  const el = toolbar.render();
  el.setAttribute('style', 'position:absolute;bottom:20px;right:20px');
  document.body.append(el);
})</script><script>((getMarkmap, getOptions, data) => {
        const {
          Markmap
        } = getMarkmap();
        window.mm = Markmap.create('svg#mindmap', getOptions == null ? void 0 : getOptions(), data);
      })(() => window.markmap,null,{"t":"root","d":0,"v":"","c":[{"t":"heading","d":1,"p":{"lines":[3,4]},"v":"Java 基础","c":[{"t":"heading","d":2,"p":{"lines":[5,6],"f":true},"v":"基础 ","c":[{"t":"heading","d":3,"p":{"lines":[7,8]},"v":"基础中的基础","c":[{"t":"list_item","d":5,"p":{"lines":[9,10]},"v":"基本概念","c":[{"t":"list_item","d":7,"p":{"lines":[10,11]},"v":"JRE与JDK"},{"t":"list_item","d":7,"p":{"lines":[11,12]},"v":"Java 7 和 Java SE 7"},{"t":"list_item","d":7,"p":{"lines":[12,13]},"v":"JDK1.8和Java8"}]},{"t":"list_item","d":5,"p":{"lines":[14,15]},"v":"Object的11个方法","c":[{"t":"list_item","d":7,"p":{"lines":[15,16]},"v":"equals","c":[{"t":"list_item","d":9,"p":{"lines":[16,17]},"v":"<code>常量.equals</code>"},{"t":"list_item","d":9,"p":{"lines":[17,18]},"v":"<code>Objects.equals</code> <strong>推荐</strong>"},{"t":"list_item","d":9,"p":{"lines":[18,19]},"v":"<a href=\"https://www.cnblogs.com/skywang12345/p/3324958.html\">hashcode和equals(重要)</a>"}]}]},{"t":"list_item","d":5,"p":{"lines":[20,21]},"v":"面向对象","c":[{"t":"list_item","d":7,"p":{"lines":[21,22]},"v":"封装"},{"t":"list_item","d":7,"p":{"lines":[22,23]},"v":"继承"},{"t":"list_item","d":7,"p":{"lines":[23,24]},"v":"多态","c":[{"t":"list_item","d":9,"p":{"lines":[24,25]},"v":"上转下转"},{"t":"list_item","d":9,"p":{"lines":[25,26]},"v":"深入(JVM内容)","c":[{"t":"list_item","d":11,"p":{"lines":[26,27]},"v":"动态链接"},{"t":"list_item","d":11,"p":{"lines":[27,28]},"v":"非虚方法和虚方法"},{"t":"list_item","d":11,"p":{"lines":[28,29]},"v":"方法重写本质"},{"t":"list_item","d":11,"p":{"lines":[29,30]},"v":"虚方法表"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[31,32]},"v":"Java异常体系"},{"t":"list_item","d":5,"p":{"lines":[33,34]},"v":"常用关键字"},{"t":"list_item","d":5,"p":{"lines":[35,36]},"v":"<a href=\"https://juejin.cn/post/6844903791863529480\">静/非静态内部类</a>","c":[{"t":"list_item","d":7,"p":{"lines":[36,37]},"v":"是否懒加载"},{"t":"list_item","d":7,"p":{"lines":[37,38]},"v":"是否可以创建静态成员"},{"t":"list_item","d":7,"p":{"lines":[38,39]},"v":"能否调用调用外部类静态成员"},{"t":"list_item","d":7,"p":{"lines":[39,40]},"v":"有没有指向外部类的引用<br /><code>外部类类名.this</code>"},{"t":"list_item","d":7,"p":{"lines":[40,41]},"v":"创建方式"}]},{"t":"list_item","d":5,"p":{"lines":[42,43]},"v":"枚举","c":[{"t":"list_item","d":7,"p":{"lines":[43,44]},"v":"本质"},{"t":"list_item","d":7,"p":{"lines":[44,45]},"v":"常见用法"}]},{"t":"list_item","d":5,"p":{"lines":[46,47]},"v":"包装类","c":[{"t":"list_item","d":7,"p":{"lines":[47,48]},"v":"缓存机制","c":[{"t":"list_item","d":9,"p":{"lines":[48,49]},"v":"Integer当数值在-128 ~127时，会将创建的 Integer 对象缓存起来"},{"t":"list_item","d":9,"p":{"lines":[49,50]},"v":"Character当数值在0-~127时，会将创建的Character对象缓存起来"},{"t":"list_item","d":9,"p":{"lines":[50,51]},"v":"因此，整型包装类对象之间值的比较，全部使用 equals 方法比较"}]},{"t":"list_item","d":7,"p":{"lines":[51,52]},"v":"BigDecimal","c":[{"t":"list_item","d":9,"p":{"lines":[52,53]},"v":"浮点数之间的等值判断","c":[{"t":"list_item","d":11,"p":{"lines":[53,54]},"v":"基本数据类型不能用==来比较（精度丢失）"},{"t":"list_item","d":11,"p":{"lines":[54,55]},"v":"包装数据类型不能用 equals 来判断"},{"t":"list_item","d":11,"p":{"lines":[55,56]},"v":"<strong>使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作</strong>"}]},{"t":"list_item","d":9,"p":{"lines":[56,57]},"v":"使用 BigDecimal 来定义浮点数的值，再进行浮点数的运算操作。"},{"t":"list_item","d":9,"p":{"lines":[57,58]},"v":"推荐使用String作为参数传入BigDecimal构造方法"}]},{"t":"list_item","d":7,"p":{"lines":[58,59]},"v":"使用标准","c":[{"t":"list_item","d":9,"p":{"lines":[59,60]},"v":"所有的 POJO 类属性必须使用包装数据类型。"},{"t":"list_item","d":9,"p":{"lines":[60,61]},"v":"RPC 方法的返回值和参数必须使用包装数据类型。"},{"t":"list_item","d":9,"p":{"lines":[61,62]},"v":"所有的局部变量使用基本数据类型。"}]}]},{"t":"list_item","d":5,"p":{"lines":[63,64]},"v":"Arrays.asList","c":[{"t":"list_item","d":7,"p":{"lines":[64,65]},"v":"Arrays.asList()将数组转换为集合后,底层其实还是数组"},{"t":"list_item","d":7,"p":{"lines":[65,66]},"v":"传递的数组必须是对象数组，而不是基本类型。<br /><strong>当传入一个原生数据类型数组时，Arrays.asList() 的真正得到的参数就不是数组中的元素，而是数组对象本身</strong>"},{"t":"list_item","d":7,"p":{"lines":[66,67]},"v":"使用集合的修改方法:<code>add()、remove()、clear()</code>会抛出异常。<br />Arrays.asList() 方法返回的并不是 java.util.ArrayList ，而是 java.util.Arrays 的一个内部类,"},{"t":"list_item","d":7,"p":{"lines":[67,68]},"v":"如何正确的将数组转换为ArrayList?","c":[{"t":"list_item","d":9,"p":{"lines":[68,69]},"v":"<code>new ArrayList&lt;&gt;(Arrays.asList(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;))</code>(推荐)"},{"t":"list_item","d":9,"p":{"lines":[69,70]},"v":"使用 Java8 的Stream(推荐)"},{"t":"list_item","d":9,"p":{"lines":[70,71]},"v":"使用 Guava(推荐)"},{"t":"list_item","d":9,"p":{"lines":[71,72]},"v":"使用 Apache Commons Collections"},{"t":"list_item","d":9,"p":{"lines":[72,73]},"v":"使用 Java9 的 List.of()方法"}]}]}]},{"t":"heading","d":3,"p":{"lines":[74,75]},"v":"<a href=\"https://www.cnblogs.com/yougewe/p/10125073.html\">反射</a>","c":[{"t":"list_item","d":5,"p":{"lines":[76,77]},"v":"说明"},{"t":"list_item","d":5,"p":{"lines":[77,78]},"v":"原理","c":[{"t":"list_item","d":7,"p":{"lines":[78,79]},"v":"如何获取"},{"t":"list_item","d":7,"p":{"lines":[79,80]},"v":"成员的查找"},{"t":"list_item","d":7,"p":{"lines":[80,81]},"v":"线程安全"},{"t":"list_item","d":7,"p":{"lines":[81,82]},"v":"内存使用（软指针）"},{"t":"list_item","d":7,"p":{"lines":[82,83]},"v":"数据隔离"},{"t":"list_item","d":7,"p":{"lines":[83,84]},"v":"方法执行"}]}]},{"t":"heading","d":3,"p":{"lines":[85,86]},"v":"java泛型","c":[{"t":"list_item","d":5,"p":{"lines":[87,88]},"v":"什么是泛型"},{"t":"list_item","d":5,"p":{"lines":[88,89]},"v":"原理与类型擦除"},{"t":"list_item","d":5,"p":{"lines":[89,90]},"v":"使用方式和场景"},{"t":"list_item","d":5,"p":{"lines":[90,91]},"v":"泛型通配符"},{"t":"list_item","d":5,"p":{"lines":[91,92]},"v":"泛型数组"},{"t":"list_item","d":5,"p":{"lines":[93,94]},"v":"常见问题：","c":[{"t":"list_item","d":7,"p":{"lines":[94,95]},"v":"T ,T extends xxx, ？,？extends xxx <br />和 ？super xxx 的区别？"},{"t":"list_item","d":7,"p":{"lines":[95,96]},"v":"为何不能通过直接通过<code>T[] arr=new T[10]</code>的方式来创建数组<br />如何正确创建泛型数组。"}]}]},{"t":"heading","d":3,"p":{"lines":[97,98]},"v":"String","c":[{"t":"list_item","d":5,"p":{"lines":[99,100]},"v":"String,StringBuilder,StringBuffer 使用场景"},{"t":"list_item","d":5,"p":{"lines":[100,101]},"v":"AbstractStringBilder,建造者"},{"t":"list_item","d":5,"p":{"lines":[101,102]},"v":"synchronized"},{"t":"list_item","d":5,"p":{"lines":[102,103]},"v":"字符串拼接","c":[{"t":"list_item","d":7,"p":{"lines":[103,104]},"v":"编译器优化"},{"t":"list_item","d":7,"p":{"lines":[104,105]},"v":"StringBuilder"}]},{"t":"list_item","d":5,"p":{"lines":[105,106]},"v":"字符串常量池"}]},{"t":"heading","d":3,"p":{"lines":[108,109]},"v":"SPI","c":[{"t":"list_item","d":5,"p":{"lines":[110,111]},"v":"原理","c":[{"t":"list_item","d":7,"p":{"lines":[111,112]},"v":"api"},{"t":"list_item","d":7,"p":{"lines":[112,113]},"v":"spi"}]},{"t":"list_item","d":5,"p":{"lines":[113,114]},"v":"示例","c":[{"t":"list_item","d":7,"p":{"lines":[114,115]},"v":"java spi","c":[{"t":"list_item","d":9,"p":{"lines":[115,116]},"v":"提供的api及使用"},{"t":"list_item","d":9,"p":{"lines":[116,117]},"v":"DriverManager","c":[{"t":"list_item","d":11,"p":{"lines":[117,118]},"v":"mysql自动加载"},{"t":"list_item","d":11,"p":{"lines":[118,119]},"v":"oracle必须手动加载"}]}]},{"t":"list_item","d":7,"p":{"lines":[119,120]},"v":"Spring spi思想","c":[{"t":"list_item","d":9,"p":{"lines":[120,121]},"v":"scan"},{"t":"list_item","d":9,"p":{"lines":[121,122]},"v":"自定义scope"},{"t":"list_item","d":9,"p":{"lines":[122,123]},"v":"自定义标签"}]}]}]},{"t":"heading","d":3,"p":{"lines":[125,126]},"v":"java8新特性","c":[{"t":"list_item","d":5,"p":{"lines":[127,128]},"v":"Stream"},{"t":"list_item","d":5,"p":{"lines":[128,129]},"v":"Function Interface"},{"t":"list_item","d":5,"p":{"lines":[129,130]},"v":"Lambda"},{"t":"list_item","d":5,"p":{"lines":[130,131]},"v":"Optional"},{"t":"list_item","d":5,"p":{"lines":[131,132]},"v":"Data Time-api"}]},{"t":"heading","d":3,"p":{"lines":[133,134]},"v":"语法糖","c":[{"t":"list_item","d":5,"p":{"lines":[135,136]},"v":"双大括号初始化(不推荐)"},{"t":"list_item","d":5,"p":{"lines":[136,137]},"v":"try-with-resources(针对io资源，推荐)"}]}]},{"t":"heading","d":2,"p":{"lines":[138,139],"f":true},"v":"集合 ","c":[{"t":"list_item","d":4,"p":{"lines":[140,141]},"v":"为什么要使用集合"},{"t":"list_item","d":4,"p":{"lines":[141,142]},"v":"HashMap","c":[{"t":"list_item","d":6,"p":{"lines":[142,143]},"v":"1.7","c":[{"t":"list_item","d":8,"p":{"lines":[143,144]},"v":"存储结构：数组+链表"},{"t":"list_item","d":8,"p":{"lines":[144,145]},"v":"扩容机制","c":[{"t":"list_item","d":10,"p":{"lines":[145,146]},"v":"创建新的数组"},{"t":"list_item","d":10,"p":{"lines":[146,147],"f":true},"v":"头插 ","c":[{"t":"list_item","d":12,"p":{"lines":[147,148]},"v":"使用头插可能与缓存的时间局部性原则有关"},{"t":"list_item","d":12,"p":{"lines":[148,149]},"v":"最近访问过的数据下次大概率会再次访问"},{"t":"list_item","d":12,"p":{"lines":[149,150]},"v":"把刚访问过的元素放在链表最前面可以直接被查询到，减少查找次数"}]},{"t":"list_item","d":10,"p":{"lines":[150,151]},"v":"<a href=\"https://juejin.cn/post/6844903554264596487\">resize死循环</a>"},{"t":"list_item","d":10,"p":{"lines":[151,152]},"v":"resize重新计算hash"}]}]},{"t":"list_item","d":6,"p":{"lines":[152,153]},"v":"1.8","c":[{"t":"list_item","d":8,"p":{"lines":[153,154]},"v":"存储结构","c":[{"t":"list_item","d":10,"p":{"lines":[154,155]},"v":"数组+链表+红黑树"},{"t":"list_item","d":10,"p":{"lines":[155,156]},"v":"红黑树结构转换条件","c":[{"t":"list_item","d":12,"p":{"lines":[156,157]},"v":"数组长度64"},{"t":"list_item","d":12,"p":{"lines":[157,158]},"v":"<a href=\"https://juejin.cn/post/6921914880559677447]\">树化阀值8来源</a>"},{"t":"list_item","d":12,"p":{"lines":[158,159]},"v":"退化阀值6"}]}]},{"t":"list_item","d":8,"p":{"lines":[159,160]},"v":"插曲：<a href=\"https://blog.csdn.net/zhichaosong/article/details/88844371\">红黑树由来：2-3树</a>"},{"t":"list_item","d":8,"p":{"lines":[160,161]},"v":"扩容机制","c":[{"t":"list_item","d":10,"p":{"lines":[161,162]},"v":"创建新的数组"},{"t":"list_item","d":10,"p":{"lines":[162,163]},"v":"尾插"},{"t":"list_item","d":10,"p":{"lines":[163,164],"f":true},"v":"<a href=\"https://www.fangzhipeng.com/javainterview/2019/03/11/hashmap-dead-cycle.html\">如何解决的resize死循环</a> ","c":[{"t":"list_item","d":12,"p":{"lines":[164,165],"f":true},"v":"transfer调用 ","c":[{"t":"list_item","d":14,"p":{"lines":[165,166]},"v":"直接将原来transfer()方法中的代码写在自己方法体内，不再调用"}]},{"t":"list_item","d":12,"p":{"lines":[166,167],"f":true},"v":"使用尾插 ","c":[{"t":"list_item","d":14,"p":{"lines":[167,168]},"v":"<strong>扩容后，新数组中的链表顺序依然与旧数组中的链表顺序保持一致</strong>"}]}]},{"t":"list_item","d":10,"p":{"lines":[168,169],"f":true},"v":"<a href=\"https://juejin.cn/post/6844903682664824845\">resize不重新计算hash</a> ","c":[{"t":"list_item","d":12,"p":{"lines":[169,170]},"v":"1.7扩容时需要重新计算哈希值和索引位置"},{"t":"list_item","d":12,"p":{"lines":[170,171]},"v":"1.8并不重新计算哈希值，巧妙地采用和扩容后容量进行&amp;操作来计算新的索引位置。"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[171,172]},"v":"线程不安全","c":[{"t":"list_item","d":8,"p":{"lines":[172,173]},"v":"put的时候导致的多线程数据不一致"}]},{"t":"list_item","d":6,"p":{"lines":[173,174]},"v":"初始化大小"},{"t":"list_item","d":6,"p":{"lines":[174,175]},"v":"扩容时机","c":[{"t":"list_item","d":8,"p":{"lines":[175,176]},"v":"threshold = capacity * loadFactor"},{"t":"list_item","d":8,"p":{"lines":[176,177]},"v":"Size&gt;=threshold"},{"t":"list_item","d":8,"p":{"lines":[177,178]},"v":"<a href=\"https://www.cnblogs.com/aspirant/p/11470928.html\">loadFactor 0.75来源</a>"}]},{"t":"list_item","d":6,"p":{"lines":[178,179]},"v":"put流程"},{"t":"list_item","d":6,"p":{"lines":[179,180]},"v":"容量为什么要2的幂"},{"t":"list_item","d":6,"p":{"lines":[180,181]},"v":"<a href=\"https://mp.weixin.qq.com/s/Zz6mofCtmYpABDL1ap04ow\">遍历方法及性能</a>"},{"t":"list_item","d":6,"p":{"lines":[181,182]},"v":"有什么同步容器/并发容器"},{"t":"list_item","d":6,"p":{"lines":[182,183],"f":true},"v":"HashMap漏洞导致变慢 ","c":[{"t":"list_item","d":8,"p":{"lines":[183,184]},"v":"中间对计算hashcode的成员变量做了修改，内存泄漏"},{"t":"list_item","d":8,"p":{"lines":[184,185]},"v":"hashcode设计不标准，元素落到一个桶中"}]},{"t":"list_item","d":6,"p":{"lines":[185,186],"f":true},"v":"如何为key设计hashcode ","c":[{"t":"list_item","d":8,"p":{"lines":[186,187]},"v":"计算hashCode依赖的值是不可变"},{"t":"list_item","d":8,"p":{"lines":[187,188]},"v":"hashCode必须基于对象的内容生成"},{"t":"list_item","d":8,"p":{"lines":[188,189]},"v":"hashCode产生的散列码最好能均匀分布"}]},{"t":"list_item","d":6,"p":{"lines":[189,190]},"v":"HashMap,HashTable,ConcurrentHashMap区别","c":[{"t":"list_item","d":8,"p":{"lines":[190,191]},"v":"1.7","c":[{"t":"list_item","d":10,"p":{"lines":[191,192]},"v":"三者数据结构"},{"t":"list_item","d":10,"p":{"lines":[192,193]},"v":"同步机制/锁"},{"t":"list_item","d":10,"p":{"lines":[193,194]},"v":"<code>put(null)</code>"}]},{"t":"list_item","d":8,"p":{"lines":[194,195]},"v":"1.8","c":[{"t":"list_item","d":10,"p":{"lines":[195,196]},"v":"三者数据结构"},{"t":"list_item","d":10,"p":{"lines":[196,197]},"v":"同步机制/锁"},{"t":"list_item","d":10,"p":{"lines":[197,198]},"v":"<code>put(null)</code>"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[198,199]},"v":"TreeMap","c":[{"t":"list_item","d":6,"p":{"lines":[199,200]},"v":"底层结构：红黑树"},{"t":"list_item","d":6,"p":{"lines":[200,201]},"v":"红黑树由来：<a href=\"https://blog.csdn.net/zhichaosong/article/details/88844371\">2-3树</a>","c":[{"t":"list_item","d":8,"p":{"lines":[201,202]},"v":"2-节点,3-节点"},{"t":"list_item","d":8,"p":{"lines":[202,203]},"v":"4-节点分解"},{"t":"list_item","d":8,"p":{"lines":[203,204]},"v":"不平衡时融合"}]}]},{"t":"list_item","d":4,"p":{"lines":[204,205]},"v":"ConcurrentHashMap","c":[{"t":"list_item","d":6,"p":{"lines":[205,206]},"v":"<a href=\"https://www.cnblogs.com/ITtangtang/p/3948786.html\">1.7</a>","c":[{"t":"list_item","d":8,"p":{"lines":[206,207]},"v":"数据结构:分段锁+数组+链表"},{"t":"list_item","d":8,"p":{"lines":[207,208]},"v":"同步机制:","c":[{"t":"list_item","d":10,"p":{"lines":[208,209]},"v":"<strong>segment分段锁</strong> 粒度为一段(几个hash槽)<br />分段锁继承了ReentrantLock"},{"t":"list_item","d":10,"p":{"lines":[209,210]},"v":"尝试获取锁存在并发，竞争，阻塞"}]},{"t":"list_item","d":8,"p":{"lines":[210,211]},"v":"键值对:HashEntry"},{"t":"list_item","d":8,"p":{"lines":[211,212]},"v":"操作","c":[{"t":"list_item","d":10,"p":{"lines":[212,213]},"v":"size"},{"t":"list_item","d":10,"p":{"lines":[213,214]},"v":"put"},{"t":"list_item","d":10,"p":{"lines":[214,215]},"v":"get"}]}]},{"t":"list_item","d":6,"p":{"lines":[215,216]},"v":"<a href=\"https://blog.csdn.net/programmer_at/article/details/79715177\">1.8</a>","c":[{"t":"list_item","d":8,"p":{"lines":[216,217]},"v":"数据结构:数组+链表/红黑树"},{"t":"list_item","d":8,"p":{"lines":[217,218]},"v":"同步机制","c":[{"t":"list_item","d":10,"p":{"lines":[218,219]},"v":"hash槽。减小了加锁粒度"},{"t":"list_item","d":10,"p":{"lines":[219,220],"f":true},"v":"CAS+synchronized ","c":[{"t":"list_item","d":12,"p":{"lines":[220,221]},"v":"CAS失败自旋保证成功"},{"t":"list_item","d":12,"p":{"lines":[221,222]},"v":"再失败就synchronized"}]},{"t":"list_item","d":10,"p":{"lines":[222,223],"f":true},"v":"<a href=\"https://www.cnblogs.com/aspirant/p/8623864.html\">使用synchronized原因</a> ","c":[{"t":"list_item","d":12,"p":{"lines":[223,224]},"v":"锁粒度降低了，synchronized并不比ReentrantLock差"},{"t":"list_item","d":12,"p":{"lines":[224,225]},"v":"synchronized优化空间大"},{"t":"list_item","d":12,"p":{"lines":[225,226]},"v":"大量数据操作，ReentrantLock开销较多内存"}]}]},{"t":"list_item","d":8,"p":{"lines":[226,227]},"v":"键值对：node"},{"t":"list_item","d":8,"p":{"lines":[227,228]},"v":"操作","c":[{"t":"list_item","d":10,"p":{"lines":[228,229]},"v":"size"},{"t":"list_item","d":10,"p":{"lines":[229,230]},"v":"put"},{"t":"list_item","d":10,"p":{"lines":[230,231]},"v":"get"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[231,232]},"v":"<a href=\"https://www.jianshu.com/p/8f4f58b4b8ab\">LinkedHashMap</a>","c":[{"t":"list_item","d":6,"p":{"lines":[232,233]},"v":"结构：HashMap+双向链表"},{"t":"list_item","d":6,"p":{"lines":[233,234]},"v":"两种模式(accessOrder变量)","c":[{"t":"list_item","d":8,"p":{"lines":[234,235]},"v":"插入顺序模式(false)"},{"t":"list_item","d":8,"p":{"lines":[235,236]},"v":"访问顺序模式(true)","c":[{"t":"list_item","d":10,"p":{"lines":[236,237]},"v":"<code>get</code>"},{"t":"list_item","d":10,"p":{"lines":[237,238]},"v":"重排序"}]}]},{"t":"list_item","d":6,"p":{"lines":[238,239]},"v":"扩容:遍历链表"},{"t":"list_item","d":6,"p":{"lines":[239,240]},"v":"实现LRU","c":[{"t":"list_item","d":8,"p":{"lines":[240,241]},"v":"构造器:传入capacity"},{"t":"list_item","d":8,"p":{"lines":[241,242]},"v":"removeEldestEntry:<code>return size() &gt; capacity;</code>"}]}]},{"t":"list_item","d":4,"p":{"lines":[243,244]},"v":"ArrayList","c":[{"t":"list_item","d":6,"p":{"lines":[244,245]},"v":"底层结构：数组"},{"t":"list_item","d":6,"p":{"lines":[245,246]},"v":"初始大小与扩容机制"},{"t":"list_item","d":6,"p":{"lines":[246,247]},"v":"RandomAccess 接口"},{"t":"list_item","d":6,"p":{"lines":[247,248]},"v":"<code>System.arraycopy()</code> 和 <code>Arrays.copyOf()</code>方法"},{"t":"list_item","d":6,"p":{"lines":[248,249]},"v":"有什么同步容器/并发容器"},{"t":"list_item","d":6,"p":{"lines":[249,250]},"v":"<strong><a href=\"https://juejin.cn/post/6879291161274482695\">fail-fast、fail-safe机制</a></strong>"}]},{"t":"list_item","d":4,"p":{"lines":[250,251]},"v":"LinkedList","c":[{"t":"list_item","d":6,"p":{"lines":[251,252]},"v":"底层结构：双向链表"}]},{"t":"list_item","d":4,"p":{"lines":[252,253]},"v":"Set","c":[{"t":"list_item","d":6,"p":{"lines":[253,254]},"v":"comparable 和 Comparator 的区别"},{"t":"list_item","d":6,"p":{"lines":[254,255]},"v":"无序性和不可重复性的含义是什么"},{"t":"list_item","d":6,"p":{"lines":[255,256]},"v":"有什么同步容器/并发容器"},{"t":"list_item","d":6,"p":{"lines":[256,257]},"v":"HashMap和HashSet"},{"t":"list_item","d":6,"p":{"lines":[257,258]},"v":"TreeMap和TreeSet"}]},{"t":"list_item","d":4,"p":{"lines":[258,259]},"v":"集合比较问题","c":[{"t":"list_item","d":6,"p":{"lines":[259,260]},"v":"List,Set,Map 三者的区别？"},{"t":"list_item","d":6,"p":{"lines":[260,261]},"v":"Arraylist 和 Vector 的区别?"},{"t":"list_item","d":6,"p":{"lines":[261,262]},"v":"Arraylist 与 LinkedList 区别?"},{"t":"list_item","d":6,"p":{"lines":[262,263]},"v":"ConcurrentHashMap 和 Hashtable 的区别"},{"t":"list_item","d":6,"p":{"lines":[263,264]},"v":"比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"},{"t":"list_item","d":6,"p":{"lines":[264,265]},"v":"HashMap和HashTable区别"},{"t":"list_item","d":6,"p":{"lines":[265,266]},"v":"HashMap与HashSet区别（HashSet底层基于HashMap）"},{"t":"list_item","d":6,"p":{"lines":[266,267]},"v":"HashMap和TreeMap区别"}]},{"t":"list_item","d":4,"p":{"lines":[268,269]},"v":"<a href=\"https://www.jianshu.com/p/8bc28d6b0a5e\">其他重要问题</a>"}]},{"t":"heading","d":2,"p":{"lines":[270,271],"f":true},"v":"多线程 ","c":[{"t":"list_item","d":4,"p":{"lines":[272,273]},"v":"并发基础","c":[{"t":"list_item","d":6,"p":{"lines":[273,274]},"v":"<a href=\"https://segmentfault.com/a/1190000037589073\">创建线程的方式</a>"},{"t":"list_item","d":6,"p":{"lines":[274,275]},"v":"调用<code>start()</code>和<code>run()</code>方法区别"},{"t":"list_item","d":6,"p":{"lines":[275,276]},"v":"停止线程：interrupt","c":[{"t":"list_item","d":8,"p":{"lines":[276,277]},"v":"原理"},{"t":"list_item","d":8,"p":{"lines":[277,278]},"v":"正确的停止方式"},{"t":"list_item","d":8,"p":{"lines":[278,279]},"v":"错误的停止方式","c":[{"t":"list_item","d":10,"p":{"lines":[279,280]},"v":"被弃用的stop,suspend和resume方法"},{"t":"list_item","d":10,"p":{"lines":[280,281]},"v":"用volatile设置标记位"}]}]},{"t":"list_item","d":6,"p":{"lines":[281,282]},"v":"重要方法","c":[{"t":"list_item","d":8,"p":{"lines":[282,283]},"v":"Object(三个方法都要在synchronized内)","c":[{"t":"list_item","d":10,"p":{"lines":[283,284]},"v":"wait"},{"t":"list_item","d":10,"p":{"lines":[284,285]},"v":"notify"},{"t":"list_item","d":10,"p":{"lines":[285,286]},"v":"notifyAll"}]},{"t":"list_item","d":8,"p":{"lines":[286,287]},"v":"Thread","c":[{"t":"list_item","d":10,"p":{"lines":[287,288]},"v":"sleep"},{"t":"list_item","d":10,"p":{"lines":[288,289]},"v":"join"},{"t":"list_item","d":10,"p":{"lines":[289,290]},"v":"yield"}]}]},{"t":"list_item","d":6,"p":{"lines":[290,291]},"v":"yield和sleep区别"},{"t":"list_item","d":6,"p":{"lines":[291,292]},"v":"java线程状态的切换<br /> 延伸：操作系统进程状态的切换"},{"t":"list_item","d":6,"p":{"lines":[292,293]},"v":"线程属性"},{"t":"list_item","d":6,"p":{"lines":[293,294]},"v":"线程的未捕获异常处理"},{"t":"list_item","d":6,"p":{"lines":[294,295]},"v":"线程组","c":[{"t":"list_item","d":8,"p":{"lines":[295,296]},"v":"结构","c":[{"t":"list_item","d":10,"p":{"lines":[296,297]},"v":"线程组是一个树状的结构，每个线程组下面可以有多个线程或者线程组"},{"t":"list_item","d":10,"p":{"lines":[297,298]},"v":"默认将父线程（当前执行new Thread的线程）线程组设置为自己的线程组。"}]},{"t":"list_item","d":8,"p":{"lines":[298,299]},"v":"线程组的优先级会限制线程的优先级"},{"t":"list_item","d":8,"p":{"lines":[299,300]},"v":"作用","c":[{"t":"list_item","d":10,"p":{"lines":[300,301]},"v":"统一控制线程的优先级"},{"t":"list_item","d":10,"p":{"lines":[301,302]},"v":"检查线程的权限的作用。"},{"t":"list_item","d":10,"p":{"lines":[302,303]},"v":"线程组统一异常处理"}]}]},{"t":"list_item","d":6,"p":{"lines":[303,304]},"v":"常见问题","c":[{"t":"list_item","d":8,"p":{"lines":[304,305]},"v":"并发与并行区别"},{"t":"list_item","d":8,"p":{"lines":[305,306]},"v":"为什么要使用多线程"},{"t":"list_item","d":8,"p":{"lines":[306,307]},"v":"sleep() 方法和 wait() 方法区别和共同点"}]}]},{"t":"list_item","d":4,"p":{"lines":[308,309],"f":true},"v":"<strong>并发编程三大特性</strong> ","c":[{"t":"list_item","d":6,"p":{"lines":[309,310]},"v":"原子性"},{"t":"list_item","d":6,"p":{"lines":[310,311]},"v":"可见性"},{"t":"list_item","d":6,"p":{"lines":[311,312]},"v":"有序性"}]},{"t":"list_item","d":4,"p":{"lines":[313,314]},"v":"JMM","c":[{"t":"list_item","d":6,"p":{"lines":[314,315]},"v":"基础结构"},{"t":"list_item","d":6,"p":{"lines":[315,316]},"v":"JMM与Java内存区域划分的区别与联系"},{"t":"list_item","d":6,"p":{"lines":[316,317],"f":true},"v":"JMM原子操作 ","c":[{"t":"list_item","d":8,"p":{"lines":[317,318]},"v":"read(读取）:从主内存读取数据"},{"t":"list_item","d":8,"p":{"lines":[318,319]},"v":"load(载入）:将主内存读取到的数据写入工作内存"},{"t":"list_item","d":8,"p":{"lines":[319,320]},"v":"use(使用）:从工作内存读取数据来计算"},{"t":"list_item","d":8,"p":{"lines":[320,321]},"v":"assign(赋值）:将计算好的值重新赋值到工作内存中"},{"t":"list_item","d":8,"p":{"lines":[321,322]},"v":"store(存储）:将工作内存数据写入主内存"},{"t":"list_item","d":8,"p":{"lines":[322,323]},"v":"write(写入）:将store过去的变量值赋值给主内存中的变量"},{"t":"list_item","d":8,"p":{"lines":[323,324]},"v":"lock(锁定）:将主内存变量加锁，标识为线程独占状态。其他线程将无法读或写"},{"t":"list_item","d":8,"p":{"lines":[324,325]},"v":"unlock(解锁）:将主内存变量解锁，解锁后其他线程可以锁定该变量"}]},{"t":"list_item","d":6,"p":{"lines":[325,326]},"v":"重排序","c":[{"t":"list_item","d":8,"p":{"lines":[326,327],"f":true},"v":"组成 ","c":[{"t":"list_item","d":10,"p":{"lines":[327,328]},"v":"编译器优化重排"},{"t":"list_item","d":10,"p":{"lines":[328,329]},"v":"指令并行重排"},{"t":"list_item","d":10,"p":{"lines":[329,330]},"v":"内存系统重排"}]},{"t":"list_item","d":8,"p":{"lines":[330,331]},"v":"编程规则","c":[{"t":"list_item","d":10,"p":{"lines":[331,332]},"v":"as-if-serial"},{"t":"list_item","d":10,"p":{"lines":[332,333]},"v":"happens-before"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[334,335]},"v":"<a href=\"https://zhuanlan.zhihu.com/p/137193948\">volatile</a>","c":[{"t":"list_item","d":6,"p":{"lines":[335,336]},"v":"保证内存可见性","c":[{"t":"list_item","d":8,"p":{"lines":[336,337]},"v":"说明"},{"t":"list_item","d":8,"p":{"lines":[337,338]},"v":"原理","c":[{"t":"list_item","d":10,"p":{"lines":[338,339]},"v":"MESI缓存一致性协议"},{"t":"list_item","d":10,"p":{"lines":[339,340]},"v":"cpu总线嗅探机制"},{"t":"list_item","d":10,"p":{"lines":[340,341]},"v":"lock"}]},{"t":"list_item","d":8,"p":{"lines":[341,342]},"v":"总线风暴"}]},{"t":"list_item","d":6,"p":{"lines":[342,343]},"v":"禁止重排序","c":[{"t":"list_item","d":8,"p":{"lines":[343,344]},"v":"说明"},{"t":"list_item","d":8,"p":{"lines":[344,345],"f":true},"v":"原理(内存屏障) ","c":[{"t":"list_item","d":10,"p":{"lines":[345,346]},"v":"volatile写","c":[{"t":"list_item","d":12,"p":{"lines":[346,347]},"v":"前面:storestore"},{"t":"list_item","d":12,"p":{"lines":[347,348]},"v":"后面:sotreload"}]},{"t":"list_item","d":10,"p":{"lines":[348,349]},"v":"volatile写","c":[{"t":"list_item","d":12,"p":{"lines":[349,350]},"v":"后面1:loadload"},{"t":"list_item","d":12,"p":{"lines":[350,351]},"v":"后面2:loadstore"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[351,352]},"v":"不保证原子性：","c":[{"t":"list_item","d":8,"p":{"lines":[352,353]},"v":"原因"},{"t":"list_item","d":8,"p":{"lines":[353,354]},"v":"解决","c":[{"t":"list_item","d":10,"p":{"lines":[354,355]},"v":"synchronized"},{"t":"list_item","d":10,"p":{"lines":[355,356]},"v":"Atomic(CAS)"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[357,358]},"v":"锁的变迁","c":[{"t":"list_item","d":6,"p":{"lines":[358,359]},"v":"jdk1.5之前:synchronized重量锁"},{"t":"list_item","d":6,"p":{"lines":[359,360]},"v":"jdk1.5","c":[{"t":"list_item","d":8,"p":{"lines":[360,361]},"v":"原因"},{"t":"list_item","d":8,"p":{"lines":[361,362]},"v":"变化:增加","c":[{"t":"list_item","d":10,"p":{"lines":[362,363]},"v":"Lock锁"},{"t":"list_item","d":10,"p":{"lines":[363,364]},"v":"并发容器"},{"t":"list_item","d":10,"p":{"lines":[364,365]},"v":"线程池"}]},{"t":"list_item","d":8,"p":{"lines":[365,366]},"v":"依据原理","c":[{"t":"list_item","d":10,"p":{"lines":[366,367]},"v":"Atomic--UnSafe--CAS"},{"t":"list_item","d":10,"p":{"lines":[367,368]},"v":"AQS"},{"t":"list_item","d":10,"p":{"lines":[368,369]},"v":"LockSupport"},{"t":"list_item","d":10,"p":{"lines":[369,370]},"v":"volatile"}]}]},{"t":"list_item","d":6,"p":{"lines":[370,371]},"v":"jdk1.6","c":[{"t":"list_item","d":8,"p":{"lines":[371,372]},"v":"变化:synchronized锁的升级"},{"t":"list_item","d":8,"p":{"lines":[372,373]},"v":"原因"}]},{"t":"list_item","d":6,"p":{"lines":[373,374]},"v":"jdk1.8:增加StampedLock"}]},{"t":"list_item","d":4,"p":{"lines":[375,376]},"v":"synchronized","c":[{"t":"list_item","d":6,"p":{"lines":[376,377]},"v":"3种使用方法","c":[{"t":"list_item","d":8,"p":{"lines":[377,378]},"v":"代码块","c":[{"t":"list_item","d":10,"p":{"lines":[378,379]},"v":"自己指定对象锁"},{"t":"list_item","d":10,"p":{"lines":[379,380]},"v":"<strong>底层原理</strong>：","c":[{"t":"list_item","d":12,"p":{"lines":[380,381]},"v":"monitorenter"},{"t":"list_item","d":12,"p":{"lines":[381,382]},"v":"monitorexit"},{"t":"list_item","d":12,"p":{"lines":[382,383]},"v":"程序计数器"}]}]},{"t":"list_item","d":8,"p":{"lines":[383,384]},"v":"成员方法","c":[{"t":"list_item","d":10,"p":{"lines":[384,385]},"v":"this对象锁"},{"t":"list_item","d":10,"p":{"lines":[385,386]},"v":"<strong>底层原理</strong>：ACC_SYNCHRONIZED"}]},{"t":"list_item","d":8,"p":{"lines":[386,387]},"v":"静态方法","c":[{"t":"list_item","d":10,"p":{"lines":[387,388]},"v":".class类锁"},{"t":"list_item","d":10,"p":{"lines":[388,389]},"v":"<strong>底层原理</strong>：ACC_SYNCHRONIZED，ACC_STATIC"}]},{"t":"list_item","d":8,"p":{"lines":[389,390]},"v":"注意：构造方法本身就属于线程安全的，不存在同步的构造方法一说。<br />不能加synchronized"}]},{"t":"list_item","d":6,"p":{"lines":[390,391]},"v":"锁的升级(不可逆)","c":[{"t":"list_item","d":8,"p":{"lines":[391,392]},"v":"无锁(CAS)"},{"t":"list_item","d":8,"p":{"lines":[392,393]},"v":"偏向锁","c":[{"t":"list_item","d":10,"p":{"lines":[393,394]},"v":"原理"},{"t":"list_item","d":10,"p":{"lines":[394,395]},"v":"锁的性质"},{"t":"list_item","d":10,"p":{"lines":[395,396]},"v":"对象头中的内容"},{"t":"list_item","d":10,"p":{"lines":[396,397]},"v":"升级过程"}]},{"t":"list_item","d":8,"p":{"lines":[397,398]},"v":"轻量锁","c":[{"t":"list_item","d":10,"p":{"lines":[398,399]},"v":"原理"},{"t":"list_item","d":10,"p":{"lines":[399,400]},"v":"锁的性质"},{"t":"list_item","d":10,"p":{"lines":[400,401]},"v":"对象头中的内容"},{"t":"list_item","d":10,"p":{"lines":[401,402]},"v":"升级过程"}]},{"t":"list_item","d":8,"p":{"lines":[402,403]},"v":"重量锁","c":[{"t":"list_item","d":10,"p":{"lines":[403,404]},"v":"原理"},{"t":"list_item","d":10,"p":{"lines":[404,405]},"v":"锁的性质"},{"t":"list_item","d":10,"p":{"lines":[405,406]},"v":"对象头中的内容"},{"t":"list_item","d":10,"p":{"lines":[406,407]},"v":"阻塞的好处(cpu)与代价(内核态)"}]}]},{"t":"list_item","d":6,"p":{"lines":[407,408]},"v":"特性保证","c":[{"t":"list_item","d":8,"p":{"lines":[408,409],"f":true},"v":"可见性 ","c":[{"t":"list_item","d":10,"p":{"lines":[409,410]},"v":"获得锁，清空工作内存"},{"t":"list_item","d":10,"p":{"lines":[410,411]},"v":"从主内存拷贝共享变量最新的值到工作内存成为副本"},{"t":"list_item","d":10,"p":{"lines":[411,412]},"v":"执行代码，将修改后的副本的值刷新回主内存中，线程释放锁"},{"t":"list_item","d":10,"p":{"lines":[412,413]},"v":"而获取不到锁的线程会阻塞等待，所以变量的值肯定一直都是最新的。"}]},{"t":"list_item","d":8,"p":{"lines":[413,414],"f":true},"v":"原子性 ","c":[{"t":"list_item","d":10,"p":{"lines":[414,415]},"v":"单一线程持有"},{"t":"list_item","d":10,"p":{"lines":[415,416]},"v":"可见性的强制刷新"}]},{"t":"list_item","d":8,"p":{"lines":[416,417],"f":true},"v":"有序性 ","c":[{"t":"list_item","d":10,"p":{"lines":[417,418]},"v":"as-if-serial"},{"t":"list_item","d":10,"p":{"lines":[418,419]},"v":"happends-before"}]}]},{"t":"list_item","d":6,"p":{"lines":[419,420],"f":true},"v":"synchronized 和 ReentrantLock 的区别 ","c":[{"t":"list_item","d":8,"p":{"lines":[420,421]},"v":"jvm-api层面"},{"t":"list_item","d":8,"p":{"lines":[421,422]},"v":"是否可中断"},{"t":"list_item","d":8,"p":{"lines":[422,423]},"v":"公平非公平"},{"t":"list_item","d":8,"p":{"lines":[423,424]},"v":"锁绑定多个条件"}]},{"t":"list_item","d":6,"p":{"lines":[424,425]},"v":"synchronized 和 volatile 的区别"}]},{"t":"list_item","d":4,"p":{"lines":[426,427]},"v":"CAS","c":[{"t":"list_item","d":6,"p":{"lines":[427,428]},"v":"乐观锁与悲观锁"},{"t":"list_item","d":6,"p":{"lines":[428,429]},"v":"概念"},{"t":"list_item","d":6,"p":{"lines":[429,430]},"v":"底层原理"},{"t":"list_item","d":6,"p":{"lines":[430,431]},"v":"CAS的应用：UnSafe和Atomic"},{"t":"list_item","d":6,"p":{"lines":[431,432]},"v":"问题","c":[{"t":"list_item","d":8,"p":{"lines":[432,433]},"v":"ABA问题","c":[{"t":"list_item","d":10,"p":{"lines":[433,434]},"v":"AtomicStampedReference"},{"t":"list_item","d":10,"p":{"lines":[434,435]},"v":"AtomicMarkableReference"}]},{"t":"list_item","d":8,"p":{"lines":[435,436]},"v":"循环时间长开销大","c":[{"t":"list_item","d":10,"p":{"lines":[436,437]},"v":"解决思路是让JVM支持处理器提供的pause指令"}]},{"t":"list_item","d":8,"p":{"lines":[437,438]},"v":"只能保证一个共享变量的原子操作","c":[{"t":"list_item","d":10,"p":{"lines":[438,439]},"v":"使用JDK 1.5开始就提供的AtomicReference类保证对象之间的原子性，<br />把多个变量放到一个对象里面进行CAS操作；"},{"t":"list_item","d":10,"p":{"lines":[439,440]},"v":"使用锁。锁内的临界区代码可以保证只有当前线程能操作。"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[441,442]},"v":"AQS","c":[{"t":"list_item","d":6,"p":{"lines":[442,443]},"v":"概念"},{"t":"list_item","d":6,"p":{"lines":[443,444]},"v":"底层","c":[{"t":"list_item","d":8,"p":{"lines":[444,445]},"v":"Unsafe(提供CAS操作)"},{"t":"list_item","d":8,"p":{"lines":[445,446]},"v":"LockSupport(提供park/unpark操作)"}]},{"t":"list_item","d":6,"p":{"lines":[446,447]},"v":"CLH数据结构"},{"t":"list_item","d":6,"p":{"lines":[447,448]},"v":"资源共享模式/同步方式"},{"t":"list_item","d":6,"p":{"lines":[448,449]},"v":"<strong>模版设计模式</strong>"},{"t":"list_item","d":6,"p":{"lines":[449,450]},"v":"源码分析","c":[{"t":"list_item","d":8,"p":{"lines":[450,451]},"v":"获取资源流程","c":[{"t":"list_item","d":10,"p":{"lines":[451,452]},"v":"acquire"},{"t":"list_item","d":10,"p":{"lines":[452,453]},"v":"acquireShared"}]},{"t":"list_item","d":8,"p":{"lines":[453,454]},"v":"释放资源流程","c":[{"t":"list_item","d":10,"p":{"lines":[454,455]},"v":"release"},{"t":"list_item","d":10,"p":{"lines":[455,456]},"v":"releaseShared"}]}]},{"t":"list_item","d":6,"p":{"lines":[456,457]},"v":"两个队列","c":[{"t":"list_item","d":8,"p":{"lines":[457,458]},"v":"CLH队列"},{"t":"list_item","d":8,"p":{"lines":[458,459]},"v":"条件队列"}]},{"t":"list_item","d":6,"p":{"lines":[459,460]},"v":"AQS组件","c":[{"t":"list_item","d":8,"p":{"lines":[460,461]},"v":"AQS实现的锁(实现Lock接口)","c":[{"t":"list_item","d":10,"p":{"lines":[461,462]},"v":"ReentrantLock","c":[{"t":"list_item","d":12,"p":{"lines":[462,463]},"v":"内部类Sync继承AQS"},{"t":"list_item","d":12,"p":{"lines":[463,464]},"v":"Condition底层使用LockSupport"}]},{"t":"list_item","d":10,"p":{"lines":[464,465]},"v":"ReentrantReadWriteLock","c":[{"t":"list_item","d":12,"p":{"lines":[465,466]},"v":"读锁和写锁都有继承AQS的内部类Sync"}]}]},{"t":"list_item","d":8,"p":{"lines":[466,467]},"v":"AQS通信工具类","c":[{"t":"list_item","d":10,"p":{"lines":[467,468]},"v":"Semaphore","c":[{"t":"list_item","d":12,"p":{"lines":[468,469]},"v":"内部有一个继承了AQS的同步器Sync"}]},{"t":"list_item","d":10,"p":{"lines":[469,470]},"v":"CountDownLatch","c":[{"t":"list_item","d":12,"p":{"lines":[470,471]},"v":"内部有一个继承了AQS的同步器Sync"}]},{"t":"list_item","d":10,"p":{"lines":[471,472]},"v":"CyclicBarrier","c":[{"t":"list_item","d":12,"p":{"lines":[472,473]},"v":"内部使用ReentrantLock"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[473,474]},"v":"其他","c":[{"t":"list_item","d":8,"p":{"lines":[474,475]},"v":"AOS"},{"t":"list_item","d":8,"p":{"lines":[475,476]},"v":"AQLS"}]}]},{"t":"list_item","d":4,"p":{"lines":[477,478]},"v":"Atomic","c":[{"t":"list_item","d":6,"p":{"lines":[478,479]},"v":"组成","c":[{"t":"list_item","d":8,"p":{"lines":[479,480]},"v":"基本类型"},{"t":"list_item","d":8,"p":{"lines":[480,481]},"v":"数组类型"},{"t":"list_item","d":8,"p":{"lines":[481,482]},"v":"引用类型"},{"t":"list_item","d":8,"p":{"lines":[482,483]},"v":"对象的属性修改类型"}]},{"t":"list_item","d":6,"p":{"lines":[483,484]},"v":"AtomicInteger","c":[{"t":"list_item","d":8,"p":{"lines":[484,485]},"v":"示例"},{"t":"list_item","d":8,"p":{"lines":[485,486]},"v":"基本原理"}]}]},{"t":"list_item","d":4,"p":{"lines":[487,488]},"v":"LockSupport","c":[{"t":"list_item","d":6,"p":{"lines":[488,489]},"v":"是什么"},{"t":"list_item","d":6,"p":{"lines":[489,490]},"v":"使用原理"},{"t":"list_item","d":6,"p":{"lines":[490,491]},"v":"<a href=\"https://blog.csdn.net/saintyyu/article/details/107426428\">底层原理</a>"},{"t":"list_item","d":6,"p":{"lines":[491,492]},"v":"<a href=\"https://www.pdai.tech/md/java/thread/java-thread-x-lock-LockSupport.html\">常见问题</a>","c":[{"t":"list_item","d":8,"p":{"lines":[492,493]},"v":"park底层使用的是<code>UNSAFE.park</code>"},{"t":"list_item","d":8,"p":{"lines":[493,494]},"v":"为什么LockSupport也是核心基础类? AQS框架借助于两个类：Unsafe(提供CAS操作)和LockSupport(提供park/unpark操作)"},{"t":"list_item","d":8,"p":{"lines":[494,495]},"v":"写出分别通过wait/notify和LockSupport的park/unpark实现同步?"},{"t":"list_item","d":8,"p":{"lines":[495,496]},"v":"LockSupport.park()会释放锁资源吗? 那么Condition.await()呢?"},{"t":"list_item","d":8,"p":{"lines":[496,497]},"v":"Thread.sleep()、Object.wait()、Condition.await()、LockSupport.park()的区别? <strong>重点</strong>"},{"t":"list_item","d":8,"p":{"lines":[497,498]},"v":"如果在wait()之前执行了notify()会怎样? 如果在park()之前执行了unpark()会怎样?"}]}]},{"t":"list_item","d":4,"p":{"lines":[499,500]},"v":"锁、通信工具类<br />和底层使用","c":[{"t":"list_item","d":6,"p":{"lines":[500,501]},"v":"AQS实现的锁(实现Lock接口)","c":[{"t":"list_item","d":8,"p":{"lines":[501,502]},"v":"ReentrantLock","c":[{"t":"list_item","d":10,"p":{"lines":[502,503]},"v":"内部类Sync继承AQS"},{"t":"list_item","d":10,"p":{"lines":[503,504]},"v":"Condition底层使用LockSupport"}]},{"t":"list_item","d":8,"p":{"lines":[504,505]},"v":"ReentrantReadWriteLock","c":[{"t":"list_item","d":10,"p":{"lines":[505,506]},"v":"读锁和写锁都有继承AQS的内部类Sync"}]}]},{"t":"list_item","d":6,"p":{"lines":[506,507]},"v":"AQS通信工具类","c":[{"t":"list_item","d":8,"p":{"lines":[507,508]},"v":"Semaphore","c":[{"t":"list_item","d":10,"p":{"lines":[508,509]},"v":"内部有一个继承了AQS的同步器Sync"}]},{"t":"list_item","d":8,"p":{"lines":[509,510]},"v":"CountDownLatch","c":[{"t":"list_item","d":10,"p":{"lines":[510,511]},"v":"内部有一个继承了AQS的同步器Sync"}]},{"t":"list_item","d":8,"p":{"lines":[511,512]},"v":"CyclicBarrier","c":[{"t":"list_item","d":10,"p":{"lines":[512,513]},"v":"内部使用ReentrantLock"}]}]},{"t":"list_item","d":6,"p":{"lines":[513,514]},"v":"非AQS的通信工具类","c":[{"t":"list_item","d":8,"p":{"lines":[514,515]},"v":"Exchanger","c":[{"t":"list_item","d":10,"p":{"lines":[515,516]},"v":"LockSupport"},{"t":"list_item","d":10,"p":{"lines":[516,517]},"v":"CAS(Atomic)"}]},{"t":"list_item","d":8,"p":{"lines":[517,518]},"v":"Phaser","c":[{"t":"list_item","d":10,"p":{"lines":[518,519]},"v":"有使用LockSupport"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[520,521]},"v":"锁的种类","c":[{"t":"list_item","d":6,"p":{"lines":[521,522]},"v":"锁的有无","c":[{"t":"list_item","d":8,"p":{"lines":[522,523]},"v":"乐观锁"},{"t":"list_item","d":8,"p":{"lines":[523,524]},"v":"悲观锁"}]},{"t":"list_item","d":6,"p":{"lines":[524,525]},"v":"synchronized的锁","c":[{"t":"list_item","d":8,"p":{"lines":[525,526]},"v":"无锁"},{"t":"list_item","d":8,"p":{"lines":[526,527]},"v":"偏向锁"},{"t":"list_item","d":8,"p":{"lines":[527,528]},"v":"轻量锁"},{"t":"list_item","d":8,"p":{"lines":[528,529]},"v":"重量锁"}]},{"t":"list_item","d":6,"p":{"lines":[529,530]},"v":"锁的性质分类","c":[{"t":"list_item","d":8,"p":{"lines":[530,531]},"v":"可重入锁和非可重入锁","c":[{"t":"list_item","d":10,"p":{"lines":[531,532]},"v":"表现"},{"t":"list_item","d":10,"p":{"lines":[532,533]},"v":"原理：粒度（加锁范围）"},{"t":"list_item","d":10,"p":{"lines":[533,534],"f":true},"v":"实例 ","c":[{"t":"list_item","d":12,"p":{"lines":[534,535]},"v":"可重入锁"},{"t":"list_item","d":12,"p":{"lines":[535,536]},"v":"不可重入锁"}]}]},{"t":"list_item","d":8,"p":{"lines":[536,537],"f":true},"v":"公平锁与非公平锁 ","c":[{"t":"list_item","d":10,"p":{"lines":[537,538]},"v":"表现"},{"t":"list_item","d":10,"p":{"lines":[538,539]},"v":"原理"},{"t":"list_item","d":10,"p":{"lines":[539,540]},"v":"实例","c":[{"t":"list_item","d":12,"p":{"lines":[540,541]},"v":"公平锁"},{"t":"list_item","d":12,"p":{"lines":[541,542]},"v":"非公平锁"},{"t":"list_item","d":12,"p":{"lines":[542,543]},"v":"可以切换:ReentrantLock"}]}]},{"t":"list_item","d":8,"p":{"lines":[543,544],"f":true},"v":"读写锁和排它锁 ","c":[{"t":"list_item","d":10,"p":{"lines":[544,545]},"v":"表现"},{"t":"list_item","d":10,"p":{"lines":[545,546]},"v":"原理"},{"t":"list_item","d":10,"p":{"lines":[546,547]},"v":"实例","c":[{"t":"list_item","d":12,"p":{"lines":[547,548]},"v":"读写锁"},{"t":"list_item","d":12,"p":{"lines":[548,549]},"v":"排它锁"}]}]},{"t":"list_item","d":8,"p":{"lines":[549,550]},"v":"是否可中断"}]}]},{"t":"list_item","d":4,"p":{"lines":[551,552]},"v":"并发集合容器","c":[{"t":"list_item","d":6,"p":{"lines":[552,553]},"v":"<a href=\"https://juejin.cn/post/6844903954719965192\">什么是同步容器和并发容器</a>","c":[{"t":"list_item","d":8,"p":{"lines":[553,554]},"v":"同步容器：synchronized"},{"t":"list_item","d":8,"p":{"lines":[554,555]},"v":"并发容器：AQS锁、CAS、COW、分段锁"}]},{"t":"list_item","d":6,"p":{"lines":[555,556]},"v":"同步容器","c":[{"t":"list_item","d":8,"p":{"lines":[556,557]},"v":"vector:在面对多线程下的复合操作的时候也是需要通过客户端加锁的方式保证原子性"},{"t":"list_item","d":8,"p":{"lines":[557,558]},"v":"HashTable"},{"t":"list_item","d":8,"p":{"lines":[558,559]},"v":"Collections下的各种 SynchronizedXXX"}]},{"t":"list_item","d":6,"p":{"lines":[559,560]},"v":"并发容器","c":[{"t":"list_item","d":8,"p":{"lines":[560,561]},"v":"Queue","c":[{"t":"list_item","d":10,"p":{"lines":[561,562]},"v":"BlockingQueue","c":[{"t":"list_item","d":12,"p":{"lines":[562,563]},"v":"ArrayBlockingQueue"},{"t":"list_item","d":12,"p":{"lines":[563,564]},"v":"LinkedBlockingQueue"},{"t":"list_item","d":12,"p":{"lines":[564,565]},"v":"DelayQueue"},{"t":"list_item","d":12,"p":{"lines":[565,566]},"v":"Priority BlockingQueue"},{"t":"list_item","d":12,"p":{"lines":[566,567]},"v":"SynchronousQueue"},{"t":"list_item","d":12,"p":{"lines":[567,568]},"v":"LinkedBlockingDeque"},{"t":"list_item","d":12,"p":{"lines":[568,569]},"v":"LinkedTransferQueue"}]},{"t":"list_item","d":10,"p":{"lines":[569,570]},"v":"ConcurrenLinkedQueue","c":[{"t":"list_item","d":12,"p":{"lines":[570,571]},"v":"Unsafe:CAS"},{"t":"list_item","d":12,"p":{"lines":[571,572]},"v":"<a href=\"https://blog.csdn.net/lzxlfly/article/details/86710382\">LinkedBlockingQueue与ConcurrentLinkedQueue的区别</a>"}]}]},{"t":"list_item","d":8,"p":{"lines":[572,573]},"v":"ConcurrentMap","c":[{"t":"list_item","d":10,"p":{"lines":[573,574]},"v":"ConcurrentHashMap","c":[{"t":"list_item","d":12,"p":{"lines":[574,575]},"v":"看HashMap那里"}]},{"t":"list_item","d":10,"p":{"lines":[575,576]},"v":"ConcurrentNavigableMap"},{"t":"list_item","d":10,"p":{"lines":[576,577]},"v":"ConcurrentSkipListMap"}]},{"t":"list_item","d":8,"p":{"lines":[577,578]},"v":"CopyOnWrite","c":[{"t":"list_item","d":10,"p":{"lines":[578,579]},"v":"CopyOnWriteArrayList","c":[{"t":"list_item","d":12,"p":{"lines":[579,580]},"v":"ReentrantLock加锁"}]},{"t":"list_item","d":10,"p":{"lines":[580,581]},"v":"CopyOnWriteArrayMap"},{"t":"list_item","d":10,"p":{"lines":[581,582]},"v":"CopyOnWriteArraySet"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[583,584]},"v":"线程池","c":[{"t":"list_item","d":6,"p":{"lines":[584,585]},"v":"结构","c":[{"t":"list_item","d":8,"p":{"lines":[585,586]},"v":"任务(Runnable /Callable)"},{"t":"list_item","d":8,"p":{"lines":[586,587]},"v":"任务的执行(Executor)"},{"t":"list_item","d":8,"p":{"lines":[587,588]},"v":"异步计算的结果(Future)"}]},{"t":"list_item","d":6,"p":{"lines":[588,589]},"v":"创建","c":[{"t":"list_item","d":8,"p":{"lines":[589,590],"f":true},"v":"ThreadPoolExecutor构造方法参数及含义 ","c":[{"t":"list_item","d":10,"p":{"lines":[590,591]},"v":"int corePoolSize：该线程池中核心线程数最大值"},{"t":"list_item","d":10,"p":{"lines":[591,592]},"v":"int maximumPoolSize：该线程池中线程总数最大值 。"},{"t":"list_item","d":10,"p":{"lines":[592,593]},"v":"long keepAliveTime：非核心线程闲置超时时长。"},{"t":"list_item","d":10,"p":{"lines":[593,594]},"v":"TimeUnit unit：keepAliveTime的单位。"},{"t":"list_item","d":10,"p":{"lines":[594,595]},"v":"BlockingQueue workQueue：阻塞队列，维护着等待执行的Runnable任务对象。"},{"t":"list_item","d":10,"p":{"lines":[595,596]},"v":"ThreadFactory threadFactory：<br />创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，<br/>如是否守护线程、线程的优先级等。<br />如果不指定，会新建一个默认的线程工厂。"},{"t":"list_item","d":10,"p":{"lines":[596,597]},"v":"RejectedExecutionHandler handler 拒绝策略","c":[{"t":"list_item","d":12,"p":{"lines":[597,598]},"v":"AbortPolicy：默认拒绝处理策略，丢弃任务并抛出RejectedExecutionException异常。"},{"t":"list_item","d":12,"p":{"lines":[598,599]},"v":"DiscardPolicy：丢弃新来的任务，但是不抛出异常。"},{"t":"list_item","d":12,"p":{"lines":[599,600]},"v":"DiscardOldestPolicy：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。"},{"t":"list_item","d":12,"p":{"lines":[600,601]},"v":"CallerRunsPolicy：由调用线程处理该任务。"}]}]},{"t":"list_item","d":8,"p":{"lines":[601,602],"f":true},"v":"Executors默认实现(底层使用ThreadPoolExecutor) ","c":[{"t":"list_item","d":10,"p":{"lines":[602,603]},"v":"FixedThreadPool","c":[{"t":"list_item","d":12,"p":{"lines":[603,604]},"v":"参数设置"},{"t":"list_item","d":12,"p":{"lines":[604,605]},"v":"执行过程"},{"t":"list_item","d":12,"p":{"lines":[605,606]},"v":"弊端"}]},{"t":"list_item","d":10,"p":{"lines":[606,607]},"v":"CachedThreadPool","c":[{"t":"list_item","d":12,"p":{"lines":[607,608]},"v":"参数设置"},{"t":"list_item","d":12,"p":{"lines":[608,609]},"v":"执行过程"},{"t":"list_item","d":12,"p":{"lines":[609,610]},"v":"弊端"}]},{"t":"list_item","d":10,"p":{"lines":[610,611]},"v":"SingleThreadExecutor","c":[{"t":"list_item","d":12,"p":{"lines":[611,612]},"v":"参数设置"},{"t":"list_item","d":12,"p":{"lines":[612,613]},"v":"执行过程"},{"t":"list_item","d":12,"p":{"lines":[613,614]},"v":"弊端"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[614,615]},"v":"<strong>线程池工作流程</strong>"},{"t":"list_item","d":6,"p":{"lines":[615,616],"f":true},"v":"ThreadPool状态转换 ","c":[{"t":"list_item","d":8,"p":{"lines":[616,617]},"v":"RUNNING"},{"t":"list_item","d":8,"p":{"lines":[617,618]},"v":"SHUTDOWN"},{"t":"list_item","d":8,"p":{"lines":[618,619]},"v":"STOP"},{"t":"list_item","d":8,"p":{"lines":[619,620]},"v":"TIDYING"},{"t":"list_item","d":8,"p":{"lines":[620,621]},"v":"TERMINATED"}]},{"t":"list_item","d":6,"p":{"lines":[621,622],"f":true},"v":"ScheduledThreadPool ","c":[{"t":"list_item","d":8,"p":{"lines":[622,623]},"v":"继承了ThreadPoolExecutor"},{"t":"list_item","d":8,"p":{"lines":[623,624]},"v":"主要用来在给定的延迟后运行任务，或者定期执行任务"},{"t":"list_item","d":8,"p":{"lines":[624,625]},"v":"实际项目中会使<code>用quartz</code>"}]},{"t":"list_item","d":6,"p":{"lines":[625,626]},"v":"<strong>为什么不要用默认实现</strong> <br/> (上面的默认实现有什么弊端)"},{"t":"list_item","d":6,"p":{"lines":[626,627]},"v":"参数如何设置(N+1,2N)"},{"t":"list_item","d":6,"p":{"lines":[627,628]},"v":"<a href=\"https://mp.weixin.qq.com/s?__biz=Mzg3NjU3NTkwMQ==&amp;mid=2247505057&amp;idx=1&amp;sn=621ebc409b589478e2e05388e079d8c0&amp;source=41#wechat_redirect\">异常线程处理</a>"},{"t":"list_item","d":6,"p":{"lines":[628,629]},"v":"常见区别","c":[{"t":"list_item","d":8,"p":{"lines":[629,630]},"v":"sumbit() vs execute()","c":[{"t":"list_item","d":10,"p":{"lines":[630,631]},"v":"execute()方法不会返回结果"},{"t":"list_item","d":10,"p":{"lines":[631,632]},"v":"submit()会返回一个 FutureTask 对象，并可以获得结果"},{"t":"list_item","d":10,"p":{"lines":[632,633]},"v":"<a href=\"https://www.jianshu.com/p/29610984f1dd\">异常处理</a>"}]},{"t":"list_item","d":8,"p":{"lines":[633,634]},"v":"Runnable vs Callable"},{"t":"list_item","d":8,"p":{"lines":[634,635]},"v":"shutdown() vs shutdownNow()"}]}]},{"t":"list_item","d":4,"p":{"lines":[636,637]},"v":"<strong>ThreadLocal(待做)</strong>"}]},{"t":"heading","d":2,"p":{"lines":[638,639],"f":true},"v":"IO/NIO/AIO "}]},{"t":"heading","d":1,"p":{"lines":[640,641]},"v":"JVM","c":[{"t":"heading","d":2,"p":{"lines":[642,643],"f":true},"v":"基础知识 ","c":[{"t":"list_item","d":4,"p":{"lines":[644,645]},"v":"jvm发展"},{"t":"list_item","d":4,"p":{"lines":[645,646]},"v":"特点：","c":[{"t":"list_item","d":6,"p":{"lines":[646,647]},"v":"一次编译，到处运行"},{"t":"list_item","d":6,"p":{"lines":[647,648]},"v":"自动内存管理"},{"t":"list_item","d":6,"p":{"lines":[648,649]},"v":"自动垃圾回收"}]},{"t":"list_item","d":4,"p":{"lines":[649,650]},"v":"架构模型","c":[{"t":"list_item","d":6,"p":{"lines":[650,651]},"v":"基于栈式架构"},{"t":"list_item","d":6,"p":{"lines":[651,652]},"v":"基于寄存器架构"}]},{"t":"list_item","d":4,"p":{"lines":[652,653]},"v":"JVM生命周期","c":[{"t":"list_item","d":6,"p":{"lines":[653,654]},"v":"启动"},{"t":"list_item","d":6,"p":{"lines":[654,655]},"v":"执行"},{"t":"list_item","d":6,"p":{"lines":[655,656]},"v":"退出"}]}]},{"t":"heading","d":2,"p":{"lines":[657,658],"f":true},"v":"内存与垃圾回收 ","c":[{"t":"heading","d":3,"p":{"lines":[659,660]},"v":"上层","c":[{"t":"list_item","d":5,"p":{"lines":[661,662]},"v":"画出详细架构"},{"t":"list_item","d":5,"p":{"lines":[662,663]},"v":"类加载过程","c":[{"t":"list_item","d":7,"p":{"lines":[663,664]},"v":"loading 加载(加载和链接交叉进行)","c":[{"t":"list_item","d":9,"p":{"lines":[664,665]},"v":"目的"}]},{"t":"list_item","d":7,"p":{"lines":[665,666]},"v":"linking 链接(加载和链接交叉进行)","c":[{"t":"list_item","d":9,"p":{"lines":[666,667]},"v":"verify 验证","c":[{"t":"list_item","d":11,"p":{"lines":[667,668]},"v":"目的"}]},{"t":"list_item","d":9,"p":{"lines":[668,669]},"v":"prepare 准备","c":[{"t":"list_item","d":11,"p":{"lines":[669,670]},"v":"目的"}]},{"t":"list_item","d":9,"p":{"lines":[670,671]},"v":"Resolve 解析","c":[{"t":"list_item","d":11,"p":{"lines":[671,672]},"v":"目的"},{"t":"list_item","d":11,"p":{"lines":[672,673]},"v":"执行时机"}]}]},{"t":"list_item","d":7,"p":{"lines":[673,674]},"v":"initialization 初始化","c":[{"t":"list_item","d":9,"p":{"lines":[674,675]},"v":"目的"},{"t":"list_item","d":9,"p":{"lines":[675,676]},"v":"特点","c":[{"t":"list_item","d":11,"p":{"lines":[676,677]},"v":"顺序执行"},{"t":"list_item","d":11,"p":{"lines":[677,678]},"v":"父类先与子类"},{"t":"list_item","d":11,"p":{"lines":[678,679]},"v":"<code>&lt;clint&gt;</code>多线程同步加锁"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[679,680]},"v":"类加载器","c":[{"t":"list_item","d":7,"p":{"lines":[680,681]},"v":"分清关系","c":[{"t":"list_item","d":9,"p":{"lines":[681,682]},"v":"继承关系"},{"t":"list_item","d":9,"p":{"lines":[682,683]},"v":"上下层关系<br />(涉及双亲委派)"},{"t":"list_item","d":9,"p":{"lines":[683,684]},"v":"包含关系<br />(自定义类加载器包含其他java编写类加载器)"}]},{"t":"list_item","d":7,"p":{"lines":[684,685]},"v":"通常分类","c":[{"t":"list_item","d":9,"p":{"lines":[685,686]},"v":"BootStrap ClassLoader","c":[{"t":"list_item","d":11,"p":{"lines":[686,687]},"v":"目的"},{"t":"list_item","d":11,"p":{"lines":[687,688]},"v":"父类"},{"t":"list_item","d":11,"p":{"lines":[688,689]},"v":"加载库"}]},{"t":"list_item","d":9,"p":{"lines":[689,690]},"v":"Extension ClassLoader","c":[{"t":"list_item","d":11,"p":{"lines":[690,691]},"v":"目的"},{"t":"list_item","d":11,"p":{"lines":[691,692]},"v":"父类"},{"t":"list_item","d":11,"p":{"lines":[692,693]},"v":"加载库"}]},{"t":"list_item","d":9,"p":{"lines":[693,694]},"v":"AppClassLoader ClassLoader","c":[{"t":"list_item","d":11,"p":{"lines":[694,695]},"v":"目的"},{"t":"list_item","d":11,"p":{"lines":[695,696]},"v":"父类"},{"t":"list_item","d":11,"p":{"lines":[696,697]},"v":"加载库"}]}]},{"t":"list_item","d":7,"p":{"lines":[697,698]},"v":"按照规范","c":[{"t":"list_item","d":9,"p":{"lines":[698,699]},"v":"引导类加载器（Bootstrap ClassLoader） c/c++编写"},{"t":"list_item","d":9,"p":{"lines":[699,700]},"v":"自定义类加载器（User-Defined ClassLoader） java编写","c":[{"t":"list_item","d":11,"p":{"lines":[700,701]},"v":"为何要自定义类加载器"}]}]},{"t":"list_item","d":7,"p":{"lines":[701,702]},"v":"抽象类ClassLoader","c":[{"t":"list_item","d":9,"p":{"lines":[702,703]},"v":"继承结构"},{"t":"list_item","d":9,"p":{"lines":[703,704]},"v":"虚拟机的入口应用:<code>sun.misc.Launcher</code>"},{"t":"list_item","d":9,"p":{"lines":[704,705]},"v":"获取classloader的方式"}]},{"t":"list_item","d":7,"p":{"lines":[705,706]},"v":"<strong>双亲委派机制</strong>","c":[{"t":"list_item","d":9,"p":{"lines":[706,707]},"v":"<strong>原理</strong>"},{"t":"list_item","d":9,"p":{"lines":[707,708]},"v":"自定义java.lang.String是否会加载"},{"t":"list_item","d":9,"p":{"lines":[708,709]},"v":"优势","c":[{"t":"list_item","d":11,"p":{"lines":[709,710]},"v":"避免类的重复加载"},{"t":"list_item","d":11,"p":{"lines":[710,711]},"v":"保护程序安全，防止核心api被随意篡改"}]},{"t":"list_item","d":9,"p":{"lines":[711,712]},"v":"例外案例"}]},{"t":"list_item","d":7,"p":{"lines":[712,713]},"v":"沙箱安全机制"},{"t":"list_item","d":7,"p":{"lines":[713,714]},"v":"其他","c":[{"t":"list_item","d":9,"p":{"lines":[714,715]},"v":"jvm 中判断两个class对象是否为同一个类2个判断条件"},{"t":"list_item","d":9,"p":{"lines":[715,716]},"v":"类加载器引用哦作为类型信息存于方法区"},{"t":"list_item","d":9,"p":{"lines":[716,717]},"v":"引用类型转换时，要保证两个类加载器相同"}]}]}]},{"t":"heading","d":3,"p":{"lines":[718,719]},"v":"中层","c":[{"t":"list_item","d":5,"p":{"lines":[720,721]},"v":"<strong>Java内存区域布局说明</strong>"},{"t":"list_item","d":5,"p":{"lines":[721,722]},"v":"程序计数器","c":[{"t":"list_item","d":7,"p":{"lines":[722,723]},"v":"是什么","c":[{"t":"list_item","d":9,"p":{"lines":[723,724]},"v":"线程私有"},{"t":"list_item","d":9,"p":{"lines":[724,725]},"v":"取值"},{"t":"list_item","d":9,"p":{"lines":[725,726]},"v":"作用"},{"t":"list_item","d":9,"p":{"lines":[726,727]},"v":"没有OOM"},{"t":"list_item","d":9,"p":{"lines":[727,728]},"v":"生命周期"}]},{"t":"list_item","d":7,"p":{"lines":[728,729]},"v":"问题","c":[{"t":"list_item","d":9,"p":{"lines":[729,730]},"v":"为什么使用PC寄存字器记录当当前线程的执行地址"},{"t":"list_item","d":9,"p":{"lines":[730,731]},"v":"pc寄存器为什么被设定为线程私有"}]}]},{"t":"list_item","d":5,"p":{"lines":[731,732]},"v":"虚拟机栈","c":[{"t":"list_item","d":7,"p":{"lines":[732,733]},"v":"是什么","c":[{"t":"list_item","d":9,"p":{"lines":[733,734]},"v":"线程私有"},{"t":"list_item","d":9,"p":{"lines":[734,735]},"v":"对应方法调用，入栈，出栈"},{"t":"list_item","d":9,"p":{"lines":[735,736]},"v":"作用"},{"t":"list_item","d":9,"p":{"lines":[736,737]},"v":"没有垃圾回收"},{"t":"list_item","d":9,"p":{"lines":[737,738]},"v":"异常"}]},{"t":"list_item","d":7,"p":{"lines":[738,739]},"v":"参数设置","c":[{"t":"list_item","d":9,"p":{"lines":[739,740]},"v":"<code>-Xss</code>"}]},{"t":"list_item","d":7,"p":{"lines":[740,741]},"v":"栈帧","c":[{"t":"list_item","d":9,"p":{"lines":[741,742]},"v":"是什么","c":[{"t":"list_item","d":11,"p":{"lines":[742,743]},"v":"Java虚拟机栈（Java Virtual Machine Stack),早期也叫Java栈。"},{"t":"list_item","d":11,"p":{"lines":[743,744]},"v":"每个线程在创建时都会创建一个虚拟机栈，<br />其内部保存一个个的栈帧 (Stack Frame),对应着一次次的Java方法调用。"},{"t":"list_item","d":11,"p":{"lines":[744,745]},"v":"是线程私有的"}]},{"t":"list_item","d":9,"p":{"lines":[745,746]},"v":"运行原理-栈帧弹出"},{"t":"list_item","d":9,"p":{"lines":[746,747]},"v":"内部组成","c":[{"t":"list_item","d":11,"p":{"lines":[747,748]},"v":"局部变量表","c":[{"t":"list_item","d":13,"p":{"lines":[748,749]},"v":"作用"},{"t":"list_item","d":13,"p":{"lines":[749,750]},"v":"生命周期"},{"t":"list_item","d":13,"p":{"lines":[750,751]},"v":"slot","c":[{"t":"list_item","d":15,"p":{"lines":[751,752]},"v":"概念/作用"},{"t":"list_item","d":15,"p":{"lines":[752,753]},"v":"32位,64位占用"},{"t":"list_item","d":15,"p":{"lines":[753,754]},"v":"存储数据类型"},{"t":"list_item","d":15,"p":{"lines":[754,755]},"v":"存储内容与顺序"},{"t":"list_item","d":15,"p":{"lines":[755,756]},"v":"槽的重用"}]},{"t":"list_item","d":13,"p":{"lines":[756,757]},"v":"内存分配(<strong>编译期间</strong>完成分配)"},{"t":"list_item","d":13,"p":{"lines":[757,758]},"v":"线程私有不存在数据安全问题"},{"t":"list_item","d":13,"p":{"lines":[758,759]},"v":"垃圾回收：局部变量表中的变量也是重要的垃圾回收根节点"}]},{"t":"list_item","d":11,"p":{"lines":[759,760]},"v":"操作数栈","c":[{"t":"list_item","d":13,"p":{"lines":[760,761]},"v":"编译时就已经确定深度<code>max_stacks</code>"},{"t":"list_item","d":13,"p":{"lines":[761,762]},"v":"操作：出栈入栈"},{"t":"list_item","d":13,"p":{"lines":[762,763]},"v":"具体流程示例"},{"t":"list_item","d":13,"p":{"lines":[763,764]},"v":"栈顶缓存技术"}]},{"t":"list_item","d":11,"p":{"lines":[764,765]},"v":"帧数据区","c":[{"t":"list_item","d":13,"p":{"lines":[765,766]},"v":"动态链接","c":[{"t":"list_item","d":15,"p":{"lines":[766,767]},"v":"什么是动态链接"},{"t":"list_item","d":15,"p":{"lines":[767,768]},"v":"<strong>深入</strong>：方法的调用：解析和分派","c":[{"t":"list_item","d":17,"p":{"lines":[768,769]},"v":"绑定与链接","c":[{"t":"list_item","d":19,"p":{"lines":[769,770]},"v":"早期绑定"},{"t":"list_item","d":19,"p":{"lines":[770,771]},"v":"晚期绑定"},{"t":"list_item","d":19,"p":{"lines":[771,772]},"v":"静态连接"},{"t":"list_item","d":19,"p":{"lines":[772,773]},"v":"动态链接"}]},{"t":"list_item","d":17,"p":{"lines":[773,774]},"v":"<strong>非虚方法与虚方法</strong>","c":[{"t":"list_item","d":19,"p":{"lines":[774,775],"f":true},"v":"什么是非虚方法 ","c":[{"t":"list_item","d":21,"p":{"lines":[775,776]},"v":"静态方法"},{"t":"list_item","d":21,"p":{"lines":[776,777]},"v":"私有方法"},{"t":"list_item","d":21,"p":{"lines":[777,778]},"v":"final方法"},{"t":"list_item","d":21,"p":{"lines":[778,779]},"v":"构造器"},{"t":"list_item","d":21,"p":{"lines":[779,780]},"v":"父类方法(使用super显式调用)"}]},{"t":"list_item","d":19,"p":{"lines":[780,781],"f":true},"v":"什么是虚方法 ","c":[{"t":"list_item","d":21,"p":{"lines":[781,782]},"v":"非虚方法之外的方法"}]},{"t":"list_item","d":19,"p":{"lines":[782,783],"f":true},"v":"无个调用指令 ","c":[{"t":"list_item","d":21,"p":{"lines":[783,784]},"v":"invokespecial"},{"t":"list_item","d":21,"p":{"lines":[784,785]},"v":"invokestatic"},{"t":"list_item","d":21,"p":{"lines":[785,786]},"v":"invokevirtual"},{"t":"list_item","d":21,"p":{"lines":[786,787]},"v":"invokeinterface"},{"t":"list_item","d":21,"p":{"lines":[787,788]},"v":"invokedynamic"}]},{"t":"list_item","d":19,"p":{"lines":[788,789]},"v":"方法重写本质"},{"t":"list_item","d":19,"p":{"lines":[789,790]},"v":"虚方法表","c":[{"t":"list_item","d":21,"p":{"lines":[790,791]},"v":"出现原因"},{"t":"list_item","d":21,"p":{"lines":[791,792]},"v":"作用"},{"t":"list_item","d":21,"p":{"lines":[792,793]},"v":"内存位置"},{"t":"list_item","d":21,"p":{"lines":[793,794]},"v":"建立时期"},{"t":"list_item","d":21,"p":{"lines":[794,795]},"v":"插入条目<br />(需要解释这些信息)","c":[{"t":"list_item","d":23,"p":{"lines":[795,796]},"v":"符号引用"},{"t":"list_item","d":23,"p":{"lines":[796,797]},"v":"直接引用"},{"t":"list_item","d":23,"p":{"lines":[797,798]},"v":"解析时机"}]}]}]}]}]},{"t":"list_item","d":13,"p":{"lines":[798,799]},"v":"方法返回地址","c":[{"t":"list_item","d":15,"p":{"lines":[799,800]},"v":"栈帧退出方式"},{"t":"list_item","d":15,"p":{"lines":[800,801]},"v":"作用"}]},{"t":"list_item","d":13,"p":{"lines":[801,802]},"v":"一些附加信息"}]}]}]},{"t":"list_item","d":7,"p":{"lines":[802,803],"f":true},"v":"问题 ","c":[{"t":"list_item","d":9,"p":{"lines":[803,804]},"v":"栈中可能出现的异常"},{"t":"list_item","d":9,"p":{"lines":[804,805]},"v":"i++和++i的区别。<br />从字节码，局部变量表，操作数栈层面解释"},{"t":"list_item","d":9,"p":{"lines":[805,806]},"v":"举例栈溢出的情况？(StackOverflowError)"},{"t":"list_item","d":9,"p":{"lines":[806,807]},"v":"调整栈大小，就能保证不出现溢出吗？"},{"t":"list_item","d":9,"p":{"lines":[807,808]},"v":"分配的栈内存越大越好吗？"},{"t":"list_item","d":9,"p":{"lines":[808,809]},"v":"垃圾回收是否会涉及到虚拟机栈？"},{"t":"list_item","d":9,"p":{"lines":[809,810]},"v":"方法中定义的局部变量是否线程安全？"}]}]},{"t":"list_item","d":5,"p":{"lines":[810,811]},"v":"本地方法接口+库(非运行时数据区结构)","c":[{"t":"list_item","d":7,"p":{"lines":[811,812]},"v":"定义:一个Native Method就是一个Java调用非Java代码的接口。"},{"t":"list_item","d":7,"p":{"lines":[812,813]},"v":"特点:该方法的实现由非Java语言实现，比如 C。"},{"t":"list_item","d":7,"p":{"lines":[813,814]},"v":"目的:","c":[{"t":"list_item","d":9,"p":{"lines":[814,815]},"v":"与java环境外交互"},{"t":"list_item","d":9,"p":{"lines":[815,816]},"v":"与操作系统交互"},{"t":"list_item","d":9,"p":{"lines":[816,817]},"v":"Sun's java"}]}]},{"t":"list_item","d":5,"p":{"lines":[817,818]},"v":"本地方法栈","c":[{"t":"list_item","d":7,"p":{"lines":[818,819]},"v":"目的"},{"t":"list_item","d":7,"p":{"lines":[819,820]},"v":"在Hotspot JVM中，直接将本地方法栈和虚拟机栈合二为一。"}]},{"t":"list_item","d":5,"p":{"lines":[821,822]},"v":"堆","c":[{"t":"list_item","d":7,"p":{"lines":[822,823]},"v":"空间划分与比例<code>1:2</code> <code>6:1:1</code>"},{"t":"list_item","d":7,"p":{"lines":[823,824]},"v":"自适应调节策略"},{"t":"list_item","d":7,"p":{"lines":[824,825]},"v":"堆大小设置参数<code>-Xms</code> <code>-Xmx</code>","c":[{"t":"list_item","d":9,"p":{"lines":[825,826]},"v":"默认 1/64,1/4"}]},{"t":"list_item","d":7,"p":{"lines":[826,827]},"v":"对象分配","c":[{"t":"list_item","d":9,"p":{"lines":[827,828]},"v":"一般过程"},{"t":"list_item","d":9,"p":{"lines":[828,829]},"v":"特殊情况"}]},{"t":"list_item","d":7,"p":{"lines":[829,830]},"v":"四种GC","c":[{"t":"list_item","d":9,"p":{"lines":[830,831]},"v":"Minor GC","c":[{"t":"list_item","d":11,"p":{"lines":[831,832]},"v":"回收区域"},{"t":"list_item","d":11,"p":{"lines":[832,833]},"v":"触发机制"},{"t":"list_item","d":11,"p":{"lines":[833,834]},"v":"耗时代价"},{"t":"list_item","d":11,"p":{"lines":[834,835]},"v":"Survivor的被动收集"}]},{"t":"list_item","d":9,"p":{"lines":[835,836]},"v":"Major GC","c":[{"t":"list_item","d":11,"p":{"lines":[836,837]},"v":"回收区域"},{"t":"list_item","d":11,"p":{"lines":[837,838]},"v":"触发机制"},{"t":"list_item","d":11,"p":{"lines":[838,839]},"v":"耗时代价"}]},{"t":"list_item","d":9,"p":{"lines":[839,840]},"v":"Mixed GC","c":[{"t":"list_item","d":11,"p":{"lines":[840,841]},"v":"回收区域"},{"t":"list_item","d":11,"p":{"lines":[841,842]},"v":"只有G1回收器有该GC"}]},{"t":"list_item","d":9,"p":{"lines":[842,843]},"v":"Full GC","c":[{"t":"list_item","d":11,"p":{"lines":[843,844]},"v":"回收区域"},{"t":"list_item","d":11,"p":{"lines":[844,845]},"v":"触发机制"},{"t":"list_item","d":11,"p":{"lines":[845,846]},"v":"耗时代价"}]}]},{"t":"list_item","d":7,"p":{"lines":[846,847]},"v":"TLAB:快速分配策略。","c":[{"t":"list_item","d":9,"p":{"lines":[847,848]},"v":"作用"},{"t":"list_item","d":9,"p":{"lines":[848,849]},"v":"分配流程：","c":[{"t":"list_item","d":11,"p":{"lines":[849,850]},"v":"JVM确实是将TLAB作为内存分配的首选"},{"t":"list_item","d":11,"p":{"lines":[850,851]},"v":"失败后，JVM就会尝试着通过使用加锁机制确保数据操作的原子性，<br />从而直接在Eden空间中分配内存。"}]},{"t":"list_item","d":9,"p":{"lines":[851,852]},"v":"大小：默认整个Eden空间的1%<br /> <code>-XX:TLABWasteTargetPercent</code>设置"}]},{"t":"list_item","d":7,"p":{"lines":[852,853]},"v":"逃逸分析<br />( <strong>十分不成熟，Hotspot也没用</strong> )","c":[{"t":"list_item","d":9,"p":{"lines":[853,854]},"v":"种类：","c":[{"t":"list_item","d":11,"p":{"lines":[854,855]},"v":"方法逃逸"},{"t":"list_item","d":11,"p":{"lines":[855,856]},"v":"线程逃逸"}]},{"t":"list_item","d":9,"p":{"lines":[856,857]},"v":"基于逃逸分析的优化","c":[{"t":"list_item","d":11,"p":{"lines":[857,858]},"v":"栈上分配(就没实现)"},{"t":"list_item","d":11,"p":{"lines":[858,859]},"v":"同步省略"},{"t":"list_item","d":11,"p":{"lines":[859,860]},"v":"标量替换"}]}]},{"t":"list_item","d":7,"p":{"lines":[860,861]},"v":"堆是分配对象的唯一选择:否定-&gt;肯定"}]},{"t":"list_item","d":5,"p":{"lines":[862,863]},"v":"方法区","c":[{"t":"list_item","d":7,"p":{"lines":[863,864]},"v":"特点","c":[{"t":"list_item","d":9,"p":{"lines":[864,865]},"v":"线程共享"},{"t":"list_item","d":9,"p":{"lines":[865,866]},"v":"本地内存"}]},{"t":"list_item","d":7,"p":{"lines":[866,867]},"v":"存储内容：具体看 <strong>细节演进</strong>"},{"t":"list_item","d":7,"p":{"lines":[867,868]},"v":"大小设置","c":[{"t":"list_item","d":9,"p":{"lines":[868,869]},"v":"1.7","c":[{"t":"list_item","d":11,"p":{"lines":[869,870]},"v":"<code>-XX:PermSize</code>"},{"t":"list_item","d":11,"p":{"lines":[870,871]},"v":"<code>-XX:MaxPermSize</code>"}]},{"t":"list_item","d":9,"p":{"lines":[871,872]},"v":"1.8","c":[{"t":"list_item","d":11,"p":{"lines":[872,873]},"v":"<code>-XX:MetaspaceSize</code><br />初始分配空间大小，<br />同时也是水位线大小"},{"t":"list_item","d":11,"p":{"lines":[873,874]},"v":"<code>-XX:MaxMetaspaceSize</code>方法区最大大小，默认-1"},{"t":"list_item","d":11,"p":{"lines":[874,875]},"v":"水位线--full GC--自动调整"}]}]},{"t":"list_item","d":7,"p":{"lines":[875,876]},"v":"<strong>内部结构演进变迁</strong>:看图去"},{"t":"list_item","d":7,"p":{"lines":[876,877]},"v":"为什么要移除永久代"},{"t":"list_item","d":7,"p":{"lines":[877,878]},"v":"常量池和运行时常量池"},{"t":"list_item","d":7,"p":{"lines":[878,879]},"v":"为何要移除永久代"},{"t":"list_item","d":7,"p":{"lines":[879,880]},"v":"<strong>什么是符号引用</strong><br />","c":[{"t":"list_item","d":9,"p":{"lines":[880,881]},"v":"说明：","c":[{"t":"list_item","d":11,"p":{"lines":[881,882]},"v":"以元祖JVM:Sun JDK 1.0.2的32位x86为例"},{"t":"list_item","d":11,"p":{"lines":[882,883]},"v":"整体原理类似"}]},{"t":"list_item","d":9,"p":{"lines":[883,884]},"v":"符号引用","c":[{"t":"list_item","d":11,"p":{"lines":[884,885],"f":true},"v":"说明 ","c":[{"t":"list_item","d":13,"p":{"lines":[885,886]},"v":"通常是设计字符串的，是用文本形式来表示引用关系"},{"t":"list_item","d":13,"p":{"lines":[886,887]},"v":"实际使用时可以藉此找到相应的位置"}]}]},{"t":"list_item","d":9,"p":{"lines":[887,888]},"v":"直接引用","c":[{"t":"list_item","d":11,"p":{"lines":[888,889],"f":true},"v":"表现形式 ","c":[{"t":"list_item","d":13,"p":{"lines":[889,890]},"v":"指向methodblock的指针"},{"t":"list_item","d":13,"p":{"lines":[890,891]},"v":"虚方法表下标"}]},{"t":"list_item","d":11,"p":{"lines":[891,892]},"v":"说明"}]},{"t":"list_item","d":9,"p":{"lines":[892,893]},"v":"解析时机"}]},{"t":"list_item","d":7,"p":{"lines":[893,894]},"v":"垃圾回收","c":[{"t":"list_item","d":9,"p":{"lines":[894,895]},"v":"是否要回收","c":[{"t":"list_item","d":11,"p":{"lines":[895,896]},"v":"《规范》提到过可以不要求虚拟机在方法区中实现垃圾收集"},{"t":"list_item","d":11,"p":{"lines":[896,897]},"v":"回收条件苛刻，效果比较难令人满意。"}]},{"t":"list_item","d":9,"p":{"lines":[897,898]},"v":"回收内容","c":[{"t":"list_item","d":11,"p":{"lines":[898,899]},"v":"常量池中废弃的常量","c":[{"t":"list_item","d":13,"p":{"lines":[899,900]},"v":"回收策略"},{"t":"list_item","d":13,"p":{"lines":[900,901],"f":true},"v":"组成 ","c":[{"t":"list_item","d":15,"p":{"lines":[901,902]},"v":"字面量常量"},{"t":"list_item","d":15,"p":{"lines":[902,903]},"v":"符号引用"}]}]},{"t":"list_item","d":11,"p":{"lines":[903,904]},"v":"不再使用的类","c":[{"t":"list_item","d":13,"p":{"lines":[904,905],"f":true},"v":"回收策略 ","c":[{"t":"list_item","d":15,"p":{"lines":[905,906]},"v":"该类所有的实例都已经被回收"},{"t":"list_item","d":15,"p":{"lines":[906,907]},"v":"加载该类的类加载器已经被回收"}]}]}]}]}]},{"t":"list_item","d":5,"p":{"lines":[907,908],"f":true},"v":"问题 ","c":[{"t":"list_item","d":7,"p":{"lines":[908,909]},"v":"说一下JVM内存模型吧，有哪些区？分别干什么的？"},{"t":"list_item","d":7,"p":{"lines":[909,910]},"v":"Java8的内存分代改进"},{"t":"list_item","d":7,"p":{"lines":[910,911]},"v":"JVM内存分哪几个区，每个区的作用是什么？"},{"t":"list_item","d":7,"p":{"lines":[911,912]},"v":"JVM内存分布/内存结构？栈和堆的区别？堆的结构？为什么两个survivor区？"},{"t":"list_item","d":7,"p":{"lines":[912,913]},"v":"Eden和Survior的比例分配"},{"t":"list_item","d":7,"p":{"lines":[913,914]},"v":"jvm内存分区，为什么要有新生代和老年代"},{"t":"list_item","d":7,"p":{"lines":[914,915]},"v":"Java的内存分区"},{"t":"list_item","d":7,"p":{"lines":[915,916]},"v":"讲讲jvm运行时数据库区"},{"t":"list_item","d":7,"p":{"lines":[916,917]},"v":"什么时候对象会进入老年代？"},{"t":"list_item","d":7,"p":{"lines":[917,918]},"v":"JVM内存为什么要分成新生代，老年代，持久代。<br />新生代中为什么要分为Eden和Survivor。"},{"t":"list_item","d":7,"p":{"lines":[918,919]},"v":"Jvm内存模型以及分区，需要详细到每个区放什么。"},{"t":"list_item","d":7,"p":{"lines":[919,920]},"v":"JVM的内存模型，Java8做了什么修改"},{"t":"list_item","d":7,"p":{"lines":[920,921]},"v":"JVM内存分哪几个区，每个区的作用是什么？"},{"t":"list_item","d":7,"p":{"lines":[921,922]},"v":"java内存分配"},{"t":"list_item","d":7,"p":{"lines":[922,923]},"v":"jvm的永久代中会发生垃圾回收吗？"},{"t":"list_item","d":7,"p":{"lines":[923,924]},"v":"jvm内存分区，为什么要有新生代和老年代？"}]},{"t":"list_item","d":5,"p":{"lines":[925,926]},"v":"<strong>对象的实例化内存布局和访问定位</strong>","c":[{"t":"list_item","d":7,"p":{"lines":[926,927]},"v":"创建对象的方式"},{"t":"list_item","d":7,"p":{"lines":[927,928],"f":true},"v":"创建对象的步骤（六步） ","c":[{"t":"list_item","d":9,"p":{"lines":[928,929]},"v":"判断对象对应的类是否加载，链接，初始化。（加载类元信息）"},{"t":"list_item","d":9,"p":{"lines":[929,930]},"v":"为对象分配内存","c":[{"t":"list_item","d":11,"p":{"lines":[930,931]},"v":"指针碰撞","c":[{"t":"list_item","d":13,"p":{"lines":[931,932]},"v":"原理"},{"t":"list_item","d":13,"p":{"lines":[932,933]},"v":"对应算法"}]},{"t":"list_item","d":11,"p":{"lines":[933,934]},"v":"空闲列表分配","c":[{"t":"list_item","d":13,"p":{"lines":[934,935]},"v":"原理"},{"t":"list_item","d":13,"p":{"lines":[935,936]},"v":"对应算法"}]}]},{"t":"list_item","d":9,"p":{"lines":[936,937]},"v":"处理并发安全问题","c":[{"t":"list_item","d":11,"p":{"lines":[937,938]},"v":"CAS"},{"t":"list_item","d":11,"p":{"lines":[938,939]},"v":"TLAB"}]},{"t":"list_item","d":9,"p":{"lines":[939,940]},"v":"初始化分配到的空间"},{"t":"list_item","d":9,"p":{"lines":[940,941]},"v":"设置对象的对象头"},{"t":"list_item","d":9,"p":{"lines":[941,942]},"v":"执行init方法进行初始化","c":[{"t":"list_item","d":11,"p":{"lines":[942,943]},"v":"属性初始化方式","c":[{"t":"list_item","d":13,"p":{"lines":[943,944]},"v":"1.默认初始化"},{"t":"list_item","d":13,"p":{"lines":[944,945]},"v":"2.显式初始化"},{"t":"list_item","d":13,"p":{"lines":[945,946]},"v":"3.代码块中初始化"},{"t":"list_item","d":13,"p":{"lines":[946,947]},"v":"4.构造器中初始化"},{"t":"list_item","d":13,"p":{"lines":[947,948]},"v":"5.对象.属性 初始化"}]},{"t":"list_item","d":11,"p":{"lines":[948,949]},"v":"init中包括2,3,4"}]}]},{"t":"list_item","d":7,"p":{"lines":[949,950]},"v":"内部布局","c":[{"t":"list_item","d":9,"p":{"lines":[950,951]},"v":"对象头(下面3项都是一字宽)","c":[{"t":"list_item","d":11,"p":{"lines":[951,952]},"v":"Mark Word--存储对象的hashCode或锁信息等","c":[{"t":"list_item","d":13,"p":{"lines":[952,953]},"v":"不同锁状态内容不同"}]},{"t":"list_item","d":11,"p":{"lines":[953,954]},"v":"Class Metadata Address--存储到对象类型数据的指针"},{"t":"list_item","d":11,"p":{"lines":[954,955]},"v":"Array length--数组的长度（如果是数组）"}]},{"t":"list_item","d":9,"p":{"lines":[955,956]},"v":"实例数据"},{"t":"list_item","d":9,"p":{"lines":[956,957]},"v":"对齐填充:占位符"}]},{"t":"list_item","d":7,"p":{"lines":[957,958]},"v":"定位访问","c":[{"t":"list_item","d":9,"p":{"lines":[958,959]},"v":"句柄访问","c":[{"t":"list_item","d":11,"p":{"lines":[959,960]},"v":"说明"},{"t":"list_item","d":11,"p":{"lines":[960,961]},"v":"优点"},{"t":"list_item","d":11,"p":{"lines":[961,962]},"v":"缺点"}]},{"t":"list_item","d":9,"p":{"lines":[962,963]},"v":"直接指针","c":[{"t":"list_item","d":11,"p":{"lines":[963,964]},"v":"说明"},{"t":"list_item","d":11,"p":{"lines":[964,965]},"v":"优点"},{"t":"list_item","d":11,"p":{"lines":[965,966]},"v":"缺点"}]}]},{"t":"list_item","d":7,"p":{"lines":[966,967],"f":true},"v":"问题 ","c":[{"t":"list_item","d":9,"p":{"lines":[967,968]},"v":"对象在JVM中是怎么存储的？"},{"t":"list_item","d":9,"p":{"lines":[968,969]},"v":"对象头信息里面有哪些东西？"},{"t":"list_item","d":9,"p":{"lines":[969,970]},"v":"java对象头里有什么"}]}]},{"t":"list_item","d":5,"p":{"lines":[970,971]},"v":"直接内存"}]},{"t":"heading","d":3,"p":{"lines":[972,973]},"v":"下层","c":[{"t":"list_item","d":5,"p":{"lines":[974,975]},"v":"执行引擎","c":[{"t":"list_item","d":7,"p":{"lines":[975,976]},"v":"作用"},{"t":"list_item","d":7,"p":{"lines":[976,977]},"v":"相关概念","c":[{"t":"list_item","d":9,"p":{"lines":[977,978]},"v":"编译原理"},{"t":"list_item","d":9,"p":{"lines":[978,979]},"v":"机器码"},{"t":"list_item","d":9,"p":{"lines":[979,980]},"v":"指令"},{"t":"list_item","d":9,"p":{"lines":[980,981]},"v":"指令集"},{"t":"list_item","d":9,"p":{"lines":[981,982]},"v":"汇编"},{"t":"list_item","d":9,"p":{"lines":[982,983]},"v":"高级语言"}]},{"t":"list_item","d":7,"p":{"lines":[983,984]},"v":"编译器分类","c":[{"t":"list_item","d":9,"p":{"lines":[984,985]},"v":"前端编译器<br />java--&gt;.class"},{"t":"list_item","d":9,"p":{"lines":[985,986]},"v":"后端运行期编译器：JIT<br /> .class--&gt;机器码"},{"t":"list_item","d":9,"p":{"lines":[986,987]},"v":"静态提前编译器：AOT(Ahead of Time Compiler)编译器，<br /> .java--&gt;机器码"}]},{"t":"list_item","d":7,"p":{"lines":[987,988]},"v":"Java代码执行方式分类","c":[{"t":"list_item","d":9,"p":{"lines":[988,989]},"v":"种类","c":[{"t":"list_item","d":11,"p":{"lines":[989,990]},"v":"源代码编译成字节码文件，<br />然后在运行时通过解释器将字节码文件转为机器码执行"},{"t":"list_item","d":11,"p":{"lines":[990,991]},"v":"直接编译成机器码"}]},{"t":"list_item","d":9,"p":{"lines":[991,992]},"v":"HotSpot执行方式","c":[{"t":"list_item","d":11,"p":{"lines":[992,993]},"v":"<code>-Xint</code>:完全采用解释器模式执行程序；"},{"t":"list_item","d":11,"p":{"lines":[993,994]},"v":"<code>-Xcomp</code>:完全采用即时编译器模式执行程序。如果即时编译出现问题，解释器会介入执行。"},{"t":"list_item","d":11,"p":{"lines":[994,995]},"v":"<code>-Xmixed</code>(默认):采用解释器+即时编译器的混合模式共同执行程序。"}]}]},{"t":"list_item","d":7,"p":{"lines":[995,996]},"v":"Java执行引擎组成","c":[{"t":"list_item","d":9,"p":{"lines":[996,997]},"v":"解释器","c":[{"t":"list_item","d":11,"p":{"lines":[997,998]},"v":"为什么java源码到机器语言中间要有个字节码"},{"t":"list_item","d":11,"p":{"lines":[998,999]},"v":"工作机制"},{"t":"list_item","d":11,"p":{"lines":[999,1000]},"v":"种类","c":[{"t":"list_item","d":13,"p":{"lines":[1000,1001]},"v":"字节码解释器"},{"t":"list_item","d":13,"p":{"lines":[1001,1002]},"v":"模板解释器"}]}]},{"t":"list_item","d":9,"p":{"lines":[1002,1003]},"v":"即时编译器","c":[{"t":"list_item","d":11,"p":{"lines":[1003,1004]},"v":"工作机制"},{"t":"list_item","d":11,"p":{"lines":[1004,1005]},"v":"热点代码","c":[{"t":"list_item","d":13,"p":{"lines":[1005,1006]},"v":"概念"},{"t":"list_item","d":13,"p":{"lines":[1006,1007]},"v":"热点探测","c":[{"t":"list_item","d":15,"p":{"lines":[1007,1008]},"v":"方法调用计数器","c":[{"t":"list_item","d":17,"p":{"lines":[1008,1009]},"v":"工作机制"},{"t":"list_item","d":17,"p":{"lines":[1009,1010]},"v":"单位：方法"},{"t":"list_item","d":17,"p":{"lines":[1010,1011]},"v":"默认使用相对频率<br />关闭热度衰减使用绝对次数"},{"t":"list_item","d":17,"p":{"lines":[1011,1012]},"v":"阀值"},{"t":"list_item","d":17,"p":{"lines":[1012,1013]},"v":"设置阀值<code>-XX:CompileThreshold</code>"},{"t":"list_item","d":17,"p":{"lines":[1013,1014]},"v":"执行逻辑"},{"t":"list_item","d":17,"p":{"lines":[1014,1015]},"v":"热度衰减","c":[{"t":"list_item","d":19,"p":{"lines":[1015,1016]},"v":"半衰期：<code>-XX:CounterHalfLifeTime</code>"},{"t":"list_item","d":19,"p":{"lines":[1016,1017]},"v":"关闭：<code>-XX:-UseCounterDecay</code>"}]}]},{"t":"list_item","d":15,"p":{"lines":[1017,1018]},"v":"回边计数器","c":[{"t":"list_item","d":17,"p":{"lines":[1018,1019]},"v":"工作机制"},{"t":"list_item","d":17,"p":{"lines":[1019,1020]},"v":"栈上替换(OSR)"}]}]}]},{"t":"list_item","d":11,"p":{"lines":[1020,1021]},"v":"Java内置JIT编译器","c":[{"t":"list_item","d":13,"p":{"lines":[1021,1022]},"v":"C1","c":[{"t":"list_item","d":15,"p":{"lines":[1022,1023]},"v":"client模式下运行"},{"t":"list_item","d":15,"p":{"lines":[1023,1024]},"v":"简单和可靠的优化，耗时短"},{"t":"list_item","d":15,"p":{"lines":[1024,1025],"f":true},"v":"优化策略 ","c":[{"t":"list_item","d":17,"p":{"lines":[1025,1026]},"v":"方法内联：将引用的函数代码编译到引用点处，<br />这样可以减少栈帧的生成，减少参数传递以及跳转过程"},{"t":"list_item","d":17,"p":{"lines":[1026,1027]},"v":"去虚拟化：对唯一的实现类进行内联"},{"t":"list_item","d":17,"p":{"lines":[1027,1028]},"v":"沉余消除：在运行期间把一些不会执行的代码折叠掉"}]}]},{"t":"list_item","d":13,"p":{"lines":[1028,1029]},"v":"C2","c":[{"t":"list_item","d":15,"p":{"lines":[1029,1030]},"v":"server模式下运行"},{"t":"list_item","d":15,"p":{"lines":[1030,1031]},"v":"耗时较长的优化，以及激进优化"},{"t":"list_item","d":15,"p":{"lines":[1031,1032],"f":true},"v":"优化策略 ","c":[{"t":"list_item","d":17,"p":{"lines":[1032,1033]},"v":"标量替换：用标量值代替聚合对象的属性值"},{"t":"list_item","d":17,"p":{"lines":[1033,1034]},"v":"栈上分配：对于未逃逸的对象分配对象在栈而不是堆"},{"t":"list_item","d":17,"p":{"lines":[1034,1035]},"v":"同步消除：清除同步操作，通常指synchronized"}]}]}]},{"t":"list_item","d":11,"p":{"lines":[1035,1036]},"v":"java中的实际优化策略：<a href=\"http://zhongmingmao.me/2019/01/02/jvm-advanced-jit/\">分层编译(1.7引入,1.8默认开启)</a>"}]}]},{"t":"list_item","d":7,"p":{"lines":[1036,1037]},"v":"其他编译器：","c":[{"t":"list_item","d":9,"p":{"lines":[1037,1038]},"v":"Graa1"},{"t":"list_item","d":9,"p":{"lines":[1038,1039]},"v":"AOT"}]}]},{"t":"list_item","d":5,"p":{"lines":[1040,1041]},"v":"String与StringTable(中间插曲)","c":[{"t":"list_item","d":7,"p":{"lines":[1041,1042]},"v":"创建String","c":[{"t":"list_item","d":9,"p":{"lines":[1042,1043]},"v":"字面量","c":[{"t":"list_item","d":11,"p":{"lines":[1043,1044]},"v":"一个对象"},{"t":"list_item","d":11,"p":{"lines":[1044,1045]},"v":"返回的索引指向"}]},{"t":"list_item","d":9,"p":{"lines":[1045,1046]},"v":"new","c":[{"t":"list_item","d":11,"p":{"lines":[1046,1047]},"v":"两个对象"},{"t":"list_item","d":11,"p":{"lines":[1047,1048]},"v":"返回的索引指向"}]},{"t":"list_item","d":9,"p":{"lines":[1048,1049]},"v":"<strong>StringBuilder和StringBuffer的toString</strong>"},{"t":"list_item","d":9,"p":{"lines":[1049,1050]},"v":"(本质同上)new String(&quot;a&quot;)+new String(&quot;b&quot;)"}]},{"t":"list_item","d":7,"p":{"lines":[1050,1051]},"v":"String的不可变性"},{"t":"list_item","d":7,"p":{"lines":[1051,1052]},"v":"String底层存储结构","c":[{"t":"list_item","d":9,"p":{"lines":[1052,1053]},"v":"jdk8:final char[]"},{"t":"list_item","d":9,"p":{"lines":[1053,1054]},"v":"jdk9:final byte[]"}]},{"t":"list_item","d":7,"p":{"lines":[1054,1055]},"v":"String Table相关","c":[{"t":"list_item","d":9,"p":{"lines":[1055,1056]},"v":"特点"},{"t":"list_item","d":9,"p":{"lines":[1056,1057]},"v":"长度","c":[{"t":"list_item","d":11,"p":{"lines":[1057,1058]},"v":"默认长度","c":[{"t":"list_item","d":13,"p":{"lines":[1058,1059]},"v":"jdk6"},{"t":"list_item","d":13,"p":{"lines":[1059,1060]},"v":"jdk7"},{"t":"list_item","d":13,"p":{"lines":[1060,1061]},"v":"jdk8"}]},{"t":"list_item","d":11,"p":{"lines":[1061,1062]},"v":"长度设置"}]},{"t":"list_item","d":9,"p":{"lines":[1062,1063]},"v":"内存分配变迁","c":[{"t":"list_item","d":11,"p":{"lines":[1063,1064]},"v":"jdk6"},{"t":"list_item","d":11,"p":{"lines":[1064,1065]},"v":"jdk7"},{"t":"list_item","d":11,"p":{"lines":[1065,1066]},"v":"jdk8"}]}]},{"t":"list_item","d":7,"p":{"lines":[1066,1067]},"v":"<strong>inter()的使用</strong>","c":[{"t":"list_item","d":9,"p":{"lines":[1067,1068]},"v":"1.7之前"},{"t":"list_item","d":9,"p":{"lines":[1068,1069]},"v":"1.7及之后"}]},{"t":"list_item","d":7,"p":{"lines":[1069,1070]},"v":"StringTable垃圾回收:<br />GC时也会对StringTable进行垃圾回收"},{"t":"list_item","d":7,"p":{"lines":[1070,1071]},"v":"G1中的String去重操作(了解)"},{"t":"list_item","d":7,"p":{"lines":[1071,1072]},"v":"<strong>面试题</strong>"}]},{"t":"list_item","d":5,"p":{"lines":[1073,1074]},"v":"垃圾回收器","c":[{"t":"list_item","d":7,"p":{"lines":[1074,1075]},"v":"整体概述"},{"t":"list_item","d":7,"p":{"lines":[1075,1076]},"v":"垃圾回收相关算法","c":[{"t":"list_item","d":9,"p":{"lines":[1076,1077]},"v":"标记阶段","c":[{"t":"list_item","d":11,"p":{"lines":[1077,1078]},"v":"说明"},{"t":"list_item","d":11,"p":{"lines":[1078,1079]},"v":"算法","c":[{"t":"list_item","d":13,"p":{"lines":[1079,1080]},"v":"引用计数算法"},{"t":"list_item","d":13,"p":{"lines":[1080,1081]},"v":"可达性分析算法"}]}]},{"t":"list_item","d":9,"p":{"lines":[1081,1082]},"v":"清除阶段","c":[{"t":"list_item","d":11,"p":{"lines":[1082,1083]},"v":"说明"},{"t":"list_item","d":11,"p":{"lines":[1083,1084]},"v":"算法","c":[{"t":"list_item","d":13,"p":{"lines":[1084,1085]},"v":"分代收集算法","c":[{"t":"list_item","d":15,"p":{"lines":[1085,1086]},"v":"标记一清除算法（Mark-Sweep)"},{"t":"list_item","d":15,"p":{"lines":[1086,1087]},"v":"复制算法（Copying)"},{"t":"list_item","d":15,"p":{"lines":[1087,1088]},"v":"标记-压缩算法（Mark-Compact )"}]},{"t":"list_item","d":13,"p":{"lines":[1088,1089]},"v":"增量收集算法"},{"t":"list_item","d":13,"p":{"lines":[1089,1090]},"v":"分区算法(G1)"}]}]},{"t":"list_item","d":9,"p":{"lines":[1090,1091]},"v":"对象的finalization机制"},{"t":"list_item","d":9,"p":{"lines":[1091,1092]},"v":"对象的三种状态"}]},{"t":"list_item","d":7,"p":{"lines":[1092,1093]},"v":"垃圾回收相关概念","c":[{"t":"list_item","d":9,"p":{"lines":[1093,1094]},"v":"<code>System.gc()</code>"},{"t":"list_item","d":9,"p":{"lines":[1094,1095]},"v":"内存溢出"},{"t":"list_item","d":9,"p":{"lines":[1095,1096]},"v":"内存泄漏"},{"t":"list_item","d":9,"p":{"lines":[1096,1097]},"v":"Stop the world"},{"t":"list_item","d":9,"p":{"lines":[1097,1098]},"v":"垃圾回收的串行，并发与并行"},{"t":"list_item","d":9,"p":{"lines":[1098,1099]},"v":"安全点与安全区域"},{"t":"list_item","d":9,"p":{"lines":[1099,1100]},"v":"<strong>java中的引用</strong>","c":[{"t":"list_item","d":11,"p":{"lines":[1100,1101]},"v":"强引用"},{"t":"list_item","d":11,"p":{"lines":[1101,1102]},"v":"软引用"},{"t":"list_item","d":11,"p":{"lines":[1102,1103]},"v":"弱引用"},{"t":"list_item","d":11,"p":{"lines":[1103,1104]},"v":"虚引用"},{"t":"list_item","d":11,"p":{"lines":[1104,1105]},"v":"<code>-------------------</code>"},{"t":"list_item","d":11,"p":{"lines":[1105,1106]},"v":"终结器引用"}]}]},{"t":"list_item","d":7,"p":{"lines":[1106,1107]},"v":"垃圾回收器","c":[{"t":"list_item","d":9,"p":{"lines":[1107,1108]},"v":"分类","c":[{"t":"list_item","d":11,"p":{"lines":[1108,1109]},"v":"按线程数","c":[{"t":"list_item","d":13,"p":{"lines":[1109,1110]},"v":"串行"},{"t":"list_item","d":13,"p":{"lines":[1110,1111]},"v":"并行"}]},{"t":"list_item","d":11,"p":{"lines":[1111,1112]},"v":"按工作模式","c":[{"t":"list_item","d":13,"p":{"lines":[1112,1113]},"v":"并发"},{"t":"list_item","d":13,"p":{"lines":[1113,1114]},"v":"独占"}]},{"t":"list_item","d":11,"p":{"lines":[1114,1115]},"v":"按碎片处理方式分","c":[{"t":"list_item","d":13,"p":{"lines":[1115,1116]},"v":"压缩整理"},{"t":"list_item","d":13,"p":{"lines":[1116,1117]},"v":"非压缩整理，空闲列表"}]},{"t":"list_item","d":11,"p":{"lines":[1117,1118]},"v":"按工作的区间分","c":[{"t":"list_item","d":13,"p":{"lines":[1118,1119]},"v":"新生代"},{"t":"list_item","d":13,"p":{"lines":[1119,1120]},"v":"老年代"},{"t":"list_item","d":13,"p":{"lines":[1120,1121]},"v":"混合"},{"t":"list_item","d":13,"p":{"lines":[1121,1122]},"v":"Full"}]}]},{"t":"list_item","d":9,"p":{"lines":[1122,1123]},"v":"性能指标","c":[{"t":"list_item","d":11,"p":{"lines":[1123,1124]},"v":"主要的三个：","c":[{"t":"list_item","d":13,"p":{"lines":[1124,1125]},"v":"<strong>吞吐量</strong>"},{"t":"list_item","d":13,"p":{"lines":[1125,1126]},"v":"垃圾收集开销"},{"t":"list_item","d":13,"p":{"lines":[1126,1127]},"v":"<strong>暂停时间</strong>"},{"t":"list_item","d":13,"p":{"lines":[1127,1128]},"v":"收集频率"},{"t":"list_item","d":13,"p":{"lines":[1128,1129]},"v":"<strong>内存占用</strong>"},{"t":"list_item","d":13,"p":{"lines":[1129,1130]},"v":"快速"}]},{"t":"list_item","d":11,"p":{"lines":[1130,1131]},"v":"吞吐量，暂停时间的相互限制"}]},{"t":"list_item","d":9,"p":{"lines":[1131,1132]},"v":"为什么要有多种垃圾回收器"},{"t":"list_item","d":9,"p":{"lines":[1132,1133]},"v":"7中经典垃圾回收器","c":[{"t":"list_item","d":11,"p":{"lines":[1133,1134]},"v":"时间顺序：","c":[{"t":"list_item","d":13,"p":{"lines":[1134,1135]},"v":"serial<br />parNew(是serial多线程版本)"},{"t":"list_item","d":13,"p":{"lines":[1135,1136]},"v":"Parallel<br />CMS"},{"t":"list_item","d":13,"p":{"lines":[1136,1137]},"v":"G1"}]},{"t":"list_item","d":11,"p":{"lines":[1137,1138]},"v":"<strong>组合关系</strong>"},{"t":"list_item","d":11,"p":{"lines":[1138,1139]},"v":"<strong>详细说明</strong> <br />","c":[{"t":"list_item","d":13,"p":{"lines":[1139,1140]},"v":"Serial","c":[{"t":"list_item","d":15,"p":{"lines":[1140,1141]},"v":"说明","c":[{"t":"list_item","d":17,"p":{"lines":[1141,1142]},"v":"分类"},{"t":"list_item","d":17,"p":{"lines":[1142,1143]},"v":"作用位置"},{"t":"list_item","d":17,"p":{"lines":[1143,1144]},"v":"使用算法"},{"t":"list_item","d":17,"p":{"lines":[1144,1145]},"v":"吞吐/响应 优先"},{"t":"list_item","d":17,"p":{"lines":[1145,1146]},"v":"适用场景"}]},{"t":"list_item","d":15,"p":{"lines":[1146,1147]},"v":"工作流程"},{"t":"list_item","d":15,"p":{"lines":[1147,1148]},"v":"触发:见中层的堆"}]},{"t":"list_item","d":13,"p":{"lines":[1148,1149]},"v":"Serial Old","c":[{"t":"list_item","d":15,"p":{"lines":[1149,1150]},"v":"说明","c":[{"t":"list_item","d":17,"p":{"lines":[1150,1151]},"v":"分类"},{"t":"list_item","d":17,"p":{"lines":[1151,1152]},"v":"作用位置"},{"t":"list_item","d":17,"p":{"lines":[1152,1153]},"v":"使用算法"},{"t":"list_item","d":17,"p":{"lines":[1153,1154]},"v":"吞吐/响应 优先"},{"t":"list_item","d":17,"p":{"lines":[1154,1155]},"v":"适用场景"}]},{"t":"list_item","d":15,"p":{"lines":[1155,1156]},"v":"工作流程"},{"t":"list_item","d":15,"p":{"lines":[1156,1157]},"v":"触发:见中层的堆"}]},{"t":"list_item","d":13,"p":{"lines":[1157,1158]},"v":"ParNew","c":[{"t":"list_item","d":15,"p":{"lines":[1158,1159]},"v":"说明","c":[{"t":"list_item","d":17,"p":{"lines":[1159,1160]},"v":"分类"},{"t":"list_item","d":17,"p":{"lines":[1160,1161]},"v":"作用位置"},{"t":"list_item","d":17,"p":{"lines":[1161,1162]},"v":"使用算法"},{"t":"list_item","d":17,"p":{"lines":[1162,1163]},"v":"吞吐/响应 优先"},{"t":"list_item","d":17,"p":{"lines":[1163,1164]},"v":"适用场景"}]},{"t":"list_item","d":15,"p":{"lines":[1164,1165]},"v":"工作流程"},{"t":"list_item","d":15,"p":{"lines":[1165,1166]},"v":"触发:见中层的堆"},{"t":"list_item","d":15,"p":{"lines":[1166,1167]},"v":"背景：Serial多线程版本"},{"t":"list_item","d":15,"p":{"lines":[1167,1168]},"v":"<code>单核/多核</code> <code>serial/parnew</code>"}]},{"t":"list_item","d":13,"p":{"lines":[1168,1169]},"v":"Parallel Scavenge","c":[{"t":"list_item","d":15,"p":{"lines":[1169,1170]},"v":"说明","c":[{"t":"list_item","d":17,"p":{"lines":[1170,1171]},"v":"分类"},{"t":"list_item","d":17,"p":{"lines":[1171,1172]},"v":"作用位置"},{"t":"list_item","d":17,"p":{"lines":[1172,1173]},"v":"使用算法"},{"t":"list_item","d":17,"p":{"lines":[1173,1174]},"v":"吞吐/响应 优先"},{"t":"list_item","d":17,"p":{"lines":[1174,1175]},"v":"适用场景"}]},{"t":"list_item","d":15,"p":{"lines":[1175,1176]},"v":"工作流程"},{"t":"list_item","d":15,"p":{"lines":[1176,1177]},"v":"触发:见中层的堆"},{"t":"list_item","d":15,"p":{"lines":[1177,1178]},"v":"与parNew区别"}]},{"t":"list_item","d":13,"p":{"lines":[1178,1179]},"v":"Parallel Old","c":[{"t":"list_item","d":15,"p":{"lines":[1179,1180]},"v":"说明","c":[{"t":"list_item","d":17,"p":{"lines":[1180,1181]},"v":"分类"},{"t":"list_item","d":17,"p":{"lines":[1181,1182]},"v":"作用位置"},{"t":"list_item","d":17,"p":{"lines":[1182,1183]},"v":"使用算法"},{"t":"list_item","d":17,"p":{"lines":[1183,1184]},"v":"吞吐/响应 优先"},{"t":"list_item","d":17,"p":{"lines":[1184,1185]},"v":"适用场景"}]},{"t":"list_item","d":15,"p":{"lines":[1185,1186]},"v":"工作流程"},{"t":"list_item","d":15,"p":{"lines":[1186,1187]},"v":"触发:见中层的堆"}]},{"t":"list_item","d":13,"p":{"lines":[1187,1188]},"v":"CMS","c":[{"t":"list_item","d":15,"p":{"lines":[1188,1189]},"v":"概述","c":[{"t":"list_item","d":17,"p":{"lines":[1189,1190]},"v":"分类"},{"t":"list_item","d":17,"p":{"lines":[1190,1191]},"v":"作用位置"},{"t":"list_item","d":17,"p":{"lines":[1191,1192]},"v":"使用算法"},{"t":"list_item","d":17,"p":{"lines":[1192,1193]},"v":"吞吐/响应 优先"},{"t":"list_item","d":17,"p":{"lines":[1193,1194]},"v":"适用场景"}]},{"t":"list_item","d":15,"p":{"lines":[1194,1195]},"v":"触发(特殊)","c":[{"t":"list_item","d":17,"p":{"lines":[1195,1196]},"v":"<strong>达到阀值，而不是满了</strong>"}]},{"t":"list_item","d":15,"p":{"lines":[1196,1197]},"v":"垃圾回收机制","c":[{"t":"list_item","d":17,"p":{"lines":[1197,1198],"f":true},"v":"回收流程 ","c":[{"t":"list_item","d":19,"p":{"lines":[1198,1199]},"v":"初始标记(STW):仅仅只是标记出GC Roots能直接关联到的对象。"},{"t":"list_item","d":19,"p":{"lines":[1199,1200]},"v":"并发标记(不STW):从GC Roots的直接关联对象开始遍历整个对象图的过程"},{"t":"list_item","d":19,"p":{"lines":[1200,1201]},"v":"重新标记(STW):为了修正并发标记期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录"},{"t":"list_item","d":19,"p":{"lines":[1201,1202]},"v":"并发清除(不STW):此阶段清理删除掉标记阶段判断的已经死亡的对象，释放内存空间"}]},{"t":"list_item","d":17,"p":{"lines":[1202,1203]},"v":"后备方案","c":[{"t":"list_item","d":19,"p":{"lines":[1203,1204]},"v":"情况：比如大对象导致空间不足"},{"t":"list_item","d":19,"p":{"lines":[1204,1205]},"v":"错误：Concurrent Mode Failure"},{"t":"list_item","d":19,"p":{"lines":[1205,1206]},"v":"解决：serial old fullGC"}]}]},{"t":"list_item","d":15,"p":{"lines":[1206,1207],"f":true},"v":"搭配问题 ","c":[{"t":"list_item","d":17,"p":{"lines":[1207,1208]},"v":"无法与Parallel Scavenge搭配"}]},{"t":"list_item","d":15,"p":{"lines":[1208,1209],"f":true},"v":"废弃原因 ","c":[{"t":"list_item","d":17,"p":{"lines":[1209,1210]},"v":"内存碎片，大对象无法分配"},{"t":"list_item","d":17,"p":{"lines":[1210,1211]},"v":"后备serial old效率过低"},{"t":"list_item","d":17,"p":{"lines":[1211,1212]},"v":"并发导致程序变慢"},{"t":"list_item","d":17,"p":{"lines":[1212,1213]},"v":"浮动垃圾无法处理"}]}]},{"t":"list_item","d":13,"p":{"lines":[1213,1214]},"v":"G1","c":[{"t":"list_item","d":15,"p":{"lines":[1214,1215]},"v":"概述","c":[{"t":"list_item","d":17,"p":{"lines":[1215,1216]},"v":"分类"},{"t":"list_item","d":17,"p":{"lines":[1216,1217]},"v":"作用位置"},{"t":"list_item","d":17,"p":{"lines":[1217,1218]},"v":"吞吐/响应 优先"},{"t":"list_item","d":17,"p":{"lines":[1218,1219],"f":true},"v":"使用算法 ","c":[{"t":"list_item","d":19,"p":{"lines":[1219,1220]},"v":"局部复制"},{"t":"list_item","d":19,"p":{"lines":[1220,1221]},"v":"整体标记压缩"}]},{"t":"list_item","d":17,"p":{"lines":[1221,1222]},"v":"适用场景"}]},{"t":"list_item","d":15,"p":{"lines":[1222,1223]},"v":"出现原因"},{"t":"list_item","d":15,"p":{"lines":[1223,1224],"f":true},"v":"缺点 ","c":[{"t":"list_item","d":17,"p":{"lines":[1224,1225]},"v":"额外内存占用:Remember Set"}]},{"t":"list_item","d":15,"p":{"lines":[1225,1226]},"v":"分区算法，分代收集","c":[{"t":"list_item","d":17,"p":{"lines":[1226,1227]},"v":"region组成"},{"t":"list_item","d":17,"p":{"lines":[1227,1228]},"v":"region角色变换"},{"t":"list_item","d":17,"p":{"lines":[1228,1229]},"v":"Humongous region"},{"t":"list_item","d":17,"p":{"lines":[1229,1230]},"v":"region分段(默认8)"}]},{"t":"list_item","d":15,"p":{"lines":[1230,1231]},"v":"参数调优"},{"t":"list_item","d":15,"p":{"lines":[1231,1232]},"v":"垃圾回收机制","c":[{"t":"list_item","d":17,"p":{"lines":[1232,1233]},"v":"预备知识","c":[{"t":"list_item","d":19,"p":{"lines":[1233,1234],"f":true},"v":"dirty card queue ","c":[{"t":"list_item","d":21,"p":{"lines":[1234,1235]},"v":"作用：用来更新Rset，避免线程同步开销"}]},{"t":"list_item","d":19,"p":{"lines":[1235,1236],"f":true},"v":"Remember Set ","c":[{"t":"list_item","d":21,"p":{"lines":[1236,1237]},"v":"作用：准确的反映老年代对所在的内存分段中对象的引用"}]}]},{"t":"list_item","d":17,"p":{"lines":[1237,1238]},"v":"回收种类","c":[{"t":"list_item","d":19,"p":{"lines":[1238,1239]},"v":"minorGC","c":[{"t":"list_item","d":21,"p":{"lines":[1239,1240]},"v":"触发"},{"t":"list_item","d":21,"p":{"lines":[1240,1241]},"v":"回收区域"},{"t":"list_item","d":21,"p":{"lines":[1241,1242],"f":true},"v":"详细过程 ","c":[{"t":"list_item","d":23,"p":{"lines":[1242,1243]},"v":"第一阶段，扫描根。"},{"t":"list_item","d":23,"p":{"lines":[1243,1244]},"v":"第二阶段，更新RSet。"},{"t":"list_item","d":23,"p":{"lines":[1244,1245]},"v":"第三阶段，处理RSet。"},{"t":"list_item","d":23,"p":{"lines":[1245,1246]},"v":"第四阶段，复制对象。"},{"t":"list_item","d":23,"p":{"lines":[1246,1247]},"v":"第五阶段，处理引用。"}]}]},{"t":"list_item","d":19,"p":{"lines":[1247,1248]},"v":"老年代并发标记过程","c":[{"t":"list_item","d":21,"p":{"lines":[1248,1249]},"v":"触发"},{"t":"list_item","d":21,"p":{"lines":[1249,1250]},"v":"回收区域"},{"t":"list_item","d":21,"p":{"lines":[1250,1251],"f":true},"v":"详细过程 ","c":[{"t":"list_item","d":23,"p":{"lines":[1251,1252]},"v":"1.初始标记阶段"},{"t":"list_item","d":23,"p":{"lines":[1252,1253]},"v":"2.根区域扫描（Root Region Scanning)"},{"t":"list_item","d":23,"p":{"lines":[1253,1254]},"v":"3.并发标记（Concurrent Marking)"},{"t":"list_item","d":23,"p":{"lines":[1254,1255]},"v":"4.再次标记（Remark)"},{"t":"list_item","d":23,"p":{"lines":[1255,1256]},"v":"5.独占清理（cleanup,STW)"},{"t":"list_item","d":23,"p":{"lines":[1256,1257]},"v":"6.并发清理阶段"}]},{"t":"list_item","d":21,"p":{"lines":[1257,1258],"f":true},"v":"回收结果 ","c":[{"t":"list_item","d":23,"p":{"lines":[1258,1259]},"v":"百分百为垃圾的内存分段被回收"},{"t":"list_item","d":23,"p":{"lines":[1259,1260]},"v":"部分为垃圾的内存分段被计算"}]}]},{"t":"list_item","d":19,"p":{"lines":[1260,1261]},"v":"mixedGC","c":[{"t":"list_item","d":21,"p":{"lines":[1261,1262]},"v":"触发"},{"t":"list_item","d":21,"p":{"lines":[1262,1263]},"v":"回收区域"},{"t":"list_item","d":21,"p":{"lines":[1263,1264]},"v":"<strong>可预测时间模型(重要)</strong>"}]},{"t":"list_item","d":19,"p":{"lines":[1264,1265]},"v":"full GC(失败保护)","c":[{"t":"list_item","d":21,"p":{"lines":[1265,1266]},"v":"触发"},{"t":"list_item","d":21,"p":{"lines":[1266,1267],"f":true},"v":"性能 ","c":[{"t":"list_item","d":23,"p":{"lines":[1267,1268]},"v":"单线程"},{"t":"list_item","d":23,"p":{"lines":[1268,1269]},"v":"独占式"},{"t":"list_item","d":23,"p":{"lines":[1269,1270]},"v":"高强度"},{"t":"list_item","d":23,"p":{"lines":[1270,1271]},"v":"总之很差"}]}]}]}]}]}]},{"t":"list_item","d":11,"p":{"lines":[1271,1272]},"v":"垃圾回收器的选择"}]}]},{"t":"list_item","d":7,"p":{"lines":[1273,1274],"f":true},"v":"问题 ","c":[{"t":"list_item","d":9,"p":{"lines":[1274,1275]},"v":"垃圾收集的算法有哪些？如何判断一个对象是否可以回收？"},{"t":"list_item","d":9,"p":{"lines":[1275,1276]},"v":"垃圾收集器工作的基本流程。"},{"t":"list_item","d":9,"p":{"lines":[1276,1277]},"v":"JVMGC算法有哪些，目前的JDK版本采用什么回收算法"},{"t":"list_item","d":9,"p":{"lines":[1277,1278]},"v":"G1回收器讲下回收过程"},{"t":"list_item","d":9,"p":{"lines":[1278,1279]},"v":"GC是什么？为什么要有GC?"},{"t":"list_item","d":9,"p":{"lines":[1279,1280]},"v":"GC的两种判定方法？CMS收集器与G1收集器的特点。"},{"t":"list_item","d":9,"p":{"lines":[1280,1281]},"v":"说一下GC算法，分代回收说下"},{"t":"list_item","d":9,"p":{"lines":[1281,1282]},"v":"垃圾收集策略和算法"},{"t":"list_item","d":9,"p":{"lines":[1282,1283]},"v":"jvm GC原理，JVM怎么回收内存"},{"t":"list_item","d":9,"p":{"lines":[1283,1284]},"v":"CMS特点，垃圾回收算法有哪些？各自的优缺点，他们共同的缺点是什么？"},{"t":"list_item","d":9,"p":{"lines":[1284,1285]},"v":"java的垃圾回收器都有哪些，说下g1的应用场景，平时你是如何搭配使用垃圾回收器的"},{"t":"list_item","d":9,"p":{"lines":[1285,1286]},"v":"你知道哪几种垃圾收集器，各自的优缺点，重点讲下cms和G1,包括原理，流程，优缺点。"},{"t":"list_item","d":9,"p":{"lines":[1286,1287]},"v":"垃圾回收算法的实现原理。"},{"t":"list_item","d":9,"p":{"lines":[1287,1288]},"v":"讲一讲垃圾回收算法。"},{"t":"list_item","d":9,"p":{"lines":[1288,1289]},"v":"什么情况下触发垃圾回收？"},{"t":"list_item","d":9,"p":{"lines":[1289,1290]},"v":"如何选择合适的垃圾收集算法？"},{"t":"list_item","d":9,"p":{"lines":[1290,1291]},"v":"JVM有哪三种垃圾回收器？"},{"t":"list_item","d":9,"p":{"lines":[1291,1292]},"v":"常见的垃圾回收器算法有哪些，各有什么优劣？"},{"t":"list_item","d":9,"p":{"lines":[1292,1293]},"v":"system.gc()和runtime.gc()会做什么事情？"},{"t":"list_item","d":9,"p":{"lines":[1293,1294]},"v":"Java GC机制？GC Roots有哪些？"},{"t":"list_item","d":9,"p":{"lines":[1294,1295]},"v":"Java对象的回收方式，回收算法。"},{"t":"list_item","d":9,"p":{"lines":[1295,1296]},"v":"CMS和G1了解么，CMS解决什么问题，说一下回收的过程。"},{"t":"list_item","d":9,"p":{"lines":[1296,1297]},"v":"CMS回收停顿了几次，为什么要停顿两次。"}]}]}]}]},{"t":"heading","d":2,"p":{"lines":[1298,1299],"f":true},"v":"字节码与类加载子系统 "},{"t":"heading","d":2,"p":{"lines":[1300,1301],"f":true},"v":"jvm调优 "}]},{"t":"heading","d":1,"p":{"lines":[1302,1303]},"v":"常用框架","c":[{"t":"heading","d":2,"p":{"lines":[1304,1305],"f":true},"v":"Spring","c":[{"t":"heading","d":3,"p":{"lines":[1306,1307]},"v":"基础","c":[{"t":"list_item","d":5,"p":{"lines":[1308,1309]},"v":"什么是Spring框架"},{"t":"list_item","d":5,"p":{"lines":[1309,1310]},"v":"Spring框架的重要模块"},{"t":"list_item","d":5,"p":{"lines":[1310,1311]},"v":"为什么要使用Spring框架"},{"t":"list_item","d":5,"p":{"lines":[1311,1312]},"v":"Spring框架的两大核心","c":[{"t":"list_item","d":7,"p":{"lines":[1312,1313]},"v":"IOC"},{"t":"list_item","d":7,"p":{"lines":[1313,1314]},"v":"AOP"}]},{"t":"list_item","d":5,"p":{"lines":[1314,1315]},"v":"BeanFactory和ApplicationContextSpring"}]},{"t":"heading","d":3,"p":{"lines":[1316,1317]},"v":"IOC","c":[{"t":"list_item","d":5,"p":{"lines":[1318,1319]},"v":"概念"},{"t":"list_item","d":5,"p":{"lines":[1319,1320]},"v":"<a href=\"https://javadoop.com/post/spring-ioc\">IOC容器初始化过程</a>"},{"t":"list_item","d":5,"p":{"lines":[1321,1322]},"v":"基于xml的IOC","c":[{"t":"list_item","d":7,"p":{"lines":[1322,1323]},"v":"存入容器方式","c":[{"t":"list_item","d":9,"p":{"lines":[1323,1324]},"v":"Bean标签","c":[{"t":"list_item","d":11,"p":{"lines":[1324,1325]},"v":"默认构造函数"},{"t":"list_item","d":11,"p":{"lines":[1325,1326]},"v":"工厂类"},{"t":"list_item","d":11,"p":{"lines":[1326,1327]},"v":"静态工厂方法"}]}]},{"t":"list_item","d":7,"p":{"lines":[1327,1328]},"v":"依赖注入方式","c":[{"t":"list_item","d":9,"p":{"lines":[1328,1329]},"v":"注入Bean类型","c":[{"t":"list_item","d":11,"p":{"lines":[1329,1330]},"v":"使用构造函数(一般不用)"},{"t":"list_item","d":11,"p":{"lines":[1330,1331]},"v":"使用set方法(常用)"},{"t":"list_item","d":11,"p":{"lines":[1331,1332]},"v":"使用注解"}]},{"t":"list_item","d":9,"p":{"lines":[1332,1333]},"v":"注入基本类型和集合类型","c":[{"t":"list_item","d":11,"p":{"lines":[1333,1334]},"v":"通过xml"}]}]},{"t":"list_item","d":7,"p":{"lines":[1334,1335]},"v":"生命周期，类型等都通过bean标签属性"}]},{"t":"list_item","d":5,"p":{"lines":[1336,1337]},"v":"基于注解的IOC","c":[{"t":"list_item","d":7,"p":{"lines":[1337,1338]},"v":"存入容器的注解","c":[{"t":"list_item","d":9,"p":{"lines":[1338,1339]},"v":"@Component"},{"t":"list_item","d":9,"p":{"lines":[1339,1340]},"v":"@Controller"},{"t":"list_item","d":9,"p":{"lines":[1340,1341]},"v":"@Service"},{"t":"list_item","d":9,"p":{"lines":[1341,1342]},"v":"@Repository"}]},{"t":"list_item","d":7,"p":{"lines":[1342,1343]},"v":"依赖注入的注解","c":[{"t":"list_item","d":9,"p":{"lines":[1343,1344]},"v":"注入Bean类型","c":[{"t":"list_item","d":11,"p":{"lines":[1344,1345]},"v":"@AutoWired"},{"t":"list_item","d":11,"p":{"lines":[1345,1346]},"v":"@Qualifier"},{"t":"list_item","d":11,"p":{"lines":[1346,1347]},"v":"@Reasource"}]},{"t":"list_item","d":9,"p":{"lines":[1347,1348]},"v":"注入基本类型","c":[{"t":"list_item","d":11,"p":{"lines":[1348,1349]},"v":"@Value"}]}]},{"t":"list_item","d":7,"p":{"lines":[1349,1350]},"v":"生命周期相关注解","c":[{"t":"list_item","d":9,"p":{"lines":[1350,1351]},"v":"@PostConstruct"},{"t":"list_item","d":9,"p":{"lines":[1351,1352]},"v":"@PreDestroy"}]},{"t":"list_item","d":7,"p":{"lines":[1352,1353]},"v":"改变作用范围<br />(和存入容器的注解搭配使用<br />上面四四个或@bean)","c":[{"t":"list_item","d":9,"p":{"lines":[1353,1354]},"v":"@Scope"}]}]},{"t":"list_item","d":5,"p":{"lines":[1355,1356]},"v":"注意：对于无法添加注解<br />如导入的第三方依赖<br />可以通过xml将其存入或者向其注入<br />或者使用下面的<code>@Bean</code>"}]},{"t":"heading","d":3,"p":{"lines":[1357,1358]},"v":"摆脱xml的注解","c":[{"t":"list_item","d":5,"p":{"lines":[1359,1360]},"v":"@Configuration"},{"t":"list_item","d":5,"p":{"lines":[1360,1361]},"v":"@ComponentScan","c":[{"t":"list_item","d":7,"p":{"lines":[1361,1362]},"v":"对应<code>component:scan</code>"}]},{"t":"list_item","d":5,"p":{"lines":[1362,1363]},"v":"@Bean","c":[{"t":"list_item","d":7,"p":{"lines":[1363,1364]},"v":"对应xml中的工厂方法"},{"t":"list_item","d":7,"p":{"lines":[1364,1365]},"v":"通常配置在Config类<br />返回指定对象的上方"}]},{"t":"list_item","d":5,"p":{"lines":[1365,1366]},"v":"@Import"},{"t":"list_item","d":5,"p":{"lines":[1366,1367]},"v":"@PropertySource"}]},{"t":"heading","d":3,"p":{"lines":[1368,1369]},"v":"AOP","c":[{"t":"list_item","d":5,"p":{"lines":[1370,1371]},"v":"说明"},{"t":"list_item","d":5,"p":{"lines":[1371,1372]},"v":"相关概念","c":[{"t":"list_item","d":7,"p":{"lines":[1372,1373]},"v":"Joinpoint"},{"t":"list_item","d":7,"p":{"lines":[1373,1374]},"v":"Pointcut"},{"t":"list_item","d":7,"p":{"lines":[1374,1375]},"v":"Advice","c":[{"t":"list_item","d":9,"p":{"lines":[1375,1376]},"v":"前置通知"},{"t":"list_item","d":9,"p":{"lines":[1376,1377]},"v":"后置通知"},{"t":"list_item","d":9,"p":{"lines":[1377,1378]},"v":"异常通知"},{"t":"list_item","d":9,"p":{"lines":[1378,1379]},"v":"最终通知"},{"t":"list_item","d":9,"p":{"lines":[1379,1380]},"v":"环绕通知"}]},{"t":"list_item","d":7,"p":{"lines":[1380,1381]},"v":"Introduction"},{"t":"list_item","d":7,"p":{"lines":[1381,1382]},"v":"Target"},{"t":"list_item","d":7,"p":{"lines":[1382,1383]},"v":"Weaving"},{"t":"list_item","d":7,"p":{"lines":[1383,1384]},"v":"Proxy"},{"t":"list_item","d":7,"p":{"lines":[1384,1385]},"v":"Aspect"}]},{"t":"list_item","d":5,"p":{"lines":[1386,1387]},"v":"实现原理","c":[{"t":"list_item","d":7,"p":{"lines":[1387,1388]},"v":"静态代理AspectJ"},{"t":"list_item","d":7,"p":{"lines":[1388,1389]},"v":"动态代理","c":[{"t":"list_item","d":9,"p":{"lines":[1389,1390]},"v":"JDK"},{"t":"list_item","d":9,"p":{"lines":[1390,1391]},"v":"GBLib"},{"t":"list_item","d":9,"p":{"lines":[1391,1392]},"v":"两者对比"}]},{"t":"list_item","d":7,"p":{"lines":[1392,1393]},"v":"动态和静态对比"}]},{"t":"list_item","d":5,"p":{"lines":[1394,1395]},"v":"使用","c":[{"t":"list_item","d":7,"p":{"lines":[1395,1396]},"v":"xml","c":[{"t":"list_item","d":9,"p":{"lines":[1396,1397]},"v":"配置步骤"},{"t":"list_item","d":9,"p":{"lines":[1397,1398]},"v":"切入点表达式"}]},{"t":"list_item","d":7,"p":{"lines":[1398,1399]},"v":"注解","c":[{"t":"list_item","d":9,"p":{"lines":[1399,1400]},"v":"开启支持","c":[{"t":"list_item","d":11,"p":{"lines":[1400,1401]},"v":"xml：<code>aop:aspectj-autoproxy</code>"},{"t":"list_item","d":11,"p":{"lines":[1401,1402]},"v":"注解：<code>@EnableAspectJAutoProxy</code>"}]},{"t":"list_item","d":9,"p":{"lines":[1402,1403]},"v":"配置步骤"},{"t":"list_item","d":9,"p":{"lines":[1403,1404]},"v":"切入点表达式"}]}]}]},{"t":"heading","d":3,"p":{"lines":[1405,1406]},"v":"Bean","c":[{"t":"list_item","d":5,"p":{"lines":[1407,1408]},"v":"创建Bean的方式","c":[{"t":"list_item","d":7,"p":{"lines":[1408,1409]},"v":"默认构造函数"},{"t":"list_item","d":7,"p":{"lines":[1409,1410]},"v":"工厂类"},{"t":"list_item","d":7,"p":{"lines":[1410,1411]},"v":"静态工厂"}]},{"t":"list_item","d":5,"p":{"lines":[1412,1413]},"v":"Scope作用范围","c":[{"t":"list_item","d":7,"p":{"lines":[1413,1414]},"v":"singleton：单例的（默认值）"},{"t":"list_item","d":7,"p":{"lines":[1414,1415]},"v":"prototype：多例的"},{"t":"list_item","d":7,"p":{"lines":[1415,1416]},"v":"request：作用于web应用的请求范围"},{"t":"list_item","d":7,"p":{"lines":[1416,1417]},"v":"session：作用于web应用的会话范围"},{"t":"list_item","d":7,"p":{"lines":[1417,1418]},"v":"global-session：Spring5中已经没有了"}]},{"t":"list_item","d":5,"p":{"lines":[1419,1420]},"v":"生命周期"},{"t":"list_item","d":5,"p":{"lines":[1421,1422]},"v":"线程安全问题"}]},{"t":"heading","d":3,"p":{"lines":[1423,1424]},"v":"事务","c":[{"t":"list_item","d":5,"p":{"lines":[1425,1426]},"v":"Spring对事务的支持","c":[{"t":"list_item","d":7,"p":{"lines":[1426,1427]},"v":"取决于数据库"}]},{"t":"list_item","d":5,"p":{"lines":[1428,1429]},"v":"Spring事务相关API","c":[{"t":"list_item","d":7,"p":{"lines":[1429,1430]},"v":"PlatformTransactionManager"},{"t":"list_item","d":7,"p":{"lines":[1430,1431]},"v":"TransactionDefinition"},{"t":"list_item","d":7,"p":{"lines":[1431,1432]},"v":"TransactionStatus"}]},{"t":"list_item","d":5,"p":{"lines":[1433,1434]},"v":"事务管理方式","c":[{"t":"list_item","d":7,"p":{"lines":[1434,1435]},"v":"编程式（基本不用，仅仅为了了解原理）"},{"t":"list_item","d":7,"p":{"lines":[1435,1436]},"v":"声明式（基于AOP）","c":[{"t":"list_item","d":9,"p":{"lines":[1436,1437]},"v":"基于xml","c":[{"t":"list_item","d":11,"p":{"lines":[1437,1438]},"v":"配置流程"}]},{"t":"list_item","d":9,"p":{"lines":[1438,1439]},"v":"xml开启支持+注解配置","c":[{"t":"list_item","d":11,"p":{"lines":[1439,1440]},"v":"配置流程"}]},{"t":"list_item","d":9,"p":{"lines":[1440,1441]},"v":"纯注解配置","c":[{"t":"list_item","d":11,"p":{"lines":[1441,1442]},"v":"配置流程"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[1443,1444]},"v":"<strong>事务属性</strong><br />tx:advice标签内部可以配置<br />也可以使用注解配置","c":[{"t":"list_item","d":7,"p":{"lines":[1444,1445]},"v":"propagation(传播行为):(7)","c":[{"t":"list_item","d":9,"p":{"lines":[1445,1446]},"v":"支持当前事务的情况(3)","c":[{"t":"list_item","d":11,"p":{"lines":[1446,1447]},"v":"required(默认)"},{"t":"list_item","d":11,"p":{"lines":[1447,1448]},"v":"supports"},{"t":"list_item","d":11,"p":{"lines":[1448,1449]},"v":"mandatory"}]},{"t":"list_item","d":9,"p":{"lines":[1449,1450]},"v":"不支持当前事务的情况(3)","c":[{"t":"list_item","d":11,"p":{"lines":[1450,1451]},"v":"requires_new"},{"t":"list_item","d":11,"p":{"lines":[1451,1452]},"v":"not_supported"},{"t":"list_item","d":11,"p":{"lines":[1452,1453]},"v":"never"}]},{"t":"list_item","d":9,"p":{"lines":[1453,1454]},"v":"其他情况(1)","c":[{"t":"list_item","d":11,"p":{"lines":[1454,1455]},"v":"nested"}]}]},{"t":"list_item","d":7,"p":{"lines":[1455,1456]},"v":"isolation(隔离级别)(5)","c":[{"t":"list_item","d":9,"p":{"lines":[1456,1457]},"v":"default"},{"t":"list_item","d":9,"p":{"lines":[1457,1458]},"v":"read_uncommitted"},{"t":"list_item","d":9,"p":{"lines":[1458,1459]},"v":"read_committed"},{"t":"list_item","d":9,"p":{"lines":[1459,1460]},"v":"repeatable_read"},{"t":"list_item","d":9,"p":{"lines":[1460,1461]},"v":"serializable"}]},{"t":"list_item","d":7,"p":{"lines":[1461,1462]},"v":"timeout(超时属性)","c":[{"t":"list_item","d":9,"p":{"lines":[1462,1463]},"v":"用于指定事务的超时时间"},{"t":"list_item","d":9,"p":{"lines":[1463,1464]},"v":"默认值是-1"}]},{"t":"list_item","d":7,"p":{"lines":[1464,1465]},"v":"read-only(只读属性)","c":[{"t":"list_item","d":9,"p":{"lines":[1465,1466]},"v":"用于指定事务是否只读"},{"t":"list_item","d":9,"p":{"lines":[1466,1467]},"v":"默认false"}]},{"t":"list_item","d":7,"p":{"lines":[1467,1468]},"v":"回滚规则","c":[{"t":"list_item","d":9,"p":{"lines":[1468,1469]},"v":"rollback-for"},{"t":"list_item","d":9,"p":{"lines":[1469,1470]},"v":"no-rollback-for"}]}]}]},{"t":"heading","d":3,"p":{"lines":[1472,1473]},"v":"设计模式","c":[{"t":"list_item","d":5,"p":{"lines":[1474,1475]},"v":"工厂设计模式","c":[{"t":"list_item","d":7,"p":{"lines":[1475,1476]},"v":"BeanFactory"},{"t":"list_item","d":7,"p":{"lines":[1476,1477]},"v":"ApplicationContext"}]},{"t":"list_item","d":5,"p":{"lines":[1477,1478]},"v":"单例设计模式","c":[{"t":"list_item","d":7,"p":{"lines":[1478,1479]},"v":"bean默认作用域"},{"t":"list_item","d":7,"p":{"lines":[1479,1480]},"v":"实现：ConcurrentHashMap 实现单例注册表的特殊方式"}]},{"t":"list_item","d":5,"p":{"lines":[1480,1481]},"v":"代理设计模式","c":[{"t":"list_item","d":7,"p":{"lines":[1481,1482]},"v":"代理模式在 AOP 中的应用"},{"t":"list_item","d":7,"p":{"lines":[1482,1483]},"v":"代理模式的实现","c":[{"t":"list_item","d":9,"p":{"lines":[1483,1484]},"v":"静态代理AspectJ"},{"t":"list_item","d":9,"p":{"lines":[1484,1485]},"v":"动态代理","c":[{"t":"list_item","d":11,"p":{"lines":[1485,1486]},"v":"JDK"},{"t":"list_item","d":11,"p":{"lines":[1486,1487]},"v":"GBLib"},{"t":"list_item","d":11,"p":{"lines":[1487,1488]},"v":"两者对比"}]},{"t":"list_item","d":9,"p":{"lines":[1488,1489]},"v":"动态和静态对比"}]}]},{"t":"list_item","d":5,"p":{"lines":[1489,1490]},"v":"模板方法","c":[{"t":"list_item","d":7,"p":{"lines":[1490,1491]},"v":"jdbcTemplate"},{"t":"list_item","d":7,"p":{"lines":[1491,1492]},"v":"hibernateTemplate"},{"t":"list_item","d":7,"p":{"lines":[1492,1493]},"v":"RedisTemplate"}]},{"t":"list_item","d":5,"p":{"lines":[1493,1494]},"v":"观察者模式","c":[{"t":"list_item","d":7,"p":{"lines":[1494,1495]},"v":"Spring 事件驱动模型中的三种角色","c":[{"t":"list_item","d":9,"p":{"lines":[1495,1496]},"v":"事件角色"},{"t":"list_item","d":9,"p":{"lines":[1496,1497]},"v":"事件监听者角色"},{"t":"list_item","d":9,"p":{"lines":[1497,1498]},"v":"事件发布者角色"}]},{"t":"list_item","d":7,"p":{"lines":[1498,1499]},"v":"Spring 的事件流程总结"}]},{"t":"list_item","d":5,"p":{"lines":[1499,1500]},"v":"适配器模式","c":[{"t":"list_item","d":7,"p":{"lines":[1500,1501]},"v":"spring AOP中的适配器模式"},{"t":"list_item","d":7,"p":{"lines":[1501,1502]},"v":"spring MVC中的适配器模式"}]},{"t":"list_item","d":5,"p":{"lines":[1502,1503]},"v":"装饰者模式"}]}]},{"t":"heading","d":2,"p":{"lines":[1504,1505],"f":true},"v":"SpringMVC "},{"t":"heading","d":2,"p":{"lines":[1506,1507],"f":true},"v":"SpringBoot "},{"t":"heading","d":2,"p":{"lines":[1508,1509],"f":true},"v":"Mybatis ","c":[{"t":"list_item","d":4,"p":{"lines":[1510,1511]},"v":"基本使用","c":[{"t":"list_item","d":6,"p":{"lines":[1511,1512]},"v":"xml","c":[{"t":"list_item","d":8,"p":{"lines":[1512,1513]},"v":"常见标签","c":[{"t":"list_item","d":10,"p":{"lines":[1513,1514]},"v":"select"},{"t":"list_item","d":10,"p":{"lines":[1514,1515]},"v":"insert","c":[{"t":"list_item","d":12,"p":{"lines":[1515,1516]},"v":"selectKey(获取插入数据的主键)"}]},{"t":"list_item","d":10,"p":{"lines":[1516,1517]},"v":"update"},{"t":"list_item","d":10,"p":{"lines":[1517,1518]},"v":"delete"}]},{"t":"list_item","d":8,"p":{"lines":[1518,1519]},"v":"配置标签","c":[{"t":"list_item","d":10,"p":{"lines":[1519,1520]},"v":"typeAliases","c":[{"t":"list_item","d":12,"p":{"lines":[1520,1521]},"v":"package<br />(指定<strong>实体类</strong>包，用于起别名)"}]},{"t":"list_item","d":10,"p":{"lines":[1521,1522]},"v":"mapper","c":[{"t":"list_item","d":12,"p":{"lines":[1522,1523]},"v":"package<br />(指定<strong>dao类</strong>包，避免往SqlConfig文件中的<br />mappers中添加mapper标签)"}]}]},{"t":"list_item","d":8,"p":{"lines":[1523,1524]},"v":"其他标签","c":[{"t":"list_item","d":10,"p":{"lines":[1524,1525]},"v":"resultMap"},{"t":"list_item","d":10,"p":{"lines":[1525,1526]},"v":"parameterMap"},{"t":"list_item","d":10,"p":{"lines":[1526,1527]},"v":"include"},{"t":"list_item","d":10,"p":{"lines":[1527,1528]},"v":"sql"},{"t":"list_item","d":10,"p":{"lines":[1528,1529]},"v":"selectKey"}]},{"t":"list_item","d":8,"p":{"lines":[1529,1530]},"v":"动态sql标签","c":[{"t":"list_item","d":10,"p":{"lines":[1530,1531]},"v":"trim"},{"t":"list_item","d":10,"p":{"lines":[1531,1532]},"v":"where"},{"t":"list_item","d":10,"p":{"lines":[1532,1533]},"v":"set"},{"t":"list_item","d":10,"p":{"lines":[1533,1534]},"v":"foreach"},{"t":"list_item","d":10,"p":{"lines":[1534,1535]},"v":"if"},{"t":"list_item","d":10,"p":{"lines":[1535,1536]},"v":"choose"},{"t":"list_item","d":10,"p":{"lines":[1536,1537]},"v":"when"},{"t":"list_item","d":10,"p":{"lines":[1537,1538]},"v":"otherwise"},{"t":"list_item","d":10,"p":{"lines":[1538,1539]},"v":"bind"},{"t":"list_item","d":10,"p":{"lines":[1539,1540]},"v":"include","c":[{"t":"list_item","d":12,"p":{"lines":[1540,1541]},"v":"搭配<code>sql</code>标签"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[1541,1542]},"v":"注解","c":[{"t":"list_item","d":8,"p":{"lines":[1542,1543]},"v":"常见标签","c":[{"t":"list_item","d":10,"p":{"lines":[1543,1544]},"v":"@Select"},{"t":"list_item","d":10,"p":{"lines":[1544,1545]},"v":"@Insert"},{"t":"list_item","d":10,"p":{"lines":[1545,1546]},"v":"@Update"},{"t":"list_item","d":10,"p":{"lines":[1546,1547]},"v":"@Delete"}]},{"t":"list_item","d":8,"p":{"lines":[1547,1548]},"v":"其他标签","c":[{"t":"list_item","d":10,"p":{"lines":[1548,1549]},"v":"@Results","c":[{"t":"list_item","d":12,"p":{"lines":[1549,1550]},"v":"定义并使用"}]},{"t":"list_item","d":10,"p":{"lines":[1550,1551]},"v":"@ResultMap","c":[{"t":"list_item","d":12,"p":{"lines":[1551,1552]},"v":"使用已定义的"}]}]}]}]},{"t":"list_item","d":4,"p":{"lines":[1553,1554]},"v":"映射关系","c":[{"t":"list_item","d":6,"p":{"lines":[1554,1555]},"v":"<code>&lt;parameterMap&gt;</code>---ParameterMap"},{"t":"list_item","d":6,"p":{"lines":[1555,1556]},"v":"<code>&lt;resultMap&gt;</code>---ResultMap","c":[{"t":"list_item","d":8,"p":{"lines":[1556,1557]},"v":"子元素:ResultMapping"}]},{"t":"list_item","d":6,"p":{"lines":[1557,1558]},"v":"<code>&lt;select&gt;/&lt;update&gt;/&lt;insert&gt;/&lt;delet&gt;</code>---MappedStatement"}]},{"t":"list_item","d":4,"p":{"lines":[1559,1560]},"v":"<strong>执行流程</strong>"},{"t":"list_item","d":4,"p":{"lines":[1561,1562]},"v":"dao接口到MappedStatement的映射"},{"t":"list_item","d":4,"p":{"lines":[1563,1564]},"v":"动态sql","c":[{"t":"list_item","d":6,"p":{"lines":[1564,1565]},"v":"原理"},{"t":"list_item","d":6,"p":{"lines":[1565,1566]},"v":"应用:dao方法重载"}]},{"t":"list_item","d":4,"p":{"lines":[1567,1568]},"v":"多表查询","c":[{"t":"list_item","d":6,"p":{"lines":[1568,1569]},"v":"一对一(多对一)"},{"t":"list_item","d":6,"p":{"lines":[1569,1570]},"v":"一对多"},{"t":"list_item","d":6,"p":{"lines":[1570,1571]},"v":"多对多"}]},{"t":"list_item","d":4,"p":{"lines":[1572,1573]},"v":"加载","c":[{"t":"list_item","d":6,"p":{"lines":[1573,1574]},"v":"立即加载","c":[{"t":"list_item","d":8,"p":{"lines":[1574,1575]},"v":"使用场景"},{"t":"list_item","d":8,"p":{"lines":[1575,1576]},"v":"说明"}]},{"t":"list_item","d":6,"p":{"lines":[1576,1577]},"v":"延迟加载","c":[{"t":"list_item","d":8,"p":{"lines":[1577,1578]},"v":"使用场景"},{"t":"list_item","d":8,"p":{"lines":[1578,1579]},"v":"说明"},{"t":"list_item","d":8,"p":{"lines":[1579,1580]},"v":"配置"},{"t":"list_item","d":8,"p":{"lines":[1580,1581]},"v":"原理:拦截器"}]}]},{"t":"list_item","d":4,"p":{"lines":[1582,1583]},"v":"缓存","c":[{"t":"list_item","d":6,"p":{"lines":[1583,1584]},"v":"说明"},{"t":"list_item","d":6,"p":{"lines":[1584,1585]},"v":"种类","c":[{"t":"list_item","d":8,"p":{"lines":[1585,1586]},"v":"一级缓存","c":[{"t":"list_item","d":10,"p":{"lines":[1586,1587]},"v":"概念"},{"t":"list_item","d":10,"p":{"lines":[1587,1588]},"v":"触发"}]},{"t":"list_item","d":8,"p":{"lines":[1588,1589]},"v":"二级缓存","c":[{"t":"list_item","d":10,"p":{"lines":[1589,1590]},"v":"概念"},{"t":"list_item","d":10,"p":{"lines":[1590,1591]},"v":"配置开启","c":[{"t":"list_item","d":12,"p":{"lines":[1591,1592]},"v":"xml","c":[{"t":"list_item","d":14,"p":{"lines":[1592,1593]},"v":"config.xml"},{"t":"list_item","d":14,"p":{"lines":[1593,1594]},"v":"dao.xml"},{"t":"list_item","d":14,"p":{"lines":[1594,1595]},"v":"<code>&lt;select&gt;</code>"}]},{"t":"list_item","d":12,"p":{"lines":[1595,1596]},"v":"注解","c":[{"t":"list_item","d":14,"p":{"lines":[1596,1597]},"v":"SqlMapConfig.xml"},{"t":"list_item","d":14,"p":{"lines":[1597,1598]},"v":"@CacheNamespace(blocking=true)"}]}]},{"t":"list_item","d":10,"p":{"lines":[1598,1599]},"v":"触发"}]}]}]},{"t":"list_item","d":4,"p":{"lines":[1600,1601]},"v":"分页","c":[{"t":"list_item","d":6,"p":{"lines":[1601,1602],"f":true},"v":"RowBounds ","c":[{"t":"list_item","d":8,"p":{"lines":[1602,1603]},"v":"内存分页"},{"t":"list_item","d":8,"p":{"lines":[1603,1604]},"v":"返回结果集的子集"}]},{"t":"list_item","d":6,"p":{"lines":[1604,1605],"f":true},"v":"分页插件 ","c":[{"t":"list_item","d":8,"p":{"lines":[1605,1606]},"v":"拦截sql,物理分页"},{"t":"list_item","d":8,"p":{"lines":[1606,1607]},"v":"<code>select _ from student</code>"},{"t":"list_item","d":8,"p":{"lines":[1607,1608]},"v":"拦截 sql 后重写为：<br /> <code>select t._ from （select \\* from student）t limit 0，10</code>"}]}]},{"t":"list_item","d":4,"p":{"lines":[1609,1610]},"v":"插件","c":[{"t":"list_item","d":6,"p":{"lines":[1610,1611]},"v":"分页插件原理"},{"t":"list_item","d":6,"p":{"lines":[1611,1612]},"v":"自定义插件步骤"}]}]},{"t":"heading","d":2,"p":{"lines":[1613,1614],"f":true},"v":"Netty "},{"t":"heading","d":2,"p":{"lines":[1615,1616],"f":true},"v":"quartz "}]},{"t":"heading","d":1,"p":{"lines":[1617,1618]},"v":"数据库","c":[{"t":"heading","d":2,"p":{"lines":[1619,1620]},"v":"关系型数据库","c":[{"t":"heading","d":3,"p":{"lines":[1621,1622],"f":true},"v":"Mysql","c":[{"t":"heading","d":4,"p":{"lines":[1623,1624]},"v":"<a href=\"https://blog.csdn.net/weixin_43649997/article/details/105835007\">三大范式</a>","c":[{"t":"list_item","d":6,"p":{"lines":[1625,1626]},"v":"第一范式"},{"t":"list_item","d":6,"p":{"lines":[1626,1627]},"v":"第二范式"},{"t":"list_item","d":6,"p":{"lines":[1627,1628]},"v":"第三范式"}]},{"t":"heading","d":4,"p":{"lines":[1629,1630]},"v":"事务","c":[{"t":"list_item","d":6,"p":{"lines":[1631,1632]},"v":"四大特征","c":[{"t":"list_item","d":8,"p":{"lines":[1632,1633]},"v":"A原子性","c":[{"t":"list_item","d":10,"p":{"lines":[1633,1634]},"v":"概述"},{"t":"list_item","d":10,"p":{"lines":[1634,1635]},"v":"原理","c":[{"t":"list_item","d":12,"p":{"lines":[1635,1636]},"v":"undo log"},{"t":"list_item","d":12,"p":{"lines":[1636,1637]},"v":"回滚"}]}]},{"t":"list_item","d":8,"p":{"lines":[1637,1638]},"v":"C持久性","c":[{"t":"list_item","d":10,"p":{"lines":[1638,1639]},"v":"概述"},{"t":"list_item","d":10,"p":{"lines":[1639,1640]},"v":"原理:其他三个"}]},{"t":"list_item","d":8,"p":{"lines":[1640,1641]},"v":"I隔离性","c":[{"t":"list_item","d":10,"p":{"lines":[1641,1642]},"v":"概述"},{"t":"list_item","d":10,"p":{"lines":[1642,1643]},"v":"原理","c":[{"t":"list_item","d":12,"p":{"lines":[1643,1644]},"v":"MVCC"},{"t":"list_item","d":12,"p":{"lines":[1644,1645]},"v":"锁"}]}]},{"t":"list_item","d":8,"p":{"lines":[1645,1646]},"v":"D一致性","c":[{"t":"list_item","d":10,"p":{"lines":[1646,1647]},"v":"概述"},{"t":"list_item","d":10,"p":{"lines":[1647,1648]},"v":"原理(双写缓冲)","c":[{"t":"list_item","d":12,"p":{"lines":[1648,1649]},"v":"buffer pool"},{"t":"list_item","d":12,"p":{"lines":[1649,1650]},"v":"redo log"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[1651,1652]},"v":"并发事务的问题","c":[{"t":"list_item","d":8,"p":{"lines":[1652,1653]},"v":"脏读"},{"t":"list_item","d":8,"p":{"lines":[1653,1654]},"v":"不可重复读（虚读）"},{"t":"list_item","d":8,"p":{"lines":[1654,1655]},"v":"幻读"}]},{"t":"list_item","d":6,"p":{"lines":[1656,1657]},"v":"隔离级别","c":[{"t":"list_item","d":8,"p":{"lines":[1657,1658]},"v":"read uncommitted:","c":[{"t":"list_item","d":10,"p":{"lines":[1658,1659]},"v":"说明"},{"t":"list_item","d":10,"p":{"lines":[1659,1660]},"v":"产生问题"}]},{"t":"list_item","d":8,"p":{"lines":[1660,1661]},"v":"read committed:","c":[{"t":"list_item","d":10,"p":{"lines":[1661,1662]},"v":"说明"},{"t":"list_item","d":10,"p":{"lines":[1662,1663]},"v":"产生问题"}]},{"t":"list_item","d":8,"p":{"lines":[1663,1664]},"v":"repeatalbe read:","c":[{"t":"list_item","d":10,"p":{"lines":[1664,1665]},"v":"说明"},{"t":"list_item","d":10,"p":{"lines":[1665,1666]},"v":"产生问题"}]},{"t":"list_item","d":8,"p":{"lines":[1666,1667]},"v":"serializable","c":[{"t":"list_item","d":10,"p":{"lines":[1667,1668]},"v":"说明"},{"t":"list_item","d":10,"p":{"lines":[1668,1669]},"v":"可以解决所有问题"}]}]}]},{"t":"heading","d":4,"p":{"lines":[1670,1671]},"v":"索引","c":[{"t":"list_item","d":6,"p":{"lines":[1672,1673]},"v":"概述","c":[{"t":"list_item","d":8,"p":{"lines":[1673,1674]},"v":"索引是什么"},{"t":"list_item","d":8,"p":{"lines":[1674,1675],"f":true},"v":"什么时候需要建索引 ","c":[{"t":"list_item","d":10,"p":{"lines":[1675,1676]},"v":"不修改"},{"t":"list_item","d":10,"p":{"lines":[1676,1677]},"v":"经常作为条件查询，排序，分组"},{"t":"list_item","d":10,"p":{"lines":[1677,1678]},"v":"外键"}]},{"t":"list_item","d":8,"p":{"lines":[1678,1679],"f":true},"v":"什么时候不要建索引 ","c":[{"t":"list_item","d":10,"p":{"lines":[1679,1680]},"v":"用不到"},{"t":"list_item","d":10,"p":{"lines":[1680,1681]},"v":"记录少"},{"t":"list_item","d":10,"p":{"lines":[1681,1682]},"v":"频繁更新"},{"t":"list_item","d":10,"p":{"lines":[1682,1683]},"v":"经常增删"},{"t":"list_item","d":10,"p":{"lines":[1683,1684]},"v":"数据重复且分布平均的表字段"}]},{"t":"list_item","d":8,"p":{"lines":[1684,1685],"f":true},"v":"什么时候创建复合索引 ","c":[{"t":"list_item","d":10,"p":{"lines":[1685,1686]},"v":"用得到"},{"t":"list_item","d":10,"p":{"lines":[1686,1687]},"v":"高并发"},{"t":"list_item","d":10,"p":{"lines":[1687,1688]},"v":"一个索引当几个用"}]},{"t":"list_item","d":8,"p":{"lines":[1688,1689]},"v":"索引优点","c":[{"t":"list_item","d":10,"p":{"lines":[1689,1690]},"v":"查询速度"},{"t":"list_item","d":10,"p":{"lines":[1690,1691]},"v":"优化使用(MRR,ICP)"},{"t":"list_item","d":10,"p":{"lines":[1691,1692]},"v":"创建维护消耗"},{"t":"list_item","d":10,"p":{"lines":[1692,1693]},"v":"磁盘占用"}]}]},{"t":"list_item","d":6,"p":{"lines":[1694,1695]},"v":"索引分类","c":[{"t":"list_item","d":8,"p":{"lines":[1695,1696]},"v":"按属性/作用分类","c":[{"t":"list_item","d":10,"p":{"lines":[1696,1697]},"v":"普通索引"},{"t":"list_item","d":10,"p":{"lines":[1697,1698]},"v":"唯一索引"},{"t":"list_item","d":10,"p":{"lines":[1698,1699]},"v":"主键索引"},{"t":"list_item","d":10,"p":{"lines":[1699,1700]},"v":"复合索引"},{"t":"list_item","d":10,"p":{"lines":[1700,1701]},"v":"全文索引"}]},{"t":"list_item","d":8,"p":{"lines":[1701,1702]},"v":"按引擎分类","c":[{"t":"list_item","d":10,"p":{"lines":[1702,1703]},"v":"B+"},{"t":"list_item","d":10,"p":{"lines":[1703,1704]},"v":"Hash"},{"t":"list_item","d":10,"p":{"lines":[1704,1705]},"v":"全文"},{"t":"list_item","d":10,"p":{"lines":[1705,1706]},"v":"R-Tree"}]},{"t":"list_item","d":8,"p":{"lines":[1706,1707]},"v":"按是否聚簇分类","c":[{"t":"list_item","d":10,"p":{"lines":[1707,1708]},"v":"聚簇索引"},{"t":"list_item","d":10,"p":{"lines":[1708,1709]},"v":"二级索引"}]}]},{"t":"list_item","d":6,"p":{"lines":[1710,1711]},"v":"索引语法","c":[{"t":"list_item","d":8,"p":{"lines":[1711,1712]},"v":"创建"},{"t":"list_item","d":8,"p":{"lines":[1712,1713]},"v":"删除"},{"t":"list_item","d":8,"p":{"lines":[1713,1714]},"v":"查看"}]},{"t":"list_item","d":6,"p":{"lines":[1715,1716]},"v":"索引添加与Cardinality","c":[{"t":"list_item","d":8,"p":{"lines":[1716,1717]},"v":"fast index creation"},{"t":"list_item","d":8,"p":{"lines":[1717,1718]},"v":"Cardinality"}]}]},{"t":"heading","d":4,"p":{"lines":[1719,1720]},"v":"存储引擎","c":[{"t":"list_item","d":6,"p":{"lines":[1721,1722]},"v":"MyISAM","c":[{"t":"list_item","d":8,"p":{"lines":[1722,1723]},"v":"索引树结构"},{"t":"list_item","d":8,"p":{"lines":[1723,1724]},"v":"聚簇索引的选择"},{"t":"list_item","d":8,"p":{"lines":[1724,1725]},"v":"二级索引检索过程"}]},{"t":"list_item","d":6,"p":{"lines":[1725,1726]},"v":"Innodb","c":[{"t":"list_item","d":8,"p":{"lines":[1726,1727]},"v":"索引树结构"},{"t":"list_item","d":8,"p":{"lines":[1727,1728]},"v":"二级索引检索过程"}]},{"t":"list_item","d":6,"p":{"lines":[1728,1729]},"v":"常见问题","c":[{"t":"list_item","d":8,"p":{"lines":[1729,1730],"f":true},"v":"M和I两者区别 ","c":[{"t":"list_item","d":10,"p":{"lines":[1730,1731]},"v":"事务"},{"t":"list_item","d":10,"p":{"lines":[1731,1732]},"v":"主键"},{"t":"list_item","d":10,"p":{"lines":[1732,1733]},"v":"外键"},{"t":"list_item","d":10,"p":{"lines":[1733,1734]},"v":"锁"},{"t":"list_item","d":10,"p":{"lines":[1734,1735]},"v":"索引"},{"t":"list_item","d":10,"p":{"lines":[1735,1736]},"v":"count(*)"}]},{"t":"list_item","d":8,"p":{"lines":[1736,1737]},"v":"为什么使用B+树，不使用：","c":[{"t":"list_item","d":10,"p":{"lines":[1737,1738]},"v":"B树"},{"t":"list_item","d":10,"p":{"lines":[1738,1739]},"v":"红黑树"}]}]}]},{"t":"heading","d":4,"p":{"lines":[1740,1741]},"v":"调优","c":[{"t":"list_item","d":6,"p":{"lines":[1742,1743]},"v":"explain使用与分析","c":[{"t":"list_item","d":8,"p":{"lines":[1743,1744]},"v":"<strong>id</strong>"},{"t":"list_item","d":8,"p":{"lines":[1744,1745]},"v":"select_type"},{"t":"list_item","d":8,"p":{"lines":[1745,1746]},"v":"table"},{"t":"list_item","d":8,"p":{"lines":[1746,1747],"f":true},"v":"<strong>type</strong> ","c":[{"t":"list_item","d":10,"p":{"lines":[1747,1748]},"v":"system"},{"t":"list_item","d":10,"p":{"lines":[1748,1749]},"v":"const"},{"t":"list_item","d":10,"p":{"lines":[1749,1750]},"v":"eq_ref"},{"t":"list_item","d":10,"p":{"lines":[1750,1751]},"v":"ref"},{"t":"list_item","d":10,"p":{"lines":[1751,1752]},"v":"range"},{"t":"list_item","d":10,"p":{"lines":[1752,1753]},"v":"index"},{"t":"list_item","d":10,"p":{"lines":[1753,1754]},"v":"ALL"}]},{"t":"list_item","d":8,"p":{"lines":[1754,1755]},"v":"possible_keys"},{"t":"list_item","d":8,"p":{"lines":[1755,1756]},"v":"<strong>key</strong>"},{"t":"list_item","d":8,"p":{"lines":[1756,1757]},"v":"<strong>key_len</strong>"},{"t":"list_item","d":8,"p":{"lines":[1757,1758]},"v":"<strong>ref</strong>"},{"t":"list_item","d":8,"p":{"lines":[1758,1759]},"v":"<strong>rows</strong>"},{"t":"list_item","d":8,"p":{"lines":[1759,1760]},"v":"<strong>extra</strong>","c":[{"t":"list_item","d":10,"p":{"lines":[1760,1761]},"v":"using filesort(危险)"},{"t":"list_item","d":10,"p":{"lines":[1761,1762]},"v":"using temporary(非常危险)"},{"t":"list_item","d":10,"p":{"lines":[1762,1763]},"v":"using index"},{"t":"list_item","d":10,"p":{"lines":[1763,1764]},"v":"using where"},{"t":"list_item","d":10,"p":{"lines":[1764,1765]},"v":"using join buffer"},{"t":"list_item","d":10,"p":{"lines":[1765,1766]},"v":"impossible where"}]}]},{"t":"list_item","d":6,"p":{"lines":[1767,1768]},"v":"最左前缀原则"},{"t":"list_item","d":6,"p":{"lines":[1769,1770]},"v":"索引失效原因","c":[{"t":"list_item","d":8,"p":{"lines":[1770,1771]},"v":"不遵循最左前缀"},{"t":"list_item","d":8,"p":{"lines":[1771,1772]},"v":"索引列上的任何操作","c":[{"t":"list_item","d":10,"p":{"lines":[1772,1773]},"v":"计算"},{"t":"list_item","d":10,"p":{"lines":[1773,1774]},"v":"函数"},{"t":"list_item","d":10,"p":{"lines":[1774,1775]},"v":"（自动or手动）类型转换"}]},{"t":"list_item","d":8,"p":{"lines":[1775,1776]},"v":"范围查询","c":[{"t":"list_item","d":10,"p":{"lines":[1776,1777]},"v":"<code>between and;in</code>"},{"t":"list_item","d":10,"p":{"lines":[1777,1778]},"v":"<code>or</code>"},{"t":"list_item","d":10,"p":{"lines":[1778,1779]},"v":"<code>%...</code>(覆盖索引有奇效)"},{"t":"list_item","d":10,"p":{"lines":[1779,1780]},"v":"<code>is null;is not null</code>"},{"t":"list_item","d":10,"p":{"lines":[1780,1781]},"v":"<code>!=;&lt;&gt;</code>"}]}]},{"t":"list_item","d":6,"p":{"lines":[1782,1783]},"v":"小标驱动大表","c":[{"t":"list_item","d":8,"p":{"lines":[1783,1784]},"v":"左表驱动右表","c":[{"t":"list_item","d":10,"p":{"lines":[1784,1785]},"v":"left join"},{"t":"list_item","d":10,"p":{"lines":[1785,1786]},"v":"exist"}]},{"t":"list_item","d":8,"p":{"lines":[1786,1787]},"v":"右表驱动左表","c":[{"t":"list_item","d":10,"p":{"lines":[1787,1788]},"v":"right join"},{"t":"list_item","d":10,"p":{"lines":[1788,1789]},"v":"in"}]}]},{"t":"list_item","d":6,"p":{"lines":[1790,1791]},"v":"排序优化","c":[{"t":"list_item","d":8,"p":{"lines":[1791,1792]},"v":"mysql排序方式","c":[{"t":"list_item","d":10,"p":{"lines":[1792,1793]},"v":"index sort"},{"t":"list_item","d":10,"p":{"lines":[1793,1794]},"v":"file sort","c":[{"t":"list_item","d":12,"p":{"lines":[1794,1795]},"v":"单路","c":[{"t":"list_item","d":14,"p":{"lines":[1795,1796]},"v":"io次数:2"},{"t":"list_item","d":14,"p":{"lines":[1796,1797]},"v":"第二次随机io"}]},{"t":"list_item","d":12,"p":{"lines":[1797,1798]},"v":"双路","c":[{"t":"list_item","d":14,"p":{"lines":[1798,1799]},"v":"io次数:1"},{"t":"list_item","d":14,"p":{"lines":[1799,1800]},"v":"一次顺序io"},{"t":"list_item","d":14,"p":{"lines":[1800,1801]},"v":"buffer不够：多次io"}]},{"t":"list_item","d":12,"p":{"lines":[1801,1802]},"v":"<strong>参数优化策略</strong>"}]}]},{"t":"list_item","d":8,"p":{"lines":[1802,1803]},"v":"order by优化","c":[{"t":"list_item","d":10,"p":{"lines":[1803,1804]},"v":"遵循最左前缀进行排序","c":[{"t":"list_item","d":12,"p":{"lines":[1804,1805]},"v":"order"},{"t":"list_item","d":12,"p":{"lines":[1805,1806]},"v":"where(const)+order"}]},{"t":"list_item","d":10,"p":{"lines":[1806,1807]},"v":"不让索引失效"},{"t":"list_item","d":10,"p":{"lines":[1807,1808]},"v":"不能一升一降"}]},{"t":"list_item","d":8,"p":{"lines":[1808,1809]},"v":"group by优化","c":[{"t":"list_item","d":10,"p":{"lines":[1809,1810]},"v":"实质是先排序后进行分组"},{"t":"list_item","d":10,"p":{"lines":[1810,1811]},"v":"能写在where限定的条件就不要去having限定了"}]}]},{"t":"list_item","d":6,"p":{"lines":[1812,1813]},"v":"慢查询日志"}]},{"t":"heading","d":4,"p":{"lines":[1814,1815]},"v":"锁","c":[{"t":"list_item","d":6,"p":{"lines":[1816,1817]},"v":"<a href=\"https://i6448038.github.io/2019/02/23/mysql-lock/\">Mysql锁底层</a>","c":[{"t":"list_item","d":8,"p":{"lines":[1817,1818]},"v":"latch"},{"t":"list_item","d":8,"p":{"lines":[1818,1819]},"v":"lock"}]},{"t":"list_item","d":6,"p":{"lines":[1820,1821]},"v":"锁的分类","c":[{"t":"list_item","d":8,"p":{"lines":[1821,1822]},"v":"<a href=\"https://www.cnblogs.com/laoyeye/p/8097684.html\">乐观锁</a>","c":[{"t":"list_item","d":10,"p":{"lines":[1822,1823]},"v":"时间戳"},{"t":"list_item","d":10,"p":{"lines":[1823,1824]},"v":"版本号"},{"t":"list_item","d":10,"p":{"lines":[1824,1825]},"v":"条件限制"}]},{"t":"list_item","d":8,"p":{"lines":[1825,1826]},"v":"悲观锁","c":[{"t":"list_item","d":10,"p":{"lines":[1826,1827]},"v":"Myisam表锁","c":[{"t":"list_item","d":12,"p":{"lines":[1827,1828]},"v":"读锁"},{"t":"list_item","d":12,"p":{"lines":[1828,1829]},"v":"写锁"}]},{"t":"list_item","d":10,"p":{"lines":[1829,1830]},"v":"Innodb锁","c":[{"t":"list_item","d":12,"p":{"lines":[1830,1831]},"v":"意向表锁","c":[{"t":"list_item","d":14,"p":{"lines":[1831,1832]},"v":"意向共享锁"},{"t":"list_item","d":14,"p":{"lines":[1832,1833]},"v":"意向排他锁"}]},{"t":"list_item","d":12,"p":{"lines":[1833,1834]},"v":"普通行锁","c":[{"t":"list_item","d":14,"p":{"lines":[1834,1835]},"v":"共享锁"},{"t":"list_item","d":14,"p":{"lines":[1835,1836]},"v":"排它锁"}]},{"t":"list_item","d":12,"p":{"lines":[1836,1837]},"v":"锁算法","c":[{"t":"list_item","d":14,"p":{"lines":[1837,1838]},"v":"记录锁"},{"t":"list_item","d":14,"p":{"lines":[1838,1839]},"v":"间隙锁"},{"t":"list_item","d":14,"p":{"lines":[1839,1840]},"v":"临键锁"}]},{"t":"list_item","d":12,"p":{"lines":[1840,1841]},"v":"插入意向锁"},{"t":"list_item","d":12,"p":{"lines":[1841,1842]},"v":"自增锁"}]}]}]},{"t":"list_item","d":6,"p":{"lines":[1843,1844]},"v":"<strong><a href=\"https://blog.csdn.net/geekjoker/article/details/79444076\">加锁流程</a></strong>","c":[{"t":"list_item","d":8,"p":{"lines":[1844,1845]},"v":"需要了解","c":[{"t":"list_item","d":10,"p":{"lines":[1845,1846]},"v":"聚集索引和二级索引"},{"t":"list_item","d":10,"p":{"lines":[1846,1847]},"v":"innodb二级索引查询流程"},{"t":"list_item","d":10,"p":{"lines":[1847,1848]},"v":"innodb的锁算法"}]},{"t":"list_item","d":8,"p":{"lines":[1848,1849]},"v":"不同情景 <br />(<strong>下列条件相互组合</strong>)","c":[{"t":"list_item","d":10,"p":{"lines":[1849,1850]},"v":"查询方式","c":[{"t":"list_item","d":12,"p":{"lines":[1850,1851]},"v":"等值查询"},{"t":"list_item","d":12,"p":{"lines":[1851,1852]},"v":"范围查询"}]},{"t":"list_item","d":10,"p":{"lines":[1852,1853]},"v":"隔离级别","c":[{"t":"list_item","d":12,"p":{"lines":[1853,1854]},"v":"RC"},{"t":"list_item","d":12,"p":{"lines":[1854,1855]},"v":"RR"},{"t":"list_item","d":12,"p":{"lines":[1855,1856]},"v":"serializable"}]},{"t":"list_item","d":10,"p":{"lines":[1856,1857]},"v":"操作","c":[{"t":"list_item","d":12,"p":{"lines":[1857,1858]},"v":"<code>select</code>(只用在serializable下考虑)"},{"t":"list_item","d":12,"p":{"lines":[1858,1859]},"v":"<code>delete</code>/<code>select...for update</code>"}]},{"t":"list_item","d":10,"p":{"lines":[1859,1860]},"v":"使用索引","c":[{"t":"list_item","d":12,"p":{"lines":[1860,1861]},"v":"主键索引<br />(注意临键锁会不会加在主键)"},{"t":"list_item","d":12,"p":{"lines":[1861,1862]},"v":"唯一索引"},{"t":"list_item","d":12,"p":{"lines":[1862,1863]},"v":"非唯一索引<br />(注意临键锁会不会加在主键)"},{"t":"list_item","d":12,"p":{"lines":[1863,1864]},"v":"无索引"}]}]}]}]},{"t":"heading","d":4,"p":{"lines":[1865,1866]},"v":"MVCC","c":[{"t":"list_item","d":6,"p":{"lines":[1867,1868]},"v":"快照读与当前读"},{"t":"list_item","d":6,"p":{"lines":[1868,1869]},"v":"原理","c":[{"t":"list_item","d":8,"p":{"lines":[1869,1870]},"v":"版本链","c":[{"t":"list_item","d":10,"p":{"lines":[1870,1871]},"v":"隐藏字段"},{"t":"list_item","d":10,"p":{"lines":[1871,1872]},"v":"undo log"}]},{"t":"list_item","d":8,"p":{"lines":[1872,1873]},"v":"readview"}]}]},{"t":"heading","d":4,"p":{"lines":[1875,1876]},"v":"主从复制","c":[{"t":"list_item","d":6,"p":{"lines":[1877,1878]},"v":"主从复制","c":[{"t":"list_item","d":8,"p":{"lines":[1878,1879]},"v":"原理"}]},{"t":"list_item","d":6,"p":{"lines":[1879,1880]},"v":"读写分离"}]},{"t":"heading","d":4,"p":{"lines":[1881,1882]},"v":"底层优化","c":[{"t":"list_item","d":6,"p":{"lines":[1883,1884]},"v":"MRR"},{"t":"list_item","d":6,"p":{"lines":[1884,1885]},"v":"ICP"}]},{"t":"heading","d":4,"p":{"lines":[1886,1887]},"v":"大表调优"}]},{"t":"heading","d":3,"p":{"lines":[1888,1889],"f":true},"v":"oracle"}]},{"t":"heading","d":2,"p":{"lines":[1890,1891]},"v":"nosql","c":[{"t":"heading","d":3,"p":{"lines":[1892,1893],"f":true},"v":"Redis","c":[{"t":"list_item","d":5,"p":{"lines":[1894,1895]},"v":"基本数据类型","c":[{"t":"list_item","d":7,"p":{"lines":[1895,1896]},"v":"String","c":[{"t":"list_item","d":9,"p":{"lines":[1896,1897]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1897,1898]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1898,1899]},"v":"数据结构:SDS"}]},{"t":"list_item","d":7,"p":{"lines":[1900,1901]},"v":"Hash","c":[{"t":"list_item","d":9,"p":{"lines":[1901,1902]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1902,1903]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1903,1904],"f":true},"v":"数据结构 ","c":[{"t":"list_item","d":11,"p":{"lines":[1904,1905]},"v":"小于(64,512):ziplist"},{"t":"list_item","d":11,"p":{"lines":[1905,1906]},"v":"否则：hashtable"}]}]},{"t":"list_item","d":7,"p":{"lines":[1907,1908]},"v":"List","c":[{"t":"list_item","d":9,"p":{"lines":[1908,1909]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1909,1910]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1910,1911]},"v":"数据结构"}]},{"t":"list_item","d":7,"p":{"lines":[1912,1913]},"v":"Set","c":[{"t":"list_item","d":9,"p":{"lines":[1913,1914]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1914,1915]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1915,1916],"f":true},"v":"数据结构 ","c":[{"t":"list_item","d":11,"p":{"lines":[1916,1917]},"v":"默认使用IntSet"},{"t":"list_item","d":11,"p":{"lines":[1917,1918]},"v":"一定情况下IntSet转换为HashTable"}]}]},{"t":"list_item","d":7,"p":{"lines":[1919,1920]},"v":"ZSet","c":[{"t":"list_item","d":9,"p":{"lines":[1920,1921]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1921,1922]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1922,1923],"f":true},"v":"数据结构 ","c":[{"t":"list_item","d":11,"p":{"lines":[1923,1924]},"v":"小于(64,512):ziplist"},{"t":"list_item","d":11,"p":{"lines":[1924,1925]},"v":"否则：hashtable+skiplist"}]}]},{"t":"list_item","d":7,"p":{"lines":[1926,1927]},"v":"HyperLogLog","c":[{"t":"list_item","d":9,"p":{"lines":[1927,1928]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[1928,1929]},"v":"应用场景"},{"t":"list_item","d":9,"p":{"lines":[1929,1930]},"v":"数据结构"}]},{"t":"list_item","d":7,"p":{"lines":[1930,1931]},"v":"BitMap"}]},{"t":"list_item","d":5,"p":{"lines":[1932,1933]},"v":"高级算法","c":[{"t":"list_item","d":7,"p":{"lines":[1933,1934]},"v":"scan"},{"t":"list_item","d":7,"p":{"lines":[1934,1935]},"v":"GeoHash"}]},{"t":"list_item","d":5,"p":{"lines":[1936,1937]},"v":"过期淘汰","c":[{"t":"list_item","d":7,"p":{"lines":[1937,1938]},"v":"过期删除策略","c":[{"t":"list_item","d":9,"p":{"lines":[1938,1939]},"v":"定时删除"},{"t":"list_item","d":9,"p":{"lines":[1939,1940]},"v":"惰性删除"},{"t":"list_item","d":9,"p":{"lines":[1940,1941]},"v":"定期删除"}]},{"t":"list_item","d":7,"p":{"lines":[1941,1942]},"v":"内存淘汰策略","c":[{"t":"list_item","d":9,"p":{"lines":[1942,1943]},"v":"no-eviction"},{"t":"list_item","d":9,"p":{"lines":[1943,1944]},"v":"allkeys","c":[{"t":"list_item","d":11,"p":{"lines":[1944,1945]},"v":"random"},{"t":"list_item","d":11,"p":{"lines":[1945,1946]},"v":"lru"},{"t":"list_item","d":11,"p":{"lines":[1946,1947]},"v":"lfu"}]},{"t":"list_item","d":9,"p":{"lines":[1947,1948]},"v":"volatile","c":[{"t":"list_item","d":11,"p":{"lines":[1948,1949]},"v":"ttl"},{"t":"list_item","d":11,"p":{"lines":[1949,1950]},"v":"random"},{"t":"list_item","d":11,"p":{"lines":[1950,1951]},"v":"lru"},{"t":"list_item","d":11,"p":{"lines":[1951,1952]},"v":"lfu"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[1953,1954]},"v":"持久化","c":[{"t":"list_item","d":7,"p":{"lines":[1954,1955]},"v":"RDB","c":[{"t":"list_item","d":9,"p":{"lines":[1955,1956]},"v":"持久化原理/过程"},{"t":"list_item","d":9,"p":{"lines":[1956,1957]},"v":"配置"},{"t":"list_item","d":9,"p":{"lines":[1957,1958]},"v":"触发","c":[{"t":"list_item","d":11,"p":{"lines":[1958,1959]},"v":"自动","c":[{"t":"list_item","d":13,"p":{"lines":[1959,1960]},"v":"默认的三个"},{"t":"list_item","d":13,"p":{"lines":[1960,1961]},"v":"原理"}]},{"t":"list_item","d":11,"p":{"lines":[1961,1962]},"v":"手动(4种)"}]},{"t":"list_item","d":9,"p":{"lines":[1962,1963]},"v":"check检查"},{"t":"list_item","d":9,"p":{"lines":[1963,1964]},"v":"优缺点"}]},{"t":"list_item","d":7,"p":{"lines":[1964,1965]},"v":"AOF","c":[{"t":"list_item","d":9,"p":{"lines":[1965,1966]},"v":"持久化原理/过程"},{"t":"list_item","d":9,"p":{"lines":[1966,1967]},"v":"配置"},{"t":"list_item","d":9,"p":{"lines":[1967,1968]},"v":"触发","c":[{"t":"list_item","d":11,"p":{"lines":[1968,1969]},"v":"开启后自动"},{"t":"list_item","d":11,"p":{"lines":[1969,1970]},"v":"手动<code>bgrewriteaof</code>"}]},{"t":"list_item","d":9,"p":{"lines":[1970,1971]},"v":"check检查"},{"t":"list_item","d":9,"p":{"lines":[1971,1972]},"v":"AOF重写","c":[{"t":"list_item","d":11,"p":{"lines":[1972,1973]},"v":"原理","c":[{"t":"list_item","d":13,"p":{"lines":[1973,1974]},"v":"读取服务器现有KV"},{"t":"list_item","d":13,"p":{"lines":[1974,1975]},"v":"fork子<strong>进程</strong>"}]},{"t":"list_item","d":11,"p":{"lines":[1975,1976]},"v":"触发"},{"t":"list_item","d":11,"p":{"lines":[1976,1977]},"v":"重写数据不一致问题"},{"t":"list_item","d":11,"p":{"lines":[1977,1978]},"v":"重写数据不一致问题解决"}]},{"t":"list_item","d":9,"p":{"lines":[1978,1979]},"v":"优缺点"},{"t":"list_item","d":9,"p":{"lines":[1979,1980]},"v":"(总结)AOF的两个缓冲区"}]},{"t":"list_item","d":7,"p":{"lines":[1980,1981]},"v":"AOF+RDB混合"}]},{"t":"list_item","d":5,"p":{"lines":[1982,1983]},"v":"事务","c":[{"t":"list_item","d":7,"p":{"lines":[1983,1984]},"v":"基本命令"},{"t":"list_item","d":7,"p":{"lines":[1984,1985]},"v":"乐观锁"},{"t":"list_item","d":7,"p":{"lines":[1985,1986]},"v":"两种异常情况：","c":[{"t":"list_item","d":9,"p":{"lines":[1986,1987]},"v":"全都不执行"},{"t":"list_item","d":9,"p":{"lines":[1987,1988]},"v":"执行可以执行的"}]}]},{"t":"list_item","d":5,"p":{"lines":[1989,1990]},"v":"并发问题解决","c":[{"t":"list_item","d":7,"p":{"lines":[1990,1991]},"v":"乐观锁"},{"t":"list_item","d":7,"p":{"lines":[1991,1992]},"v":"分布式锁"},{"t":"list_item","d":7,"p":{"lines":[1992,1993]},"v":"消息队列"},{"t":"list_item","d":7,"p":{"lines":[1993,1994]},"v":"时间戳"}]},{"t":"list_item","d":5,"p":{"lines":[1995,1996]},"v":"消息发布订阅"},{"t":"list_item","d":5,"p":{"lines":[1997,1998]},"v":"集群","c":[{"t":"list_item","d":7,"p":{"lines":[1998,1999]},"v":"主从复制","c":[{"t":"list_item","d":9,"p":{"lines":[1999,2000]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[2000,2001]},"v":"配置"},{"t":"list_item","d":9,"p":{"lines":[2001,2002]},"v":"master宕机"}]},{"t":"list_item","d":7,"p":{"lines":[2002,2003]},"v":"哨兵模式","c":[{"t":"list_item","d":9,"p":{"lines":[2003,2004]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[2004,2005]},"v":"配置"},{"t":"list_item","d":9,"p":{"lines":[2005,2006]},"v":"master宕机"}]},{"t":"list_item","d":7,"p":{"lines":[2006,2007]},"v":"分片cluster","c":[{"t":"list_item","d":9,"p":{"lines":[2007,2008]},"v":"说明","c":[{"t":"list_item","d":11,"p":{"lines":[2008,2009]},"v":"两个端口"},{"t":"list_item","d":11,"p":{"lines":[2009,2010]},"v":"集群总线"},{"t":"list_item","d":11,"p":{"lines":[2010,2011],"f":true},"v":"数据存取 ","c":[{"t":"list_item","d":13,"p":{"lines":[2011,2012]},"v":"CRC16"},{"t":"list_item","d":13,"p":{"lines":[2012,2013]},"v":"hash槽"},{"t":"list_item","d":13,"p":{"lines":[2013,2014]},"v":"重定向"}]},{"t":"list_item","d":11,"p":{"lines":[2014,2015]},"v":"主从复制模型"}]},{"t":"list_item","d":9,"p":{"lines":[2015,2016]},"v":"配置"},{"t":"list_item","d":9,"p":{"lines":[2016,2017]},"v":"master宕机"}]}]},{"t":"list_item","d":5,"p":{"lines":[2018,2019]},"v":"缓存失效/更新问题","c":[{"t":"list_item","d":7,"p":{"lines":[2019,2020]},"v":"缓存雪崩","c":[{"t":"list_item","d":9,"p":{"lines":[2020,2021]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[2021,2022]},"v":"解决方案"}]},{"t":"list_item","d":7,"p":{"lines":[2022,2023]},"v":"缓存穿透","c":[{"t":"list_item","d":9,"p":{"lines":[2023,2024]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[2024,2025]},"v":"解决方案"}]},{"t":"list_item","d":7,"p":{"lines":[2025,2026]},"v":"缓存击穿","c":[{"t":"list_item","d":9,"p":{"lines":[2026,2027]},"v":"说明"},{"t":"list_item","d":9,"p":{"lines":[2027,2028]},"v":"解决方案"}]},{"t":"list_item","d":7,"p":{"lines":[2028,2029]},"v":"双写一致","c":[{"t":"list_item","d":9,"p":{"lines":[2029,2030]},"v":"分析问题","c":[{"t":"list_item","d":11,"p":{"lines":[2030,2031]},"v":"先更新数据库，<br />再删除缓存","c":[{"t":"list_item","d":13,"p":{"lines":[2031,2032]},"v":"正常"},{"t":"list_item","d":13,"p":{"lines":[2032,2033]},"v":"失败"},{"t":"list_item","d":13,"p":{"lines":[2033,2034]},"v":"并发"}]},{"t":"list_item","d":11,"p":{"lines":[2034,2035]},"v":"先删除缓存，<br />再更新数据库","c":[{"t":"list_item","d":13,"p":{"lines":[2035,2036]},"v":"正常"},{"t":"list_item","d":13,"p":{"lines":[2036,2037]},"v":"失败"},{"t":"list_item","d":13,"p":{"lines":[2037,2038]},"v":"并发"},{"t":"list_item","d":13,"p":{"lines":[2038,2039]},"v":"<code>关联：缓存读写策略中的旁路缓存</code>"}]}]},{"t":"list_item","d":9,"p":{"lines":[2039,2040]},"v":"解决方案"}]}]},{"t":"list_item","d":5,"p":{"lines":[2041,2042]},"v":"线程模型","c":[{"t":"list_item","d":7,"p":{"lines":[2042,2043],"f":true},"v":"为什么使用单线程 ","c":[{"t":"list_item","d":9,"p":{"lines":[2043,2044]},"v":"可维护性，方便开发和调试"},{"t":"list_item","d":9,"p":{"lines":[2044,2045]},"v":"单线程也能处理并发请求(多路复用)"},{"t":"list_item","d":9,"p":{"lines":[2045,2046]},"v":"性能瓶颈不是cpu，而是内存和网络"}]},{"t":"list_item","d":7,"p":{"lines":[2046,2047],"f":true},"v":"为什么能单线程处理那么多客户端 ","c":[{"t":"list_item","d":9,"p":{"lines":[2047,2048]},"v":"纯内存"},{"t":"list_item","d":9,"p":{"lines":[2048,2049]},"v":"单线程，无锁"},{"t":"list_item","d":9,"p":{"lines":[2049,2050]},"v":"多路复用"},{"t":"list_item","d":9,"p":{"lines":[2050,2051]},"v":"高效底层数据结构优化"}]},{"t":"list_item","d":7,"p":{"lines":[2051,2052]},"v":"为什么6.0前不使用多线程"},{"t":"list_item","d":7,"p":{"lines":[2052,2053],"f":true},"v":"Redis 6.0为什么使用多线程 ","c":[{"t":"list_item","d":9,"p":{"lines":[2053,2054]},"v":"提高网络io读写性能"},{"t":"list_item","d":9,"p":{"lines":[2054,2055]},"v":"<code>默认禁用</code>"}]}]},{"t":"list_item","d":5,"p":{"lines":[2056,2057]},"v":"redis应用","c":[{"t":"list_item","d":7,"p":{"lines":[2057,2058]},"v":"redis分布式锁","c":[{"t":"list_item","d":9,"p":{"lines":[2058,2059]},"v":"高效分布式锁条件","c":[{"t":"list_item","d":11,"p":{"lines":[2059,2060]},"v":"互斥"},{"t":"list_item","d":11,"p":{"lines":[2060,2061]},"v":"防止死锁"},{"t":"list_item","d":11,"p":{"lines":[2061,2062]},"v":"性能"},{"t":"list_item","d":11,"p":{"lines":[2062,2063]},"v":"可重入"}]},{"t":"list_item","d":9,"p":{"lines":[2063,2064]},"v":"两个问题及解决思路","c":[{"t":"list_item","d":11,"p":{"lines":[2064,2065]},"v":"setnx,expire原子性"},{"t":"list_item","d":11,"p":{"lines":[2065,2066]},"v":"锁提前失效"}]},{"t":"list_item","d":9,"p":{"lines":[2066,2067]},"v":"redisson锁","c":[{"t":"list_item","d":11,"p":{"lines":[2067,2068]},"v":"流程/原理"},{"t":"list_item","d":11,"p":{"lines":[2068,2069]},"v":"看门狗机制"},{"t":"list_item","d":11,"p":{"lines":[2069,2070]},"v":"lua脚本"},{"t":"list_item","d":11,"p":{"lines":[2070,2071]},"v":"实现可重入:Hash"},{"t":"list_item","d":11,"p":{"lines":[2071,2072]},"v":"缺陷"}]}]},{"t":"list_item","d":7,"p":{"lines":[2072,2073]},"v":"缓存","c":[{"t":"list_item","d":9,"p":{"lines":[2073,2074],"f":true},"v":"旁路缓存模式 ","c":[{"t":"list_item","d":11,"p":{"lines":[2074,2075]},"v":"关联：双写一致问题"}]},{"t":"list_item","d":9,"p":{"lines":[2075,2076]},"v":"读写穿透"},{"t":"list_item","d":9,"p":{"lines":[2076,2077]},"v":"异步缓存写入"}]},{"t":"list_item","d":7,"p":{"lines":[2077,2078]},"v":"布隆过滤器"},{"t":"list_item","d":7,"p":{"lines":[2078,2079]},"v":"布谷鸟过滤器"}]}]},{"t":"heading","d":3,"p":{"lines":[2081,2082],"f":true},"v":"MongoDB"}]}]},{"t":"heading","d":1,"p":{"lines":[2083,2084]},"v":"基础","c":[{"t":"heading","d":2,"p":{"lines":[2085,2086],"f":true},"v":"设计模式","c":[{"t":"heading","d":3,"p":{"lines":[2087,2088]},"v":"七大原则"},{"t":"heading","d":3,"p":{"lines":[2089,2090]},"v":"设计模式","c":[{"t":"heading","d":4,"p":{"lines":[2091,2092]},"v":"创建型模式"},{"t":"heading","d":4,"p":{"lines":[2093,2094]},"v":"结构型模式"},{"t":"heading","d":4,"p":{"lines":[2095,2096]},"v":"行为型模式"},{"t":"heading","d":4,"p":{"lines":[2097,2098]},"v":"J2EE型模式"}]}]},{"t":"heading","d":2,"p":{"lines":[2099,2100]},"v":"计算机网络","c":[{"t":"heading","d":3,"p":{"lines":[2101,2102],"f":true},"v":"理论<br />(参考《计算机网络》谢希仁) ","c":[{"t":"list_item","d":5,"p":{"lines":[2103,2104]},"v":"概述","c":[{"t":"list_item","d":7,"p":{"lines":[2104,2105]},"v":"基本概念","c":[{"t":"list_item","d":9,"p":{"lines":[2105,2106]},"v":"结点"},{"t":"list_item","d":9,"p":{"lines":[2106,2107]},"v":"链路"},{"t":"list_item","d":9,"p":{"lines":[2107,2108]},"v":"主机"},{"t":"list_item","d":9,"p":{"lines":[2108,2109]},"v":"internet和Internet"},{"t":"list_item","d":9,"p":{"lines":[2109,2110]},"v":"ISP和IXP"}]},{"t":"list_item","d":7,"p":{"lines":[2110,2111]},"v":"因特网组成","c":[{"t":"list_item","d":9,"p":{"lines":[2111,2112]},"v":"边缘部分","c":[{"t":"list_item","d":11,"p":{"lines":[2112,2113]},"v":"client-server"},{"t":"list_item","d":11,"p":{"lines":[2113,2114]},"v":"p2p"}]},{"t":"list_item","d":9,"p":{"lines":[2114,2115]},"v":"核心部分","c":[{"t":"list_item","d":11,"p":{"lines":[2115,2116]},"v":"电路交换"},{"t":"list_item","d":11,"p":{"lines":[2116,2117]},"v":"报文交换"},{"t":"list_item","d":11,"p":{"lines":[2117,2118]},"v":"分组交换"}]}]},{"t":"list_item","d":7,"p":{"lines":[2118,2119]},"v":"计算机网络类别","c":[{"t":"list_item","d":9,"p":{"lines":[2119,2120]},"v":"广域网WAN"},{"t":"list_item","d":9,"p":{"lines":[2120,2121]},"v":"区域网MAN"},{"t":"list_item","d":9,"p":{"lines":[2121,2122]},"v":"城域网LAN"},{"t":"list_item","d":9,"p":{"lines":[2122,2123]},"v":"个人区域网PAN"}]},{"t":"list_item","d":7,"p":{"lines":[2123,2124]},"v":"计算机网络性能指标","c":[{"t":"list_item","d":9,"p":{"lines":[2124,2125]},"v":"速率"},{"t":"list_item","d":9,"p":{"lines":[2125,2126]},"v":"管带"},{"t":"list_item","d":9,"p":{"lines":[2126,2127]},"v":"吞吐量"},{"t":"list_item","d":9,"p":{"lines":[2127,2128]},"v":"时延","c":[{"t":"list_item","d":11,"p":{"lines":[2128,2129]},"v":"发送"},{"t":"list_item","d":11,"p":{"lines":[2129,2130]},"v":"处理"},{"t":"list_item","d":11,"p":{"lines":[2130,2131]},"v":"传播"},{"t":"list_item","d":11,"p":{"lines":[2131,2132]},"v":"排队"}]},{"t":"list_item","d":9,"p":{"lines":[2132,2133]},"v":"时延带宽积"},{"t":"list_item","d":9,"p":{"lines":[2133,2134]},"v":"往返时间RRT"},{"t":"list_item","d":9,"p":{"lines":[2134,2135]},"v":"利用率"}]},{"t":"list_item","d":7,"p":{"lines":[2135,2136]},"v":"计算机网络体系结构","c":[{"t":"list_item","d":9,"p":{"lines":[2136,2137]},"v":"OSI七层"},{"t":"list_item","d":9,"p":{"lines":[2137,2138]},"v":"TCP/IP四层"},{"t":"list_item","d":9,"p":{"lines":[2138,2139]},"v":"课本按照五层"}]}]},{"t":"list_item","d":5,"p":{"lines":[2139,2140]},"v":"物理层"},{"t":"list_item","d":5,"p":{"lines":[2140,2141]},"v":"链路层","c":[{"t":"list_item","d":7,"p":{"lines":[2141,2142]},"v":"点对点信道","c":[{"t":"list_item","d":9,"p":{"lines":[2142,2143]},"v":"基本概念","c":[{"t":"list_item","d":11,"p":{"lines":[2143,2144]},"v":"链路"},{"t":"list_item","d":11,"p":{"lines":[2144,2145]},"v":"数据链路"},{"t":"list_item","d":11,"p":{"lines":[2145,2146]},"v":"网络适配器"}]},{"t":"list_item","d":9,"p":{"lines":[2146,2147]},"v":"三个基本问题","c":[{"t":"list_item","d":11,"p":{"lines":[2147,2148]},"v":"封装成帧:帧格式"},{"t":"list_item","d":11,"p":{"lines":[2148,2149]},"v":"透明传输:原理"},{"t":"list_item","d":11,"p":{"lines":[2149,2150]},"v":"差错检测","c":[{"t":"list_item","d":13,"p":{"lines":[2150,2151]},"v":"循环冗余检验CRC"},{"t":"list_item","d":13,"p":{"lines":[2151,2152]},"v":"帧检验序列FCS"}]}]},{"t":"list_item","d":9,"p":{"lines":[2152,2153]},"v":"ppp协议","c":[{"t":"list_item","d":11,"p":{"lines":[2153,2154]},"v":"协议特点"},{"t":"list_item","d":11,"p":{"lines":[2154,2155]},"v":"协议组成"},{"t":"list_item","d":11,"p":{"lines":[2155,2156]},"v":"PPP帧格式"},{"t":"list_item","d":11,"p":{"lines":[2156,2157]},"v":"透明传输","c":[{"t":"list_item","d":13,"p":{"lines":[2157,2158]},"v":"异步传输：字节填充"},{"t":"list_item","d":13,"p":{"lines":[2158,2159]},"v":"同步传输：零比特填充"}]},{"t":"list_item","d":11,"p":{"lines":[2159,2160]},"v":"确保边界：零比特填充"},{"t":"list_item","d":11,"p":{"lines":[2160,2161]},"v":"PPP工作状态"}]}]},{"t":"list_item","d":7,"p":{"lines":[2161,2162]},"v":"广播信道","c":[{"t":"list_item","d":9,"p":{"lines":[2162,2163]},"v":"适配器作用"},{"t":"list_item","d":9,"p":{"lines":[2163,2164]},"v":"三个基本问题","c":[{"t":"list_item","d":11,"p":{"lines":[2164,2165]},"v":"封装成帧:帧格式"},{"t":"list_item","d":11,"p":{"lines":[2165,2166]},"v":"透明传输:不需要"},{"t":"list_item","d":11,"p":{"lines":[2166,2167]},"v":"差错检测","c":[{"t":"list_item","d":13,"p":{"lines":[2167,2168]},"v":"循环冗余检验CRC"},{"t":"list_item","d":13,"p":{"lines":[2168,2169]},"v":"帧检验序列FCS"}]}]},{"t":"list_item","d":9,"p":{"lines":[2169,2170]},"v":"协议","c":[{"t":"list_item","d":11,"p":{"lines":[2170,2171]},"v":"<strong>CSMA/CD碰撞检测</strong>"},{"t":"list_item","d":11,"p":{"lines":[2171,2172]},"v":"TDMA"},{"t":"list_item","d":11,"p":{"lines":[2172,2173]},"v":"FDMA"},{"t":"list_item","d":11,"p":{"lines":[2173,2174]},"v":"slotted ALOHA"},{"t":"list_item","d":11,"p":{"lines":[2174,2175]},"v":"ALOHA"}]},{"t":"list_item","d":9,"p":{"lines":[2175,2176]},"v":"MAC地址","c":[{"t":"list_item","d":11,"p":{"lines":[2176,2177]},"v":"概念"},{"t":"list_item","d":11,"p":{"lines":[2177,2178]},"v":"作用"},{"t":"list_item","d":11,"p":{"lines":[2178,2179]},"v":"地址格式"},{"t":"list_item","d":11,"p":{"lines":[2179,2180]},"v":"MAC帧格式"}]}]},{"t":"list_item","d":7,"p":{"lines":[2180,2181]},"v":"扩展以太网","c":[{"t":"list_item","d":9,"p":{"lines":[2181,2182]},"v":"物理层","c":[{"t":"list_item","d":11,"p":{"lines":[2182,2183]},"v":"集线器"}]},{"t":"list_item","d":9,"p":{"lines":[2183,2184]},"v":"链路层","c":[{"t":"list_item","d":11,"p":{"lines":[2184,2185]},"v":"网桥","c":[{"t":"list_item","d":13,"p":{"lines":[2185,2186]},"v":"<strong>自学习和转发过程</strong>"},{"t":"list_item","d":13,"p":{"lines":[2186,2187]},"v":"生成树算法"}]},{"t":"list_item","d":11,"p":{"lines":[2187,2188]},"v":"交换机(多接口网桥)"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[2188,2189]},"v":"网络层","c":[{"t":"list_item","d":7,"p":{"lines":[2189,2190]},"v":"网络层提供的两种服务","c":[{"t":"list_item","d":9,"p":{"lines":[2190,2191]},"v":"面向连接：VC(虚电路)"},{"t":"list_item","d":9,"p":{"lines":[2191,2192]},"v":"无连接：数据报"}]},{"t":"list_item","d":7,"p":{"lines":[2192,2193]},"v":"ip协议","c":[{"t":"list_item","d":9,"p":{"lines":[2193,2194]},"v":"ip配套协议(作用+说明)","c":[{"t":"list_item","d":11,"p":{"lines":[2194,2195]},"v":"ARP(p123)"},{"t":"list_item","d":11,"p":{"lines":[2195,2196]},"v":"ICMP(p146)"},{"t":"list_item","d":11,"p":{"lines":[2196,2197]},"v":"IGMP(p171)"}]},{"t":"list_item","d":9,"p":{"lines":[2197,2198]},"v":"虚拟互联网络"},{"t":"list_item","d":9,"p":{"lines":[2198,2199]},"v":"ip地址种类","c":[{"t":"list_item","d":11,"p":{"lines":[2199,2200]},"v":"分类的ip地址"},{"t":"list_item","d":11,"p":{"lines":[2200,2201]},"v":"划分子网"},{"t":"list_item","d":11,"p":{"lines":[2201,2202]},"v":"构成超网CIDR"}]},{"t":"list_item","d":9,"p":{"lines":[2202,2203]},"v":"ip地址与硬件地址"},{"t":"list_item","d":9,"p":{"lines":[2203,2204]},"v":"ip数据报","c":[{"t":"list_item","d":11,"p":{"lines":[2204,2205]},"v":"ip数据报格式"},{"t":"list_item","d":11,"p":{"lines":[2205,2206]},"v":"分片"},{"t":"list_item","d":11,"p":{"lines":[2206,2207]},"v":"首部检验和"}]}]},{"t":"list_item","d":7,"p":{"lines":[2207,2208]},"v":"路由协议与算法","c":[{"t":"list_item","d":9,"p":{"lines":[2208,2209]},"v":"协议分类","c":[{"t":"list_item","d":11,"p":{"lines":[2209,2210]},"v":"内部网关协议IGP","c":[{"t":"list_item","d":13,"p":{"lines":[2210,2211]},"v":"RIP","c":[{"t":"list_item","d":15,"p":{"lines":[2211,2212],"f":true},"v":"工作原理 ","c":[{"t":"list_item","d":17,"p":{"lines":[2212,2213]},"v":"相邻路由表的交换"}]},{"t":"list_item","d":15,"p":{"lines":[2213,2214]},"v":"算法：距离向量算法(p135)"},{"t":"list_item","d":15,"p":{"lines":[2214,2215],"f":true},"v":"RIP报文格式 ","c":[{"t":"list_item","d":17,"p":{"lines":[2215,2216]},"v":"在<strong>运输层</strong>进行路由信息的交换"},{"t":"list_item","d":17,"p":{"lines":[2216,2217]},"v":"因为是运输层所以有UDP首部"}]},{"t":"list_item","d":15,"p":{"lines":[2217,2218],"f":true},"v":"特点 ","c":[{"t":"list_item","d":17,"p":{"lines":[2218,2219]},"v":"快消息传得慢"}]},{"t":"list_item","d":15,"p":{"lines":[2219,2220]},"v":"优缺点"}]},{"t":"list_item","d":13,"p":{"lines":[2220,2221]},"v":"OSPF","c":[{"t":"list_item","d":15,"p":{"lines":[2221,2222]},"v":"工作原理","c":[{"t":"list_item","d":17,"p":{"lines":[2222,2223]},"v":"洪泛法"}]},{"t":"list_item","d":15,"p":{"lines":[2223,2224]},"v":"算法：Dijkstra最短路径算法"},{"t":"list_item","d":15,"p":{"lines":[2224,2225]},"v":"报文格式 <br /> 直接用<strong>ip数据报</strong>传送OSPF分组","c":[{"t":"list_item","d":17,"p":{"lines":[2225,2226]},"v":"5种分组类型"},{"t":"list_item","d":17,"p":{"lines":[2226,2227]},"v":"其他"}]},{"t":"list_item","d":15,"p":{"lines":[2227,2228]},"v":"其他特点"}]}]},{"t":"list_item","d":11,"p":{"lines":[2228,2229]},"v":"外部网关协议EGP","c":[{"t":"list_item","d":13,"p":{"lines":[2229,2230]},"v":"BGP"}]}]},{"t":"list_item","d":9,"p":{"lines":[2230,2231]},"v":"算法种类","c":[{"t":"list_item","d":11,"p":{"lines":[2231,2232]},"v":"不分层","c":[{"t":"list_item","d":13,"p":{"lines":[2232,2233]},"v":"全局/局部"},{"t":"list_item","d":13,"p":{"lines":[2233,2234]},"v":"(自适应)动态/静态"}]},{"t":"list_item","d":11,"p":{"lines":[2234,2235]},"v":"分层","c":[{"t":"list_item","d":13,"p":{"lines":[2235,2236]},"v":"自治系统内路由算法"},{"t":"list_item","d":13,"p":{"lines":[2236,2237]},"v":"自治系统间路由算法"}]}]}]},{"t":"list_item","d":7,"p":{"lines":[2237,2238]},"v":"路由器组成"},{"t":"list_item","d":7,"p":{"lines":[2238,2239],"f":true},"v":"ip多播(了解) ","c":[{"t":"list_item","d":9,"p":{"lines":[2239,2240]},"v":"多播路由器"},{"t":"list_item","d":9,"p":{"lines":[2240,2241]},"v":"基本原理"},{"t":"list_item","d":9,"p":{"lines":[2241,2242]},"v":"协议","c":[{"t":"list_item","d":11,"p":{"lines":[2242,2243]},"v":"网际组管理协议IGMP"},{"t":"list_item","d":11,"p":{"lines":[2243,2244]},"v":"多播路由协议"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[2245,2246]},"v":"运输层","c":[{"t":"list_item","d":7,"p":{"lines":[2246,2247]},"v":"概述","c":[{"t":"list_item","d":9,"p":{"lines":[2247,2248]},"v":"进程通信"},{"t":"list_item","d":9,"p":{"lines":[2248,2249]},"v":"运输层的分用和复用"},{"t":"list_item","d":9,"p":{"lines":[2249,2250]},"v":"两个主要协议概述"}]},{"t":"list_item","d":7,"p":{"lines":[2250,2251]},"v":"UDP","c":[{"t":"list_item","d":9,"p":{"lines":[2251,2252]},"v":"特点"},{"t":"list_item","d":9,"p":{"lines":[2252,2253]},"v":"UDP首部格式"},{"t":"list_item","d":9,"p":{"lines":[2253,2254]},"v":"检验和计算"}]},{"t":"list_item","d":7,"p":{"lines":[2254,2255]},"v":"TCP","c":[{"t":"list_item","d":9,"p":{"lines":[2255,2256],"f":true},"v":"特点 ","c":[{"t":"list_item","d":11,"p":{"lines":[2256,2257]},"v":"面向连接"},{"t":"list_item","d":11,"p":{"lines":[2257,2258]},"v":"每一条TCP链接只能有两个端点"},{"t":"list_item","d":11,"p":{"lines":[2258,2259]},"v":"TCP提供可交付的服务"},{"t":"list_item","d":11,"p":{"lines":[2259,2260]},"v":"TCP提供全双工通信"},{"t":"list_item","d":11,"p":{"lines":[2260,2261]},"v":"面向字节流"}]},{"t":"list_item","d":9,"p":{"lines":[2261,2262]},"v":"连接原理:socket"},{"t":"list_item","d":9,"p":{"lines":[2262,2263]},"v":"报文段首部格式"},{"t":"list_item","d":9,"p":{"lines":[2263,2264]},"v":"可靠传输","c":[{"t":"list_item","d":11,"p":{"lines":[2264,2265]},"v":"工作原理 <br /> <strong>自动重传ARQ</strong>","c":[{"t":"list_item","d":13,"p":{"lines":[2265,2266]},"v":"停止等待协议","c":[{"t":"list_item","d":15,"p":{"lines":[2266,2267]},"v":"无差错情况"},{"t":"list_item","d":15,"p":{"lines":[2267,2268]},"v":"出现差错"},{"t":"list_item","d":15,"p":{"lines":[2268,2269]},"v":"确认丢失和确认迟到"}]},{"t":"list_item","d":13,"p":{"lines":[2269,2270]},"v":"连续等待ARQ","c":[{"t":"list_item","d":15,"p":{"lines":[2270,2271]},"v":"滑动窗口"},{"t":"list_item","d":15,"p":{"lines":[2271,2272]},"v":"按序到达的最后一个分组发送确认"},{"t":"list_item","d":15,"p":{"lines":[2272,2273]},"v":"go-back-n"}]}]},{"t":"list_item","d":11,"p":{"lines":[2273,2274]},"v":"实现","c":[{"t":"list_item","d":13,"p":{"lines":[2274,2275],"f":true},"v":"以字节为单位的滑动窗口 ","c":[{"t":"list_item","d":15,"p":{"lines":[2275,2276]},"v":"边界","c":[{"t":"list_item","d":17,"p":{"lines":[2276,2277]},"v":"含义","c":[{"t":"list_item","d":19,"p":{"lines":[2277,2278]},"v":"前沿"},{"t":"list_item","d":19,"p":{"lines":[2278,2279]},"v":"后沿"}]},{"t":"list_item","d":17,"p":{"lines":[2279,2280]},"v":"移动","c":[{"t":"list_item","d":19,"p":{"lines":[2280,2281]},"v":"后沿前移"},{"t":"list_item","d":19,"p":{"lines":[2281,2282]},"v":"~前沿收缩~"}]}]},{"t":"list_item","d":15,"p":{"lines":[2282,2283]},"v":"数据发送流程","c":[{"t":"list_item","d":17,"p":{"lines":[2283,2284]},"v":"窗口"},{"t":"list_item","d":17,"p":{"lines":[2284,2285]},"v":"三个指针"}]},{"t":"list_item","d":15,"p":{"lines":[2285,2286]},"v":"缓存与窗口关系","c":[{"t":"list_item","d":17,"p":{"lines":[2286,2287]},"v":"tcp发送缓存","c":[{"t":"list_item","d":19,"p":{"lines":[2287,2288],"f":true},"v":"存放内容 ","c":[{"t":"list_item","d":21,"p":{"lines":[2288,2289]},"v":"发送应用程序传送给发送方TCP准备发送的数据"},{"t":"list_item","d":21,"p":{"lines":[2289,2290]},"v":"TCP已发送但尚未收到确认的数据"}]}]},{"t":"list_item","d":17,"p":{"lines":[2290,2291]},"v":"tcp接收缓存","c":[{"t":"list_item","d":19,"p":{"lines":[2291,2292],"f":true},"v":"存放内容 ","c":[{"t":"list_item","d":21,"p":{"lines":[2292,2293]},"v":"按序到达的、但尚未被接收应用程序读取的数据"},{"t":"list_item","d":21,"p":{"lines":[2293,2294]},"v":"未按序到达的数据"}]},{"t":"list_item","d":19,"p":{"lines":[2294,2295],"f":true},"v":"窗口与缓存对应 ","c":[{"t":"list_item","d":21,"p":{"lines":[2295,2296]},"v":"接收缓存填满，接收窗口为0"}]}]},{"t":"list_item","d":17,"p":{"lines":[2296,2297]},"v":"缓存特点","c":[{"t":"list_item","d":19,"p":{"lines":[2297,2298]},"v":"环形缓存，循环使用"}]},{"t":"list_item","d":17,"p":{"lines":[2298,2299]},"v":"<strong>注意点</strong>","c":[{"t":"list_item","d":19,"p":{"lines":[2299,2300]},"v":"发送窗口和接收窗口并不总是一样大的（时间滞后）"},{"t":"list_item","d":19,"p":{"lines":[2300,2301]},"v":"不按序到达数据的处理"},{"t":"list_item","d":19,"p":{"lines":[2301,2302]},"v":"tcp接收方必须要有累积确认的功能"}]}]}]},{"t":"list_item","d":13,"p":{"lines":[2302,2303],"f":true},"v":"超时重传时间的选择 ","c":[{"t":"list_item","d":15,"p":{"lines":[2303,2304]},"v":"自适应算法"}]},{"t":"list_item","d":13,"p":{"lines":[2304,2305],"f":true},"v":"选择确认SACK ","c":[{"t":"list_item","d":15,"p":{"lines":[2305,2306],"f":true},"v":"目的 ","c":[{"t":"list_item","d":17,"p":{"lines":[2306,2307]},"v":"只重传缺少的数据"},{"t":"list_item","d":17,"p":{"lines":[2307,2308]},"v":"不重传已经正确到达的数据"}]},{"t":"list_item","d":15,"p":{"lines":[2308,2309]},"v":"原理与开启"},{"t":"list_item","d":15,"p":{"lines":[2309,2310]},"v":"实际：大多数不使用SACK"}]}]}]},{"t":"list_item","d":9,"p":{"lines":[2310,2311]},"v":"TCP的流量控制","c":[{"t":"list_item","d":11,"p":{"lines":[2311,2312]},"v":"利用滑动窗口"},{"t":"list_item","d":11,"p":{"lines":[2312,2313]},"v":"传输效率的考虑 <br /> 报文段的发送时机"}]},{"t":"list_item","d":9,"p":{"lines":[2313,2314]},"v":"TCP的拥塞控制","c":[{"t":"list_item","d":11,"p":{"lines":[2314,2315]},"v":"一般原理","c":[{"t":"list_item","d":13,"p":{"lines":[2315,2316]},"v":"开环控制"},{"t":"list_item","d":13,"p":{"lines":[2316,2317]},"v":"闭环控制"}]},{"t":"list_item","d":11,"p":{"lines":[2317,2318]},"v":"常用方法","c":[{"t":"list_item","d":13,"p":{"lines":[2318,2319]},"v":"慢开始"},{"t":"list_item","d":13,"p":{"lines":[2319,2320]},"v":"拥塞避免"},{"t":"list_item","d":13,"p":{"lines":[2320,2321]},"v":"快重传"},{"t":"list_item","d":13,"p":{"lines":[2321,2322]},"v":"快恢复"}]},{"t":"list_item","d":11,"p":{"lines":[2322,2323]},"v":"随机早期检测"}]},{"t":"list_item","d":9,"p":{"lines":[2323,2324]},"v":"TCP的连接管理","c":[{"t":"list_item","d":11,"p":{"lines":[2324,2325]},"v":"三次挥手"},{"t":"list_item","d":11,"p":{"lines":[2325,2326]},"v":"四次握手"}]}]}]},{"t":"list_item","d":5,"p":{"lines":[2327,2328]},"v":"应用层"}]},{"t":"heading","d":3,"p":{"lines":[2329,2330],"f":true},"v":"基础问题 ","c":[{"t":"list_item","d":5,"p":{"lines":[2331,2332]},"v":"计算机网络体系结构"},{"t":"list_item","d":5,"p":{"lines":[2332,2333]},"v":"传输层：TCP和UDP","c":[{"t":"list_item","d":7,"p":{"lines":[2333,2334]},"v":"什么是三次握手？"},{"t":"list_item","d":7,"p":{"lines":[2334,2335]},"v":"什么是四次挥手？"},{"t":"list_item","d":7,"p":{"lines":[2335,2336]},"v":"TCP如何实现流量控制？"},{"t":"list_item","d":7,"p":{"lines":[2336,2337]},"v":"TCP的拥塞控制是怎么实现的？"},{"t":"list_item","d":7,"p":{"lines":[2337,2338]},"v":"TCP如何最大利用带宽？"},{"t":"list_item","d":7,"p":{"lines":[2338,2339]},"v":"TCP与UDP的区别"},{"t":"list_item","d":7,"p":{"lines":[2339,2340]},"v":"TCP如何保证传输的可靠性"},{"t":"list_item","d":7,"p":{"lines":[2340,2341]},"v":"什么是TCP粘包？"}]},{"t":"list_item","d":5,"p":{"lines":[2341,2342]},"v":"应用层：HTTP和HTTPS","c":[{"t":"list_item","d":7,"p":{"lines":[2342,2343]},"v":"HTTP和HTTPS有什么区别？"},{"t":"list_item","d":7,"p":{"lines":[2343,2344]},"v":"GET与POST的区别？"},{"t":"list_item","d":7,"p":{"lines":[2344,2345]},"v":"Session与Cookie的区别？"},{"t":"list_item","d":7,"p":{"lines":[2345,2346]},"v":"从输入网址到获得页面的过程 (越详细越好)？"},{"t":"list_item","d":7,"p":{"lines":[2346,2347]},"v":"HTTP请求有哪些常见状态码？"},{"t":"list_item","d":7,"p":{"lines":[2347,2348]},"v":"什么是RIP (距离矢量路由协议)?"}]},{"t":"list_item","d":5,"p":{"lines":[2348,2349]},"v":"网络层协议IP","c":[{"t":"list_item","d":7,"p":{"lines":[2349,2350]},"v":"IP地址的分类？"},{"t":"list_item","d":7,"p":{"lines":[2350,2351]},"v":"什么叫划分子网？"},{"t":"list_item","d":7,"p":{"lines":[2351,2352]},"v":"什么是ARP协议？"},{"t":"list_item","d":7,"p":{"lines":[2352,2353]},"v":"什么是NAT (网络地址转换)？"}]},{"t":"list_item","d":5,"p":{"lines":[2353,2354]},"v":"从 URL 输入到页面展现到底发生什么"}]}]},{"t":"heading","d":2,"p":{"lines":[2355,2356],"f":true},"v":"操作系统"},{"t":"heading","d":2,"p":{"lines":[2357,2358],"f":true},"v":"算法"}]},{"t":"heading","d":1,"p":{"lines":[2359,2360]},"v":"分布式相关","c":[{"t":"heading","d":2,"p":{"lines":[2361,2362],"f":true},"v":"分布式理论 ","c":[{"t":"heading","d":3,"p":{"lines":[2363,2364]},"v":"基础理论","c":[{"t":"heading","d":4,"p":{"lines":[2365,2366]},"v":"分布式"},{"t":"heading","d":4,"p":{"lines":[2367,2368]},"v":"分布式和集群"},{"t":"heading","d":4,"p":{"lines":[2369,2370]},"v":"微服务"}]},{"t":"heading","d":3,"p":{"lines":[2371,2372]},"v":"通信设计","c":[{"t":"heading","d":4,"p":{"lines":[2373,2374]},"v":"RPC"},{"t":"heading","d":4,"p":{"lines":[2375,2376]},"v":"REST"}]},{"t":"heading","d":3,"p":{"lines":[2377,2378]},"v":"分布式事务算法","c":[{"t":"heading","d":4,"p":{"lines":[2379,2380]},"v":"一致性问题"},{"t":"heading","d":4,"p":{"lines":[2381,2382]},"v":"2PC"},{"t":"heading","d":4,"p":{"lines":[2383,2384]},"v":"3PC"},{"t":"heading","d":4,"p":{"lines":[2385,2386]},"v":"paxos"},{"t":"heading","d":4,"p":{"lines":[2387,2388]},"v":"raft"}]}]},{"t":"heading","d":2,"p":{"lines":[2389,2390]},"v":"高可用"},{"t":"heading","d":2,"p":{"lines":[2391,2392]},"v":"分布式锁","c":[{"t":"heading","d":3,"p":{"lines":[2393,2394]},"v":"数据库"},{"t":"heading","d":3,"p":{"lines":[2395,2396]},"v":"redis"},{"t":"heading","d":3,"p":{"lines":[2397,2398]},"v":"zookeeper"},{"t":"heading","d":3,"p":{"lines":[2399,2400]},"v":"etcd"}]},{"t":"heading","d":2,"p":{"lines":[2401,2402]},"v":"分布式协调框架","c":[{"t":"heading","d":3,"p":{"lines":[2403,2404]},"v":"zookeeper"}]},{"t":"heading","d":2,"p":{"lines":[2405,2406]},"v":"RPC框架","c":[{"t":"heading","d":3,"p":{"lines":[2407,2408]},"v":"SpringCloud"},{"t":"heading","d":3,"p":{"lines":[2409,2410],"f":true},"v":"Dubbo"}]}]},{"t":"heading","d":1,"p":{"lines":[2411,2412]},"v":"消息队列","c":[{"t":"heading","d":2,"p":{"lines":[2413,2414],"f":true},"v":"Kafka"},{"t":"heading","d":2,"p":{"lines":[2415,2416],"f":true},"v":"RocketMQ"}]}],"p":{}})</script>
</body>
</html>
