> 考虑到以前学的时候没做笔记，没有系统的认识。因此重新梳理一遍
>
> 偶尔会进行整理，但大多数时间可能在读资料

> 根据linux-c整理而成

# 1. C语言基础

## 1.1. 程序基本概念

### 1.1.1. 程序基本概念

- 程序（Program）:
  - **告诉计算机应如何完成一个计算任务** 
  - 这里的计算可以是数学运算，比如解方程，也可以是符号运算，比如查找和替换文档中的某个单词
  - 从根本上说，计算机是由数字电路组成的运算机器，只能对数字做运算，程序之所以能做符号运算，是因为符号在计算机内部也是用数字表示的
  - 此外，程序还可以处理声音和图像，声音和图像在计算机内部必然也是用数字表示的，这些数字经过专门的硬件设备转换成人可以听到、看到的声音和图像。

- 指令（Instruction）:程序由一系列指令（Instruction）组成，指令是指示计算机做某种运算的命令，通常包括以下几类：
  - **输入（Input）**：从键盘、文件或者其它设备获取数据。
  - **输出（Output）**：把数据显示到屏幕，或者存入一个文件，或者发送到其它设备。
  - **基本运算**：执行最基本的数学运算（加减乘除）和数据存取。
  - **测试和分支**：测试某个条件，然后根据不同的测试结果执行不同的后续指令。
  - **循环**：重复执行一系列操作。

  > 对于程序来说，有上面这几类指令就足够了。你曾用过的任何一个程序，不管它有多么复杂，都是由这几类指令组成的。
  > 程序是那么的复杂，而编写程序可以用的指令却只有这么简单的几种，这中间巨大的落差就要由程序员去填了
  > 所以编写程序理应是一件相当复杂的工作。
  > **编写程序可以说就是这样一个过程：把复杂的任务分解成子任务，把子任务再分解成更简单的任务，层层分解，直到最后简单得可以用以上指令来完成。**

### 1.1.2. 编程语言

#### 1.1.2.1. 分类

- 编程语言（Programming Language）分为
  - 低级语言（Low-level Language）
    > 直接用计算机指令编写程序
    - 机器语言（Machine Language）
    - 汇编语言（Assembly Language）
  - 高级语言（High-level Language）
    > 用语句（Statement）编写程序，
    - C、C++、Java、Python 等属于高级语言

- 语句:是计算机指令的抽象表示。举个例子，同样一个语句用 C 语言、汇编语言和机器语言分别表示如下：

  | 编程语言 | 表示形式                                                    |
  | -------- | ----------------------------------------------------------- |
  | C 语言   | `a=b+1;`                                                    |
  | 汇编语言 | `mov 0x804a01c,%eax<br>add $0x1,%eax<br>mov %eax,0x804a018` |
  | 机器语言 | `a1 1c a0 04 08<br>83 c0 01<br>a3 18 a0 04 08`              |

#### 1.1.2.2. 汇编器和编译器

- 汇编语言->机器语言
  - 计算机只能对数字做运算，符号、声音、图像在计算机内部都要用数字表示，指令也不例外
  - 上表中的机器语言完全由十六进制数字组成
  - 最早的程序员都是直接用机器语言编程，但是很麻烦，需要查大量的表格来确定每个数字表示什么意思，编写出来的程序很不直观，而且容易出错
  - 于是有了汇编语言，把机器语言中一组一组的数字用助记符（Mnemonic）表示，直接用这些助记符写出汇编程序
  - 然后让汇编器（Assembler）去查表把助记符替换成数字，也就把汇编语言翻译成了机器语言
    - 从上面的例子可以看出，汇编语言和机器语言的指令是一一对应的，汇编语言有三条指令，机器语言也有三条指令，汇编器就是做一个简单的替换工作
    - 例如在第一条指令中，把 `movl ?,%eax` 这种格式的指令替换成机器码 `a1 ?`，`?` 表示一个地址，在汇编指令中是 `0x804a01c`，转换成机器码之后是 `1c a0 04 08` 
      > （这是指令中的十六进制数的小端表示，小端表示将在**「目标文件」**章节 介绍）。

- 高级语言->机器语言
  - 从上面的例子还可以看出，C 语言的语句和低级语言的指令之间不是简单的一一对应关系，一条 `a=b+1;` 语句要翻译成三条汇编或机器指令
  - 这个过程称为 **编译（Compile）** ，由编译器（Compiler）来完成，显然编译器的功能比汇编器要复杂得多
  - 用 C 语言编写的程序必须经过编译转成机器指令才能被计算机执行，编译需要花一些时间，这是用高级语言编程的一个缺点，然而更多的是优点
    - 首先，用 C 语言编程更容易，写出来的代码更紧凑，可读性更强，出了错也更容易改正
    - 其次，C 语言是可移植的（Portable）或者称为平台无关的（Platform Independent）。

#### 1.1.2.3. C语言的编译和可移植性

- 平台：
  - 平台这个词有很多种解释，可以指计算机体系结构（Architecture），也可以指操作系统（Operating System），也可以指开发平台（编译器、链接器等）
  - **不同的计算机体系结构有不同的指令集（Instruction Set）** ，可以识别的机器指令格式是不同的
- 编译保证可移植性
  - **直接用某种体系结构的汇编或机器指令写出来的程序只能在这种体系结构的计算机上运行** 
  - **而各种体系结构的计算机都有各自的 C 编译器** ，
    - 可以把 C 程序编译成各种不同体系结构的机器指令
    - 这意味着用 C 语言写的程序只需稍加修改甚至不用修改就可以在各种不同的计算机上 **编译** 运行
- 不同编译器
  - 还要注意一点， **即使在相同的体系结构和操作系统下，用不同的 C 编译器（或者同一个 C 编译器的不同版本）编译同一个程序得到的结果也有可能不同** 
  - **C 语言有些语法特性在 C 标准中并没有明确规定，各编译器有不同的实现，** 编译出来的指令的行为特性也会不同，应该尽量避免使用不可移植的语法特性。
- 其他高级语言
  - 各种高级语言都具有 C 语言的这些优点，所以绝大部分程序是用高级语言编写的
  - 只有和硬件关系密切的少数程序（例如驱动程序）才会用到低级语言

#### 1.1.2.4. 编译执行和解释执行

- 总结一下编译执行的过程
  - 首先你用文本编辑器写一个 C 程序
  - 然后保存成一个文件，例如program.c（通常 C 程序的文件名后缀是 `.c`），这称为源代码（Source Code）或源文件
  - 然后运行编译器对它进行编译，编译的过程并不执行程序，而是把源代码全部翻译成机器指令，再加上一些描述信息，生成一个新的文件，例如 `a.out`，这称为可执行文件
  - 可执行文件可以被操作系统加载运行，计算机执行该文件中由编译器生成的指令，如下图所示：

    ![图 1.1. 编译执行的过程](./image/intro.compile.png)

- 有些高级语言以解释（Interpret）的方式执行
  - 解释执行过程和 C 语言的编译执行过程很不一样
  - 例如编写一个 Shell 脚本 `script.sh`，内容如下：

    ```bash
      #! /bin/sh
      VAR=1
      VAR=$(($VAR+1))
      echo $VAR
    ```

  - 定义 `Shell`变量 `VAR` 的初始值是 `1`，然后自增 `1`，然后打印 `VAR` 的值
  - 用 `Shell` 程序 `/bin/sh` 解释执行这个脚本，结果如下：

    ```bash
    $ /bin/sh script.sh
    2
    ```

  - 这里的 `/bin/sh` 称为解释器（Interpreter）
  - 它把脚本中的每一行当作一条命令解释执行，而不需要先生成包含机器指令的可执行文件再执行
  - 如果把脚本中的这三行当作三条命令直接敲到 `Shell` 提示符下，也能得到同样的结果：

    ```bash
    $ VAR=1
    $ VAR=$(($VAR+1))
    $ echo $VAR
    2
    ```

  ![图 1.2. 解释执行的过程](./image/intro.interpret.png)

### 1.1.3. 编程语言发展

- 编程语言仍在发展演化
- 以上介绍的机器语言称为第一代语言（1GL，1st Generation Programming Language）
- 汇编语言称为第二代语言（2GL，2nd Generation Programming Language）
- C、C++、Java、Python 等可以称为第三代语言（3GL，3rd Generation Programming Language）
- 目前已经有了 4GL（4th Generation Programming Language）和 5GL（5th Generation Programming Language）的概念
- 3GL 的编程语言虽然是用语句编程而不直接用指令编程，但语句也分为输入、输出、基本运算、测试分支和循环等几种，和指令有直接的对应关系
- 而 4GL 以后的编程语言更多是描述要做什么（Declarative）而不描述具体一步一步怎么做（Imperative），具体一步一步怎么做完全由编译器或解释器决定
  - 例如 SQL 语言（SQL，Structured Query Language，结构化查询语言）就是这样的例子。

### 1.1.4. 调试与错误

- 编程是一件复杂的工作，因为是人做的事情，所以难免经常出错
  - 据说有这样一个典故：早期的计算机体积都很大，有一次一台计算机不能正常工作，工程师们找了半天原因最后发现是一只臭虫钻进计算机中造成的
  - 从此以后，程序中的错误被叫做臭虫（Bug），而找到这些 Bug 并加以纠正的过程就叫做调试（Debug）
  - 有时候调试是一件非常复杂的工作，要求程序员概念明确、逻辑清晰、性格沉稳，还需要一点运气
  - 调试的技能我们在后续的学习中慢慢培养，但首先我们要区分清楚程序中的 Bug 分为哪几类。

- Bug分类
  - **编译时错误**：编译器只能翻译语法正确的程序，否则将导致编译失败，无法生成可执行文件。对于自然语言来说，一点语法错误不是很严重的问题，因为我们仍然可以读懂句子。而编译器就没那么宽容了，只要有哪怕一个很小的语法错误，编译器就会输出一条错误提示信息然后罢工，你就得不到你想要的结果。虽然大部分情况下编译器给出的错误提示信息就是你出错的代码行，但也有个别时候编译器给出的错误提示信息帮助不大，甚至会误导你。在开始学习编程的前几个星期，你可能会花大量的时间来纠正语法错误。等到有了一些经验之后，还是会犯这样的错误，不过会少得多，而且你能更快地发现错误原因。等到经验更丰富之后你就会觉得，语法错误是最简单最低级的错误，编译器的错误提示也就那么几种，即使错误提示是有误导的也能够立刻找出真正的错误原因是什么。相比下面两种错误，语法错误解决起来要容易得多。
  - **运行时错误**：编译器检查不出这类错误，仍然可以生成可执行文件，但在运行时会出错而导致程序崩溃。对于我们接下来的几章将编写的简单程序来说，运行时错误很少见，到了后面的章节你会遇到越来越多的运行时错误。读者在以后的学习中要时刻**注意区分编译时和运行时（Run-time）这两个概念**，不仅在调试时需要区分这两个概念，在学习 C 语言的很多语法时都需要区分这两个概念，有些事情在编译时做，有些事情则在运行时做。
  - **逻辑错误和语义错误**：第三类错误是逻辑错误和语义错误。如果程序里有逻辑错误，编译和运行都会很顺利，看上去也不产生任何错误信息，但是程序没有干它该干的事情，而是干了别的事情。当然不管怎么样，计算机只会按你写的程序去做，问题在于你写的程序不是你真正想要的，这意味着程序的意思（即语义）是错的。找到逻辑错误在哪需要十分清醒的头脑，要通过观察程序的输出回过头来判断它到底在做什么。

```
通过本书你将掌握的最重要的技巧之一就是调试。调试的过程可能会让你感到一些沮丧，但调试也是编程中最需要动脑的、最有挑战和乐趣的部分。
从某种角度看调试就像侦探工作，根据掌握的线索来推断是什么原因和过程导致了你所看到的结果。
调试也像是一门实验科学，每次想到哪里可能有错，就修改程序然后再试一次。如果假设是对的，就能得到预期的正确结果，就可以接着调试下一个 Bug，一步一步逼近正确的程序；
如果假设错误，只好另外再找思路再做假设。「当你把不可能的全部剔除，剩下的——即使看起来再怎么不可能——就一定是事实。」。

也有一种观点认为，编程和调试是一回事，编程的过程就是逐步调试直到获得期望的结果为止。
你应该总是从一个能正确运行的小规模程序开始，每做一步小的改动就立刻进行调试，
这样的好处是总有一个正确的程序做参考：如果正确就继续编程，如果不正确，那么一定是刚才的小改动出了问题。
例如，Linux 操作系统包含了成千上万行代码，但它也不是一开始就规划好了内存管理、设备管理、文件系统、网络等等大的模块，
一开始它仅仅是 Linus Torvalds 用来琢磨 Intel 80386 芯片而写的小程序。
据 Larry Greenfield 说，「 Linus 的早期工程之一是编写一个交替打印 AAAA 和 BBBB 的程序，这玩意儿后来进化成了 Linux。」
（引自 *The Linux User's Guide* Beta1 版）在后面的章节中会给出更多关于调试和编程实践的建议。
```

### 1.1.5. C语言标准

- C 语言的发展历史大致上分为三个阶段：
  - Old Style 
    - Ken Thompson 和 Dennis Ritchie 最初发明 C 语言时有很多语法和现在最常用的写法并不一样
    - 但为了向后兼容性（Backward Compatibility），这些语法仍然在 C89 和 C99 中保留下来了，
  - C89 
    - C89 是最早的 C 语言规范，于 1989 年提出，
    - 1990 年首先由 ANSI （美国国家标准委员会，American National Standards Institute）推出
    - 后来被接纳为 ISO 国际标准（ISO/IEC 9899:1990），因而有时也称为 C90，最经典的 C 语言教材 K&R 就是基于这个版本的
    - C89 是目前最广泛采用的 C 语言标准，大多数编译器都完全支持 C89。
  - C99
    - C99 标准（ISO/IEC 9899:1999）是在 1999 年推出的，加入了许多新特性，但目前仍没有得到广泛支持，
    - 在 C99 推出之后相当长的一段时间里，连 gcc 也没有完全实现 C99 的所有特性。
    - C99 标准详见 [C99](https://en.wikipedia.org/wiki/C99)。

> linux-C本书讲 C 的语法以 C99 为准，但示例代码通常只使用 C89 语法，很少使用 C99 的新特性。

- C 标准的目的是为了精确定义 C 语言，而不是为了教别人怎么编程
  - C 标准在表达上追求准确和无歧义，却十分不容易看懂
  - Standard C 和 Standard C Library 是对 C89 及其修订版本的阐释（可惜作者没有随 C99 更新这两本书），比 C 标准更容易看懂
  - 另外，参考 C99 Rationale 也有助于加深对 C 标准的理解。

## 1.2. 常量、变量和表达式

### 1.2.1. 注释、字符串常量、转义字符

#### 1.2.1.1. 注释

- 注释可以跨行，也可以穿插在程序之中

  ```c
  #include <stdio.h>
  
  /* 
   * comment1
   * main: generate some simple output
   */
  
  int main(void)
  {
    printf(/* comment2 */"Hello, world.\n"); /* comment3 */
    return 0;
  }
  ```

  - 第一个注释跨了四行，头尾两行是注释的界定符（Delimiter） `/*` 和 `*/`，
  - 中间两行开头的 `*` 号（Asterisk）并没有特殊含义，只是为了看起来整齐，
  - 这不是语法规则而是大家都遵守的 C 代码风格（Coding Style）之一，
  - 代码风格将在 **第 9 章「编码风格」** 详细介绍。

- 使用注释需要注意两点：
  - 注释不能嵌套（Nest）使用
    - 就是说一个注释的文字中不能再出现 `/*` 和 `*/` 了
    - 例如 `/* text1 /* text2 */ text3 */` 是错误的
    - 编译器只把 `/* text1 /* text2 */` 看成注释，后面的 `text3 */` 无法解析，因而会报错。
  - 有的 C 代码中有类似 `// comment` 的注释，
    - 两个 `/` 斜线（Slash）表示从这里直到该行末尾的所有字符都属于注释，
    - 这种注释不能跨行，也不能穿插在一行代码中间。
    - 这是 **从 C++ 借鉴的语法，在 C99 中被标准化** 。

> - **C 语言标准**
>   - C 语言的发展历史大致上分为三个阶段：
>     - Old Style C
>     - C89
>     - C99
>   - 发展与语法：
>     - Ken Thompson 和 Dennis Ritchie 最初发明 C 语言时有很多语法和现在最常用的写法并不一样，
>     - 但为了向后兼容性（Backward Compatibility），这些语法仍然在 C89 和 C99 中保留下来了
>     - 不会详细说明 Old Style C，但在必要的地方会加以说明
>   - C89 是最早的 C 语言规范
>     - 于 1989 年提出，1990 年首先由 ANSI （美国国家标准委员会，American National Standards Institute）推出
>     - 后来被接纳为 ISO 国际标准（ISO/IEC 9899:1990），因而有时也称为 C90，
>     - 最经典的 C 语言教材 *K&R* 就是基于这个版本的，C89 是目前最广泛采用的 C 语言标准，
>     - 大多数编译器都完全支持 C89。
>   - C99 标准（ISO/IEC 9899:1999）
>     - 是在 1999 年推出的，加入了许多新特性，但目前仍没有得到广泛支持，
>     - 在 C99 推出之后相当长的一段时间里，连 gcc 也没有完全实现 C99 的所有特性。
>     - C99 标准详见 [C99](https://en.wikipedia.org/wiki/C99)。
>     - **笔记中C 的语法以 C99 为准，但示例代码通常只使用 C89 语法，很少使用 C99 的新特性** 。
>   - C 标准的目的
>     - 是为了精确定义 C 语言，而不是为了教别人怎么编程，
>     - C 标准在表达上追求准确和无歧义，却十分不容易看懂，
>     - *Standard C* 和 *Standard C Library* 是对 C89 及其修订版本的阐释（可惜作者没有随 C99 更新这两本书），比 C 标准更容易看懂
>     - 另外，参考 *C99 Rationale* 也有助于加深对 C 标准的理解。

#### 1.2.1.2. 字符串常量和转义字符

- 字符串与转义字符
  - 像 `"Hello, world.\n"` 这种由双引号（Double Quote）引起来的一串字符称为字符串字面值（String Literal），或者简称字符串。
  - 注意，程序的运行结果并没有双引号，`printf` 打印出来的只是里面的一串字符 `Hello, world.` ，
  - 因此双引号是字符串字面值的界定符，夹在双引号中间的一串字符才是它的内容。
  - 注意，打印出来的结果也没有 `\n` 这两个字符，在[「程序的基本概念」-「自然语言和形式语言」]()中提到过，
    - C 语言规定了一些转义序列（Escape Sequence），这里的 `\n` 并不表示它的字面意思，也就是说并不表示 `\` 和 `n` 这两个字符本身，
    - 而是合起来表示一个换行符（Line Feed）。例如我们写三条打印语句：

    ```c
    printf("Hello, world.\n");
    printf("Goodbye, ");
    printf("cruel world!\n");
    ```

    - 运行的结果是第一条语句单独打到第一行，后两条语句都打到第二行。
    - 为了节省篇幅突出重点，以后的例子通常省略 `#include` 和 `int main(void) { ... }` 这些 Boilerplate，
    - 但读者在练习时需要加上这些构成一个完整的程序才能编译通过。

- C 标准规定的 **转义字符** 有以下几种：

  <p id="c2-1">表 2.1. C 标准规定的转义字符</p>

  | 字面 | 转义                                 |
  | ---- | ------------------------------------ |
  | `\'` | 单引号 '（Single Quote或Apostrophe） |
  | `\"` | 双引号 "（Double Quote）             |
  | `\?` | 问号 ?（Question Mark）              |
  | `\\` | 反斜线 \（Backslash）                |
  | `\a` | 响铃（Alert或Bell）                  |
  | `\b` | 退格（Backspace）                    |
  | `\f` | 分页符（Form Feed）                  |
  | `\n` | 换行（Line Feed）                    |
  | `\r` | 回车（Carriage Return）              |
  | `\t` | 水平制表符（Horizontal Tab）         |
  | `\v` | 垂直制表符（Vertical Tab）           |


  - 如果在字符串字面值中要表示单引号和问号，
    - 既可以使用转义序列 `\'` 和 `\?`，
    - 也可以直接用字符 `'` 和 `?`，
  - 而要表示 `\` 或 `"` 则必须使用转义序列，
    - 因为 `\` 字符表示转义而不表示它的字面含义，
    - `"` 表示字符串的界定符而不表示它的字面含义。
  - 可见转义序列有两个作用：
    - 一是把普通字符转义成特殊字符，例如把字母 `n` 转义成换行符；
    - 二是把特殊字符转义成普通字符，例如 `\` 和 `"` 是特殊字符，转义后取它的字面值。

- 特殊控制字符：C 语言规定了几个控制字符，不能用键盘直接输入，因此采用 `\` 加字母的转义序列表示。
  > 可以用 `printf` 语句试试这几个控制字符的作用。
  - `\a`: 是响铃字符，在字符终端下显示这个字符的效果是 PC 喇叭发出嘀的一声，在图形界面终端下的效果取决于终端的实现。
  - `\b`: 在终端下显示 `\b` 和按下退格键的效果相同。
  - `\f`: 是分页符，主要用于控制打印机在打印源代码时提前分页，这样可以避免一个函数跨两页打印。
  - `\n` 和 `\r`: 分别表示 Line Feed 和 Carriage Return
    - 这两个词来自老式的英文打字机，
      - Line Feed 是跳到下一行（进纸，喂纸，有个喂的动作所以是 feed），
      - Carriage Return 是回到本行开头（Carriage 是卷着纸的轴，随着打字慢慢左移，打完一行就一下子移回最右边），
      - 如果你看过欧美的老电影应该能想起来这是什么。用老式打字机打完一行之后需要这么两个动作，`\r\n`
    - 所以现在 Windows 上的文本文件用 `\r\n` 做行分隔符，
      - 许多应用层网络协议（如 HTTP）也用 `\r\n` 做行分隔符，
      - 而 Linux 和各种 UNIX 上的文本文件只用 `\n` 做行分隔符。
  - `\t`: 在终端下显示 `\t` 和按下 `Tab` 键的效果相同，用于在终端下定位表格的下一列，
  - `\v`: 用于在终端下定位表格的下一行。
    - `\v` 比较少用，`\t` 比较常用
    - 以后将「水平制表符」简称为「制表符」或 `Tab`

- 空格与换行：
  - 注意 `"Goodbye, "` 末尾的空格，
  - 字符串字面值中的空格也算一个字符，也会出现在输出结果中，
  - 而程序中别处的空格和 `Tab` 多一个少一个往往是无关紧要的，不会对编译的结果产生任何影响，
  - 例如不缩进不会影响程序的结果，`main` 后面多几个空格也没影响，
  - 但是 `int` 和 `main` 之间至少要有一个空格分隔开：

  ```c
  int main    (void)
  {
    printf("Hello, world.\n");
    return 0;
  }
  ```

  - 不仅空格和 `Tab` 是无关紧要的，换行也是如此，我甚至可以把整个程序写成一行，但是 `include` 必须单独占一行：

    ```c
    #include<stdio.h>
    int main(void){printf("Hello, world.\n");return 0;}
    ```

    - 这样也行，但肯定不是好的代码风格，去掉缩进已经很影响可读性了，写成现在这个样子可读性更差。
    - 如果编译器说第 2 行有错误，也很难判断是哪个语句有错误。
    - 所以， **好的代码风格要求缩进整齐，每个语句一行，适当留空行。**

### 1.2.2. 常量

- 常量（Constant）是程序中最基本的元素， 有
  - 字符（Character）常量
  - 整数（Integer）常量
  - 浮点数（Floating Point）常量
  - 枚举常量
    - 枚举常量将在[「结构体」-「数据类型标志」]()介绍

- 常量示例：

  ```c
  printf("character: %c\ninteger: %d\nfloating point: %f\n", '}', 34, 3.14);
  ```

- 字符常量
  - 字符常量要用单引号括起来，例如上面的 `'}'`，
  - 注意单引号只能括一个字符而不能像双引号那样括一串字符，
  - 字符常量也可以是一个转义序列，例如 `'\n'`， 这时虽然单引号括了两个字符，但实际上只表示一个字符。
  - 和字符串字面值中使用转义序列有一点区别，如果在字符常量中要表示双引号 `"` 和问号 `?`，
    - 既可以使用转义序列 `\"`和 `\?`，也可以直接用字符 `"` 和 `?`
    - 而要表示 `'` 和 `\` 则必须使用转义序列。

> - 为什么需要规定一个转义序列 `\?` ？
>   - 因为 C 语言规定了一些三连符（Trigraph），
>   - 在某些特殊的终端上缺少某些字符，需要用 Trigraph 输入，例如用 `??=` 表示 `#` 字符。
>   - Trigraph 极不常用，介绍这个只是为了让读者理解 C 语言规定转义序列的作用，即特殊字符转普通字符，普通字符转特殊字符，
>   - `?` 也是一种特殊字符。
>   - 极不常用的 C 语法通常不会介绍。

- 整数和浮点数常量：
  - 计算机中整数和小数的内部表示方式不同，将在[「计算机中数的表示」]()详细介绍），因而在 C 语言中是两种不同的类型（Type），
  - 例如上例的 `34` 和 `3.14`，小数在计算机术语中称为浮点数。
  - 这个语句的输出结果和 `Hello world` 不太一样，字符串 `"character: %c\ninteger: %d\nfloating point: %f\n"` 并不是按原样打印输出的，而是输出成这样：

    ```bash
    character: }
    integer: 34
    floating point: 3.14
    ```
  - `printf` 中的第一个字符串称为格式化字符串（Format String），
    - 它规定了后面几个常量以何种格式插入到这个字符串中，
    - 在格式化字符串中 `%` 号（Percent Sign）后面加上字母 `c`、`d`、`f` 分别表示字符型、整型和浮点型的转换说明（Conversion Specification），
    - 转换说明只在格式化字符串中占个位置，并不出现在最终的打印结果中，这种用法通常叫做占位符（Placeholder）。
    - 这也是一种字面意思与真实意思不同的情况，但是转换说明和转义序列又有区别：
      - 转义序列是编译时处理的，而转换说明是在运行时调用 `printf` 函数处理的。
      - 源文件中的字符串字面值是 `"character: %c\ninteger: %d\nfloating point: %f\n"`，
      - `\n` 占两个字符，而编译之后保存在可执行文件中的字符串是: `character： %c` 换行 `integer: %d` 换行 `floating point: %f` 换行，
      - `\n` 已经被替换成一个换行符，而 `%c` 不变，然后在运行时这个字符串被传给 `printf`，`printf` 再把其中的 `%c`、`%d`、`%f` 解释成转换说明。

- 有时候不同类型的数据很容易弄混
  - 例如 `"5"`、`'5'`、`5`，如果你注意了它们的界定符就会很清楚，
  - 一个是字符串字面值，第二个是字符，第三个是整数

### 1.2.3. 变量

- 变量（Variable）是编程语言最重要的概念之一
  - 变量是计算机存储器中的一块命名的空间，可以在里面存储一个值（Value），
  - 存储的值是可以随时变的，比如这次存个字符 `'a'` 下次存个字符 `'b'`，
  - 正因为变量的值可以随时变所以才叫变量。

- 常量有不同的类型，因此变量也有不同的类型，
  - 变量的类型也决定了它所占的存储空间的大小。
  - 例如以下四个语句定义了四个变量 `fred`、`bob`、`jimmy` 和 `tom`，它们的类型分别是字符型、整型、浮点型：

  ```c
  char fred;
  int bob;
  float jimmy;
  double tom;
  ```

> - **声明和定义**
>   - C 语言中的声明（Declaration）有变量声明、函数声明和类型声明三种。
>   - **如果一个变量或函数的声明要求编译器为它分配存储空间，那么也可以称为定义（Definition），因此定义是声明的一种** 。
>   - 在接下来几章的示例代码中变量声明都是要分配存储空间的，因而都是定义，
>   - 等学到[「链接详解」-「定义和声明」]()我们会看到哪些变量声明不分配存储空间因而不是定义。
>   - 在下一章我们会看到函数的定义和声明也是这样区分的，分配存储空间的函数声明可以称为函数定义。
>   - 从[「结构体」]()开始我们会看到类型声明，声明一个类型是不分配存储空间的，但似乎叫「类型定义」听起来也不错，所以在本书中「类型定义」和「类型声明」表示相同的含义。
>   - 声明和语句类似，也是以 `;` 号结尾的，但是在语法上声明和语句是有区别的，语句只能出现在 `{}` 括号中，而声明既可以出现在 `{}` 中也可以出现在所有 `{}` 之外。

- 浮点型有三种，
  - `float` 是单精度浮点型，
  - `double` 是双精度浮点型，
  - `long double` 是精度更高的浮点型。
  - 它们之间的区别和转换规则将在[「数据类型详解」]()详细介绍，在随后的几章中我们只使用 `double` 类型，

- 给变量起名有一定的限制，
  - C 语言规定必须以字母或下划线 `_`（Underscore）开头，后面可以跟若干个字母、数字、下划线，但不能有其它字符。
    - 例如这些是合法的变量名： `Abc`、`__abc__`、`_123`。
    - 但这些是不合法的变量名：`3abc`、`ab$`。
  - 其实这个规则不仅适用于变量名，也适用于所有可以由程序员起名的语法元素，
    - 例如以后要讲的函数名、宏定义、结构体成员名等
    - 在 C 语言中这些统称为 **标识符（Identifier）** 。
  - 另外要注意，表示类型的 `char`、`int`、`float`、`double` 等虽然符合上述规则，但也不能用作标识符。
    - 在 C 语言中有些单词有特殊意义，不允许用作标识符，这些单词称为 **关键字（Keyword）或保留字（Reserved Word）** 。
    - 通常用于编程的文本编辑器都会高亮显示（Highlight）这些关键字，所以只要小心一点通常不会误用作标识符。
  - C99 规定的关键字有：

    ```c
    auto  break  case  char  const  continue  default  do  double
    else  enum  extern  float  for  goto  if  inline  int  long
    register  restrict  return  short  signed  sizeof  static  struct  switch  typedef
    union  unsigned  void  volatile  while  _Bool  _Complex  _Imaginary
    ```

- 还有一点要注意， **一般来说应避免使用以下划线开头的标识符**，
  - 以下划线开头的标识符只要不和 C 语言关键字冲突的都是合法的，
  - 但是往往被编译器用作一些功能扩展，
  - C 标准库也定义了很多以下划线开头的标识符，
  - 所以除非你对编译器和 C 标准库特别清楚，一般应避免使用这种标识符，以免造成命名冲突。

- 请记住： **理解一个概念不是把定义背下来就行了，一定要理解它的外延和内涵，也就是什么情况属于这个概念，什么情况不属于这个概念，什么情况虽然属于这个概念但一般推荐的做法（Best Practice）是要尽量避免这种情况，这才算是真正理解了。**

### 1.2.4. 赋值

- 定义了变量之后，我们要把值存到它们所表示的存储空间里，可以用赋值（Assignment）语句实现：

  ```c
  char firstletter;
  int hour, minute;
  firstletter = 'a';   /* give firstletter the value 'a' */
  hour = 11;           /* assign the value 11 to hour */
  minute = 59;         /* set minute to 59 */
  ```

  - 注意变量一定要先声明后使用，编译器必须先看到变量声明，才知道 `firstletter`、`hour` 和 `minute` 是变量名，各自代表一块存储空间。
  - 另外，变量声明中的 **类型表明这个变量代表多大的一块存储空间** ，这样编译器才知道如何读写这块存储空间。
  - 还要注意，这里的等号不表示数学里的相等关系，和 `1+1=2` 的等号是不同的，这里的等号表示赋值。
  - 在数学上不会有 `i=i+1` 这种等式成立，而在 C 语言中表示把变量 `i` 的存储空间中的值取出来，再加上 `1`，得到的结果再存回i的存储空间中。
  - 再比如，在数学上 `a=7` 和 `7=a` 是一样的，而在 C 语言中后者是不合法的。
  - 总结一下：
    - 定义一个变量，就是分配一块存储空间并给它命名；
    - 给一个变量赋值，就是把一个值保存到这块存储空间中。

- 变量的定义和赋值也可以一步完成，这称为 **变量的初始化（Initialization）** ，
  - 例如要达到上面代码的效果也可以这样写：

    ```c
    char firstletter = 'a';
    int hour = 11, minute = 59;
    ```
  - 在初始化语句中，等号右边的值叫做 Initializer，例如上面的 `'a'`、`11` 和 `59`。
  - 注意， **初始化是一种特殊的声明，而不是一种赋值语句** 
  - 就 **目前** 来看，先定义一个变量再给它赋值和定义这个变量的同时给它初始化所达到的效果是一样的，C 语言的很多语法规则既适用于赋值也适用于初始化，
  - 但在以后的学习中你也会了解到它们之间的不同，请在学习过程中注意总结赋值和初始化的相同和不同之处。

- 如果在纸上「跑」一个程序（每个初学编程的人都要练这项基本功），
  - 可以用一个框表示变量的存储空间，在框的外边标上变量名，在框里记上它的值
  - 如下图所示。

    ![在纸上表示变量](./image/expr.variable.png)

  - 你可以用不同形状的框表示不同类型的变量，这样可以提醒你给变量赋的值必须符合它的类型。
  - 如果所赋的值和变量的类型不符会导致编译器报警告或报错（这是一种语义错误），例如：

    ```c
    int hour, minute;
    hour = "Hello.";       /* WRONG ! */
    minute = "59";         /* WRONG !! */
    ```

  - 注意第 3 个语句，把 `"59"` 赋给 `minute` 看起来像是对的，但是类型不对，字符串不能赋给整型变量。
  - 既然可以为变量的存储空间赋值，就应该可以把值取出来用，现在我们取出这些变量的值用 `printf` 打印：

    ```c
    printf("Current time is %d:%d", hour, minute);
    ```
  - 变量名用在等号左边表示赋值，而用在 `printf` 中表示把它的存储空间中的值取出来替换在那里。
    - 不同类型的变量所占的存储空间大小是不同的，数据表示方式也不同，变量的最小存储单位是字节（Byte），
    - 在 C 语言中 `char` 型变量占一个字节，其它类型的变量占多少字节在不同平台上有不同的规定，
    - 将在[「数据类型详解」]()详细讨论。

### 1.2.5. 表达式

#### 1.2.5.1. 表达式与运算符

- 表达式：
  - 常量和变量都可以参与加减乘除运算，
  - 例如 `1+1`、`hour-1`、`hour * 60 + minute`、`minute/60` 等。
  - 这里的 `+ - * /` 称为 **运算符（Operator）** ，而参与运算的常量和变量称为 **操作数（Operand）** ，
  - 上面四个由运算符和操作数所组成的算式称为 **表达式（Expression）** 。

- 运算优先级：
  - 和数学上规定的一样，`hour * 60 + minute` 这个表达式应该先算乘再算加，
  - 也就是说运算符是有优先级（Precedence）的，
  - `*` 和 `/` 是同一优先级，`+` 和 `-`是同一优先级，`*` 和 `/` 的优先级高于 `+` 和 `-`。
  - 对于同一优先级的运算从左到右计算，如果不希望按默认的优先级计算则要加 `()` 括号（Parenthesis）。
    - 例如 `(3+4)*5/6` 应先算 `3+4`，再算 `*5`，再算 `/6`。

- 前面讲过打印语句和赋值语句，现在我们定义：在任意表达式后面加个 `;` 号也是一种语句，称为表达式语句。
  - 例如：

    ```c
    hour * 60 + minute;
    ```
  - 这是个合法的语句，但这个语句在程序中起不到任何作用，把 `hour` 的值和 `minute` 的值取出来加乘，得到的计算结果却没有保存，白算了一通。
  - 再比如：

    ```c
    int total_minute;
    total_minute = hour * 60 + minute;
    ```

    - 这个语句就很有意义，把计算结果保存在另一个变量 `total_minute` 里。
    - 事实上 `=` 也是一种运算符，称为赋值运算符，赋值语句就是一种表达式语句，
    - `=` 的优先级比 `+` 和 `*` 都低，所以先算出 `=` 右边的结果然后才做赋值操作，
    - 整个表达式 `total_minute = hour * 60 + minute` 加个 `;` 构成一个语句。

- **任何表达式都有值和类型两个基本属性**。
  - `hour * 60 + minute` 的值是由三个 `int` 型的操作数计算出来的，所以这个表达式的类型也是 `int` 型。
  - 同理，表达式 `total_minute = hour * 60 + minute` 的类型也是 `int`，它的值是多少呢？
  - C 语言规定 *`=` 运算符的计算结果就是 `=` 左边被赋予的那个值* ，所以这个表达式的值和 `hour * 60 + minute` 的值相同，也和 `total_minute` 的值相同。

- 运算符的结合性：
  - `=` 运算符还有一个和 `+ - * /` 不同的特性，
  - 如果一个表达式中出现多个等号，不是从左到右计算而是 **从右到左计算** ，例如：

  ```c
  int total_minute, total;
  total = total_minute = hour * 60 + minute;
  ```
  - 计算顺序是先算 `hour * 60 + minute` 得到一个结果，然后算右边的等号，就是把 `hour * 60 + minute` 的结果赋给变量 `total_minute`，
  - 这个结果同时也是整个表达式 `total_minute = hour * 60 + minute` 的值，
  - 再算左边的 `=`，即把这个值再赋给变量 `total`。
  - 同样优先级的运算符是从左到右计算还是从右到左计算称为 **运算符的结合性（Associativity）** 。
  - `+ - * /` 是左结合的，`=` 是右结合的。

#### 1.2.5.2. 语法规则

- 现在我们总结一下到目前为止学过的语法规则：

  ```
  表达式 → 标识符
  表达式 → 常量
  表达式 → 字符串字面值
  表达式 → (表达式)
  表达式 → 表达式 + 表达式
  表达式 → 表达式 - 表达式
  表达式 → 表达式 * 表达式
  表达式 → 表达式 / 表达式
  表达式 → 表达式 = 表达式
  语句 → 表达式;
  语句 → printf(表达式, 表达式, 表达式, ...);
  变量声明 → 类型 标识符 = Initializer, 标识符 = Initializer, ...;
  （= Initializer 的部分可以不写）
  ```

  - 注意， **本书所列的语法规则都是简化过的，是不准确的，目的是为了便于初学者理解** 
  - 比如上面所列的语法规则并没有描述运算符的优先级和结合性。完整的 C 语法规则请参考 *C99 Annex A*。
  - 表达式可以是单个的常量或变量，也可以是根据以上规则组合而成的更复杂的表达式。
  - 以前我们用 `printf` 打印常量或变量的值，现在可以用 `printf` 打印更复杂的表达式的值，例如：

    ```c
    printf("%d:%d is %d minutes after 00:00\n", hour, minute, hour * 60 + minute);
    ```
  - 编译器在翻译这条语句时，首先根据上述语法规则把这个语句解析成下图所示的语法树，然后再根据语法树生成相应的指令。
  - 语法树的末端的是一个个 Token，每一步展开利用一条语法规则。

    ![语法树](./image/expr.parse.png)

  - 根据这些语法规则进一步组合可以写出更复杂的语句，比如在一条语句中完成计算、赋值和打印功能：

    ```c
    printf("%d:%d is %d minutes after 00:00\n", hour, minute, total_minute = hour * 60 + minute);
    ```

  - 理解组合（Composition）规则是理解语法规则的关键所在，
    - 正因为可以根据语法规则任意组合，
    - 才可以用简单的常量、变量、表达式、语句搭建出任意复杂的程序，
    - 不过从上面的例子可以看出，表达式不宜过度组合，否则会给阅读和调试带来困难。

- 根据语法规则组合出来的表达式在语义上并不总是正确的，例如：

  ```c
  minute + 1 = hour;
  ```

  - `=` 左边的表达式要求表示一个存储位置而不是一个值，
  - 这是 `=` 运算符和 `+ - * /` 运算符的又一个显著不同。
  - 有的表达式既可以表示一个存储位置也可以表示一个值，而有的表达式只能表示值，不能表示存储位置
    - 例如 `minute + 1` 这个表达式就不能表示存储位置，放在 `=` 左边是语义错误。
    - 表达式所表示的存储位置称为左值（lvalue）（允许放在 `=` 左边），而以前我们所说的表达式的值也称为右值（rvalue）（只能放在 `=` 右边）。
    - 上面的话换一种说法就是： **有的表达式既可以做左值也可以做右值，而有的表达式只能做右值** 
    - 目前我们学过的表达式中只有变量可以做左值，可以做左值的表达式还有几种，以后会讲到。

- 我们看一个有意思的例子，
  - 如果定义三个变量 `int a, b, c;`，表达式 `a = b = c` 是合法的，先求 `b = c` 的值，再把这个值赋给 `a`，
  - 而表达式 `(a = b) = c` 是不合法的，先求 `(a = b)` 的值没问题，但 `(a = b)` 这个表达式不能再做左值了，
  - 因此放在 `= c` 的 `=` 左边是错的。

#### 1.2.5.3. 整数除法的取整

- 关于整数除法运算有一点特殊之处：

  ```c
  hour = 11;
  minute = 59;
  printf("%d and %d hours\n", hour, minute / 60);
  ```
  - 执行结果是 `11 and 0 hours`，也就是说 `59/60` 得 `0`，这是因为两个 `int` 型操作数相除的表达式仍为 `int` 型，
  - 只能保存计算结果的整数部分，即使小数部分是 `0.98` 也要舍去。
  - 向下取整的运算称为 `Floor` ，用数学符号 `⌊ ⌋` 表示；向上取整的运算称为 `Ceiling`，用数学符号 `⌈ ⌉` 表示。例如：

    ```
    ⌊ 59 / 60⌋ =  0
    ⌈ 59 / 60⌉ =  1
    ⌊-59 / 60⌋ = -1
    ⌈-59 / 60⌉ =  0
    ```

  - 在 C 语言中整数除法取的既不是 `Floor` 也不是 `Ceiling`，
  - 无论操作数是正是负总是把小数部分截掉，在数轴上向零的方向取整（Truncate toward Zero），
  - 或者说当操作数为正的时候相当于 `Floor`，当操作符为负的时候相当于 `Ceiling`。
  - 回到先前的例子，要得到更精确的结果可以这样：

    ```c
    printf("%d hours and %d percent of an hour\n", hour, minute * 100 / 60);
    printf("%d and %f hours\n", hour, minute / 60.0);
    ```

  - 在第二个 `printf` 中，表达式是 `minute / 60.0`，`60.0` 是 `double` 型的，
    - `/` 运算符要求左右两边的操作数类型一致，而现在并不一致。
    - C 语言规定了一套 **隐式类型转换规则** ，
    - 在这里编译器自动把左边的 `minute` 也转成 `double` 型来计算，整个表达式的值也是 `double` 型的，
    - 在格式化字符串中应该用 `%f` 转换说明与之对应。
    - 本来编程语言作为一种形式语言要求有简单而严格的规则，自动类型转换规则不仅很复杂，而且使 C 语言的形式看起来也不那么严格了，
    - C 语言这么设计是为了书写程序简便而做的折衷，有些事情编译器可以自动做好，程序员就不必每次都写一堆繁琐的转换代码。
    - 然而 C 语言的类型转换规则非常难掌握，本书的前几章会尽量避免类型转换，
    - 到[「数据类型详解」-「类型转换」](2-C-语言本质/ch15-数据类型详解#_3-类型转换)再集中解决这个问题。

### 1.2.6. 字符类型与字符编码

- 引入：
  - 字符常量或字符型变量也可以当作整数参与运算，例如：

  ```c
  printf("%c\n", 'a'+1);
  ```

  - 执行结果是 `b`。

- 字符编码：
  - 符号在计算机内部也用数字表示，每个字符在计算机内部用一个整数表示，称为字符编码（Character Encoding）
  - 目前最常用的是 ASCII 码（American Standard Code for Information Interchange，美国信息交换标准码），

    ![](./image/ASCII.gif) 

  - 表中每一栏的最后一列是字符，前三列分别是用十进制（Dec）、十六进制（Hex）和八进制（Oct）表示的字符编码，
  - 各种进制之间的换算将在[「计算机中数的表示」-「不同进制之间的换算」](2-C-语言本质/ch14-计算机中数的表示#_2-不同进制之间的换算)介绍。
  - 从十进制那一列可以看出 ASCII 码的取值范围是 0 ~ 127 。
  - 表中的很多字符是不可见字符（Non-printable Character）或空白字符（Whitespace），不能像字母 `a` 这样把字符本身填在表中，而是用一个名字来描述该字符
    - 例如 `CR` (carriage return)、`LF` (NL line feed，newline)、`DEL` 等等
  - 作为练习，请读者查一查[表 2.1 「C标准规定的转义字符」](#c2-1)中的字符在 ASCII 码表中的什么位置。

  > 空白字符在不同的上下文中有不同的含义，
  > 在 C 语言中空白字符定义为空格、水平 `Tab`、垂直 `Tab`、换行和分页符，
  > 本书在使用「空白字符」这个词时会明确说明在当前上下文中空白字符指的是哪些字符。

- 回到刚才的例子，
  - 在 ASCII 码中字符 `a` 是 `97`，字符 `b` 是 `98`。计算 `'a'+1` 这个表达式，
  - 应该按 ASCII 码把 `'a'` 当作整数值 `97`，然后加 `1`，得到 `98`，然后 `printf` 把 `98` 这个整数值当作 ASCII 码来解释，打印出相应的字符 `b`。
  - 之前我们说「整型」是指 `int` 型，而现在我们知道 `char` 型本质上就是整数，只不过取值范围比 `int` 型小，
  - 所以以后我们把 `char` 型和 `int` 型统称为 **整数类型（Integer Type）或简称整型** ，
  - 以后我们还要学习几种类型也属于整型，将在[「数据类型详解」]()详细介绍。
  - 字符 `'a'` ~ `'z'`、`'A' `~ `'Z'`、`'0'` ~ `'9'`的 ASCII 码都是连续的，
    - 因此表达式 `'a'+25` 和 `'z'` 的值相等，`'0'+9` 和 `'9'` 的值也相等。
    - 注意 `'0'` ~ `'9'`的 ASCII 码是十六进制的 `30` ~ `39`，和整数值 0 ~ 9 是不相等的。

- 字符也可以用 ASCII 码转义序列表示，
  - 说明
    - 这种转义序列由 \ 加上 1 ~ 3 个八进制数字组成，
    - 或者由 \x 或 \X 加上 1 ~ 2 个十六进制数字组成，
    - 可以用在字符常量或字符串字面值中。
  - 例如
    - '\0' 表示 NUL 字符（Null Character），'\11' 或 '\x9' 表示 Tab 字符
    - "\11" 或 "\x9" 表示由 Tab 字符组成的字符串。
    - 注意 '0' 的 ASCII 码是 48，而 '\0'的 ASCII 码是 0，两者是不同的。

## 1.3. 简单函数

### 1.3.1. 数学函数

在数学中我们用过 sin 和 ln 这样的函数，例如 sin(π/2)=1，ln1=0 等等，在 C 语言中也可以使用这些函数（ln 函数在 C 标准库中叫做 `log`）：

<p id="e3-1">例 3.1. 在 C 语言中使用数学函数</p>

```c
  #include <math.h>
  #include <stdio.h>
  
  int main(void)
  {
  	double pi = 3.1416;
  	printf("sin(pi/2)=%f\nln1=%f\n", sin(pi/2), log(1.0));
  	return 0;
  }
```

编译运行这个程序，结果如下：

```bash
$ gcc main.c -lm
$ ./a.out
sin(pi/2)=1.000000
ln1=0.000000
```

在数学中写一个函数有时候可以省略括号，而 C 语言要求一定要加上括号，例如 `log(1.0)`。在 C 语言的术语中，`1.0` 是参数（Argument），`log` 是函数（Function），`log(1.0)` 是函数调用（Function Call）。`sin(pi/2)` 和 `log(1.0)` 这两个函数调用在我们的 `printf` 语句中处于什么位置呢？在上一章讲过，这应该是写表达式的位置。因此**函数调用也是一种表达式**，这个表达式由函数调用运算符（即 `(` `)` 括号）和两个操作数组成，操作数 `log` 是一个函数名（Function Designator），它的类型是一种函数类型（Function Type），操作数 `1.0` 是 `double` 型的。`log(1.0)` 这个表达式的值就是对数运算的结果，也是 `double` 型的，在 C 语言中函数调用表达式的值称为**函数的返回值（Return Value）**。总结一下我们新学的语法规则：

```
表达式 → 函数名
表达式 → 表达式(参数列表)
参数列表 → 表达式, 表达式, ...
```

现在我们可以完全理解 `printf` 语句了：原来 `printf` 也是一个函数，上例中的 `printf("sin(pi/2)=%f\nln1=%f\n", sin(pi/2), log(1.0))` 是带三个参数的函数调用，而函数调用也是一种表达式，因此 `printf` 语句也是表达式语句的一种。但是 `printf` 感觉不像一个数学函数，为什么呢？因为像 `log` 这种函数，我们传进去一个参数会得到一个返回值，我们调用 `log` 函数就是为了得到它的返回值，至于 `printf`，我们并不关心它的返回值（事实上它也有返回值，表示实际打印的字符数），我们调用 `printf` 不是为了得到它的返回值，而是为了利用它所产生的副作用（Side Effect）——打印。**C 语言的函数可以有 Side Effect，这一点是它和数学函数在概念上的根本区别**。

Side Effect 这个概念也适用于运算符组成的表达式。比如 `a + b` 这个表达式也可以看成一个函数调用，把运算符 `+` 看作函数，它的两个参数是 `a` 和 `b`，返回值是两个参数的和，传入两个参数，得到一个返回值，并没有产生任何 Side Effect。而赋值运算符是有 Side Effect 的，如果把 `a = b` 这个表达式看成函数调用，返回值就是所赋的值，既是 `b` 的值也是 `a` 的值，但除此之外还产生了 Side Effect，就是变量 `a` 被改变了， **改变计算机存储单元里的数据或者做输入输出操作都算 Side Effect** 。

回想一下我们的学习过程，一开始我们说赋值是一种语句，后来学了表达式，我们说赋值语句是表达式语句的一种；一开始我们说 `printf` 是一种语句，现在学了函数，我们又说 `printf` 也是表达式语句的一种。随着我们一步步的学习，把原来看似不同类型的语句统一成一种语句了。学习的过程总是这样，初学者一开始接触的很多概念从严格意义上说是错的，但是很容易理解，随着一步步学习，在理解原有概念的基础上不断纠正，不断泛化（Generalize）。比如一年级老师说小数不能减大数，其实这个概念是错的，后来引入了负数就可以减了，后来引入了分数，原来的正数和负数的概念就泛化为整数，上初中学了无理数，原来的整数和分数的概念就泛化为有理数，再上高中学了复数，有理数和无理数的概念就泛化为实数。坦白说，到目前为止本书的很多说法都是不完全正确的，但这是学习理解的必经阶段，到后面的章节都会逐步纠正的。

程序第一行的 `#` 号（Pound Sign，Number Sign 或 Hash Sign）和 `include` 表示包含一个头文件（Header File），后面尖括号（Angel Bracket）中就是文件名（这些头文件通常位于 /usr/include 目录下）。头文件中声明了我们程序中使用的库函数，根据先声明后使用的原则，要使用 `printf` 函数必须包含 `stdio.h`，要使用数学函数必须包含 `math.h`，如果什么库函数都不使用就不必包含任何头文件，例如写一个程序 `int main(void){int a;a=2;return 0;}`，不需要包含头文件就可以编译通过，当然这个程序什么也做不了。

使用 `math.h` 中声明的库函数还有一点特殊之处，`gcc` 命令行必须加 `-lm` 选项，因为数学函数位于 `libm.so` 库文件中（这些库文件通常位于 /lib 目录下），`-lm` 选项告诉编译器，我们程序中用到的数学函数要到这个库文件里找。本书用到的大部分库函数（例如 `printf`）位于 `libc.so` 库文件中，使用 `libc.so` 中的库函数在编译时不需要加 `-lc`选项，当然加了也不算错，因为这个选项是`gcc` 的默认选项。关于头文件和库函数目前理解这么多就可以了，到[第 20 章「链接详解」](2-C-语言本质/ch20-链接详解)再详细解释。

> **C 标准库和 glibc**
> 
> C 标准主要由两部分组成，一部分描述 C 的语法，另一部分描述 C 标准库。C 标准库定义了一组标准头文件，每个头文件中包含一些相关的函数、变量、类型声明和宏定义。要在一个平台上支持 C 语言，不仅要实现 C 编译器，还要实现 C 标准库，这样的实现才算符合 C 标准。不符合 C 标准的实现也是存在的，例如很多单片机的 C 语言开发工具中只有 C 编译器而没有完整的 C 标准库。
> 
> 在 Linux 平台上最广泛使用的 C 函数库是 glibc，其中包括 C 标准库的实现，也包括本书第三部分介绍的所有系统函数。几乎所有 C 程序都要调用 glibc 的库函数，所以 glibc 是 Linux 平台 C 程序运行的基础。glibc 提供一组头文件和一组库文件，最基本、最常用的 C 标准库函数和系统函数在 libc.so 库文件中，几乎所有 C 程序的运行都依赖于 libc.so，有些做数学计算的 C 程序依赖于 libm.so，以后我们还会看到多线程的 C 程序依赖于 libpthread.so。以后我说 libc 时专指 libc.so 这个库文件，而说 glibc 时指的是 glibc 提供的所有库文件。
> 
> glibc 并不是 Linux 平台唯一的基础 C 函数库，也有人在开发别的 C 函数库，比如适用于嵌入式系统的 uClibc。

### 1.3.2. 自定义函数

我们不仅可以调用 C 标准库提供的函数，也可以定义自己的函数，事实上我们已经这么做了：我们定义了 `main` 函数。例如：

```c
int main(void)
{
	int hour = 11;
	int minute = 59;
	printf("%d and %d hours\n", hour, minute / 60);
	return 0;
}
```

`main` 函数的特殊之处在于执行程序时它自动被操作系统调用，操作系统就认准了 `main` 这个名字，除了名字特殊之外，`main` 函数和别的函数没有区别。我们对照着 `main` 函数的定义来看语法规则：

```
函数定义 → 返回值类型 函数名(参数列表) 函数体
函数体 → { 语句列表 }
语句列表 → 语句列表项 语句列表项 ...
语句列表项 → 语句
语句列表项 → 变量声明、类型声明或非定义的函数声明
非定义的函数声明 → 返回值类型 函数名(参数列表);
```

我们稍后再详细解释「函数定义」和「非定义的函数声明」的区别。从[第 7 章「结构体」](1-C-语言入门/ch07-结构体)开始我们才会看到类型声明，所以现在暂不讨论。

给函数命名也要遵循上一章讲过的标识符命名规则。由于我们定义的 `main` 函数不带任何参数，参数列表应写成 `void`。函数体可以由若干条语句和声明组成，C89 要求所有声明写在所有语句之前（本书的示例代码都遵循这一规定），而 C99 的新特性允许语句和声明按任意顺序排列，只要每个标识符都遵循先声明后使用的原则就行。`main` 函数的返回值是 `int` 型的，`return 0;` 这个语句表示返回值是 `0`，`main` 函数的返回值是返回给操作系统看的，因为 `main` 函数是被操作系统调用的，通常程序执行成功就返回 `0`，在执行过程中出错就返回一个非零值。比如我们将 `main` 函数中的 `return` 语句改为 `return 4;` 再执行它，执行结束后可以在 Shell 中看到它的退出状态（Exit Status）：

```bash
$ ./a.out 
11 and 0 hours
$ echo $?
4
```

`$?` 是 Shell 中的一个特殊变量，表示上一条命令的退出状态。关于 `main` 函数需要注意两点：

1. K&R 书上的 `main` 函数定义写成 `main(){...}` 的形式，不写返回值类型也不写参数列表，这是 Old Style C 的风格。Old Style C 规定不写返回值类型就表示返回 `int` 型，不写参数列表就表示参数类型和个数没有明确指出。这种宽松的规定使编译器无法检查程序中可能存在的 Bug，增加了调试难度，不幸的是现在的 C 标准为了兼容旧的代码仍然保留了这种语法，但读者绝不应该继续使用这种语法。
2. 其实操作系统在调用 `main` 函数时是传参数的，`main` 函数最标准的形式应该是 `int main(int argc, char *argv[])`，在[第 23 章「指针」第 6 节「指向指针的指针与指针数组」](2-C-语言本质/ch23-指针#_6-指向指针的指针与指针数组)详细介绍。C 标准也允许 `int main(void)` 这种写法，如果不使用系统传进来的两个参数也可以写成这种形式。但除了这两种形式之外，定义 `main` 函数的其它写法都是错误的或不可移植的。

关于返回值和 `return` 语句我们将在[第 5 章「深入理解函数」第 1 节「return 语句」](1-C-语言入门/ch05-深入理解函数#_1-return-语句)详细讨论，我们先从不带参数也没有返回值的函数开始学习定义和使用函数：

<p id="e3-2">例 3.2. 最简单的自定义函数</p>

```c
  #include <stdio.h>
  
  void newline(void)
  {
  	printf("\n");
  }
  
  int main(void)
  {
  	printf("First Line.\n");
  	newline();
  	printf("Second Line.\n");
  	return 0;
  }
```

执行结果是：

```bash
First Line.

Second Line.
```

我们定义了一个 `newline` 函数给 `main` 函数调用，它的作用是打印一个换行，所以执行结果中间多了一个空行。`newline` 函数不仅不带参数，也没有返回值，返回值类型为 `void` 表示没有返回值<sup>[4]</sup>，这说明我们调用这个函数完全是为了利用它的 Side Effect。如果我们想要多次插入空行就可以多次调用 `newline`函数：

> <sup>[4]</sup> 敏锐的读者可能会发现一个矛盾：如果函数 `newline` 没有返回值，那么表达式 `newline()` 不就没有值了吗？然而上一章讲过任何表达式都有值和类型两个基本属性。其实这正是设计 `void` 这么一个关键字的原因：首先从语法上规定没有返回值的函数调用表达式有一个 `void` 类型的值，这样任何表达式都有值，不必考虑特殊情况，编译器的语法解析比较容易实现；然后从语义上规定 `void` 类型的表达式不能参与运算，因此 `newline() + 1` 这样的表达式不能通过语义检查，从而兼顾了语法上的一致和语义上的不矛盾。

```c
int main(void)
{
	printf("First Line.\n");
	newline();
	newline();
	newline();
	printf("Second Line.\n");
	return 0;
}
```

如果我们总需要三个三个地插入空行，我们可以再定义一个 `threeline` 函数每次插入三个空行：

<p id="e3-3">例 3.3. 较简单的自定义函数</p>

```c
  #include <stdio.h>
  
  void newline(void)
  {
  	printf("\n");
  }
  
  void threeline(void)
  {
  	newline();
  	newline();
  	newline();
  }
  
  int main(void)
  {
  	printf("Three lines:\n");
  	threeline();
  	printf("Another three lines.\n");
  	threeline();
  	return 0;
  }
```

通过这个简单的例子可以体会到：

1. 同一个函数可以被多次调用。
2. 可以用一个函数调用另一个函数，后者再去调第三个函数。
3. 通过自定义函数可以给一组复杂的操作起一个简单的名字，例如 `threeline`。对于 `main` 函数来说，只需要通过 `threeline` 这个简单的名字来调用就行了，不必知道打印三个空行具体怎么做，所有的复杂操作都被隐藏在 `threeline` 这个名字后面。
4. 使用自定义函数可以使代码更简洁，`main` 函数在任何地方想打印三个空行只需调用一个简单的 `threeline()`，而不必每次都写三个 `printf("\n")`。

读代码和读文章不一样，按从上到下从左到右的顺序读代码未必是最好的。比如上面的例子，按源文件的顺序应该是先看 `newline` 再看 `threeline` 再看 `main`。如果你换一个角度，按代码的执行顺序来读也许会更好：首先执行的是 `main` 函数中的语句，在一条 `printf` 之后调用了 `threeline`，这时再去看 `threeline` 的定义，其中又调用了 `newline`，这时再去看 `newline` 的定义，`newline` 里面有一条 `printf`，执行完成后返回 `threeline`，这里还剩下两次 `newline` 调用，效果也都一样，执行完之后返回 `main`，接下来又是一条 `printf` 和一条 `threeline`。如下图所示：

<p id="c3-1">图 3.1. 函数调用的执行顺序</p>

![函数调用的执行顺序](./image/func.funccall.png)

读代码的过程就是模仿计算机执行程序的过程，我们不仅要记住当前读到了哪一行代码，还要记住现在读的代码是被哪个函数调用的，这段代码返回后应该从上一个函数的什么地方接着往下读。

现在澄清一下函数声明、函数定义、函数原型（Prototype）这几个概念。比如 `void threeline(void)` 这一行，声明了一个函数的名字、参数类型和个数、返回值类型，这称为函数原型。在代码中可以单独写一个函数原型，后面加 `;` 号结束，而不写函数体，例如：

```c
void threeline(void);
```

这种写法只能叫函数声明而不能叫函数定义，只有带函数体的声明才叫定义。上一章讲过，只有分配存储空间的变量声明才叫变量定义，其实函数也是一样，编译器只有见到函数定义才会生成指令，而指令在程序运行时当然也要占存储空间。那么没有函数体的函数声明有什么用呢？它为编译器提供了有用的信息，编译器在翻译代码的过程中，只有见到函数原型（不管带不带函数体）之后才知道这个函数的名字、参数类型和返回值，这样碰到函数调用时才知道怎么生成相应的指令，所以函数原型必须出现在函数调用之前，这也是遵循「先声明后使用」的原则。

在上面的例子中，`main` 调用 `threeline`，`threeline` 再调用 `newline`，要保证每个函数的原型出现在调用之前，就只能按先 `newline` 再 `threeline` 再 `main` 的顺序定义了。如果使用不带函数体的声明，则可以改变函数的定义顺序：

```c
  #include <stdio.h>
  
  void newline(void);
  void threeline(void);
  
  int main(void)
  {
  	...
  }
  
  void newline(void)
  {
  	...
  }
  
  void threeline(void)
  {
  	...
  }
```

这样仍然遵循了先声明后使用的原则。

由于有 Old Style C 语法的存在，并非所有函数声明都包含完整的函数原型，例如 `void threeline();` 这个声明并没有明确指出参数类型和个数，所以不算函数原型，这个声明提供给编译器的信息只有函数名和返回值类型。如果在这样的声明之后调用函数，编译器不知道参数的类型和个数，就不会做语法检查，所以很容易引入 Bug。读者需要了解这个知识点以便维护别人用 Old Style C 风格写的代码，但绝不应该按这种风格写新的代码。

如果在调用函数之前没有声明会怎么样呢？有的读者也许碰到过这种情况，我可以解释一下，但绝不推荐这种写法。比如按上面的顺序定义这三个函数，但是把开头的两行声明去掉：

```c
  #include <stdio.h>
  
  int main(void)
  {
  	printf("Three lines:\n");
  	threeline();
  	printf("Another three lines.\n");
  	threeline();
  	return 0;
  }
  
  void newline(void)
  {
  	printf("\n");
  }
  
  void threeline(void)
  {
  	newline();
  	newline();
  	newline();
  }
```

编译时会报警告：

```bash
$ gcc main.c
main.c:17: warning: conflicting types for ‘threeline’
main.c:6: warning: previous implicit declaration of ‘threeline’ was here
```

但仍然能编译通过，运行结果也对。这里涉及到的规则称为函数的隐式声明（Implicit Declaration），在 `main` 函数中调用 `threeline` 时并没有声明它，编译器认为此处 **隐式声明** 了 `int threeline(void);`， **隐式声明的函数返回值类型都是 `int`** ，由于我们调用这个函数时没有传任何参数，所以编译器认为这个隐式声明的参数类型是 `void`，这样函数的参数和返回值类型都确定下来了，编译器根据这些信息为函数调用生成相应的指令。然后编译器接着往下看，看到 `threeline` 函数的原型是 `void threeline(void)`，和先前的隐式声明的返回值类型不符，所以报警告。好在我们也没用到这个函数的返回值，所以执行结果仍然正确。

### 1.3.3. 形参和实参

下面我们定义一个带参数的函数，我们需要在函数定义中指明参数的个数和每个参数的类型，定义参数就像定义变量一样，需要为每个参数指明类型，参数的命名也要遵循标识符命名规则。例如：

<p id="e3-4">例 3.4. 带参数的自定义函数</p>

```c
  #include <stdio.h>
  
  void print_time(int hour, int minute)
  {
  	printf("%d:%d\n", hour, minute);
  }
  
  int main(void)
  {
  	print_time(23, 59);
  	return 0;
  }
```

需要注意的是，定义变量时可以把相同类型的变量列在一起，而定义参数却不可以，例如下面这样的定义是错的：

```c
void print_time(int hour, minute)
{
	printf("%d:%d\n", hour, minute);
}
```

学习 C 语言的人肯定都乐意看到这句话：「变量是这样定义的，参数也是这样定义的，一模一样」，这意味着不用专门去记住参数应该怎么定义了。谁也不愿意看到这句话：「定义变量可以这样写，而定义参数却不可以」。C 语言的设计者也不希望自己设计的语法规则里到处都是例外，一个容易被用户接受的设计应该遵循**最少例外原则**（Rule of Least Surprise）。其实关于参数的这条规定也不算十分例外，也是可以理解的，请读者想想为什么要这么规定。学习编程语言不应该死记各种语法规定，如果能够想清楚设计者这么规定的原因（Rationale），不仅有助于记忆，而且会有更多收获。本书在必要的地方会解释一些 Rationale，或者启发读者自己去思考，例如上一节在脚注中解释了`void`关键字的 Rationale。*C99 Rationale* 是随 C99 标准一起发布的，值得参考。

总的来说，C 语言的设计是非常优美的，只要理解了少数基本概念和基本原则就可以根据组合规则写出任意复杂的程序，很少有例外的规定说这样组合是不允许的，或者那样类推是错误的。相反，C++ 的设计就非常复杂，充满了例外，全世界没几个人能把 C++ 的所有规则都牢记于心，因而 C++ 的设计一直饱受争议，这个观点在 *UNIX 编程艺术* 中有详细阐述。

在本书中，凡是提醒读者注意的地方都是多少有些 Surprise 的地方，初学者如果按常理来想很可能要想错，所以需要特别提醒一下。而初学者容易犯的另外一些错误，完全是因为没有掌握好基本概念和基本原理，或者根本无视组合规则而全凭自己主观臆断所致，对这一类问题本书不会做特别的提醒，例如有的初学者看完[第 2 章「常量、变量和表达式」](1-C-语言入门/ch02-常量、变量和表达式)之后会这样打印 π 的值：

```c
double pi=3.1416;
printf("pi\n");
```

之所以会犯这种错误，一是不理解 Literal 的含义，二是自己想当然地把变量名组合到字符串里去，而事实上根本没有这条语法规则。如果连这样的错误都需要在书上专门提醒，就好比提醒小孩吃饭一定要吃到嘴里，不要吃到鼻子里，更不要吃到耳朵里一样。

回到正题。我们调用 `print_time(23, 59)` 时，函数中的参数 `hour` 就代表 `23`，参数 `minute`就代表 `59`。确切地说，当我们讨论函数中的 `hour` 这个参数时，我们所说的「参数」是指形参（Parameter），当我们讨论传一个参数 `23` 给函数时，我们所说的「参数」是指实参（Argument），但我习惯都叫参数而不习惯总把形参、实参这两个文绉绉的词挂在嘴边（事实上大多数人都不习惯），读者可以根据上下文判断我说的到底是形参还是实参。记住这条基本原理： **形参相当于函数中定义的变量，调用函数传递参数的过程相当于定义形参变量并且用实参的值来初始化** 。例如这样调用：

```c
void print_time(int hour, int minute)
{
	printf("%d:%d\n", hour, minute);
}

int main(void)
{
	int h = 23, m = 59;
	print_time(h, m);
	return 0;
}
```

相当于在函数 `print_time` 中执行了这样一些语句：

```c
int hour = h;
int minute = m;
printf("%d:%d\n", hour, minute);
```

`main` 函数的变量 `h` 和 `print_time` 函数的参数 `hour` 是两个不同的变量，只不过它们的存储空间中都保存了相同的值 `23`，因为变量 `h` 的值赋给了参数 `hour`。同理，变量 `m` 的值赋给了参数 `minute`。C 语言的这种传递参数的方式称为 Call by Value。在调用函数时，每个参数都需要得到一个值，函数定义中有几个形参，在调用时就要传几个实参，不能多也不能少，每个参数的类型也必须对应上。

肯定有读者注意到了，为什么我们每次调用 `printf` 传的实参个数都不一样呢？因为 C 语言规定了一种特殊的参数列表格式，用命令 `man 3 printf` 可以查看到 `printf` 函数的原型：

```c
int printf(const char *format, ...);
```

第一个参数是 `const char *` 类型的，后面的 `...` 可以代表 0 个或任意多个参数，这些参数的类型也是不确定的，这称为可变参数（Variable Argument），[第 24 章「函数接口」第 6 节「可变参数」](2-C-语言本质/ch24-函数接口#_6-可变参数)将会详细讨论这种格式。总之，每个函数的原型都明确规定了返回值类型以及参数的类型和个数，即使像 `printf` 这样规定为「不确定」也是一种明确的规定，调用函数时要严格遵守这些规定，有时候我们把函数叫做**接口**（Interface），调用函数就是使用这个接口，使用接口的前提是必须和接口保持一致。

> **Man Page**
> 
> Man Page 是 Linux 开发最常用的参考手册，由很多页面组成，每个页面描述一个主题，这些页面被组织成若干个 Section。FHS（Filesystem Hierarchy Standard）标准规定了 Man Page 各 Section 的含义如下：
> 
> <p id="t3-1">表 3.1. Man Page 的 Section</p>
> 
> | Section | 描述                                                         |
> | ------- | ------------------------------------------------------------ |
> | 1       | 用户命令，例如 `ls(1)`                                         |
> | 2       | 系统调用，例如 `_exit(2)`                                      |
> | 3       | 库函数，例如 `printf(3)`                                       |
> | 4       | 特殊文件，例如 `null(4)` 描述了设备文件 /dev/null、/dev/zero 的作用 |
> | 5       | 系统配置文件的格式，例如 `passwd(5)` 描述了系统配置文件 /etc/passwd 的格式 |
> | 6       | 游戏                                                         |
> | 7       | 其它杂项，例如 `bash-builtins(7)` 描述了 bash 的各种内建命令   |
> | 8       | 系统管理命令，例如 `ifconfig(8)`                               |
> 
> 注意区分用户命令和系统管理命令，用户命令通常位于 /bin 和 /usr/bin 目录，系统管理命令通常位于 /sbin 和 /usr/sbin 目录，一般用户可以执行用户命令，而执行系统管理命令经常需要 root 权限。系统调用和库函数的区别将在[第 19 章「汇编与 C 之间的关系」第 2 节「main 函数和启动例程」](2-C-语言本质/ch19-汇编与-C-之间的关系#_2-main-函数和启动例程)说明。
> 
> Man Page 中有些页面有重名，比如敲 `man printf` 命令看到的并不是 C 函数 `printf` ，而是位于第 1 个 Section 的系统命令 `printf`，要查看位于第 3 个 Section 的 `printf` 函数应该敲 `man 3 printf`，也可以敲 `man -k printf` 命令搜索哪些页面的主题包含 `printf` 关键字。本书会经常出现类似 `printf(3)` 这样的写法，括号中的 `3` 表示 Man Page 的第 3 个 Section，或者表示「我这里想说的是 `printf` 库函数而不是 `printf` 命令」。

### 1.3.4. 全局变量、局部变量和作用域

我们把函数中定义的变量称为局部变量（Local Variable），由于形参相当于函数中定义的变量，所以形参也是一种局部变量。在这里「局部」有两层含义：

1. **一个函数中定义的变量不能被另一个函数使用**。例如 `print_time` 中的 `hour` 和 `minute` 在 `main` 函数中没有定义，不能使用，同样 `main` 函数中的局部变量也不能被 `print_time` 函数使用。如果这样定义：

```c
void print_time(int hour, int minute)
{
  printf("%d:%d\n", hour, minute);
}

int main(void)
{
  int hour = 23, minute = 59;
  print_time(hour, minute);
  return 0;
}
```
	
`main` 函数中定义了局部变量 `hour`，`print_time` 函数中也有参数 `hour`，虽然它们名称相同，但仍然是两个不同的变量，代表不同的存储单元。`main` 函数的局部变量 `minute` 和 `print_time` 函数的参数 `minute` 也是如此。

2. **每次调用函数时局部变量都表示不同的存储空间**。局部变量在每次函数调用时分配存储空间，在每次函数返回时释放存储空间，例如调用 `print_time(23, 59)` 时分配 `hour` 和 `minute` 两个变量的存储空间，在里面分别存上 `23` 和 `59`，函数返回时释放它们的存储空间，下次再调用 `print_time(12, 20)` 时又分配 `hour` 和 `minute` 的存储空间，在里面分别存上 `12` 和 `20`。

与局部变量的概念相对的是**全局变量**（Global Variable），全局变量定义在所有的函数体之外，它们在程序开始运行时分配存储空间，在程序结束时释放存储空间，在任何函数中都可以访问全局变量，例如：

<p id="e3-5">例 3.5. 全局变量</p>

```c
  #include <stdio.h>
  
  int hour = 23, minute = 59;
  
  void print_time(void)
  {
  	printf("%d:%d in print_time\n", hour, minute);
  }
  
  int main(void)
  {
  	print_time();
  	printf("%d:%d in main\n", hour, minute);
  	return 0;
  }
```

正因为全局变量在任何函数中都可以访问，所以在程序运行过程中全局变量被读写的顺序从源代码中是看不出来的，源代码的书写顺序并不能反映函数的调用顺序。程序出现了 Bug 往往就是因为在某个不起眼的地方对全局变量的读写顺序不正确，如果代码规模很大，这种错误是很难找到的。而对局部变量的访问不仅局限在一个函数内部，而且局限在一次函数调用之中，从函数的源代码很容易看出访问的先后顺序是怎样的，所以比较容易找到 Bug。因此，虽然全局变量用起来很方便，但一定要慎用，能用函数传参代替的就不要用全局变量。

如果全局变量和局部变量重名了会怎么样呢？如果上面的例子改为：

<p id="e3-6">例 3.6. 作用域</p>

![作用域](./image/func.scope.png)

则第一次调用 `print_time` 打印的是全局变量的值，第二次直接调用 `printf` 打印的则是 `main` 函数局部变量的值。在 C 语言中每个标识符都有特定的作用域，全局变量是定义在所有函数体之外的标识符，它的作用域从定义的位置开始直到源文件结束，而 `main` 函数局部变量的作用域仅限于 `main` 函数之中。如上图所示，设想整个源文件是一张大纸，也就是全局变量的作用域，而 `main` 函数是盖在这张大纸上的一张小纸，也就是 `main` 函数局部变量的作用域。在小纸上用到标识符 `hour` 和 `minute` 时应该参考小纸上的定义，因为大纸（全局变量的作用域）被盖住了，如果在小纸上用到某个标识符却没有找到它的定义，那么再去翻看下面的大纸上有没有定义，例如上图中的变量 `x`。

到目前为止我们在初始化一个变量时都是用常量做 Initializer，其实也可以用表达式做 Initializer，但要注意一点： **局部变量可以用类型相符的任意表达式来初始化，而全局变量只能用常量表达式（Constant Expression）初始化** 。例如，全局变量 `pi` 这样初始化是合法的：

```c
double pi = 3.14 + 0.0016;
```

但这样初始化是不合法的：

```c
double pi = acos(-1.0);
```

然而局部变量这样初始化却是可以的。程序开始运行时要用适当的值来初始化全局变量，所以初始值必须保存在编译生成的可执行文件中，因此初始值在**编译时**就要计算出来，然而上面第二种 Initializer 的值必须在程序**运行时**调用 `acos` 函数才能得到，所以不能用来初始化全局变量。请注意区分编译时和运行时这两个概念。为了简化编译器的实现，C 语言从语法上规定全局变量只能用常量表达式来初始化，因此下面这种全局变量初始化是不合法的：

```c
int minute = 360;
int hour = minute / 60;
```

虽然在编译时计算出 `hour` 的初始值是可能的，但是 `minute / 60` 不是常量表达式，不符合语法规定，所以编译器不必想办法去算这个初始值。

如果全局变量在定义时不初始化则初始值是 `0`，如果局部变量在定义时不初始化则初始值是不确定的。所以，**局部变量在使用之前一定要先赋值**，如果基于一个不确定的值做后续计算肯定会引入 Bug。

如何证明「局部变量的存储空间在每次函数调用时分配，在函数返回时释放」？当我们想要确认某些语法规则时，可以查教材，也可以查 C99，但最快捷的办法就是编个小程序验证一下：

<p id="e3-7">例 3.7. 验证局部变量存储空间的分配和释放</p>

```c
  #include <stdio.h>
  
  void foo(void)
  {
  	int i;
  	printf("%d\n", i);
  	i = 777;
  }
  
  int main(void)
  {
  	foo();
  	foo();
  	return 0;
  }
```

第一次调用 `foo` 函数，分配变量 `i` 的存储空间，然后打印 `i` 的值，由于 `i` 未初始化，打印的应该是一个不确定的值，然后把 `i` 赋值为 `777`，函数返回，释放i的存储空间。第二次调用 `foo` 函数，分配变量 `i` 的存储空间，然后打印 `i` 的值，由于 `i` 未初始化，如果打印的又是一个不确定的值，就证明了「局部变量的存储空间在每次函数调用时分配，在函数返回时释放」。分析完了，我们运行程序看看是不是像我们分析的这样：

```bash
134518128
777
```

结果出乎意料，第二次调用打印的 `i` 值正是第一次调用末尾赋给i的值 `777`。有一种初学者是这样，原本就没有把这条语法规则记牢，或者对自己的记忆力没信心，看到这个结果就会想：哦那肯定是我记错了，改过来记吧，应该是「函数中的局部变量具有一直存在的固定的存储空间，每次函数调用时使用它，返回时也不释放，再次调用函数时它应该还能保持上次的值」。还有一种初学者是怀疑论者或不可知论者，看到这个结果就会想：教材上明明说「局部变量的存储空间在每次函数调用时分配，在函数返回时释放」，那一定是教材写错了，教材也是人写的，是人写的就难免出错，哦，连 C99 也这么写的啊，C99 也是人写的，也难免出错，或者 C99 也许没错，但是反正运行结果就是错了，计算机这东西真靠不住，太容易受电磁干扰和宇宙射线影响了，我的程序写得再正确也有可能被干扰得不能正确运行。

这是初学者最常见的两种心态。不从客观事实和逻辑推理出发分析问题的真正原因，而仅凭主观臆断胡乱给问题定性，「说你有罪你就有罪」。先不要胡乱怀疑，我们再做一次实验，在两次 `foo` 函数调用之间插一个别的函数调用，结果就大不相同了：

```c
int main(void)
{
	foo();
	printf("hello\n");
	foo();
	return 0;
}
```

结果是：

```bash
134518200
hello
0
```

这一回，第二次调用 `foo` 打印的i值又不是 `777` 了而是 `0`，「局部变量的存储空间在每次函数调用时分配，在函数返回时释放」这个结论似乎对了，但另一个结论又不对了：全局变量不初始化才是 `0` 啊，不是说「局部变量不初始化则初值不确定」吗？

关键的一点是，我说「初值不确定」，有没有说这个不确定值不能是 `0`？有没有说这个不确定值不能是上次调用赋的值？在这里「不确定」的准确含义是：每次调用这个函数时局部变量的初值可能不一样，运行环境不同，函数的调用次序不同，都会影响到局部变量的初值。在运用逻辑推理时一定要注意，**不要把必要条件（Necessary Condition）当充分条件（Sufficient Condition）**，这一点在 Debug 时尤其重要，看到错误现象不要轻易断定原因是什么，一定要考虑再三，找出它的真正原因。例如，不要看到第二次调用打印 `777` 就下结论「函数中的局部变量具有一直存在的固定的存储空间，每次函数调用时使用它，返回时也不释放，再次调用函数时它应该还能保持上次的值」，这个结论倒是能推出 `777` 这个结果，但反过来由 `777` 这个结果却不能推出这样的结论。所以说 `777` 这个结果是该结论的必要条件，但不是充分条件。也不要看到第二次调用打印 `0` 就断定「局部变量未初始化则初值为 0」，`0` 这个结果是该结论的必要条件，但也不是充分条件。至于为什么会有这些现象，为什么这个不确定的值刚好是 `777`，或者刚好是 `0`，等学到[第 19 章「汇编与 C 之间的关系」例 19.1 「研究函数的调用过程」](2-C-语言本质/ch19-汇编与-C-之间的关系#_e19-1)就能解释这些现象了。

从[本章第 2 节「自定义函数」](#_2-自定义函数)介绍的语法规则可以看出，非定义的函数声明也可以写在局部作用域中，例如：

```c
int main(void)
{
	void print_time(int, int);
	print_time(23, 59);
	return 0;
}
```

这样声明的标识符 `print_time` 具有局部作用域，只在 `main` 函数中是有效的函数名，出了 `main` 函数就不存在 `print_time` 这个标识符了。

写非定义的函数声明时参数可以只写类型而不起名，例如上面代码中的 `void print_time(int, int);`，只要告诉编译器参数类型是什么，编译器就能为 `print_time(23, 59)` 函数调用生成正确的指令。另外注意，虽然在一个函数体中可以声明另一个函数，但不能定义另一个函数， **C 语言不允许嵌套定义函数** <sup>[5]</sup>。

> <sup>[5]</sup> 但  **gcc 的扩展特性允许嵌套定义函数** ，本书不做详细讨论。

## 1.4. 分支语句

### 1.4.1. if 语句

目前我们写的简单函数中可以有多条语句，但这些语句总是从前到后顺序执行的。除了顺序执行之外，有时候我们需要检查一个条件，然后根据检查的结果执行不同的后续代码，在 C 语言中可以用分支语句（Selection Statement）实现，比如：

```c
if (x != 0) {
	printf("x is nonzero.\n");
}
```

其中 `x != 0` 表示「x 不等于 0」的条件，这个表达式称为控制表达式（Controlling Expression）如果条件成立，则 `{}` 中的语句被执行，否则 `{}` 中的语句不执行，直接跳到 `}` 后面。`if` 和控制表达式改变了程序的控制流程（Control Flow），不再是从前到后顺序执行，而是根据不同的条件执行不同的语句，这种控制流程称为分支（Branch）。上例中的 `!=` 号表示「不等于」，像这样的运算符有：

<p id="t4-1">表 4.1. 关系运算符和相等性运算符</p>

| 运算符 | 含义       | 类型         | 优先级 |
| ------ | ---------- | ------------ | ------ |
| `==`   | 等于       | 相等性运算符 | 低     |
| `!=`   | 不等于     | 相等性运算符 | 低     |
| `>`    | 大于       | 关系运算符   | 高     |
| `<`    | 小于       | 关系运算符   | 高     |
| `>=`   | 大于或等于 | 关系运算符   | 高     |
| `<=`   | 小于或等于 | 关系运算符   | 高     |

注意以下几点：

1. 这里的 `==` 表示数学中的相等关系，相当于数学中的 `=` 号，初学者常犯的错误是在控制表达式中把 `==` 写成 `=`，在 C 语言中 `=` 号是赋值运算符，两者的含义完全不同。
2. 如果表达式所表示的比较关系成立则值为真（True），否则为假（False），在 C 语言中分别用 `int` 型的 `1` 和 `0` 表示。如果变量 `x` 的值是 `-1`，那么 `x>0` 这个表达式的值为 `0`，`x>-2` 这个表达式的值为 `1`。
3. 在数学中 `a<b<c` 表示 `b` 既大于 `a` 又小于 `c`，但作为 C 语言表达式却不是这样。以上几种运算符都是左结合的，请读者想一下这个表达式应如何求值。
4. 这些运算符的两个操作数应该是相同类型的，两边都是整型或者都是浮点型可以做比较，但两个字符串不能做比较，在[第 25 章「C 标准库」第 1 节「比较字符串」](2-C-语言本质/ch25-C-标准库#_1-比较字符串)我们会介绍比较字符串的方法。
5. `==` 和 `!=` 称为相等性运算符（Equality Operator），其余四个称为关系运算符（Relational Operator），相等性运算符的优先级低于关系运算符。

总结一下，`if (x != 0) { ... }` 这个语句的计算顺序是：首先求 `x != 0` 这个表达式的值，如果值为 `0`，就跳过 `{}` 中的语句直接执行后面的语句，如果值为 `1`，就先执行 `{}` 中的语句，然后再执行后面的语句。事实上控制表达式取任何非 `0` 值都表示真值，例如 `if (x) { ... }` 和 `if (x != 0) { ... }` 是等价的，如果 `x` 的值是 `2`，则 `x != 0` 的值是 `1`，但对于 `if` 来说不管是 `2` 还是 `1` 都表示真值。

和 `if` 语句相关的语法规则如下：

```
语句 → if (控制表达式) 语句
语句 → { 语句列表 }
语句 → ;
```

在 C 语言中，任何允许出现语句的地方既可以是由 `;` 号结尾的一条语句，也可以是由 `{}` 括起来的若干条语句或声明组成的语句块（Statement Block），语句块和[上一章](1-C-语言入门/ch03-简单函数)介绍的函数体的语法相同。注意语句块的 `}` 后面不需要加 `;` 号。如果 `}` 后面加了 `;` 号，则这个 `;` 号本身又是一条新的语句了，在 C 语言中一个单独的 `;` 号表示一条空语句（Null Statement）。上例的语句块中只有一条语句，其实没必要写成语句块，可以简单地写成：

```c
if (x != 0)
	printf("x is nonzero.\n");
```

语句块中也可以定义局部变量，例如：

```c
void foo(void)
{
	int i = 0;
	{
		int i = 1;
		int j = 2;
		printf("i=%d, j=%d\n", i, j);
	}
	printf("i=%d\n", i); /* cannot access j here */
}
```

和函数的局部变量同样道理，每次进入语句块时为变量 `j` 分配存储空间，每次退出语句块时释放变量 `j` 的存储空间。语句块也构成一个作用域，和[第 3 章「简单函数」第 4 节「全局变量、局部变量和作用域」例 3.6 「作用域」](1-C-语言入门/ch03-简单函数#e3-6)的分析类似，如果整个源文件是一张大纸，`foo` 函数是盖在上面的一张小纸，则函数中的语句块是盖在小纸上面的一张更小的纸。语句块中的变量 `i` 和函数的局部变量 `i` 是两个不同的变量，因此两次打印的 `i` 值是不同的；语句块中的变量 `j` 在退出语句块之后就没有了，因此最后一行的 `printf` 不能打印变量 `j`，否则编译器会报错。语句块可以用在任何允许出现语句的地方，不一定非得用在 `if` 语句中，单独使用语句块通常是为了定义一些比函数的局部变量更「局部」的变量。

### 1.4.2. if/else 语句

if 语句还可以带一个 else 子句（Clause），例如：

```c
if (x % 2 == 0)
	printf("x is even.\n");
else
	printf("x is odd.\n");
```

这里的 `%` 是取模（Modulo）运算符，`x%2` 表示 `x` 除以 `2` 所得的余数（Remainder），C 语言规定 `%` 运算符的两个操作数必须是整型的。两个正数相除取余数很好理解，如果操作数中有负数，结果应该是正是负呢？C99 规定，如果 `a` 和 `b` 是整型，`b` 不等于 `0`，则表达式`(a/b)*b+a%b` 的值总是等于 `a`，再结合[第 2 章「常量、变量和表达式」第 5 节「表达式」](1-C-语言入门/ch02-常量、变量和表达式#_5-表达式)讲过的整数除法运算要 Truncate Toward Zero，可以得到一个结论：**% 运算符的结果总是与被除数同号**（想一想为什么）。其它编程语言对取模运算的规定各不相同，也有规定结果和除数同号的，也有不做明确规定的。

取模运算在程序中是非常有用的，例如上面的例子判断 `x` 的奇偶性（Parity），看 `x` 除以 `2` 的余数是不是 `0`，如果是 `0` 则打印 `x is even.`，如果不是 `0` 则打印 `x is odd.`，读者应该能看出 `else` 在这里的作用了，如果在上面的例子中去掉 `else`，则不管 `x` 是奇是偶，`printf("x is odd.\n");` 总是执行。为了让这条语句更有用，可以把它封装（Encapsulate）成一个函数：

```c
void print_parity(int x)
{
	if (x % 2 == 0)
		printf("x is even.\n");
	else
		printf("x is odd.\n");
}
```

把语句封装成函数的基本步骤是：**把语句放到函数体中，把变量改成函数的参数**。这样，以后要检查一个数的奇偶性只需调用这个函数而不必重复写这条语句了，例如：

```c
print_parity(17);
print_parity(18);
```

`if/else` 语句的语法规则如下：

```
语句 → if (控制表达式) 语句 else 语句
```

右边的「语句」既可以是一条语句，也可以是由 `{}` 括起来的语句块。一条 `if` 语句中包含一条子语句，一条 `if/else` 语句中包含两条子语句，子语句可以是任何语句或语句块，当然也可以是另外一条 `if` 或 `if/else` 语句。根据组合规则，`if/else` 可以嵌套使用。例如可以这样：

```c
if (x > 0)
	printf("x is positive.\n");
else if (x < 0)
	printf("x is negative.\n");
else
	printf("x is zero.\n");
```

也可以这样：

```c
if (x > 0) {
	printf("x is positive.\n");
} else {
	if (x < 0)
		printf("x is negative.\n");
	else
		printf("x is zero.\n");
}
```

现在有一个问题，类似 `if (A) if (B) C; else D;` 形式的语句怎么理解呢？可以理解成

```c
if (A)
	if (B)
		C;
else
	D;
```

也可以理解成

```c
if (A)
	if (B)
		C;
	else
		D;
```

在[第 2 章「常量、变量和表达式」第 1 节「继续 Hello World」](1-C-语言入门/ch02-常量、变量和表达式#_1-继续-Hello-World)讲过，C 代码的缩进只是为了程序员看起来方便，实际上对编译器不起任何作用，你的代码不管写成上面哪一种缩进格式，在编译器看起来都是一样的。那么编译器到底按哪种方式理解呢？也就是说，`else` 到底是和 `if (A)` 配对还是和 `if (B)` 配对？很多编程语言的语法都有这个问题，称为 Dangling-else 问题。C 语言规定，**else 总是和它上面最近的一个 if 配对**，因此应该理解成 `else` 和 `if (B)` 配对，也就是按第二种方式理解。如果你写成上面第一种缩进的格式就很危险了：你看到的是这样，而编译器理解的却是那样。如果你希望编译器按第一种方式理解，应该明确加上 `{}`：

```c
if (A) {
	if (B)
		C;
} else
	D;
```

顺便提一下，浮点型的精度有限，不适合用 `==` 运算符做精确比较。以下代码可以说明问题：

```c
double i = 20.0;
double j = i / 7.0;
if (j * 7.0 == i)
	printf("Equal.\n");
else
	printf("Unequal.\n");
```

不同平台的浮点数实现有很多不同之处，在我的平台上运行这段程序结果为 `Unequal`，即使在你的平台上运行结果为 `Equal`，你再把 `i` 改成其它值试试，总有些值会使得结果为 `Unequal`。等学习了[第 14 章「计算机中数的表示」第 4 节「浮点数」](2-C-语言本质/ch14-计算机中数的表示#_4-浮点数)，你就知道为什么浮点型不能做精确比较了。

### 1.4.3. 布尔代数

在[本章第 1 节「if 语句」](#_1-if-语句)讲过，`a<b<c` 不表示 `b` 既大于 `a` 又小于 `c`，那么如果想表示这个含义该怎么写呢？可以这样：

```c
if (a < b) {
	if (b < c) {
		printf("b is between a and c.\n");
	}
}
```

我们也可以用逻辑与（Logical AND）运算符表示这两个条件同时成立。逻辑与运算符在 C 语言中写成两个与号（Ampersand）`&&` ，上面的语句可以改写为：

```c
if (a < b && b < c) {
	printf("b is between a and c.\n");
}
```

对于 `a < b && b < c` 这个控制表达式，要求「`a < b` 的值非 0 」和「`b < c` 的值非 0」这两个条件同时成立整个表达式的值才为 `1`，否则整个表达式的值为 `0`。也就是只有两个条件都为真，它们做逻辑与运算的结果才为真，有一个条件为假，则逻辑与运算的结果为假，如下表所示：

<p id="t4-2">表 4.2. AND 的真值表</p>

| A    | B    | A AND B |
| ---- | ---- | ------- |
| 0    | 0    | 0       |
| 0    | 1    | 0       |
| 1    | 0    | 0       |
| 1    | 1    | 1       |

这种表称为真值表（Truth Table）。注意逻辑与运算的操作数以非 0 表示真、以 0 表示假，而运算结果以 1 表示真、以 0 表示假（类型是 `int`），我们忽略这些细微的差别，在表中全部以 1 表示、真、以 0 表示假。C 语言还提供了逻辑或（Logical OR）运算符，写成两个管道符号（Pipe Sign） `||` ，逻辑非（Logical NOT）运算符，写成一个感叹号（Exclamation Mark） `!`，它们的真值表如下：

<p id="t4-3">表 4.3. OR 的真值表</p>

| A    | B    | A OR B |
| ---- | ---- | ------ |
| 0    | 0    | 0      |
| 0    | 1    | 1      |
| 1    | 0    | 1      |
| 1    | 1    | 1      |

<p id="t4-4">表 4.4. NOT 的真值表</p>

| A    | NOT A |
| ---- | ----- |
| 0    | 1     |
| 1    | 0     |

逻辑或表示两个条件只要有一个为真，它们做逻辑或运算的结果就为真，只有两个条件都为假，逻辑或运算的结果才为假。逻辑非的作用是对原来的逻辑值取反，原来是真的就是假，原来是假的就是真。逻辑非运算符只有一个操作数，称为**单目运算符（Unary Operator）**，以前讲过的加减乘除、赋值、相等性、关系、逻辑与、逻辑或运算符都有两个操作数，称为**双目运算符（Binary Operator）**。

关于逻辑运算的数学体系称为布尔代数（Boolean Algebra），以它的创始人布尔命名。在编程语言中表示真和假的数据类型叫做布尔类型，在 C 语言中通常用 `int` 型来表示，非 0 表示真，0 表示假 <sup>[6]</sup>。布尔逻辑是写程序的基本功之一，程序中的很多错误都可以归因于逻辑错误。以下是一些布尔代数的基本定理，为了简洁易读，真和假用 `1` 和 `0` 表示，`AND` 用 `*` 号表示，`OR` 用 `+` 号表示（从真值表可以看出 `AND` 和 `OR` 运算确实有点像乘法和加法运算），`NOT` 用 `¬` 表示，变量 `x`、`y`、`z` 的值可能是 `0` 也可能是 `1`。

> <sup>[6]</sup> C99 也定义了专门的布尔类型 `_Bool`，但目前没有被广泛使用。

```
¬¬x=x

x*0=0
x+1=1

x*1=x
x+0=x

x*x=x
x+x=x

x*¬x=0
x+¬x=1

x*y=y*x
x+y=y+x

x*(y*z)=(x*y)*z
x+(y+z)=(x+y)+z

x*(y+z)=x*y+x*z
x+y*z=(x+y)*(x+z)

x+x*y=x
x*(x+y)=x

x*y+x*¬y=x
(x+y)*(x+¬y)=x

¬(x*y)=¬x+¬y
¬(x+y)=¬x*¬y

x+¬x*y=x+y
x*(¬x+y)=x*y

x*y+¬x*z+y*z=x*y+¬x*z
(x+y)*(¬x+z)*(y+z)=(x+y)*(¬x+z)
```

除了第 1 行之外，这些公式都是每两行一组的，每组的两个公式就像对联一样：把其中一个公式中的 `*` 换成 `+`、`+` 换成 `*`、`0` 换成 `1`、`1` 换成 `0`，就变成了与它对称的另一个公式。这些定理都可以通过真值表证明，更多细节可参考有关数字逻辑的教材，例如 *数字逻辑基础*。我们将在本节的练习题中强化训练对这些定理的理解。

目前为止介绍的这些运算符的优先级顺序是：`!` 高于 `* / %`，高于 `+ -`，高于 `> < >= <=`，高于 `==  !=`，高于 `&&`，高于 `||`，高于 `=`。写一个控制表达式很可能同时用到这些运算符中的多个，如果记不清楚运算符的优先级一定要多套括号。我们将在[第 16 章「运算符详解」第 4 节「运算符总结」](2-C-语言本质/ch16-运算符详解#_4-运算符总结)总结 C 语言所有运算符的优先级和结合性。

### 1.4.4. switch 语句

`switch` 语句可以产生具有多个分支的控制流程。它的格式是：

```c
switch (控制表达式) {
case 常量表达式： 语句列表
case 常量表达式： 语句列表
...
default： 语句列表
}
```

例如以下程序根据传入的参数 `1 ~ 7` 分别打印 Monday ~ Sunday：

<p id="e4-1">例 4.1. switch 语句</p>

![switch 语句 1](./image/cond.switch1.png)

如果传入的参数是 `2`，则从 `case 2` 分支开始执行，先是打印相应的信息，然后遇到 `break` 语句，它的作用是跳出整个 `switch` 语句块。C 语言规定各 `case` 分支的常量表达式必须互不相同，如果控制表达式不等于任何一个常量表达式，则从 `default` 分支开始执行，通常把 `default` 分支写在最后，但不是必须的。使用 `switch` 语句要注意几点：

`case` 后面跟表达式的必须是常量表达式，这个值和全局变量的初始值一样必须在编译时计算出来。

[本章第 2 节「if/else 语句」](#_2-ifelse-语句)讲过浮点型不适合做精确比较，所以 C 语言规定 `case` 后面跟的必须是整型常量表达式。

进入 `case` 后如果没有遇到 `break` 语句就会一直往下执行，后面其它 `case` 或 `default` 分支的语句也会被执行到，直到遇到 `break`，或者执行到整个 `switch` 语句块的末尾。通常每个 `case` 后面都要加上 `break` 语句，但有时会故意不加 `break` 来利用这个特性，例如：

<p id="e4-2">例 4.2. 缺 break 的 switch 语句</p>

![switch 语句 2](./image/cond.switch2.png)

`switch` 语句不是必不可缺的，显然可以用一组 `if ... else if ... else if ... else ...` 代替，但是一方面用 `switch` 语句会使代码更清晰，另一方面，有时候编译器会对 `switch` 语句进行整体优化，使它比等价的 `if/else` 语句所生成的指令效率更高。

## 1.5. 深入理解函数

### 1.5.1. return 语句

之前我们一直在 `main` 函数中使用 `return` 语句，现在是时候全面深入地学习一下了。在有返回值的函数中，`return` 语句的作用是提供整个函数的返回值，并结束当前函数返回到调用它的地方。在没有返回值的函数中也可以使用 `return` 语句，例如当检查到一个错误时提前结束当前函数的执行并返回：

```c
  #include <math.h>
  
  void print_logarithm(double x)
  {
  	if (x <= 0.0) {
  		printf("Positive numbers only, please.\n");
  		return;
  	}
  	printf("The log of x is %f", log(x));
  }
```

这个函数首先检查参数 `x` 是否大于 `0`，如果 `x` 不大于 `0` 就打印错误提示，然后提前结束函数的执行返回到调用者，只有当 `x` 大于 `0` 时才能求对数，在打印了对数结果之后到达函数体的末尾，自然地结束执行并返回。注意，使用数学函数 `log` 需要包含头文件 `math.h`，由于 `x` 是浮点数，应该与同类型的数做比较，所以 `if` 语句中写成 `0.0`。

在[上一章「分支语句」第 2 节「if/else 语句」](1-C-语言入门/ch04-分支语句#_2-ifelse-语句)中我们定义了一个检查奇偶性的函数，如果是奇数就打印 `x is odd.`，如果是偶数就打印 `x is even.`。事实上这个函数并不十分好用，我们定义一个检查奇偶性的函数往往不是为了打印两个字符串就完了，而是为了根据奇偶性的不同分别执行不同的后续动作。我们可以把它改成一个返回布尔值的函数：

```c
int is_even(int x)
{
	if (x % 2 == 0)
		return 1;
	else
		return 0;
}
```

有些人喜欢写成 `return(1);` 这种形式也可以，表达式外面套括号表示改变运算符优先级，在这里不起任何作用。我们可以这样调用这个函数：

```c
int i = 19;
if (is_even(i)) {
	/* do something */
} else {
	/* do some other thing */
}
```

返回布尔值的函数是一类非常有用的函数，在程序中通常充当控制表达式，函数名通常带有 `is` 或 `if` 等表示判断的词，这类函数也叫做谓词（Predicate）。`is_even` 这个函数写得有点啰嗦，`x % 2` 这个表达式本来就有 `0` 值或非 `0` 值，直接把这个值当作布尔值返回就可以了：

```c
int is_even(int x)
{
	return !(x % 2);
}
```

函数的返回值应该这样理解：函数返回一个值相当于定义一个和返回值类型相同的临时变量并用 `return` 后面的表达式来初始化。例如上面的函数调用相当于这样的过程：

```c
int 临时变量 = !(x % 2);
函数退出，局部变量 x 的存储空间释放;
if (临时变量) { /* 临时变量用完就释放 */
	/* do something */
} else {
	/* do some other thing */
}
```

当 `if` 语句对函数的返回值做判断时，函数已经退出，局部变量 `x` 已经释放，所以不可能在这时候才计算表达式 `!(x % 2)` 的值，表达式的值必然是事先计算好了存在一个临时变量里的，然后函数退出，局部变量释放，`if` 语句对这个临时变量的值做判断。注意，虽然函数的返回值可以看作是一个临时变量，但我们只是读一下它的值，读完值就释放它，而不能往它里面存新的值，换句话说，函数的返回值不是左值，或者说函数调用表达式不能做左值，因此下面的赋值语句是非法的：

```c
is_even(20) = 1;
```

在[第 3 章「简单函数」第 3 节「形参和实参」](1-C-语言入门/ch03-简单函数#_3-形参和实参)中讲过，C 语言的传参规则是 Call by Value，按值传递，现在我们知道返回值也是按值传递的，即便返回语句写成 `return x;`，返回的也是变量 `x` 的值，而非变量 `x` 本身，因为变量 `x` 马上就要被释放了。

在写带有 `return` 语句的函数时要小心检查所有的代码路径（Code Path）。有些代码路径在任何条件下都执行不到，这称为 Dead Code，例如把 `&&` 和 `||` 运算符记混了（据我了解初学者犯这个低级错误的不在少数），写出如下代码：

```c
void foo(int x, int y)
{
	if (x >= 0 || y >= 0) {
		printf("both x and y are positive.\n");
		return;
	} else if (x < 0 || y < 0) {
		printf("both x and y are negetive.\n");
		return;
	}
	printf("x has a different sign from y.\n");
}
```

最后一行 `printf` 永远都没机会被执行到，是一行 Dead Code。有 Dead Code 就一定有 Bug，你写的每一行代码都是想让程序在某种情况下去执行的，你不可能故意写出一行永远不会被执行的代码，如果程序在任何情况下都不会去执行它，说明跟你预想的不一样，要么是你对所有可能的情况分析得不正确，也就是逻辑错误，要么就是像上例这样的笔误，语义错误。还有一些时候，对程序中所有可能的情况分析得不够全面将导致漏掉一些代码路径，例如：

```c
int absolute_value(int x)
{
	if (x < 0) {
		return -x;
	} else if (x > 0) {
		return x;
	}
}
```

这个函数被定义为返回 `int`，就应该在任何情况下都返回 `int`，但是上面这个程序在 `x==0` 时安静地退出函数，什么也不返回，C 语言对于这种情况会返回什么结果是未定义的，通常返回不确定的值，等学到[第 19 章「汇编与 C 之间的关系」第 1 节「函数调用」](2-C-语言本质/ch19-汇编与-C-之间的关系#_1-函数调用)你就知道为什么了。另外注意这个例子中把 `-` 号当负号用而不是当减号用，事实上 `+` 号也可以这么用。正负号是单目运算符，而加减号是双目运算符，正负号的优先级和逻辑非运算符相同，比加减的优先级要高。

以上两段代码都不会产生编译错误，编译器只做语法检查和最简单的语义检查，而不检查程序的逻辑<sup>[7]</sup>。虽然到现在为止你见到了各种各样的编译器错误提示，也许你已经十分讨厌编译器报错了，但很快你就会认识到，如果程序中有错误编译器还不报错，那一定比报错更糟糕。比如上面的绝对值函数，在你测试的时候运行得很好，也许是你没有测到 `x==0` 的情况，也许刚好在你的环境中 `x==0` 时返回的不确定值就是 `0`，然后你放心地把它集成到一个数万行的程序之中。然后你把这个程序交给用户，起初的几天里相安无事，之后每过几个星期就有用户报告说程序出错，但每次出错的现象都不一样，而且这个错误很难复现，你想让它出现时它就不出现，在你毫无防备时它又突然冒出来了。然后你花了大量的时间在数万行的程序中排查哪里错了，几天之后终于幸运地找到了这个函数的 Bug，这时候你就会想，如果当初编译器能报个错多好啊！所以，如果编译器报错了，不要责怪编译器太过于挑剔，它帮你节省了大量的调试时间。另外，在 `math.h` 中有一个 `fabs` 函数就是求绝对值的，我们通常不必自己写绝对值函数。

> <sup>[7]</sup> 有的代码路径没有返回值的问题编译器是可以检查出来的，如果编译时加 `-Wall` 选项会报警告。

### 1.5.2. 增量式开发

目前为止你看到了很多示例代码，也在它们的基础上做了很多改动并在这个过程中巩固所学的知识。但是如果从头开始编写一个程序解决某个问题，应该按什么步骤来写呢？本节提出一种增量式（Incremental）开发的思路，很适合初学者。

现在问题来了：我们要编一个程序求圆的面积，圆的半径以两个端点的座标 (x<sub>1</sub>, y<sub>1</sub>) 和 (x<sub>2</sub>, y<sub>2</sub>) 给出。首先分析和分解问题，把大问题分解成小问题，再对小问题分别求解。这个问题可分为两步：

1. 由两个端点座标求半径的长度，我们知道平面上两点间距离的公式是：

> distance = √((x<sub>2</sub>-x<sub>1</sub>)<sup>2</sup>+(y<sub>2</sub>-y<sub>1</sub>)<sup>2</sup>)

括号里的部分都可以用我们学过的 C 语言表达式来表示，求平方根可以用 `math.h` 中的 `sqrt` 函数，因此这个小问题全部都可以用我们学过的知识解决。这个公式可以实现成一个函数，参数是两点的座标，返回值是 `distance`。

2. 上一步算出的距离是圆的半径，已知圆的半径之后求面积的公式是：

>  area = π·radius<sup>2</sup>

也可以用我们学过的 C 语言表达式来解决，这个公式也可以实现成一个函数，参数是 `radius`，返回值是 `area`。

首先编写 `distance` 这个函数，我们已经明确了它的参数是两点的座标，返回值是两点间距离，可以先写一个简单的函数定义：

```c
double distance(double x1, double y1, double x2, double y2)
{
	return 0.0;
}
```

初学者写到这里就已经不太自信了：这个函数定义写得对吗？虽然我是按我理解的语法规则写的，但书上没有和这个一模一样的例子，万一不小心遗漏了什么呢？既然不自信就不要再往下写了，没有一个平稳的心态来写程序很可能会引入 Bug。所以在函数定义中插一个 `return 0.0` 立刻结束掉它，然后立刻测试这个函数定义得有没有错：

```c
int main(void)
{
	printf("distance is %f\n", distance(1.0, 2.0, 4.0, 6.0));
	return 0;
}
```

编译，运行，一切正常。这时你就会建立起信心了：既然没问题，就不用管它了，继续往下写。在测试时给这个函数的参数是 (1.0, 2.0) 和 (4.0, 6.0)，两点的 `x` 座标距离是 3.0，`y` 座标距离是 4.0，因此两点间距离应该是 5.0，你必须事先知道正确答案是 5.0，这样你才能测试程序计算的结果对不对。当然，现在函数还没实现，计算结果肯定是不对的。现在我们再往函数里添一点代码：

```c
double distance(double x1, double y1, double x2, double y2)
{
	double dx = x2 - x1;
	double dy = y2 - y1;
	printf("dx is %f\ndy is %f\n", dx, dy);

	return 0.0;
}
```

如果你不确定 `dx` 和 `dy` 这样初始化行不行，那么就此打住，在函数里插一条打印语句把 `dx` 和 `dy` 的值打出来看看。把它和上面的 `main` 函数一起编译运行，由于我们事先知道结果应该是 3.0 和 4.0，因此能够验证程序算得对不对。一旦验证无误，函数里的这句打印就可以撤掉了，像这种打印语句，以及我们用来测试的 `main` 函数，都起到了类似脚手架（Scaffold）的作用：在盖房子时很有用，但它不是房子的一部分，房子盖好之后就可以拆掉了。房子盖好之后可能还需要维修、加盖、翻新，又要再加上脚手架，这很麻烦，要是当初不用拆就好了，可是不拆不行，不拆多难看啊。写代码却可以有一个更高明的解决办法：把 Scaffolding 的代码注释掉。

```c
double distance(double x1, double y1, double x2, double y2)
{
	double dx = x2 - x1;
	double dy = y2 - y1;
	/* printf("dx is %f\ndy is %f\n", dx, dy); */
	return 0.0;
}
```

这样如果以后出了新的 Bug 又需要跟踪调试时，还可以把这句重新加进代码中使用。两点的 x 座标距离和 y 座标距离都没问题了，下面求它们的平方和：

```c
double distance(double x1, double y1, double x2, double y2)
{
	double dx = x2 - x1;
	double dy = y2 - y1;
	double dsquared = dx * dx + dy * dy;
	printf("dsquared is %f\n", dsquared);

	return 0.0;
}
```

然后再编译、运行，看看是不是得 25.0。这样的增量式开发非常适合初学者，每写一行代码都编译运行，确保没问题了再写一下行，一方面在写代码时更有信心，另一方面也方便了调试：总是有一个先前的正确版本做参照，改动之后如果出了问题，几乎可以肯定就是刚才改的那行代码出的问题，这样就避免了必须从很多行代码中查找分析到底是哪一行出的问题。在这个过程中 `printf` 功不可没，你怀疑哪一行代码有问题，就插一个 `printf` 进去看看中间的计算结果，任何错误都可以通过这个办法找出来。以后我们会介绍程序调试工具 `gdb`，它提供了更强大的调试功能帮你分析更隐蔽的错误。但即使有了 `gdb`，`printf` 这个最原始的办法仍然是最直接、最有效的。最后一步，我们完成这个函数：

<p id="e5-1">例 5.1. distance 函数</p>

```c
  #include <math.h>
  #include <stdio.h>
  
  double distance(double x1, double y1, double x2, double y2)
  {
  	double dx = x2 - x1;
  	double dy = y2 - y1;
  	double dsquared = dx * dx + dy * dy;
  	double result = sqrt(dsquared);
  
  	return result;
  }
  
  int main(void)
  {
  	printf("distance is %f\n", distance(1.0, 2.0, 4.0, 6.0));
  	return 0;
  }
```

然后编译运行，看看是不是得 5.0。随着编程经验越来越丰富，你可能每次写若干行代码再一起测试，而不是像现在这样每写一行就测试一次，但不管怎么样，增量式开发的思路是很有用的，它可以帮你节省大量的调试时间，不管你有多强，都不应该一口气写完整个程序再编译运行，那几乎是一定会有 Bug 的，到那时候再找 Bug 就难了。

这个程序中引入了很多临时变量： `dx`、`dy`、`dsquared`、`result`，如果你有信心把整个表达式一次性写好，也可以不用临时变量：

```c
double distance(double x1, double y1, double x2, double y2)
{
	return sqrt((x2-x1) * (x2-x1) + (y2-y1) * (y2-y1));
}
```

这样写简洁得多了。但如果写错了呢？只知道是这一长串表达式有错，根本不知道错在哪，而且整个函数就一个语句，插 `printf` 都没地方插。所以用临时变量有它的好处，使程序更清晰，调试更方便，而且有时候可以避免不必要的计算，例如上面这一行表达式要把 `(x2-x1)` 计算两遍，如果算完 `(x2-x1)` 把结果存在一个临时变量 `dx` 里，就不需要再算第二遍了。

接下来编写 `area` 这个函数：

```c
double area(double radius)
{
	return 3.1416 * radius * radius;
}
```

给出两点的座标求距离，给出半径求圆的面积，这两个子问题都解决了，如何把它们组合起来解决整个问题呢？给出半径的两端点座标 (1.0, 2.0) 和 (4.0, 6.0) 求圆的面积，先用 `distance` 函数求出半径的长度，再把这个长度传给 `area` 函数：

```c
double radius = distance(1.0, 2.0, 4.0, 6.0);
double result = area(radius);
```

也可以这样：

```c
double result = area(distance(1.0, 2.0, 4.0, 6.0));
```

我们一直把「给出半径的两端点座标求圆的面积」这个问题当作整个问题来看，如果它也是一个更大的程序当中的子问题呢？我们可以把先前的两个函数组合起来做成一个新的函数以便日后使用：

```c
double area_point(double x1, double y1, double x2, double y2)
{
	return area(distance(x1, y1, x2, y2));
}
```

还有另一种组合的思路，不是把 `distance` 和 `area` 两个函数调用组合起来，而是把那两个函数中的语句组合到一起：

```c
double area_point(double x1, double y1, double x2, double y2)
{
	double dx = x2 - x1;
	double dy = y2 - y1;
	double radius = sqrt(dx * dx + dy * dy);

	return 3.1416 * radius * radius;
}
```

这样组合是不理想的。这样组合了之后，原来写的 `distance` 和 `area` 两个函数还要不要了呢？如果不要了删掉，那么如果有些情况只需要求两点间的距离，或者只需要给定半径长度求圆的面积呢？`area_point` 把所有语句都写在一起，太不灵活了，满足不了这样的需要。如果保留 `distance` 和 `area` 同时也保留这个 `area_point` 怎么样呢？`area_point` 和 `distance` 有相同的代码，一旦在 `distance` 函数中发现了 Bug，或者要升级 `distance` 这个函数采用更高的计算精度，那么不仅要修改 `distance`，还要记着修改 `area_point`，同理，要修改 `area` 也要记着修改 `area_point`，维护重复的代码是非常容易出错的，在任何时候都要尽量避免。因此，**尽可能复用（Reuse）以前写的代码，避免写重复的代码**。封装就是为了复用，把解决各种小问题的代码封装成函数，在解决第一个大问题时可以用这些函数，在解决第二个大问题时可以复用这些函数。

解决问题的过程是把大的问题分成小的问题，小的问题再分成更小的问题，这个过程在代码中的体现就是函数的分层设计（Stratify）。`distance` 和 `area` 是两个底层函数，解决一些很小的问题，而 `area_point` 是一个上层函数，上层函数通过调用底层函数来解决更大的问题，底层和上层函数都可以被更上一层的函数调用，最终所有的函数都直接或间接地被 `main` 函数调用。如下图所示：

<p id="c5-1">图 5.1. 函数的分层设计</p>

![函数的分层设计](./image/func2.stratify.png)

### 1.5.3. 递归

如果定义一个概念需要用到这个概念本身，我们称它的定义是递归的（Recursive）。例如：

**frabjuous**:  an adjective used to describe something that is frabjuous.

这只是一个玩笑，如果你在字典上看到这么一个词条肯定要怒了。然而数学上确实有很多概念是用它自己来定义的，比如 n 的阶乘（Factorial）是这样定义的：n 的阶乘等于 n 乘以 n-1 的阶乘。如果这样就算定义完了，恐怕跟上面那个词条有异曲同工之妙了：n-1 的阶乘是什么？是 n-1 乘以 n-2 的阶乘。那 n-2 的阶乘又是什么？这样下去永远也没完。因此需要定义一个最关键的基础条件（Base Case）：0 的阶乘等于 1。

```
0! = 1
n! = n · (n-1)!
```
因此，3! = 3 * 2!，2! = 2 * 1!，1! = 1 * 0! = 1 * 1 = 1，正因为有了 Base Case，才不会永远没完地数下去，知道了 1! = 1 我们再反过来算回去，2! = 2 * 1! = 2 * 1 = 2，3! = 3 * 2! = 3 * 2 = 6。下面用程序来完成这一计算过程，我们要写一个计算阶乘的函数 `factorial`，先把 Base Case 这种最简单的情况写进去：

```c
int factorial(int n)
{
	if (n == 0)
		return 1;
}
```

如果参数 `n` 不是 `0` 应该 `return` 什么呢？根据定义，应该 `return n * factorial(n-1);`，为了下面的分析方便，我们引入几个临时变量把这个语句拆分一下：

```c
int factorial(int n)
{
	if (n == 0)
		return 1;
	else {
		int recurse = factorial(n-1);
		int result = n * recurse;
		return result;
	}
}
```

`factorial` 这个函数居然可以自己调用自己？是的。自己直接或间接调用自己的函数称为递归函数。这里的 `factorial` 是直接调用自己，有些时候函数 A 调用函数 B，函数 B 又调用函数 A，也就是函数 A 间接调用自己，这也是递归函数。如果你觉得迷惑，可以把 `factorial(n-1)` 这一步看成是在调用另一个函数——另一个有着相同函数名和相同代码的函数，调用它就是跳到它的代码里执行，然后再返回 `factorial(n-1)` 这个调用的下一步继续执行。我们以 `factorial(3)` 为例分析整个调用过程，如下图所示：

<p id="c5-2">图 5.2. factorial(3) 的调用过程</p>

![factorial(3)的调用过程](./image/func2.factorial.png)

图中用实线箭头表示调用，用虚线箭头表示返回，右侧的框表示在调用和返回过程中各层函数调用的存储空间变化情况。

1. `main()` 有一个局部变量 `result`，用一个框表示。
2. 调用 `factorial(3)` 时要分配参数和局部变量的存储空间，于是在 `main()` 的下面又多了一个框表示 `factorial(3)` 的参数和局部变量，其中 `n` 已初始化为 `3`。
3. `factorial(3)` 又调用 `factorial(2)`，又要分配 `factorial(2)` 的参数和局部变量，于是在 `main()` 和 `factorial(3)` 下面又多了一个框。[第 3 章「简单函数」第 4 节「全局变量、局部变量和作用域」](1-C-语言入门/ch03-简单函数#_4-全局变量、局部变量和作用域)讲过，每次调用函数时分配参数和局部变量的存储空间，退出函数时释放它们的存储空间。`factorial(3)` 和 `factorial(2)` 是两次不同的调用，`factorial(3)` 的参数 `n` 和 `factorial(2)` 的参数 `n` 各有各的存储单元，虽然我们写代码时只写了一次参数 `n`，但运行时却是两个不同的参数 `n`。并且由于调用 `factorial(2)` 时 `factorial(3)` 还没退出，所以两个函数调用的参数 `n` 同时存在，所以在原来的基础上多画一个框。
4. 依此类推，请读者对照着图自己分析整个调用过程。读者会发现这个过程和前面我们用数学公式计算 `3!` 的过程是一样的，都是先一步步展开然后再一步步收回去。

我们看上图右侧存储空间的变化过程，随着函数调用的层层深入，存储空间的一端逐渐增长，然后随着函数调用的层层返回，存储空间的这一端又逐渐缩短，并且每次访问参数和局部变量时只能访问这一端的存储单元，而不能访问内部的存储单元，比如当 `factorial(2)` 的存储空间位于末端时，只能访问它的参数和局部变量，而不能访问 `factorial(3)` 和 `main()` 的参数和局部变量。具有这种性质的数据结构称为堆栈或栈（Stack），随着函数调用和返回而不断变化的这一端称为栈顶，每个函数调用的参数和局部变量的存储空间（上图的每个小方框）称为一个栈帧（Stack Frame）。操作系统为程序的运行预留了一块栈空间，函数调用时就在这个栈空间里分配栈帧，函数返回时就释放栈帧。

在写一个递归函数时，你如何证明它是正确的？像上面那样跟踪函数的调用和返回过程算是一种办法，但只是 `factorial(3)` 就已经这么麻烦了，如果是 `factorial(100)` 呢？虽然我们已经证明了 `factorial(3)` 是正确的，因为它跟我们用数学公式计算的过程一样，结果也一样，但这不能代替 `factorial(100)` 的证明，你怎么办？别的函数你可以跟踪它的调用过程去证明它的正确性，因为每个函数只调用一次就返回了，但是对于递归函数，这么跟下去只会跟得你头都大了。事实上并不是每个函数调用都需要钻进去看的。我们在调用 `printf` 时没有钻进去看它是怎么打印的，我们只是相信它能打印，能正确完成它的工作，然后就继续写下面的代码了。在上一节中，我们写了 `distance` 和 `area` 函数，然后立刻测试证明了这两个函数是正确的，然后我们写 `area_point` 时调用了这两个函数：

```c
return area(distance(x1, y1, x2, y2));
```

在写这一句的时候，我们需要钻进 `distance` 和 `area` 函数中去走一趟才知道我们调用得是否正确吗？不需要，因为我们已经**相信**这两个函数能正确工作了，也就是相信把座标传给 `distance` 它就能返回正确的距离，把半径传给 `area` 它就能返回正确的面积，因此调用它们去完成另外一件工作也应该是正确的。这种「相信」称为 Leap of Faith，首先相信一些结论，然后再用它们去证明另外一些结论。

在写 `factorial(n)` 的代码时写到这个地方：

```c
...
int recurse = factorial(n-1);
int result = n * recurse;
...
```

这时，如果我们相信 `factorial(n-1)` 是正确的，也就是相信传给它 `n-1` 它就能返回 `(n-1)!`，那么 `recurse` 就是 `(n-1)!`，那么 `result` 就是 `n*(n-1)!`，也就是 `n!`，这正是我们要返回的 `factorial(n)`的结果。当然这有点奇怪：我们还没写完 `factorial` 这个函数，凭什么要相信 `factorial(n-1)` 是正确的？可 Leap of Faith 本身就是 Leap（跳跃）的，不是吗？**如果你相信你正在写的递归函数是正确的，并调用它，然后在此基础上写完这个递归函数，那么它就会是正确的，从而值得你相信它正确**。

这么说好像有点儿玄，我们从数学上严格证明一下 `factorial` 函数的正确性。刚才说了，`factorial(n)` 的正确性依赖于 `factorial(n-1)` 的正确性，只要后者正确，在后者的结果上乘个 `n` 返回这一步显然也没有疑问，那么我们的函数实现就是正确的。因此要证明 `factorial(n)` 的正确性就是要证明 `factorial(n-1)` 的正确性，同理，要证明 `factorial(n-1)` 的正确性就是要证明 `factorial(n-2)` 的正确性，依此类推下去，最后是：要证明 `factorial(1)` 的正确性就是要证明 `factorial(0)` 的正确性。而 `factorial(0)` 的正确性不依赖于别的函数调用，它就是程序中的一个小的分支 `return 1;`，这个 `1` 是我们根据阶乘的定义写的，肯定是正确的，因此 `factorial(1)` 的实现是正确的，因此 `factorial(2)` 也正确，依此类推，最后 `factorial(n)` 也是正确的。其实这就是在中学时学的数学归纳法（Mathematical Induction），用数学归纳法来证明只需要证明两点：Base Case 正确，递推关系正确。**写递归函数时一定要记得写 Base Case**，否则即使递推关系正确，整个函数也不正确。如果 `factorial` 函数漏掉了 Base Case：

```c
int factorial(int n)
{
	int recurse = factorial(n-1);
	int result = n * recurse;
	return result;
}
```

那么这个函数就会永远调用下去，直到操作系统为程序预留的栈空间耗尽程序崩溃（段错误）为止，这称为无穷递归（Infinite recursion）。

到目前为止我们只学习了全部 C 语法的一个小的子集，但是现在应该告诉你：这个子集是完备的，它本身就可以作为一门编程语言了，以后还要学习很多 C 语言特性，但全部都可以用已经学过的这些特性来代替。也就是说，以后要学的 C 语言特性会使代码写起来更加方便，但不是必不可少的，现在学的这些已经完全覆盖了[第 1章「程序的基本概念」第 1 节「程序和编程语言」](1-C-语言入门/ch01-程序的基本概念#_1-程序和编程语言)讲的五种基本指令了。有的读者会说循环还没讲到呢，是的，循环在下一章才讲，但有一个重要的结论就是**递归和循环是等价的**，用循环能做的事用递归都能做，反之亦然，事实上有的编程语言（比如某些 LISP 实现）只有递归而没有循环。计算机指令能做的所有事情就是数据存取、运算、测试和分支、循环（或递归），在计算机上运行高级语言写的程序最终也要翻译成指令，指令做不到的事情高级语言写的程序肯定也做不到，虽然高级语言有丰富的语法特性，但也只是比指令写起来更方便而已，能做的事情是一样多的。那么，为什么计算机要设计成这样？在设计时怎么想到计算机应该具备这几样功能，而不是更多或更少的功能？这些要归功于早期的计算机科学家，例如 Alan Turing，他们在计算机还没有诞生的年代就从数学理论上为计算机的设计指明了方向。有兴趣的读者可以参考有关计算理论的教材，例如 *IATLC*。

递归绝不只是为解决一些奇技淫巧的数学题<sup>[8]</sup>而想出来的招，它是计算机的精髓所在，也是编程语言的精髓所在。我们学习在 C 的语法时已经看到很多递归定义了，例如在[第 3 章「简单函数」第 1 节「数学函数」](1-C-语言入门/ch03-简单函数#_1-数学函数)讲过的语法规则中，「表达式」就是递归定义的：

```
表达式 → 表达式(参数列表)
参数列表 → 表达式, 表达式, ...
```

再比如在[第 4 章「分支语句」第 1 节「if 语句」](1-C-语言入门/ch04-分支语句#_1-if-语句)讲过的语规则中，「语句」也是递归定义的：

```
语句 → if (控制表达式) 语句
```

可见编译器在解析我们写的程序时一定也用了大量的递归，有关编译器的实现原理可参考 *Dragon Book*。

> <sup>[8]</sup> 例如很多编程书都会举例的汉诺塔问题，本书不打算再重复这个题目了。

## 1.6. 循环语句

### 1.6.1. while 语句

在[上章「深入理解函数」第 3 节「递归」](1-C-语言入门/ch05-深入理解函数#_3-递归)中，我们介绍了用递归求 n! 的方法，其实每次递归调用都在重复做同样一件事，就是把 n 乘到 (n-1)! 上然后把结果返回。虽说是重复，但每次做都稍微有一点区别（n 的值不一样），这种每次都有一点区别的重复工作称为迭代（Iteration）。我们使用计算机的主要目的之一就是让它做重复迭代的工作，因为把一件工作重复做成千上万次而不出错正是计算机最擅长的，也是人类最不擅长的。虽然迭代用递归来做就够了，但 C 语言提供了循环语句使迭代程序写起来更方便。例如 `factorial` 用 `while` 语句可以写成：

```c
int factorial(int n)
{
	int result = 1;
	while (n > 0) {
		result = result * n;
		n = n - 1;
	}
	return result;
}
```

和 `if` 语句类似，`while` 语句由一个控制表达式和一个子语句组成，子语句可以是由若干条语句组成的语句块。

```
语句 → while (控制表达式) 语句
```

如果控制表达式的值为真，子语句就被执行，然后再次测试控制表达式的值，如果还是真，就把子语句再执行一遍，再测试控制表达式的值……这种控制流程称为循环（Loop），子语句称为循环体。如果某次测试控制表达式的值为假，就跳出循环执行后面的 `return` 语句，如果第一次测试控制表达式的值就是假，那么直接跳到 `return` 语句，循环体一次都不执行。

变量 `result` 在这个循环中的作用是累加器（Accumulator），把每次循环的中间结果累积起来，循环结束后得到的累积值就是最终结果，由于这个例子是用乘法来累积的，所以 `result` 的初值是 1，如果用加法累积则 `result` 的初值应该是 0。变量 `n` 是循环变量（Loop Variable），每次循环要改变它的值，在控制表达式中要测试它的值，这两点合起来起到控制循环次数的作用，在这个例子中 `n` 的值是递减的，也有些循环采用递增的循环变量。这个例子具有一定的典型性，累加器和循环变量这两种模式在循环中都很常见。

可见，递归能解决的问题用循环也能解决，但解决问题的思路不一样。用递归解决这个问题靠的是递推关系n!=n·(n-1)!，用循环解决这个问题则更像是把这个公式展开了： n!=n·(n-1)·(n-2)·…·3·2·1。把公式展开了理解会更直观一些，所以有些时候循环程序比递归程序更容易理解。但也有一些公式要展开是非常复杂的甚至是不可能的，反倒是递推关系更直观一些，这种情况下递归程序比循环程序更容易理解。此外还有一点不同：看[上一章图 5.2 「factorial(3) 的调用过程」](1-C-语言入门/ch05-深入理解函数#c5-2)，在整个递归调用过程中，虽然分配和释放了很多变量，但所有变量都只在初始化时赋值，没有任何变量的值发生过改变，而上面的循环程序则通过对 `n` 和 `result` 这两个变量多次赋值来达到同样的目的。前一种思路称为函数式编程（Functional Programming），而后一种思路称为命令式编程（Imperative Programming），这个区别类似于[第 1 章「程序的基本概念」第 1 节「程序和编程语言」](1-C-语言入门/ch01-程序的基本概念#_1-程序和编程语言)讲的 Declarative 和 Imperative 的区别。函数式编程的「函数」类似于数学函数的概念，回顾一下[第 3 章「简单函数」第 1 节「数学函数」](1-C-语言入门/ch03-简单函数#_1-数学函数)所讲的，数学函数是没有 Side Effect 的，而 C 语言的函数可以有 Side Effect，比如在一个函数中修改某个全局变量的值就是一种 Side Effect。[第 3 章「简单函数」第 4 节「全局变量、局部变量和作用域」](1-C-语言入门/ch03-简单函数#_全局变量、局部变量和作用域)指出，全局变量被多次赋值会给调试带来麻烦，如果一个函数体很长，控制流程很复杂，那么局部变量被多次赋值也会有同样的问题。因此，不要以为「变量可以多次赋值」是天经地义的，有很多编程语言可以完全采用函数式编程的模式，避免 Side Effect，例如 LISP、Haskell、Erlang 等。用 C 语言编程主要还是采用 Imperative 的模式，但要记住，**给变量多次赋值时要格外小心，在代码中多次读写同一变量应该以一种一致的方式进行**。所谓「一致的方式」是说应该有一套统一的规则，规定在一段代码中哪里会对某个变量赋值、哪里会读取它的值，比如在[第 25 章「C 标准库」第 2.4 节「errno 与 perror 函数」](2-C-语言本质/ch25-C-标准库#_24-errno-与-perror-函数)会讲到访问 `errno` 的规则。

递归函数如果写得不小心就会变成无穷递归，同样道理，循环如果写得不小心就会变成无限循环（Infinite Loop）或者叫死循环。如果 `while` 语句的控制表达式永远为真就成了一个死循环，例如 `while (1) {...}`。在写循环时要小心检查你写的控制表达式有没有可能取值为假，除非你故意写死循环（有的时候这是必要的）。在上面的例子中，不管 `n` 一开始是几，每次循环都会把 `n` 减掉 1，`n` 越来越小最后必然等于 0，所以控制表达式最后必然取值为假，但如果把 `n = n - 1;` 这句漏掉就成了死循环。有的时候是不是死循环并不是那么一目了然：

```c
while (n != 1) {
	if (n % 2 == 0) {
		n = n / 2;
	} else {
		n = n * 3 + 1;
	}
}
```

如果 `n` 为正整数，这个循环能跳出来吗？循环体所做的事情是：如果 `n` 是偶数，就把 `n` 除以 2，如果 `n` 是奇数，就把 `n` 乘 3 加 1。一般来说循环变量要么递增要么递减，可是这个例子中的 `n` 一会儿变大一会儿变小，最终会不会变成 1 呢？可以找个数试试，例如一开始 `n` 等于 7，每次循环后 `n` 的值依次是：7、22、11、34、17、52、26、13、40、20、10、5、16、8、4、2、1。最后 `n` 确实等于 1 了。读者可以再试几个数都是如此，但无论试多少个数也不能代替证明，这个循环有没有可能对某些正整数 `n` 是死循环呢？其实这个例子只是给读者提提兴趣，同时提醒读者写循环时要有意识地检查控制表达式。至于这个循环有没有可能是死循环，这是著名的 3x+1 问题，目前世界上还无人能证明。许多世界难题都是这样的：描述无比简单，连小学生都能看懂，但证明却无比困难。

### 1.6.2. do/while 语句

`do/while` 语句的语法是：

```
语句 → do 语句 while (控制表达式);
```

`while` 语句先测试控制表达式的值再执行循环体，而 `do/while` 语句先执行循环体再测试控制表达式的值。如果控制表达式的值一开始就是假，`while` 语句的循环体一次都不执行，而`do/while` 语句的循环体仍然要执行一次再跳出循环。其实只要有 `while` 循环就足够了，`do/while` 循环和后面要讲的 `for` 循环都可以改写成 `while` 循环，只不过有些情况下用`do/while` 或 `for` 循环写起来更简便，代码更易读。上面的 `factorial` 也可以改用 `do/while` 循环来写：

```c
int factorial(int n)
{
	int result = 1;
	int i = 1;
	do {
		result = result * i;
		i = i + 1;
	} while (i <= n);

	return result;
}
```

写循环一定要注意循环即将结束时控制表达式的临界条件是否准确，上面的循环结束条件如果写成 `i < n` 就错了，当 `i == n` 时跳出循环，最后的结果中就少乘了一个 `n`。虽然变量名应该尽可能起得有意义一些，不过用 `i`、`j`、`k` 给循环变量起名是很常见的。

### 1.6.3. for 语句

前两节我们在 `while` 和 `do/while` 循环中使用循环变量，其实使用循环变量最常见的是 `for` 循环这种形式。`for` 语句的语法是：

```c
for (控制表达式1; 控制表达式2; 控制表达式3) 语句
```

如果不考虑循环体中包含 `continue` 语句的情况（稍后介绍 `continue` 语句），这个 `for` 循环等价于下面的 `while` 循环：

```
控制表达式 1;
while (控制表达式 2) {
	语句
	控制表达式 3;
}
```

从这种等价形式来看，`控制表达式1` 和`控制表达式3` 都可以为空，但`控制表达式2` 是必不可少的，例如 `for (;1;) {...}` 等价于 `while (1) {...}` 死循环。C 语言规定，如果`控制表达式2` 为空，则认为`控制表达式2` 的值为真，因此死循环也可以写成 `for (;;) {...}`。

上一节 `do/while` 循环的例子可以改写成 `for` 循环：

```c
int factorial(int n)
{
	int result = 1;
	int i;
	for(i = 1; i <= n; ++i)
		result = result * i;
	return result;
}
```

其中 `++i` 这个表达式相当于 `i = i + 1` <sup>[9]</sup>，`++` 称为前缀自增运算符（Prefix Increment Operator），类似地，`--` 称为前缀自减运算符（Prefix Decrement Operator）<sup>[10]</sup>，`--i` 相当于 `i = i - 1`。如果把 `++i` 这个表达式看作一个函数调用，除了传入一个参数返回一个值（等于参数值加 1）之外，还产生一个 Side Effect，就是把变量 `i` 的值增加了 1。

> <sup>[9]</sup> 这两种写法在语义上稍有区别，详见[第 16 章「运算符详解」第 2.1 节「复合赋值运算符」](2-C-语言本质/ch16-运算符详解#_21-复合赋值运算符)。
> 
> <sup>[10]</sup> increment 和 decrement 这两个词很有意思，大多数字典都说它们是名词，但经常被当成动词用，在计算机术语中，它们当动词用应该理解为 increase  by one 和 decrease by  one。现代英语中很多原本是名词的都被当成动词用，字典都跟不上时代了，再比如 transition 也是如此。

`++` 和 `--` 运算符也可以用在变量后面，例如 `i++` 和 `i--`，为了和前缀运算符区别，这两个运算符称为后缀自增运算符（Postfix Increment Operator）和后缀自减运算符（Postfix Decrement Operator）。如果把 `i++` 这个表达式看作一个函数调用，传入一个参数返回一个值，返回值就等于参数值（而不是参数值加 1），此外也产生一个 Side Effect，就是把变量 `i` 的值增加了 1，它和 `++i` 的区别就在于返回值不同。同理，`--i` 返回减 1 之后的值，而 `i--` 返回减 1 之前的值，但这两个表达式都产生同样的 Side Effect，就是把变量 `i` 的值减了 1。

使用 `++`、`--` 运算符会使程序更加简洁，但也会影响程序的可读性，*K&R* 中的示例代码大量运用 `++`、`--` 和其它表达式的组合使得代码非常简洁。为了让初学者循序渐进，在接下来的几章中 `++`、`--` 运算符总是单独组成一个表达式而不跟其它表达式组合，从[第 11 章「排序与查找」](1-C-语言入门/ch11-排序与查找)开始将采用 *K&R* 的简洁风格。

我们看一个有意思的问题：`a+++++b` 这个表达式如何理解？应该理解成 `a++ ++ +b` 还是 `a++ + ++b`，还是 `a + ++ ++b` 呢？应该按第一种方式理解。编译的过程分为词法解析和语法解析两个阶段，在词法解析阶段，编译器总是从前到后找最长的合法 Token。把这个表达式从前到后解析，变量名 `a` 是一个 Token，`a` 后面有两个以上的 `+` 号，在 C 语言中一个 `+` 号是合法的 Token（可以是加法运算符或正号），两个 `+` 号也是合法的 Token（可以是自增运算符），根据最长匹配原则，编译器绝不会止步于一个 `+` 号，而一定会把两个 `+` 号当作一个 Token。再往后解析仍然有两个以上的 `+` 号，所以又是一个 `++` 运算符。再往后解析只剩一个 `+` 号了，是加法运算符。再往后解析是变量名 `b`。词法解析之后进入下一阶段语法解析，`a` 是一个表达式，表达式 `++` 还是表达式，表达式再 `++` 还是表达式，表达式再 `+b` 还是表达式，语法上没有问题。最后编译器会做一些基本的语义分析，这时就有问题了，`++` 运算符要求操作数能做左值，`a` 能做左值所以 `a++` 没问题，但表达式 `a++` 的值只能做右值，不能再 `++` 了，所以最终编译器会报错。

C99 规定了一种新的 `for` 循环语法，在`控制表达式1` 的位置可以有变量定义。例如上例的循环变量 `i` 可以只在 `for` 循环中定义：

```c
int factorial(int n)
{
	int result = 1;
	for(int i = 1; i <= n; i++)
		result = result * i;
	return result;
}
```

如果这样定义，那么变量 `i` 只是 `for` 循环中的局部变量而不是整个函数的局部变量，相当于[第 4 章「分支语句」第 1 节「if 语句」](1-C-语言入门/ch04-分支语句#_1-if-语句)讲过的语句块中的局部变量，在循环结束后就不能再使用 `i` 这个变量了。这个程序用 `gcc` 编译要加上选项 `-std=c99`。这种语法也是从 C++ 借鉴的，考虑到兼容性不建议使用这种写法。

### 1.6.4. break 和 continue 语句

在[第 4 章「分支语句」第 4 节「switch 语句」](1-C-语言入门/ch04-分支语句#_4-switch-语句)中我们见到了 `break` 语句的一种用法，用来跳出 `switch` 语句块，这个语句也可以用来跳出循环体。`continue` 语句也会终止当前循环，和 `break` 语句不同的是，`continue` 语句终止当前循环后又回到循环体的开头准备执行下一次循环。对于`while` 循环和 `do/while` 循环，执行 `continue` 语句之后测试 `控制表达式`，如果值为真则继续执行下一次循环；对于 `for` 循环，执行 `continue` 语句之后首先计算 `控制表达式3`，然后测试 `控制表达式2`，如果值为真则继续执行下一次循环。例如下面的代码打印 1 到 100 之间的素数：

<p id="e6-1">例 6.1. 求 1 ~ 100 的素数</p>

```c
  #include <stdio.h>
  
  int is_prime(int n)
  {
  	int i;
  	for (i = 2; i < n; i++)
  		if (n % i == 0)
  			break;
  	if (i == n)
  		return 1;
  	else
  		return 0;
  }
  
  int main(void)
  {
  	int i;
  	for (i = 1; i <= 100; i++) {
  		if (!is_prime(i))
  			continue;
  		printf("%d\n", i);
  	}
  	return 0;
  }
```

`is_prime` 函数从 2 到 `n-1` 依次检查有没有能被 `n` 整除的数，如果有就说明 `n` 不是素数，立刻跳出循环而不执行 `i++`。因此，如果 `n` 不是素数，则循环结束后 `i` 一定小于 `n`，如果 `n` 是素数，则循环结束后 `i` 一定等于 `n`。注意检查临界条件：2 应该是素数，如果 `n` 是 2，则循环体一次也不执行，但 `i` 的初值就是 2，也等于 `n`，在程序中也判定为素数。其实没有必要从 2 一直检查到 `n-1`，只要从 2 检查到 `⌊sqrt(n)⌋`，如果全都不能整除就足以证明 `n` 是素数了，请读者想一想为什么。

在主程序中，从 1 到 100 依次检查每个数是不是素数，如果不是素数，并不直接跳出循环，而是 `i++` 后继续执行下一次循环，因此用 `continue` 语句。注意主程序的局部变量 `i` 和 `is_prime` 中的局部变量 `i` 是不同的两个变量，其实在调用 `is_prime` 函数时主程序的局部变量 `i` 和参数 `n` 的值相等。

### 1.6.5. 嵌套循环

[上一节求素数的例子](#e6-1)在循环中调用一个函数，而那个函数里面又有一个循环，这其实是一种嵌套循环。如果把那个函数的代码拿出来写就更清楚了：

<p id="e6-2">例 6.2. 用嵌套循环求 1 ~ 100 的素数</p>

```c
  #include <stdio.h>
  
  int main(void)
  {
  	int i, j;
  	for (i = 1; i <= 100; i++) {
  		for (j = 2; j < i; j++)
  			if (i % j == 0)
  				break;
  		if (j == i)
  			printf("%d\n", i);
  	}
  	return 0;
  }
```

现在内循环的循环变量就不能再用 `i` 了，而是改用 `j`，原来程序中 `is_prime` 函数的参数 `n` 现在直接用 `i` 代替。在有多层循环或 `switch` 嵌套的情况下，`break` 只能跳出最内层的循环或 `switch`，`continue` 也只能终止最内层循环并回到该循环的开头。

用循环也可以打印表格式的数据，比如打印小九九乘法表：

<p id="e6-3">例 6.3. 打印小九九</p>

```c
  #include <stdio.h>
  
  int main(void)
  {
  	int i, j;
  	for (i=1; i<=9; i++) {
  		for (j=1; j<=9; j++)
  			printf("%d  ", i*j);
  		printf("\n");
  	}
  	return 0;
  }
```

内循环每次打印一个数，数与数之间用两个空格隔开，外循环每次打印一行。结果如下：

```bash
1	2	3	4	5	6	7	8	9
2	4	6	8	10	12	14	16	18
3	6	9	12	15	18	21	24	27
4	8	12	16	20	24	28	32	36
5	10	15	20	25	30	35	40	45
6	12	18	24	30	36	42	48	54
7	14	21	28	35	42	49	56	63
8	16	24	32	40	48	56	64	72
9	18	27	36	45	54	63	72	81
```

结果有一位数的有两位数的，这个表格很不整齐，如果把打印语句改为 `printf("%d\t", i*j);` 就整齐了，所以 `Tab` 字符称为制表符。

### 1.6.6. goto 语句和标号

分支、循环都讲完了，现在只剩下最后一种影响控制流程的语句了，就是 `goto` 语句，实现无条件跳转。我们知道 `break` 只能跳出最内层的循环，如果在一个嵌套循环中遇到某个错误条件需要立即跳出最外层循环做出错处理，就可以用 `goto` 语句，例如：

```c
for (...)
	for (...) {
		...
		if (出现错误条件)
			goto error;
	}
error:
	出错处理;
```

这里的 `error:` 叫做标号（Label），任何语句前面都可以加若干个标号，每个标号的命名也要遵循标识符的命名规则。

`goto` 语句过于强大了，从程序中的任何地方都可以无条件跳转到任何其它地方，只要在那个地方定义一个标号就行，唯一的限制是 `goto` 只能跳转到同一个函数中的某个标号处，而不能跳到别的函数中<sup>[11]</sup>。**滥用 goto 语句会使程序的控制流程非常复杂，可读性很差**。著名的计算机科学家 Edsger W. Dijkstra 最早指出编程语言中 `goto` 语句的危害，提倡取消 `goto` 语句。`goto` 语句不是必须存在的，显然可以用别的办法替代，比如上面的代码段可以改写为：

```c
int cond = 0; /* bool variable indicating error condition */
for (...) {
	for (...) {
		...
		if (出现错误条件) {
			cond = 1;
			break;
		}
	}
	if (cond)
		break;
}
if (cond)
	出错处理;
```

> <sup>[11]</sup> C 标准库函数 `setjmp` 和 `longjmp` 配合起来可以实现函数间的跳转，但只能从被调用的函数跳回到它的直接或间接调用者（同时从栈空间弹出一个或多个栈帧），而不能从一个函数跳转到另一个和它毫不相干的函数中。`setjmp/longjmp` 函数主要也是用于出错处理，比如函数 `A` 调用函数 `B`，函数 `B` 调用函数 `C`，如果在 `C` 中出现某个错误条件，使得函数 `B` 和 `C` 继续执行下去都没有意义了，可以利用 `setjmp/longjmp` 机制快速返回到函数 `A` 做出错处理，本书不详细介绍这种机制，有兴趣的读者可参考 *APUE2e*。

通常 `goto` 语句只用于这种场合，一个函数中任何地方出现了错误条件都可以立即跳转到函数末尾做出错处理（例如释放先前分配的资源、恢复先前改动过的全局变量等），处理完之后函数返回。比较用 `goto` 和不用 `goto` 的两种写法，用`goto`语句还是方便很多。但是除此之外，在任何其它场合都不要轻易考虑使用 `goto` 语句。有些编程语言（如 C++）中有异常（Exception）处理的语法，可以代替 `goto` 和 `setjmp / longjmp` 的这种用法。

回想一下，我们在[第 4 章「分支语句」第 4 节「switch 语句」](1-C-语言入门/ch04-分支语句#_4-switch-语句)学过 `case` 和 `default` 后面也要跟冒号（`:`，Colon），事实上它们是两种特殊的标号。和标号有关的语法规则如下：

```
语句 → 标识符: 语句
语句 → case 常量表达式: 语句
语句 → default: 语句
```

反复应用这些语法规则进行组合可以在一条语句前面添加多个标号，例如在[第 4 章「分支语句」第 4 节「switch 语句」例 4.2「缺 break 的 switch 语句」](1-C-语言入门/ch04-分支语句#e4-2)的代码中，有些语句前面有多个 `case` 标号。现在我们再看 `switch` 语句的格式：

```c
switch (控制表达式) {
 case 常量表达式： 语句列表
 case 常量表达式： 语句列表
 ...
 default： 语句列表
 }
```

`{}` 里面是一组语句列表，其中每个分支的第一条语句带有 `case` 或 `default` 标号，从语法上来说，`switch` 的语句块和其它分支、循环结构的语句块没有本质区别：

```
语句 → switch (控制表达式) 语句
语句 → { 语句列表 }
```

有兴趣的读者可以在网上查找有关 *Duff's Device* 的资料，*Duff's Device* 是一段很有意思的代码，正是利用 **switch 的语句块和循环结构的语句块没有本质区别**这一点实现了一个巧妙的代码优化。

- 达夫装置

  ```c
  // 等价代码
  #include <stdio.h>

  int duff(int n)
  {
      switch (n) {
      case 0: do { printf("%d\n", 0);
          case 1: printf("%d\n", 1);
          case 2: printf("%d\n", 2);
          case 3: printf("%d\n", 3);
          case 4: printf("%d\n", 4);
          } while (--n > 0);
      }
      return 0;
  }

  int main(int argc, char* argv[])
  {
      return 0;
  }
  ```

## 1.7. 结构体

### 1.7.1. 复合类型与结构体

在编程语言中，最基本的、不可再分的数据类型称为基本类型（Primitive Type），例如整型、浮点型；根据语法规则由基本类型组合而成的类型称为复合类型（Compound Type），例如字符串是由很多字符组成的。有些场合下要把复合类型当作一个整体来用，而另外一些场合下需要分解组成这个复合类型的各种基本类型，复合类型的这种两面性为数据抽象（Data Abstraction）奠定了基础。*SICP* 指出，在学习一门编程语言时要特别注意以下三个方面：

1. 这门语言提供了哪些 Primitive，比如基本类型，比如基本运算符、表达式和语句。
2. 这门语言提供了哪些组合规则，比如基本类型如何组成复合类型，比如简单的表达式和语句如何组成复杂的表达式和语句。
3. 这门语言提供了哪些抽象机制，包括数据抽象和过程抽象（Procedure Abstraction）。

本章以结构体为例讲解数据类型的组合和数据抽象。至于过程抽象，我们在[第 4 章「分支语句」第 2 节「if/else 语句」](1-C-语言入门/ch04-分支语句#_2-ifelse-语句)已经见过最简单的形式，就是把一组语句用一个函数名封装起来，当作一个整体使用，本章将介绍更复杂的过程抽象。

现在我们用 C 语言表示一个复数。从直角座标系来看，复数由实部和虚部组成，从极座标系来看，复数由模和辐角组成，两种座标系可以相互转换，如下图所示：

<p id="c7-1">图 7.1. 复数</p>

![复数](./image/struct.complex.png)

如果用实部和虚部表示一个复数，我们可以写成由两个 `double` 型组成的结构体：

```c
struct complex_struct {
	double x, y;
};
```

这一句定义了标识符 `complex_struct` （同样遵循标识符的命名规则），这种标识符在 C 语言中称为 Tag，`struct complex_struct { double x, y; }` 整个可以看作一个类型名<sup>[12]</sup>，就像 `int` 或 `double` 一样，只不过它是一个复合类型，如果用这个类型名来定义变量，可以这样写：

> <sup>[12]</sup> 其实 C99 已经定义了复数类型 `_Complex`。如果包含 C 标准库的头文件 `complex.h`，也可以用 `complex` 做类型名。当然，只要不包含头文件 `complex.h` 就可以自己定义标识符 `complex`，但为了尽量减少混淆，本章的示例代码都用 `complex_struct` 做标识符而不用 `complex`。

```c
struct complex_struct {
	double x, y;
} z1, z2;
```

这样 `z1` 和 `z2` 就是两个变量名，变量定义后面带个 `;` 号是我们早就习惯的。但即使像先前的例子那样只定义了 `complex_struct` 这个 Tag 而不定义变量，`}` 后面的 `;` 号也不能少。这点一定要注意，类型定义也是一种声明，声明都要以 `;` 号结尾，结构体类型定义的 `}` 后面少 `;` 号是初学者常犯的错误。不管是用上面两种形式的哪一种定义了 `complex_struct` 这个 Tag，以后都可以直接用 `struct complex_struct` 来代替类型名了。例如可以这样定义另外两个复数变量：

```c
struct complex_struct z3, z4;
```

如果在定义结构体类型的同时定义了变量，也可以不必写 Tag，例如：

```c
struct {
	double x, y;
} z1, z2;
```

但这样就没办法再次引用这个结构体类型了，因为它没有名字。每个复数变量都有两个成员（Member） `x` 和 `y`，可以用 `.` 运算符（句号，Period）来访问，这两个成员的存储空间是相邻的<sup>[13]</sup>，合在一起组成复数变量的存储空间。看下面的例子：

> <sup>[13]</sup> 我们在[第 19 章「汇编与 C 之间的关系」第 4 节「结构体和联合体」](2-C-语言本质/ch19-汇编与-C-之间的关系#_4-结构体和联合体)会看到，结构体成员之间也可能有若干个填充字节。

<p id="e7-1">例 7.1. 定义和访问结构体</p>

```c
  #include <stdio.h>
  
  int main(void)
  {
  	struct complex_struct { double x, y; } z;
  	double x = 3.0;	
  	z.x = x;
  	z.y = 4.0;
  	if (z.y < 0)
  		printf("z=%f%fi\n", z.x, z.y);
  	else
  		printf("z=%f+%fi\n", z.x, z.y);
  
  	return 0;
  }
```

注意上例中变量 `x` 和变量 `z` 的成员 `x` 的名字并不冲突，因为变量 `z` 的成员 `x` 只能通过表达式 `z.x` 来访问，编译器可以从语法上区分哪个 `x` 是变量 `x`，哪个 `x` 是变量 `z` 的成员`x`，[第 19 章「汇编与 C 之间的关系」第 3 节「变量的存储布局」](2-C-语言本质/ch19-汇编与-C-之间的关系#_3-变量的存储布局)会讲到这两个标识符 `x` 属于不同的命名空间。

结构体 Tag 也可以定义在全局作用域中，这样定义的 Tag 在其定义之后的各函数中都可以使用。例如：

```c
struct complex_struct { double x, y; };

int main(void)
{
	struct complex_struct z;
	...
}
```

结构体变量也可以在定义时初始化，例如：

```c
struct complex_struct z = { 3.0, 4.0 };
```

Initializer 中的数据依次赋给结构体的各成员。如果 Initializer 中的数据比结构体的成员多，编译器会报错，但如果只是末尾多个逗号则不算错。如果 Initializer 中的数据比结构体的成员少，未指定的成员将用 `0` 来初始化，就像未初始化的全局变量一样。例如以下几种形式的初始化都是合法的：

```c
double x = 3.0;
struct complex_struct z1 = { x, 4.0, }; /* z1.x=3.0, z1.y=4.0 */
struct complex_struct z2 = { 3.0, };    /* z2.x=3.0, z2.y=0.0 */
struct complex_struct z3 = { 0 };       /* z3.x=0.0, z3.y=0.0 */
```

注意，`z1` 必须是局部变量才能用另一个变量 `x` 的值来初始化它的成员，如果是全局变量就只能用常量表达式来初始化。这也是 C99 的新特性，C89 只允许在 `{}` 中使用常量表达式来初始化，无论是初始化全局变量还是局部变量。

`{}` 这种语法不能用于结构体的赋值，例如这样是错误的：

```c
struct complex_struct z1;
z1 = { 3.0, 4.0 };
```

以前我们初始化基本类型的变量所使用的 Initializer 都是表达式，表达式当然也可以用来赋值，但现在这种由 `{}` 括起来的 Initializer 并不是表达式，所以不能用来赋值<sup>[14]</sup>。Initializer 的语法总结如下：

> <sup>[14]</sup> C99 引入一种新的表达式语法 Compound Literal 可以用来赋值，例如 `z1 = (struct complex_struct){ 3.0, 4.0 };`，本书不使用这种新语法。

```
Initializer → 表达式
Initializer → { 初始化列表 } 
初始化列表 → Designated-Initializer, Designated-Initializer, ...
（最后一个 Designated-Initializer 末尾可以有一个多余的 , 号）
Designated-Initializer → Initializer
Designated-Initializer → .标识符 = Initializer
Designated-Initializer → [常量表达式] = Initializer
```

Designated Initializer 是 C99 引入的新特性，用于初始化稀疏（Sparse）结构体和稀疏数组很方便。有些时候结构体或数组中只有某一个或某几个成员需要初始化，其它成员都用 `0` 初始化即可，用 Designated Initializer 语法可以针对每个成员做初始化（Memberwise Initialization），很方便。例如：

```c
struct complex_struct z1 = { .y = 4.0 }; /* z1.x=0.0, z1.y=4.0 */
```

数组的 Memberwise Initialization 语法将在[下一章](1-C-语言入门/ch08-数组)介绍。

结构体类型用在表达式中有很多限制，不像基本类型那么自由，比如 `+ - * /` 等算术运算符和 `&& || !` 等逻辑运算符都不能作用于结构体类型，`if` 语句、`while` 语句中的 `控制表达式` 的值也不能是结构体类型。严格来说：

- 可以做算术运算的类型称为算术类型（Arithmetic Type），算术类型包括整型和浮点型。
- 可以表示零和非零，可以参与逻辑与、或、非运算或者做控制表达式的类型称为标量类型（Scalar Type），标量类型包括算术类型和以后要讲的指针类型，详见[第 23 章「指针」第 9 节「不完全类型和复杂声明」图 23.5 「C 语言类型总结」](2-C-语言本质/ch23-指针#c23-5)。

结构体变量之间使用赋值运算符是允许的，用一个结构体变量初始化另一个结构体变量也是允许的，例如：

```c
struct complex_struct z1 = { 3.0, 4.0 };
struct complex_struct z2 = z1;
z1 = z2;
```

同样地，`z2` 必须是局部变量才能用变量 `z1` 的值来初始化。既然结构体变量之间可以相互赋值和初始化，也就可以当作函数的参数和返回值来传递：

```c
struct complex_struct add_complex(struct complex_struct z1, struct complex_struct z2)
{
	z1.x = z1.x + z2.x;
	z1.y = z1.y + z2.y;
	return z1;
}
```

这个函数实现了两个复数相加，如果在 `main` 函数中这样调用：

```c
struct complex_struct z = { 3.0, 4.0 };
z = add_complex(z, z);
```

那么调用传参的过程如下图所示：

<p id="c7-2">图 7.2. 结构体传参</p>

![结构体传参](./image/struct.parameter.png)

变量 `z` 在 `main` 函数的栈帧上，参数 `z1` 和 `z2` 在 `add_complex` 函数的栈帧上，`z` 的值分别赋给 `z1` 和 `z2`。在这个函数里，`z2` 的实部和虚部被累加到 `z1` 中，然后 `return z1;` 可以看成是：

1. 用 `z1` 初始化一个临时变量。
2. 函数返回并释放栈帧。
3. 把临时变量的值赋给变量 `z`，释放临时变量。

由 `.` 运算符组成的表达式能不能做左值取决于 `.` 运算符左边的表达式能不能做左值。在上面的例子中，`z` 是一个变量，可以做左值，因此表达式 `z.x` 也可以做左值，但表达式 `add_complex(z, z).x` 只能做右值而不能做左值，因为表达式 `add_complex(z, z)` 不能做左值。

### 1.7.2. 数据抽象

现在我们来实现一个完整的复数运算程序。在上一节我们已经定义了复数的结构体类型，现在需要围绕它定义一些函数。复数可以用直角座标或极座标表示，直角座标做加减法比较方便，极座标做乘除法比较方便。如果我们定义的复数结构体是直角座标的，那么应该提供极座标的转换函数，以便在需要的时候可以方便地取它的模和辐角：

```c
  #include <math.h>
  
  struct complex_struct {
  	double x, y;
  };
  
  double real_part(struct complex_struct z)
  {
  	return z.x;
  }
  
  double img_part(struct complex_struct z)
  {
  	return z.y;
  }
  
  double magnitude(struct complex_struct z)
  {
  	return sqrt(z.x * z.x + z.y * z.y);
  }
  
  double angle(struct complex_struct z)
  {
  	return atan2(z.y, z.x);
  }
```

此外，我们还提供两个函数用来构造复数变量，既可以提供直角座标也可以提供极座标，在函数中自动做相应的转换然后返回构造的复数变量：

```c
struct complex_struct make_from_real_img(double x, double y)
{
	struct complex_struct z;
	z.x = x;
	z.y = y;
	return z;
}

struct complex_struct make_from_mag_ang(double r, double A)
{
	struct complex_struct z;
	z.x = r * cos(A);
	z.y = r * sin(A);
	return z;
}
```

在此基础上就可以实现复数的加减乘除运算了：

```c
struct complex_struct add_complex(struct complex_struct z1, struct complex_struct z2)
{
	return make_from_real_img(real_part(z1) + real_part(z2),
				  img_part(z1) + img_part(z2));
}

struct complex_struct sub_complex(struct complex_struct z1, struct complex_struct z2)
{
	return make_from_real_img(real_part(z1) - real_part(z2),
				  img_part(z1) - img_part(z2));
}

struct complex_struct mul_complex(struct complex_struct z1, struct complex_struct z2)
{
	return make_from_mag_ang(magnitude(z1) * magnitude(z2),
				 angle(z1) + angle(z2));
}

struct complex_struct div_complex(struct complex_struct z1, struct complex_struct z2)
{
	return make_from_mag_ang(magnitude(z1) / magnitude(z2),
				 angle(z1) - angle(z2));
}
```

可以看出，复数加减乘除运算的实现并没有直接访问结构体 `complex_struct` 的成员 `x` 和 `y`，而是把它看成一个整体，通过调用相关函数来取它的直角座标和极座标。这样就可以非常方便地替换掉结构体 `complex_struct` 的存储表示，例如改为用极座标来存储：

```c
  #include <math.h>
  
  struct complex_struct {
  	double r, A;
  };
  
  double real_part(struct complex_struct z)
  {
  	return z.r * cos(z.A);
  }
  
  double img_part(struct complex_struct z)
  {
  	return z.r * sin(z.A);
  }
  
  double magnitude(struct complex_struct z)
  {
  	return z.r;
  }
  
  double angle(struct complex_struct z)
  {
  	return z.A;
  }
  
  struct complex_struct make_from_real_img(double x, double y)
  {
  	struct complex_struct z;
  	z.A = atan2(y, x);
  	z.r = sqrt(x * x + y * y);
  }
  
  struct complex_struct make_from_mag_ang(double r, double A)
  {
  	struct complex_struct z;
  	z.r = r;
  	z.A = A;
  	return z;
  }
```

虽然结构体 `complex_struct` 的存储表示做了这样的改动，`add_complex`、`sub_complex`、`mul_complex`、`div_complex` 这几个复数运算的函数却不需要做任何改动，仍然可以用，原因在于这几个函数只把结构体 `complex_struct` 当作一个整体来使用，而没有直接访问它的成员，因此也不依赖于它有哪些成员。我们结合下图具体分析一下。

<p id="c7-3">图 7.3. 数据抽象</p>

![数据抽象](./image/struct.abstraction.png)

这里是一种抽象的思想。其实「抽象」这个概念并没有那么抽象，简单地说就是「提取公因式」： ab+ac=a(b+c)。如果 a 变了，ab 和 ac 这两项都需要改，但如果写成 a(b+c) 的形式就只需要改其中一个因子。

在我们的复数运算程序中，复数有可能用直角座标或极座标来表示，我们把这个有可能变动的因素提取出来组成复数存储表示层：`real_part`、`img_part`、`magnitude`、`angle`、`make_from_real_img`、`make_from_mag_ang`。这一层看到的数据是结构体的两个成员 `x` 和 `y`，或者 `r` 和 `A`，如果改变了结构体的实现就要改变这一层函数的实现，但函数接口不改变，因此调用这一层函数接口的复数运算层也不需要改变。复数运算层看到的数据只是一个抽象的「复数」的概念，知道它有直角座标和极座标，可以调用复数存储表示层的函数得到这些座标。再往上看，其它使用复数运算的程序看到的数据是一个更为抽象的「复数」的概念，只知道它是一个数，像整数、小数一样可以加减乘除，甚至连它有直角座标和极座标也不需要知道。

这里的复数存储表示层和复数运算层称为抽象层（Abstraction Layer），从底层往上层来看，复数越来越抽象了，把所有这些层组合在一起就是一个完整的系统。**组合使得系统可以任意复杂，而抽象使得系统的复杂性是可以控制的，任何改动都只局限在某一层，而不会波及整个系统**。著名的计算机科学家 Butler Lampson 说过：*All problems in computer science can be solved by another level of indirection.* 这里的 indirection 其实就是 abstraction 的意思。

### 1.7.3. 数据类型标志

在上一节中，我们通过一个复数存储表示抽象层把 `complex_struct` 结构体的存储格式和上层的复数运算函数隔开，`complex_struct` 结构体既可以采用直角座标也可以采用极座标存储。但有时候需要同时支持两种存储格式，比如先前已经采集了一些数据存在计算机中，有些数据是以极座标存储的，有些数据是以直角座标存储的，如果要把这些数据都存到 `complex_struct` 结构体中怎么办？一种办法是规定 `complex_struct` 结构体采用直角座标格式，直角座标的数据可以直接存入 `complex_struct` 结构体，而极座标的数据先转成直角座标再存，但由于浮点数的精度有限，转换总是会损失精度的。这里介绍另一种办法，`complex_struct` 结构体由一个数据类型标志和两个浮点数组成，如果数据类型标志为 0，那么两个浮点数就表示直角座标，如果数据类型标志为 1，那么两个浮点数就表示极座标。这样，直角座标和极座标的数据都可以适配（Adapt）到 `complex_struct` 结构体中，无需转换和损失精度：

```c
enum coordinate_type { RECTANGULAR, POLAR };
struct complex_struct {
	enum coordinate_type t;
	double a, b;
};
```

`enum` 关键字的作用和 `struct` 关键字类似，把 `coordinate_type` 这个标识符定义为一个 Tag，`struct complex_struct` 表示一个结构体类型，而 `enum coordinate_type` 表示一个枚举（Enumeration）类型。枚举类型的成员是常量，它们的值由编译器自动分配，例如定义了上面的枚举类型之后，`RECTANGULAR` 就表示常量 0，`POLAR` 表示常量 1。如果不希望从 0 开始分配，可以这样定义：

```c
enum coordinate_type { RECTANGULAR = 1, POLAR };
```

这样，`RECTANGULAR` 就表示常量 1，而 `POLAR` 表示常量 2。枚举常量也是一种整型，其值在编译时确定，因此也可以出现在常量表达式中，可以用于初始化全局变量或者作为 `case` 分支的判断条件。

有一点需要注意，虽然结构体的成员名和变量名不在同一命名空间中，但枚举的成员名却和变量名在同一命名空间中，所以会出现命名冲突。例如这样是不合法的：

```c
int main(void)
{
	enum coordinate_type { RECTANGULAR = 1, POLAR };
	int RECTANGULAR;
	printf("%d %d\n", RECTANGULAR, POLAR);
	return 0;
}
```

`complex_struct` 结构体的格式变了，就需要修改复数存储表示层的函数，但只要保持函数接口不变就不会影响到上层函数。例如：

```c
struct complex_struct make_from_real_img(double x, double y)
{
	struct complex_struct z;
	z.t = RECTANGULAR;
	z.a = x;
	z.b = y;
	return z;
}

struct complex_struct make_from_mag_ang(double r, double A)
{
	struct complex_struct z;
	z.t = POLAR;
	z.a = r;
	z.b = A;
	return z;
}
```

### 1.7.4. 嵌套结构体

结构体也是一种递归定义：结构体的成员具有某种数据类型，而结构体本身也是一种数据类型。换句话说，结构体的成员可以是另一个结构体，即结构体可以嵌套定义。例如我们在复数的基础上定义复平面上的线段：

```c
struct segment {
	struct complex_struct start;
	struct complex_struct end;
};
```

从[本章第 1 节「复合类型与结构体」](#_1-复合类型与结构体)讲的 Initializer 的语法可以看出，Initializer 也可以嵌套，因此嵌套结构体可以嵌套地初始化，例如：

```c
struct segment s = {{ 1.0, 2.0 }, { 4.0, 6.0 }};
```

也可以平坦（Flat）地初始化。例如：

```c
struct segment s = { 1.0, 2.0, 4.0, 6.0 };
```

甚至可以把两种方式混合使用（这样可读性很差，应该避免）：

```c
struct segment s = {{ 1.0, 2.0 }, 4.0, 6.0 };
```

利用 C99 的新特性也可以做 Memberwise Initialization，例如<sup>[15]</sup>：

```c
struct segment s = { .start.x = 1.0, .end.x = 2.0 };
```

> <sup>[15]</sup> 为了便于理解，[本章第 1 节「复合类型与结构体」](#_1-复合类型与结构体)讲的 Initializer 语法并没有描述这种复杂的用法。

访问嵌套结构体的成员要用到多个 `.` 运算符，例如：

```c
s.start.t = RECTANGULAR;
s.start.a = 1.0;
s.start.b = 2.0;
```

## 1.8. 数组

### 1.8.1. 数组的基本概念

数组（Array）也是一种复合数据类型，它由一系列相同类型的元素（Element）组成。例如定义一个由 4 个 `int` 型元素组成的数组 `count`：

```c
int count[4];
```

和结构体成员类似，数组 `count` 的 4 个元素的存储空间也是相邻的。结构体成员可以是基本数据类型，也可以是复合数据类型，数组中的元素也是如此。根据组合规则，我们可以定义一个由 4 个结构体元素组成的数组：

```c
struct complex_struct {
	double x, y;
} a[4];
```

也可以定义一个包含数组成员的结构体：

```c
struct {
	double x, y;
	int count[4];
} s;
```

数组类型的长度应该用一个整数常量表达式来指定<sup>[16]</sup>。数组中的元素通过下标（或者叫索引，Index）来访问。例如前面定义的由 4 个 `int` 型元素组成的数组 `count` 图示如下：

<p id="c8-1">图 8.1. 数组 count</p>

![数组 count](./image/array.count.png)

> <sup>[16]</sup> C99 的新特性允许在数组长度表达式中使用变量，称为变长数组（VLA，Variable Length Array），VLA 只能定义为局部变量而不能是全局变量，与 VLA 有关的语法规则比较复杂，而且很多编译器不支持这种新特性，不建议使用。

整个数组占了 4 个 `int` 型的存储单元，存储单元用小方框表示，里面的数字是存储在这个单元中的数据（假设都是 0），而框外面的数字是下标，这四个单元分别用 `count[0]`、`count[1]`、`count[2]`、`count[3]` 来访问。注意，在定义数组 `int count[4];` 时，方括号（Bracket）中的数字4表示数组的长度，而在访问数组时，方括号中的数字表示访问数组的第几个元素。和我们平常数数不同，数组元素是从「第 0 个」开始数的，大多数编程语言都是这么规定的，所以计算机术语中有 Zeroth 这个词。这样规定使得访问数组元素非常方便，比如 `count` 数组中的每个元素占 4 个字节，则 `count[i]` 表示从数组开头跳过 `4 * i` 个字节之后的那个存储单元。这种数组下标的表达式不仅可以表示存储单元中的值，也可以表示存储单元本身，也就是说可以做左值，因此以下语句都是正确的：

```c
count[0] = 7;
count[1] = count[0] * 2;
++count[2];
```

到目前为止我们学习了五种**后缀运算符**：后缀 `++`、后缀 `--`、结构体取成员 `.`、数组取下标 `[]`、函数调用 `()`。还学习了五种**单目运算符（或者叫前缀运算符）**：前缀 `++`、前缀 `--`、正号 `+`、负号 `-`、逻辑非 `!`。在 C 语言中后缀运算符的优先级最高，单目运算符的优先级仅次于后缀运算符，比其它运算符的优先级都高，所以上面举例的 `++count[2]` 应该看作对 `count[2]` 做前缀 `++` 运算。

数组下标也可以是表达式，但表达式的值必须是整型的。例如：

```c
int i = 10;
count[i] = count[i+1];
```

使用数组下标不能超出数组的长度范围，这一点在使用变量做数组下标时尤其要注意。C 编译器并不检查 `count[-1]` 或是 `count[100]` 这样的访问越界错误，编译时能顺利通过，所以属于运行时错误<sup>[17]</sup>。但有时候这种错误很隐蔽，发生访问越界时程序可能并不会立即崩溃，而执行到后面某个正确的语句时却有可能突然崩溃（在[第 10 章「gdb」第 4 节「段错误」](1-C-语言入门/ch10-gdb#_4-段错误)我们会看到这样的例子）。所以从一开始写代码时就要小心避免出问题，事后依靠调试来解决问题的成本是很高的。

> <sup>[17]</sup> 你可能会想为什么编译器对这么明显的错误都视而不见？理由一，这种错误并不总是显而易见的，在[第 23 章「指针」第 1 节「指针的基本概念」](2-C-语言本质/ch23-指针#_1-指针的基本概念)会讲到通过指针而不是数组名来访问数组的情况，指针指向数组中的什么位置只有运行时才知道，编译时无法检查是否越界，而运行时每次访问数组元素都检查越界会严重影响性能，所以干脆不检查了；理由二，C99 Rationale 指出 C 语言的设计精神是：相信每个 C 程序员都是高手，不要阻止程序员去干他们需要干的事，高手们使用 `count[-1]` 这种技巧其实并不少见，不应该当作错误。

数组也可以像结构体一样初始化，未赋初值的元素也是用 `0` 来初始化，例如：

```c
int count[4] = { 3, 2, };
```

则 `count[0]` 等于 3， `count[1]` 等于 2，后面两个元素等于 0。如果定义数组的同时初始化它，也可以不指定数组的长度，例如：

```c
int count[] = { 3, 2, 1, };
```

编译器会根据 Initializer 有三个元素确定数组的长度为 3。利用 C99 的新特性也可以做 Memberwise Initialization：

```c
int count[4] = { [2] = 3 };
```

下面举一个完整的例子：

<p id="e8-1">例 8.1. 定义和访问数组</p>

```c
  #include <stdio.h>
  
  int main(void)
  {
  	int count[4] = { 3, 2, }, i;
  
  	for (i = 0; i < 4; i++)
  		printf("count[%d]=%d\n", i, count[i]);
  	return 0;
  }
```

这个例子通过循环把数组中的每个元素依次访问一遍，在计算机术语中称为遍历（Traversal）。注意控制表达式 `i < 4`，如果写成 `i <= 4` 就错了，因为 `count[4]` 是访问越界。

数组和结构体虽然有很多相似之处，但也有一个显著的不同：数组不能相互赋值或初始化。例如这样是错的：

```c
int a[5] = { 4, 3, 2, 1 };
int b[5] = a;
```

相互赋值也是错的：

```c
a = b;
```

既然不能相互赋值，也就**不能用数组类型作为函数的参数或返回值**。如果写出这样的函数定义：

```c
void foo(int a[5])
{
	...
}
```

然后这样调用：

```c
int array[5] = {0};
foo(array);
```

编译器也不会报错，但这样写并不是传一个数组类型参数的意思。对于数组类型有一条特殊规则：**数组类型做右值使用时，自动转换成指向数组首元素的指针**。所以上面的函数调用其实是传一个指针类型的参数，而不是数组类型的参数。接下来的几章里有的函数需要访问数组，我们就把数组定义为全局变量给函数访问，等以后讲了指针再使用传参的办法。这也解释了为什么数组类型不能相互赋值或初始化，例如上面提到的 `a = b` 这个表达式，`a` 和 `b` 都是数组类型的变量，但是 `b` 做右值使用，自动转换成指针类型，而左边仍然是数组类型，所以编译器报的错是 `error: incompatible types in assignment`。

### 1.8.2. 数组应用实例：统计随机数

本节通过一个实例介绍使用数组的一些基本模式。问题是这样的：首先生成一列 0 ~ 9 的随机数保存在数组中，然后统计其中每个数字出现的次数并打印，检查这些数字的随机性如何。随机数在某些场合（例如游戏程序）是非常有用的，但是用计算机生成完全随机的数却不是那么容易。计算机执行每一条指令的结果都是确定的，没有一条指令产生的是随机数，调用 C 标准库得到的随机数其实是伪随机（Pseudorandom）数，是用数学公式算出来的确定的数，只不过这些数看起来很随机，并且从统计意义上也很接近均匀分布（Uniform Distribution）的随机数。

C 标准库中生成伪随机数的是 `rand` 函数，使用这个函数需要包含头文件 `stdlib.h`，它没有参数，返回值是一个介于 0 和 `RAND_MAX` 之间的接近均匀分布的整数。`RAND_MAX` 是该头文件中定义的一个常量，在不同的平台上有不同的取值，但可以肯定它是一个非常大的整数。通常我们用到的随机数是限定在某个范围之中的，例如 0 ~ 9，而不是 0 ~ `RAND_MAX`，我们可以用 `%` 运算符将 `rand` 函数的返回值处理一下：

```c
int x = rand() % 10;
```

完整的程序如下：

<p id="e8-2">例 8.2. 生成并打印随机数</p>

```c
  #include <stdio.h>
  #include <stdlib.h>
  #define N 20
  
  int a[N];
  
  void gen_random(int upper_bound)
  {
  	int i;
  	for (i = 0; i < N; i++)
  		a[i] = rand() % upper_bound;
  }
  
  void print_random()
  {
  	int i;
  	for (i = 0; i < N; i++)
  		printf("%d ", a[i]);
  	printf("\n");
  }
  
  int main(void)
  {
  	gen_random(10);
  	print_random();
  	return 0;
  }
```

这里介绍一种新的语法：用 `#define` 定义一个常量。 **实际上编译器的工作分为两个阶段，先是预处理（Preprocess）阶段，然后才是编译阶段，** 用 `gcc` 的 `-E` 选项可以看到预处理之后、编译之前的程序，例如：

```bash
$ gcc -E main.c
...（这里省略了很多行 stdio.h 和 stdlib.h 的代码）

int a[20];

void gen_random(int upper_bound)
{
 int i;
 for (i = 0; i < 20; i++)
  a[i] = rand() % upper_bound;
}

void print_random()
{
 int i;
 for (i = 0; i < 20; i++)
  printf("%d ", a[i]);
 printf("\n");
}

int main(void)
{
 gen_random(10);
 print_random();
 return 0;
}
```

可见在这里预处理器做了两件事情，一是把头文件 `stdio.h` 和 `stdlib.h` 在代码中展开，二是把 `#define` 定义的标识符 `N` 替换成它的定义 20（在代码中做了三处替换，分别位于数组的定义中和两个函数中）。 **像 `#include` 和 `#define` 这种以 `#` 号开头的行称为预处理指示（Preprocessing Directive）** ，我们将在[第 21 章「预处理」](2-C-语言本质/ch21-预处理)学习其它预处理指示。此外，用 `cpp main.c` 命令也可以达到同样的效果，只做预处理而不编译，`cpp` 表示 C preprocessor。

那么用 `#define` 定义的常量和[上一章「结构体」第 3 节「数据类型标志」](1-C-语言入门/ch07-结构体#_3-数据类型标志)讲的枚举常量有什么区别呢？首先， **`define` 不仅用于定义常量，也可以定义更复杂的语法结构，称为宏（Macro）定义** 。 **其次，`define` 定义是在预处理阶段处理的，而枚举是在编译阶段处理的** 试试看把[上一章「结构体」第 3 节「数据类型标志」习题 2](1-C-语言入门/ch07-结构体#习题-1) 的程序改成下面这样是什么结果。

```c
  #include <stdio.h>
  #define RECTANGULAR 1
  #define POLAR 2
  
  int main(void)
  {
  	int RECTANGULAR;
  	printf("%d %d\n", RECTANGULAR, POLAR);
  	return 0;
  }
```

注意，虽然 `include` 和 `define` 在预处理指示中有特殊含义，但它们并不是 C 语言的关键字，换句话说，它们也可以用作标识符，例如声明 `int include;` 或者 `void define(int);`。在预处理阶段，如果一行以 `#` 号开头，后面跟 `include` 或 `define`，预处理器就认为这是一条预处理指示，除此之外出现在其它地方的 `include` 或 `define` 预处理器并不关心，只是当成普通标识符交给编译阶段去处理。

回到随机数这个程序继续讨论，一开始为了便于分析和调试，我们取小一点的数组长度，只生成 20 个随机数，这个程序的运行结果为：

```bash
3 6 7 5 3 5 6 2 9 1 2 7 0 9 3 6 0 6 2 6
```

看起来很随机了。但随机性如何呢？分布得均匀吗？所谓均匀分布，应该每个数出现的概率是一样的。在上面的 20 个结果中，6 出现了 5 次，而 4 和 8 一次也没出现过。但这说明不了什么问题，毕竟我们的样本太少了，才 20 个数，如果样本足够多，比如说 100000 个数，统计一下其中每个数字出现的次数也许能说明问题。但总不能把 100000 个数都打印出来然后挨个去数吧？我们需要写一个函数统计每个数字出现的次数。完整的程序如下：

<p id="e8-3">例 8.3. 统计随机数的分布</p>

```c
  #include <stdio.h>
  #include <stdlib.h>
  #define N 100000
  
  int a[N];
  
  void gen_random(int upper_bound)
  {
  	int i;
  	for (i = 0; i < N; i++)
  		a[i] = rand() % upper_bound;
  }
  
  int howmany(int value)
  {
  	int count = 0, i;
  	for (i = 0; i < N; i++)
  		if (a[i] == value)
  			++count;
  	return count;
  }
  
  int main(void)
  {
  	int i;
  
  	gen_random(10);
  	printf("value\thow many\n");
  	for (i = 0; i < 10; i++)
  		printf("%d\t%d\n", i, howmany(i));
  
  	return 0;
  }
```

我们只要把 `#define N` 的值改为 100000，就相当于把整个程序中所有用到 `N` 的地方都改为 100000 了。如果我们不这么写，而是在定义数组时直接写成 `int a[20];`，在每个循环中也直接使用 20 这个值，这称为硬编码（Hard coding）。如果原来的代码是硬编码的，那么一旦需要把 20 改成 100000 就非常麻烦，你需要找遍整个代码，判断哪些 20 表示这个数组的长度就改为 100000，哪些 20 表示别的数量则不做改动，如果代码很长，这是很容易出错的。所以，**写代码时应尽可能避免硬编码**，这其实也是一个「提取公因式」的过程，和[上一章「结构体」第 2 节「数据抽象」](1-C-语言入门/ch07-结构体#_2-数据抽象)讲的抽象具有相同的作用，就是避免一个地方的改动波及到大的范围。这个程序的运行结果如下：

```bash
$ ./a.out
value    how many
0        10130
1        10072
2        9990
3        9842
4        10174
5        9930
6        10059
7        9954
8        9891
9        9958
```

各数字出现的次数都在 10000 次左右，可见是比较均匀的。

### 1.8.3. 数组应用实例：直方图

继续上面的例子。我们统计一列 0 ~ 9 的随机数，打印每个数字出现的次数，像这样的统计结果称为直方图（Histogram）。有时候我们并不只是想打印，更想把统计结果保存下来以便做后续处理。我们可以把程序改成这样：

```c
int main(void)
{
	int howmanyones = howmany(1);
	int howmanytwos = howmany(2);
	...
}
```

这显然太繁琐了。要是这样的随机数有 100 个呢？显然这里用数组最合适不过了：

```c
int main(void)
{
	int i, histogram[10];

	gen_random(10);
	for (i = 0; i < 10; i++)
		histogram[i] = howmany(i);
	...
}
```

有意思的是，这里的循环变量 `i` 有两个作用，一是作为参数传给 `howmany` 函数，统计数字 `i` 出现的次数，二是做 `histogram` 的下标，也就是「把数字 `i` 出现的次数保存在数组 `histogram` 的第 `i` 个位置」。

尽管上面的方法可以准确地得到统计结果，但是效率很低，这 100000 个随机数需要从头到尾检查十遍，每一遍检查只统计一种数字的出现次数。其实可以把 `histogram` 中的元素当作累加器来用，这些随机数只需要从头到尾检查一遍（Single Pass）就可以得出结果：

```c
int main(void)
{
	int i, histogram[10] = {0};

	gen_random(10);
	for (i = 0; i < N; i++)
		histogram[a[i]]++;
	...
}
```

首先把 `histogram` 的所有元素初始化为 0，注意使用局部变量的值之前一定要初始化，否则值是不确定的。接下来的代码很有意思，在每次循环中，`a[i]` 就是出现的随机数，而这个随机数同时也是 `histogram` 的下标，这个随机数每出现一次就把 `histogram` 中相应的元素加 1。

把上面的程序运行几遍，你就会发现每次产生的随机数都是一样的，不仅如此，在别的计算机上运行该程序产生的随机数很可能也是这样的。这正说明了这些数是伪随机数，是用一套确定的公式基于某个初值算出来的，只要初值相同，随后的整个数列就都相同。实际应用中不可能使用每次都一样的随机数，例如开发一个麻将游戏，每次运行这个游戏摸到的牌不应该是一样的。因此，C 标准库允许我们自己指定一个初值，然后在此基础上生成伪随机数，这个初值称为 Seed，可以用 `srand` 函数指定 Seed。通常我们通过别的途径得到一个不确定的数作为 Seed，例如调用 `time` 函数得到当前系统时间距 `1970 年 1 月 1 日 00:00:00` 的秒数<sup>[18]</sup>，然后传给 `srand`：

```c
srand(time(NULL));
```

然后再调用 `rand`，得到的随机数就和刚才完全不同了。调用 `time` 函数需要包含头文件 `time.h`，这里的 `NULL` 表示空指针，到[第 23 章「指针」第 1 节「指针的基本概念」](2-C-语言本质/ch23-指针#_1-指针的基本概念)再详细解释。

> <sup>[18]</sup> 各种派生自 UNIX 的系统都把这个时刻称为 Epoch，因为 UNIX 系统最早发明于 1969 年。

### 1.8.4. 字符串

之前我一直对字符串避而不谈，不做详细解释，现在已经具备了必要的基础知识，可以深入讨论一下字符串了。字符串可以看作一个数组，它的每个元素是字符型的，例如字符串 `"Hello, world.\n"` 图示如下：

<p id="c8-2">图 8.2. 字符串</p>

![字符串](./image/array.string.png)

注意每个字符**<abbr title="原无此字">串</abbr>**末尾都有一个字符 `'\0'` 做结束符，这里的 `\0` 是 ASCII 码的八进制表示，也就是 ASCII 码为 0 的 `Null` 字符，在 C 语言中这种字符串也称为「以零结尾的字符串」（Null-terminated String）。数组元素可以通过数组名加下标的方式访问，而字符串字面值也可以像数组名一样使用，可以加下标访问其中的字符：

```c
char c = "Hello, world.\n"[0];
```

但是通过下标修改其中的字符却是不允许的：

```c
"Hello, world.\n"[0] = 'A';
```

这行代码会产生编译错误，说字符串字面值是只读的，不允许修改。字符串字面值还有一点和数组名类似，做右值使用时自动转换成指向首元素的指针，在[第 3 章「简单函数」第 3 节「形参和实参」](1-C-语言入门/ch03-简单函数#_3-形参和实参)我们看到 `printf` 原型的第一个参数是指针类型，而 `printf("hello world")` 其实就是传一个指针参数给 `printf`。

前面讲过数组可以像结构体一样初始化，如果是字符数组，也可以用一个字符串字面值来初始化：

```c
char str[10] = "Hello";
```

相当于：

```c
char str[10] = { 'H', 'e', 'l', 'l', 'o', '\0' };
```

`str` 的后四个元素没有指定，自动初始化为 `'\0'`，即 `Null` 字符。注意，虽然字符串字面值 `"Hello"` 是只读的，但用它初始化的数组 `str` 却是可读可写的。数组 `str` 中保存了一串字符，以 `'\0'` 结尾，也可以叫字符串。在本书中只要是以 `Null` 字符结尾的一串字符都叫字符串，不管是像 `str` 这样的数组，还是像 `"Hello"` 这样的字符串字面值。

如果用于初始化的字符串字面值比数组还长，比如：

```c
char str[10] = "Hello, world.\n";
```

则数组 `str` 只包含字符串的前 10 个字符，不包含 `Null` 字符，这种情况编译器会给出警告。如果要用一个字符串字面值准确地初始化一个字符数组，最好的办法是不指定数组的长度，让编译器自己计算：

```c
char str[] = "Hello, world.\n";
```

字符串字面值的长度包括 `Null` 字符在内一共 15 个字符，编译器会确定数组 `str` 的长度为 15。

有一种情况需要特别注意，如果用于初始化的字符串字面值比数组刚好长出一个 `Null` 字符的长度，比如：

```c
char str[14] = "Hello, world.\n";
```

则数组 `str` 不包含 `Null` 字符，并且编译器不会给出警告，C99 Rationale 说这样规定是为程序员方便，以前的很多编译器都是这样实现的，不管它有理没理，C 标准既然这么规定了我们也没办法，只能自己小心了。

补充一点，`printf` 函数的格式化字符串中可以用 `%s` 表示字符串的占位符。在学字符数组以前，我们用 `%s` 没什么意义，因为

```c
printf("string: %s\n", "Hello");
```

还不如写成

```c
printf("string: Hello\n");
```

但现在字符串可以保存在一个数组里面，用 `%s` 来打印就很有必要了：

```c
printf("string: %s\n", str);
```

`printf` 会从数组 `str` 的开头一直打印到 `Null` 字符为止，`Null` 字符本身是 Non-printable 字符，不打印。这其实是一个危险的信号：如果数组 `str` 中没有 `Null` 字符，那么 `printf` 函数就会访问数组越界，后果可能会很诡异：有时候打印出乱码，有时候看起来没错误，有时候引起程序崩溃。

### 1.8.5. 多维数组

就像结构体可以嵌套一样，数组也可以嵌套，一个数组的元素可以是另外一个数组，这样就构成了多维数组（Multi-dimensional Array）。例如定义并初始化一个二维数组：

```c
int a[3][2] = { 1, 2, 3, 4, 5 };
```

数组 `a` 有 3 个元素，`a[0]`、`a[1]`、`a[2]`。每个元素也是一个数组，例如 `a[0]` 是一个数组，它有两个元素 `a[0][0]`、`a[0][1]`，这两个元素的类型是 `int`，值分别是 1、2，同理，数组 `a[1]` 的两个元素是 3、4，数组 `a[2]`的两个元素是 5、0。如下图所示：

<p id="c8-3">图 8.3. 多维数组</p>

![多维数组](./image/array.multidim.png)

从概念模型上看，这个二维数组是三行两列的表格，元素的两个下标分别是行号和列号。从物理模型上看，这六个元素在存储器中仍然是连续存储的，就像一维数组一样，相当于把概念模型的表格一行一行接起来拼成一串，C 语言的这种存储方式称为 Row-major 方式，而有些编程语言（例如 FORTRAN）是把概念模型的表格一列一列接起来拼成一串存储的，称为 Column-major 方式。

多维数组也可以像嵌套结构体一样用嵌套 Initializer 初始化，例如上面的二维数组也可以这样初始化：

```c
int a[][2] = { { 1, 2 },
		{ 3, 4 },
		{ 5, } };
```

**注意，除了第一维的长度可以由编译器自动计算而不需要指定，其余各维都必须明确指定长度** 。利用 C99 的新特性也可以做 Memberwise Initialization，例如：

```c
int a[3][2] = { [0][1] = 9, [2][1] = 8 };
```

结构体和数组嵌套的情况也可以做 Memberwise Initialization，例如：

```c
struct complex_struct {
	double x, y;
} a[4] = { [0].x = 8.0 };

struct {
	double x, y;
	int count[4];
} s = { .count[2] = 9 };
```

如果是多维字符数组，也可以嵌套使用字符串字面值做 Initializer，例如：

<p id="e8-4">例 8.4. 多维字符数组</p>

```c
  #include <stdio.h>
  
  void print_day(int day)
  {
  	char days[8][10] = { "", "Monday", "Tuesday",
  			     "Wednesday", "Thursday", "Friday",
  			     "Saturday", "Sunday" };
  
  	if (day < 1 || day > 7)
  		printf("Illegal day number!\n");
  	printf("%s\n", days[day]);
  }
  
  int main(void)
  {
  	print_day(2);
  	return 0;
  }
```

<p id="c8-4">图 8.4. 多维字符数组</p>

![多维字符数组](./image/array.multichar.png)

这个程序中定义了一个多维字符数组 `char days[8][10];`，为了使 1 ~ 7 刚好映射到 `days[1]~days[7]`，我们把 `days[0]` 空出来不用，所以第一维的长度是 8，为了使最长的字符串 `"Wednesday"` 能够保存到一行，末尾还能多出一个 Null 字符的位置，所以第二维的长度是 10。

这个程序和[第 4 章「分支语句」例 4.1「switch 语句」](104#e4-1)的功能其实是一样的，但是代码简洁多了。简洁的代码不仅可读性强，而且维护成本也低，像[第 4 章「分支语句」例 4.1「switch 语句」](1-C-语言入门/ch04-分支语句#e4-1)那样一堆 `case`、`printf` 和 `break`，如果漏写一个 `break` 就要出 Bug。这个程序之所以简洁，是因为用数据代替了代码。具体来说，通过下标访问字符串组成的数组可以代替一堆 `case` 分支判断，这样就可以把每个 `case` 里重复的代码（`printf` 调用）提取出来，从而又一次达到了「提取公因式」的效果。这种方法称为**数据驱动的编程**（Data-driven Programming），写代码最重要的是选择正确的数据结构来组织信息，设计控制流程和算法尚在其次，只要数据结构选择得正确，其它代码自然而然就变得容易理解和维护了，就像这里的 `printf` 自然而然就被提取出来了。*人月神话*中说过：*Show  me your flowcharts and conceal your tables, and I shall continue to be  mystified. Show me your tables, and I won't usually need your  flowcharts; they'll be obvious.*

最后，综合本章的知识，我们来写一个最简单的小游戏——剪刀石头布：

<p id="e8-5">例 8.5. 剪刀石头布</p>

```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <time.h>
  
  int main(void)
  {
  	char gesture[3][10] = { "scissor", "stone", "cloth" };
  	int man, computer, result, ret;
  
  	srand(time(NULL));
  	while (1) {
  		computer = rand() % 3;
  	  	printf("\nInput your gesture (0-scissor 1-stone 2-cloth):\n");
  		ret = scanf("%d", &man);
  	  	if (ret != 1 || man < 0 || man > 2) {
  			printf("Invalid input! Please input 0, 1 or 2.\n");
  			continue;
  		}
  		printf("Your gesture: %s\tComputer's gesture: %s\n", 
  			gesture[man], gesture[computer]);
  
  		result = (man - computer + 4) % 3 - 1;
  		if (result > 0)
  			printf("You win!\n");
  		else if (result == 0)
  			printf("Draw!\n");
  		else
  			printf("You lose!\n");
  	}
  	return 0;
  }
```

0、1、2 三个整数分别是「剪刀、石头、布」在程序中的内部表示，用户也要求输入 0、1 或 2，然后和计算机随机生成的 0、1 或 2 比胜负。这个程序的主体是一个死循环，需要按 `Ctrl-C` 退出程序。以往我们写的程序都只有打印输出，在这个程序中我们第一次碰到处理用户输入的情况。我们简单介绍一下 `scanf` 函数的用法，到[第 25 章「C 标准库」第 2.9 节「格式化 I/O 函数」](2-C-语言本质/ch25-C-标准库#_29-格式化-IO-函数)再详细解释。`scanf("%d", &man)` 这个调用的功能是等待用户输入一个整数并回车，这个整数会被 `scanf` 函数保存在 `man` 这个整型变量里。如果用户输入合法（输入的确实是数字而不是别的字符），则 `scanf` 函数返回 1，表示成功读入一个数据。但即使用户输入的是整数，我们还需要进一步检查是不是在 0 ~ 2 的范围内，写程序时对用户输入要格外小心，用户有可能输入任何数据，他才不管游戏规则是什么。

和 `printf` 类似，`scanf` 也可以用 `%c`、`%f`、`%s` 等转换说明。如果在传给 `scanf` 的第一个参数中用 `%d`、`%f`或 `%c` 表示读入一个整数、浮点数或字符，则第二个参数的形式应该是 `&` 运算符加相应类型的变量名，表示读进来的数保存到这个变量中，`&` 运算符的作用是得到一个指针类型，到[第 23 章「指针」第 1 节「指针的基本概念」](2-C-语言本质/ch23-指针#_1-指针的基本概念)再详细解释；如果在第一个参数中用 `%s` 读入一个字符串，则第二个参数应该是数组名，数组名前面不加 `&`，因为数组类型做右值时自动转换成指针类型，在[第 10 章「gdb」第 2 节「断点」](1-C-语言入门/ch10-gdb#_2-断点)有 `scanf` 读入字符串的例子。

留给读者思考的问题是：`(man - computer + 4) % 3 - 1` 这个神奇的表达式是如何比较出 0、1、2 这三个数字在「剪刀石头布」意义上的大小的？

## 1.9. 编码风格

代码风格好不好就像字写得好不好看一样，如果一个公司招聘秘书，肯定不要字写得难看的，同理，代码风格糟糕的程序员肯定也是不称职的。虽然编译器不会挑剔难看的代码，照样能编译通过，但是和你一个 Team 的其他程序员肯定受不了，你自己也受不了，写完代码几天之后再来看，自己都不知道自己写的是什么。*SICP* 里有句话说得好：*Thus, programs must be written for people to read, and only incidentally for machines to execute.* 代码主要是为了写给人看的，而不是写给机器看的，只是顺便也能用机器执行而已，如果是为了写给机器看那直接写机器指令就好了，没必要用高级语言了。代码和语言文字一样是为了表达思想、记载信息，所以一定要写得清楚整洁才能有效地表达。正因为如此，在一个软件项目中，代码风格一般都用文档规定死了，所有参与项目的人不管他自己原来是什么风格，都要遵守统一的风格，例如 Linux 内核的 *CodingStyle* 就是这样一个文档。本章我们以内核的代码风格为基础来讲解好的编码风格都有哪些规定，这些规定的 Rationale 是什么。我只是以 Linux 内核为例来讲解编码风格的概念，并没有说内核编码风格就一定是最好的编码风格，但 Linux 内核项目如此成功，就足以说明它的编码风格是最好的 C 语言编码风格之一了。

### 1.9.1. 缩进和空白

我们知道 C 语言的语法对缩进和空白没有要求，空格、`Tab`、换行都可以随意写，实现同样功能的代码可以写得很好看，也可以写得很难看。例如上一章[第 8 章「数组」第 5 节「多维数组」例 8.5「剪刀石头布」](1-C-语言入门/ch08-数组#e8-5)的代码如果写成这样就很难看了：

<p id="e9-1">例 9.1. 缺少缩进和空白的代码</p>

```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <time.h>
  int main(void)
  {
  char gesture[3][10]={"scissor","stone","cloth"};
  int man,computer,result, ret;
  srand(time(NULL));
  while(1){
  computer=rand()%3;
  printf("\nInput your gesture (0-scissor 1-stone 2-cloth):\n");
  ret=scanf("%d",&man);
  if(ret!=1||man<0||man>2){
  printf("Invalid input! Please input 0, 1 or 2.\n");
  continue;
  }
  printf("Your gesture: %s\tComputer's gesture: %s\n",gesture[man],gesture[computer]);
  result=(man-computer+4)%3-1;
  if(result>0)printf("You win!\n");
  else if(result==0)printf("Draw!\n");
  else printf("You lose!\n");
  }
  return 0;
  }
```

一是缺少空白字符，代码密度太大，看着很费劲。二是没有缩进，看不出来哪个 `{` 和哪个 `}` 配对，像这么短的代码还能凑合着看，如果代码超过一屏就完全没法看了。*CodingStyle* 中关于空白字符并没有特别规定，因为基本上所有的 C 代码风格对于空白字符的规定都差不多，主要有以下几条。

1. 关键字 `if`、`while`、`for` 与其后的控制表达式的(括号之间插入一个空格分隔，但括号内的表达式应紧贴括号。例如：
	
	```c
	while␣(1);
	```
	
2. 双目运算符的两侧各插入一个空格分隔，单目运算符和操作数之间不加空格，例如 `i␣=␣i␣+␣1`、`++i`、`!(i␣<␣1)`、`-x`、`&a[1]` 等。
3. 后缀运算符和操作数之间也不加空格，例如取结构体成员 `s.a`、函数调用 `foo(arg1)`、取数组成员 `a[i]`。
4. `,` 号和 `;` 号之后要加空格，这是英文的书写习惯，例如 `for␣(i␣=␣1;␣i␣<␣10;␣i++)`、`foo(arg1,␣arg2)`。
5. 以上关于双目运算符和后缀运算符的规则并没有严格要求，有时候为了突出优先级也可以写得更紧凑一些，例如 `for␣(i=1;␣i<10;␣i++)`、`distance␣=␣sqrt(x*x␣+␣y*y)` 等。但是省略的空格一定不要误导了读代码的人，例如 `a||b␣&&␣c` 很容易让人理解成错误的优先级。
6. 由于 UNIX 系统标准的字符终端是 24 行 80 列的，接近或大于 80 个字符的较长语句要折行写，折行后用空格和上面的表达式或参数对齐，例如：
	
	```c
	if␣(sqrt(x*x␣+␣y*y)␣>␣5.0
	    &&␣x␣<␣0.0
	    &&␣y␣>␣0.0)
	```
	
	再比如：
	
	```c
	foo(sqrt(x*x␣+␣y*y),
	    a[i-1]␣+␣b[i-1]␣+␣c[i-1])
	```
	
7. 较长的字符串可以断成多个字符串然后分行书写，例如：
	
	```c
	printf("This is such a long sentence that "
	       "it cannot be held within a line\n");
	```
	
	C 编译器会自动把相邻的多个字符串接在一起，以上两个字符串相当于一个字符串 `"This is such a long sentence that it cannot be held within a line\n"`。
8. 有的人喜欢在变量定义语句中用 `Tab` 字符，使变量名对齐，这样看起来很美观。
	
	```c
	       →int    →a, b;
	       →double →c;
	```
	

内核代码风格关于缩进的规则有以下几条。

1. 要用缩进体现出语句块的层次关系，使用 `Tab` 字符缩进，不能用空格代替 `Tab`。在标准的字符终端上一个 `Tab` 看起来是 8 个空格的宽度，如果你的文本编辑器可以设置 `Tab` 的显示宽度是几个空格，建议也设成 8，这样大的缩进使代码看起来非常清晰。如果有的行用空格做缩进，有的行用 `Tab` 做缩进，甚至空格和 `Tab` 混用，那么一旦改变了文本编辑器的 `Tab` 显示宽度就会看起来非常混乱，所以内核代码风格规定只能用 `Tab` 做缩进，不能用空格代替 `Tab`。
2. `if/else`、`while`、`do/while`、`for`、`switch` 这些可以带语句块的语句，语句块的 `{` 或 `}` 应该和关键字写在同一行，用空格隔开，而不是单独占一行。例如应该这样写：
	
	```c
	if␣(...)␣{
	       →语句列表
	}␣else␣if␣(...)␣{
	       →语句列表
	}
	```
	
	但很多人习惯这样写：
	
	```c
	if␣(...)
	{
	       →语句列表
	}
	else␣if␣(...)
	{
	       →语句列表
	}
	```
	
	内核的写法和 *K&R* 一致，好处是不必占太多行，使得一屏能显示更多代码。这两种写法用得都很广泛，只要在同一个项目中能保持统一就可以了。
3. 函数定义的 `{` 和 `}` 单独占一行，这一点和语句块的规定不同，例如：
	
	```c
	int␣foo(int␣a,␣int␣b)
	{
	       →语句列表
	}
	```
	
4. `switch` 和语句块里的 `case`、`default` 对齐写，也就是说语句块里的 `case`、`default` 标号相对于 `switch` 不往里缩进，但标号下的语句要往里缩进。例如：
	
	```c
	      →switch␣(c)␣{
	      →case 'A':
	      →       →语句列表
	      →case 'B':
	      →       →语句列表
	      →default:
	      →       →语句列表
	      →}
	```
	
	用于 `goto` 语句的自定义标号应该顶头写不缩进，而不管标号下的语句缩进到第几层。
	
5. 代码中每个逻辑段落之间应该用一个空行分隔开。例如每个函数定义之间应该插入一个空行，头文件、全局变量定义和函数定义之间也应该插入空行，例如：
	
	```c
	#include <stdio.h>
	#include <stdlib.h>
	
	int g;
	double h;
	
	int foo(void)
	{
	       →语句列表
	}
	
	int bar(int a)
	{
	       →语句列表
	}
	
	int main(void)
	{
	       →语句列表
	}
	```
	
6. 一个函数的语句列表如果很长，也可以根据相关性分成若干组，用空行分隔。这条规定不是严格要求，通常把变量定义组成一组，后面加空行，`return` 语句之前加空行，例如：
	
	```c
	int main(void)
	{
	       →int    →a, b;
	       →double →c;
	
	       →语句组1
	
	       →语句组2
	
	       →return 0;
	}
	```

### 1.9.2. 注释

单行注释应采用 `/*␣comment␣*/` 的形式，用空格把界定符和文字分开。多行注释最常见的是这种形式：

```c
/*
␣*␣Multi-line
␣*␣comment
␣*/
```

也有更花哨的形式：

```c
/*************\
* Multi-line  *
* comment     *
\*************/
```

使用注释的场合主要有以下几种。

1. 整个源文件的顶部注释。说明此模块的相关信息，例如文件名、作者和版本历史等，顶头写不缩进。例如内核源代码目录下的 `kernel/sched.c` 文件的开头：
	
	```
	/*
	 *  kernel/sched.c
	 *
	 *  Kernel scheduler and related syscalls
	 *
	 *  Copyright (C) 1991-2002  Linus Torvalds
	 *
	 *  1996-12-23  Modified by Dave Grothe to fix bugs in semaphores and
	 *              make semaphores SMP safe
	 *  1998-11-19  Implemented schedule_timeout() and related stuff
	 *              by Andrea Arcangeli
	 *  2002-01-04  New ultra-scalable O(1) scheduler by Ingo Molnar:
	 *              hybrid priority-list and round-robin design with
	 *              an array-switch method of distributing timeslices
	 *              and per-CPU runqueues.  Cleanups and useful suggestions
	 *              by Davide Libenzi, preemptible kernel bits by Robert Love.
	 *  2003-09-03  Interactivity tuning by Con Kolivas.
	 *  2004-04-02  Scheduler domains code by Nick Piggin
	 */
	```
	
2. 函数注释。说明此函数的功能、参数、返回值、错误码等，写在函数定义上侧，和此函数定义之间不留空行，顶头写不缩进。
3. 相对独立的语句组注释。对这一组语句做特别说明，写在语句组上侧，和此语句组之间不留空行，与当前语句组的缩进一致。
4. 代码行右侧的简短注释。对当前代码行做特别说明，一般为单行注释，和代码之间至少用一个空格隔开，一个源文件中所有的右侧注释最好能上下对齐。尽管[第 2 章「常量、变量和表达式」第 1 节「继续 Hello World」例 2.1「带更多注释的Hello World」](1-C-语言入门/ch02-常量、变量和表达式#e2-1)讲过注释可以穿插在一行代码中间，但不建议这么写。内核源代码目录下的 `lib/radix-tree.c` 文件中的一个函数包含了上述三种注释：
	
	```c
	/**
	 *      radix_tree_insert    -    insert into a radix tree
	 *      @root:          radix tree root
	 *      @index:         index key
	 *      @item:          item to insert
	 *
	 *      Insert an item into the radix tree at position @index.
	 */
	int radix_tree_insert(struct radix_tree_root *root,
	                        unsigned long index, void *item)
	{
	        struct radix_tree_node *node = NULL, *slot;
	        unsigned int height, shift;
	        int offset;
	        int error;
	
	        /* Make sure the tree is high enough.  */
	        if ((!index && !root->rnode) ||
	                        index > radix_tree_maxindex(root->height)) {
	                error = radix_tree_extend(root, index);
	                if (error)
	                        return error;
	        }
	
	        slot = root->rnode;
	        height = root->height;
	        shift = (height-1) * RADIX_TREE_MAP_SHIFT;
	
	        offset = 0;                     /* uninitialised var warning */
	        do {
	                if (slot == NULL) {
	                        /* Have to add a child node.  */
	                        if (!(slot = radix_tree_node_alloc(root)))
	                                return -ENOMEM;
	                        if (node) {
	                                node->slots[offset] = slot;
	                                node->count++;
	                        } else
	                                root->rnode = slot;
	                }
	
	                /* Go a level down */
	                offset = (index >> shift) & RADIX_TREE_MAP_MASK;
	                node = slot;
	                slot = node->slots[offset];
	                shift -= RADIX_TREE_MAP_SHIFT;
	                height--;
	        } while (height > 0);
	
	        if (slot != NULL)
	                return -EEXIST;
	
	        BUG_ON(!node);
	        node->count++;
	        node->slots[offset] = item;
	        BUG_ON(tag_get(node, 0, offset));
	        BUG_ON(tag_get(node, 1, offset));
	
	        return 0;
	}
	```
	
	*CodingStyle* 中特别指出，函数内的注释要尽可能少用。写注释主要是为了说明你的代码「能做什么」（比如函数接口定义），而不是为了说明「怎样做」，只要代码写得足够清晰，「怎样做」是一目了然的，如果你需要用注释才能解释清楚，那就表示你的代码可读性很差，除非是特别需要提醒注意的地方才使用函数内注释。
5. 复杂的结构体定义比函数更需要注释。例如内核源代码目录下的 `kernel/sched.c` 文件中定义了这样一个结构体：
	
	```c
	/*
	 * This is the main, per-CPU runqueue data structure.
	 *
	 * Locking rule: those places that want to lock multiple runqueues
	 * (such as the load balancing or the thread migration code), lock
	 * acquire operations must be ordered by ascending &runqueue.
	 */
	struct runqueue {
	        spinlock_t lock;
	
	        /*
	         * nr_running and cpu_load should be in the same cacheline because
	         * remote CPUs use both these fields when doing load calculation.
	         */
	        unsigned long nr_running;
	#ifdef CONFIG_SMP
	        unsigned long cpu_load[3];
	#endif
	        unsigned long long nr_switches;
	
	        /*
	         * This is part of a global counter where only the total sum
	         * over all CPUs matters. A task can increase this counter on
	         * one CPU and if it got migrated afterwards it may decrease
	         * it on another CPU. Always updated under the runqueue lock:
	         */
	        unsigned long nr_uninterruptible;
	
	        unsigned long expired_timestamp;
	        unsigned long long timestamp_last_tick;
	        task_t *curr, *idle;
	        struct mm_struct *prev_mm;
	        prio_array_t *active, *expired, arrays[2];
	        int best_expired_prio;
	        atomic_t nr_iowait;
	
	#ifdef CONFIG_SMP
	        struct sched_domain *sd;
	
	        /* For active balancing */
	        int active_balance;
	        int push_cpu;
	
	        task_t *migration_thread;
	        struct list_head migration_queue;
	        int cpu;
	#endif
	
	#ifdef CONFIG_SCHEDSTATS
	        /* latency stats */
	        struct sched_info rq_sched_info;
	
	        /* sys_sched_yield() stats */
	        unsigned long yld_exp_empty;
	        unsigned long yld_act_empty;
	        unsigned long yld_both_empty;
	        unsigned long yld_cnt;
	
	        /* schedule() stats */
	        unsigned long sched_switch;
	        unsigned long sched_cnt;
	        unsigned long sched_goidle;
	
	        /* try_to_wake_up() stats */
	        unsigned long ttwu_cnt;
	        unsigned long ttwu_local;
	#endif
	};
	```
	
6. 复杂的宏定义和变量声明也需要注释。例如内核源代码目录下的 `include/linux/jiffies.h` 文件中的定义：
	
	```c
	/* TICK_USEC_TO_NSEC is the time between ticks in nsec assuming real ACTHZ and  */
	/* a value TUSEC for TICK_USEC (can be set bij adjtimex)                */
	#define TICK_USEC_TO_NSEC(TUSEC) (SH_DIV (TUSEC * USER_HZ * 1000, ACTHZ, 8))
	
	/* some arch's have a small-data section that can be accessed register-relative
	 * but that can only take up to, say, 4-byte variables. jiffies being part of
	 * an 8-byte variable may not be correctly accessed unless we force the issue
	 */
	#define __jiffy_data  __attribute__((section(".data")))
	
	/*
	 * The 64-bit value is not volatile - you MUST NOT read it
	 * without sampling the sequence number in xtime_lock.
	 * get_jiffies_64() will do this for you as appropriate.
	 */
	extern u64 __jiffy_data jiffies_64;
	extern unsigned long volatile __jiffy_data jiffies;
	```
	
### 1.9.3. 标识符命名

标识符命名应遵循以下原则：

1. 标识符命名要清晰明了，可以使用完整的单词和易于理解的缩写。短的单词可以通过去元音形成缩写，较长的单词可以取单词的头几个字母形成缩写。看别人的代码看多了就可以总结出一些缩写惯例，例如 `count` 写成 `cnt`，`block` 写成 `blk`，`length` 写成 `len`，`window` 写成 `win`，`message` 写成 `msg`，`number` 写成 `nr`，`temporary` 可以写成 `temp`，也可以进一步写成 `tmp`，最有意思的是 `internationalization` 写成 `i18n`，词根 `trans` 经常缩写成 `x`，例如 `transmit` 写成 `xmt`。我就不多举例了，请读者在看代码时自己注意总结和积累。
2. 内核编码风格规定变量、函数和类型采用全小写加下划线的方式命名，常量（比如宏定义和枚举常量）采用全大写加下划线的方式命名，比如上一节举例的函数名 `radix_tree_insert`、类型名 `struct radix_tree_root`、常量名 `RADIX_TREE_MAP_SHIFT` 等。

	微软发明了一种变量命名法叫匈牙利命名法（Hungarian notation），在变量名中用前缀表示类型，例如 `iCnt`（i 表示 int）、`pMsg`（p 表示 pointer）、`lpszText`（lpsz 表示 long pointer to a zero-ended string）等。Linus 在 *CodingStyle* 中毫不客气地讽刺了这种写法：*Encoding  the type of a function into the name (so-called Hungarian notation) is  brain damaged - the compiler knows the types anyway and can check those,  and it only confuses the programmer.  No wonder MicroSoft makes buggy  programs.* 代码风格本来就是一个很有争议的问题，如果你接受本章介绍的内核编码风格（也是本书所有范例代码的风格），就不要使用大小写混合的变量命名方式<sup>[19]</sup>，更不要使用匈牙利命名法。

	> <sup>[19]</sup> 大小写混合的命名方式是 Modern C++ 风格所提倡的，在 C++ 代码中很普遍，称为 CamelCase，大概是因为有高有低像驼峰一样。

3. 全局变量和全局函数的命名一定要详细，不惜多用几个单词多写几个下划线，例如函数名`radix_tree_insert`，因为它们在整个项目的许多源文件中都会用到，必须让使用者明确这个变量或函数是干什么用的。局部变量和只在一个源文件中调用的内部函数的命名可以简略一些，但不能太短。尽量不要使用单个字母做变量名，只有一个例外：用 `i`、`j`、`k` 做循环变量是可以的。
4. 针对中国程序员的一条特别规定：禁止用汉语拼音做标识符，可读性极差。

### 1.9.4. 函数

每个函数都应该设计得尽可能简单，简单的函数才容易维护。应遵循以下原则：

1. 实现一个函数只是为了做好一件事情，不要把函数设计成用途广泛、面面俱到的，这样的函数肯定会超长，而且往往不可重用，维护困难。
2. 函数内部的缩进层次不宜过多，一般以少于 4 层为宜。如果缩进层次太多就说明设计得太复杂了，应考虑分割成更小的函数（Helper Function）来调用。
3. 函数不要写得太长，建议在 24 行的标准终端上不超过两屏，太长会造成阅读困难，如果一个函数超过两屏就应该考虑分割函数了。*CodingStyle* 中特别说明，如果一个函数在概念上是简单的，只是长度很长，这倒没关系。例如函数由一个大的 `switch` 组成，其中有非常多的 `case`，这是可以的，因为各 `case` 分支互不影响，整个函数的复杂度只等于其中一个 `case` 的复杂度，这种情况很常见，例如 TCP 协议的状态机实现。
4. 执行函数就是执行一个动作，函数名通常应包含动词，例如 `get_current`、`radix_tree_insert`。
5. 比较重要的函数定义上侧必须加注释，说明此函数的功能、参数、返回值、错误码等。
6. 另一种度量函数复杂度的办法是看有多少个局部变量，5 到 10 个局部变量已经很多了，再多就很难维护了，应该考虑分割成多个函数。

### 1.9.5. indent 工具

indent 工具可以把代码格式化成某种风格，例如把[本章第 1 节例 9.1「缺少缩进和空白的代码」](#e9-1)格式化成内核编码风格：

```bash
  $ indent -kr -i8 main.c 
  $ cat main.c
  #include <stdio.h>
  #include <stdlib.h>
  #include <time.h>
  int main(void)
  {
  	char gesture[3][10] = { "scissor", "stone", "cloth" };
  	int man, computer, result, ret;
  	srand(time(NULL));
  	while (1) {
  		computer = rand() % 3;
  		printf
  		    ("\nInput your gesture (0-scissor 1-stone 2-cloth):\n");
  		ret = scanf("%d", &man);
  		if (ret != 1 || man < 0 || man > 2) {
  			printf("Invalid input! Please input 0, 1 or 2.\n");
  			continue;
  		}
  		printf("Your gesture: %s\tComputer's gesture: %s\n",
  		       gesture[man], gesture[computer]);
  		result = (man - computer + 4) % 3 - 1;
  		if (result > 0)
  			printf("You win!\n");
  		else if (result == 0)
  			printf("Draw!\n");
  		else
  			printf("You lose!\n");
  	}
  	return 0;
  }
```

`-kr` 选项表示 K&R 风格，`-i8` 表示缩进 8 个空格的长度。如果没有指定 `-nut` 选项，则每 8 个缩进空格会自动用一个 `Tab` 代替。注意 indent 命令会直接修改原文件，而不是打印到屏幕上或者输出到另一个文件，这一点和很多 UNIX 命令不同。可以看出，`-kr -i8` 两个选项格式化出来的代码已经很符合本章介绍的代码风格了，添加了必要的缩进和空白，较长的代码行也会自动折行。美中不足的是没有添加适当的空行，因为 indent 工具也不知道哪几行代码在逻辑上是一组的，空行还是要自己动手添，当然原有的空行肯定不会被 indent 删去的。

如果你采纳本章介绍的*内核编码风格*，基本上 `-kr -i8` 这两个参数就够用了。indent 工具也有支持其它编码风格的选项，具体请参考 Man Page。有时候 indent 工具的确非常有用，比如某个项目中途决定改变编码风格（这很少见），或者往某个项目中添加的几个代码文件来自另一个编码风格不同的项目，但绝不能因为有了 indent 工具就肆无忌惮，一开始把代码写得乱七八糟，最后再依靠 indent 去清理。

## 1.10. gdb

程序中除了一目了然的 Bug 之外都需要一定的调试手段来分析到底错在哪。到目前为止我们的调试手段只有一种：根据程序执行时的出错现象假设错误原因，然后在代码中适当的位置插入 `printf`，执行程序并分析打印结果，如果结果和预期的一样，就基本上证明了自己假设的错误原因，就可以动手修正 Bug 了，如果结果和预期的不一样，就根据结果做进一步的假设和分析。本章我们介绍一种很强大的调试工具 `gdb`，可以完全操控程序的运行，使得程序就像你手里的玩具一样，叫它走就走，叫它停就停，并且随时可以查看程序中所有的内部状态，比如各变量的值、传给函数的参数、当前执行的代码行等。掌握了 `gdb` 的用法之后，调试手段就更加丰富了。但要注意，即使调试手段丰富了，调试的基本思想仍然是「分析现象 -> 假设错误原因 -> 产生新的现象去验证假设」这样一个循环，根据现象如何假设错误原因，以及如何设计新的现象去验证假设，这都需要非常严密的分析和思考，如果因为手里有了强大的工具就滥用而忽略了分析过程，往往会治标不治本地修正 Bug，导致一个错误现象消失了但 Bug 仍然存在，甚至是把程序越改越错。本章通过初学者易犯的几个错误实例来讲解如何使用 `gdb` 调试程序，在每个实例后面总结一部分常用的 `gdb` 命令。

### 1.10.1. 单步执行和跟踪函数调用

看下面的程序：

<p id="e10-1">例 10.1. 函数调试实例</p>

```c
  #include <stdio.h>
  
  int add_range(int low, int high)
  {
  	int i, sum;
  	for (i = low; i <= high; i++)
  		sum = sum + i;
  	return sum;
  }
  
  int main(void)
  {
  	int result[100];
  	result[0] = add_range(1, 10);
  	result[1] = add_range(1, 100);
  	printf("result[0]=%d\nresult[1]=%d\n", result[0], result[1]);
  	return 0;
  }
```

`add_range` 函数从 `low` 加到 `high`，在 `main` 函数中首先从 1 加到 10，把结果保存下来，然后从 1 加到 100，再把结果保存下来，最后打印的两个结果是：

```bash
result[0]=55
result[1]=5105
```

第一个结果正确<sup>[20]</sup>，第二个结果显然不正确，在小学我们就听说过高斯小时候的故事，从 1 加到 100 应该是 5050。一段代码，第一次运行结果是对的，第二次运行却不对，这是很常见的一类错误现象，这种情况不应该怀疑代码而应该怀疑数据，因为第一次和第二次运行的都是同一段代码，如果代码是错的，那为什么第一次的结果能对呢？然而第一次和第二次运行时相关的数据却有可能不同，错误的数据会导致错误的结果。在动手调试之前，读者先试试只看代码能不能看出错误原因，只要前面几章学得扎实就应该能看出来。

> <sup>[20]</sup> 这么说不够准确，在有些平台和操作系统上第一个结果也未必正确，如果在你机器上运行第一个结果也不正确，首先检查一下程序有没有抄错，如果没抄错那就没关系了，顺着我的讲解往下看就好了，结果是多少都无关紧要。

在编译时要加上 `-g` 选项，生成的可执行文件才能用 `gdb` 进行源码级调试：

```bash
$ gcc -g main.c -o main
$ gdb main
GNU gdb 6.8-debian
Copyright (C) 2008 Free Software Foundation, Inc.
License GPLv3+: GNU GPL version 3 or later <http://gnu.org/licenses/gpl.html>
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.  Type "show copying"
and "show warranty" for details.
This GDB was configured as "i486-linux-gnu"...
(gdb) 
```

`-g` 选项的作用是在可执行文件中加入源代码的信息，比如可执行文件中第几条机器指令对应源代码的第几行，但并不是把整个源文件嵌入到可执行文件中，所以在调试时必须保证 `gdb` 能找到源文件。`gdb` 提供一个类似 Shell 的命令行环境，上面的 `(gdb)` 就是提示符，在这个提示符下输入 `help` 可以查看命令的类别：

```bash
(gdb) help
List of classes of commands:

aliases -- Aliases of other commands
breakpoints -- Making program stop at certain points
data -- Examining data
files -- Specifying and examining files
internals -- Maintenance commands
obscure -- Obscure features
running -- Running the program
stack -- Examining the stack
status -- Status inquiries
support -- Support facilities
tracepoints -- Tracing of program execution without stopping the program
user-defined -- User-defined commands

Type "help" followed by a class name for a list of commands in that class.
Type "help all" for the list of all commands.
Type "help" followed by command name for full documentation.
Type "apropos word" to search for commands related to "word".
Command name abbreviations are allowed if unambiguous.
```

也可以进一步查看某一类别中有哪些命令，例如查看 `files` 类别下有哪些命令可用：

```bash
(gdb) help files
Specifying and examining files.

List of commands:

add-shared-symbol-files -- Load the symbols from shared objects in the dynamic linker's link map
add-symbol-file -- Load symbols from FILE
add-symbol-file-from-memory -- Load the symbols out of memory from a dynamically loaded object file
cd -- Set working directory to DIR for debugger and program being debugged
core-file -- Use FILE as core dump for examining memory and registers
directory -- Add directory DIR to beginning of search path for source files
edit -- Edit specified file or function
exec-file -- Use FILE as program for getting contents of pure memory
file -- Use FILE as program to be debugged
forward-search -- Search for regular expression (see regex(3)) from last line listed
generate-core-file -- Save a core file with the current state of the debugged process
list -- List specified function or line
...
```

现在试试用 `list` 命令从第一行开始列出源代码：

```bash
(gdb) list 1
1	#include <stdio.h>
2	
3	int add_range(int low, int high)
4	{
5		int i, sum;
6		for (i = low; i <= high; i++)
7			sum = sum + i;
8		return sum;
9	}
10
```

一次只列 10 行，如果要从第 11 行开始继续列源代码可以输入

```bash
(gdb) list
```

也可以什么都不输直接敲回车，`gdb` 提供了一个很方便的功能，在提示符下直接敲回车表示重复上一条命令。

```bash
(gdb) （直接回车）
11	int main(void)
12	{
13		int result[100];
14		result[0] = add_range(1, 10);
15		result[1] = add_range(1, 100);
16		printf("result[0]=%d\nresult[1]=%d\n", result[0], result[1]);
17		return 0;
18
```

`gdb` 的很多常用命令有简写形式，例如 `list` 命令可以写成 `l`，要列一个函数的源代码也可以用函数名做参数：

```bash
(gdb) l add_range
1	#include <stdio.h>
2	
3	int add_range(int low, int high)
4	{
5		int i, sum;
6		for (i = low; i <= high; i++)
7			sum = sum + i;
8		return sum;
9	}
10
```

现在退出 `gdb` 的环境：

```bash
(gdb) quit
```

我们做一个实验，把源代码改名或移到别处再用 `gdb` 调试，这样就列不出源代码了：

```bash
$ mv main.c mian.c
$ gdb main
...
(gdb) l
5	main.c: No such file or directory.
	in main.c
```

可见 `gcc` 的 `-g` 选项并不是把源代码嵌入到可执行文件中的，在调试时也需要源文件。现在把源代码恢复原样，我们继续调试。首先用 `start` 命令开始执行程序：

```bash
$ gdb main
...
(gdb) start
Breakpoint 1 at 0x80483ad: file main.c, line 14.
Starting program: /home/akaedu/main 
main () at main.c:14
14		result[0] = add_range(1, 10);
(gdb)
```

`gdb` 停在 `main` 函数中变量定义之后的第一条语句处等待我们发命令，`gdb` 列出的这条语句是即将执行的下一条语句。我们可以用 `next` 命令（简写为 `n`）控制这些语句一条一条地执行：

```bash
(gdb) n
15		result[1] = add_range(1, 100);
(gdb) （直接回车）
16		printf("result[0]=%d\nresult[1]=%d\n", result[0], result[1]);
(gdb) （直接回车）
result[0]=55
result[1]=5105
17		return 0;
```

用 `n` 命令依次执行两行赋值语句和一行打印语句，在执行打印语句时结果立刻打出来了，然后停在 `return` 语句之前等待我们发命令。虽然我们完全控制了程序的执行，但仍然看不出哪里错了，因为错误不在 `main` 函数中而在 `add_range` 函数中，现在用 `start` 命令重新来过，这次用 `step` 命令（简写为 `s`）钻进 `add_range` 函数中去跟踪执行：

```bash
(gdb) start
The program being debugged has been started already.
Start it from the beginning? (y or n) y

Breakpoint 2 at 0x80483ad: file main.c, line 14.
Starting program: /home/akaedu/main 
main () at main.c:14
14		result[0] = add_range(1, 10);
(gdb) s
add_range (low=1, high=10) at main.c:6
6		for (i = low; i <= high; i++)
```

这次停在了 `add_range` 函数中变量定义之后的第一条语句处。在函数中有几种查看状态的办法，`backtrace` 命令（简写为 `bt`）可以查看函数调用的栈帧：

```bash
  (gdb) bt
  #0  add_range (low=1, high=10) at main.c:6
  #1  0x080483c1 in main () at main.c:14
```

可见当前的 `add_range` 函数是被 `main` 函数调用的，`main` 传进来的参数是 `low=1, high=10`。`main` 函数的栈帧编号为 1，`add_range` 的栈帧编号为 0。现在可以用 `info` 命令（简写为 `i`）查看 `add_range` 函数局部变量的值：

```bash
(gdb) i locals
i = 0
sum = 0
```

如果想查看 `main` 函数当前局部变量的值也可以做到，先用 `frame` 命令（简写为 `f`）选择 1 号栈帧然后再查看局部变量：

```bash
  (gdb) f 1
  #1  0x080483c1 in main () at main.c:14
  14		result[0] = add_range(1, 10);
  (gdb) i locals 
  result = {0, 0, 0, 0, 0, 0, 134513196, 225011984, -1208685768, -1081160480, 
  ...
    -1208623680}
```

注意到 `result` 数组中有很多元素具有杂乱无章的值，我们知道未经初始化的局部变量具有不确定的值。到目前为止一切正常。用 `s` 或 `n` 往下走几步，然后用 `print` 命令（简写为 `p`）打印出变量 `sum` 的值：

```bash
(gdb) s
7			sum = sum + i;
(gdb) （直接回车）
6		for (i = low; i <= high; i++)
(gdb) （直接回车）
7			sum = sum + i;
(gdb) （直接回车）
6		for (i = low; i <= high; i++)
(gdb) p sum
$1 = 3
```

第一次循环 `i` 是 1，第二次循环 `i` 是 2，加起来是 3，没错。这里的 `$1` 表示 `gdb` 保存着这些中间结果，`$` 后面的编号会自动增长，在命令中可以用 `$1`、`$2`、`$3` 等编号代替相应的值。由于我们本来就知道第一次调用的结果是正确的，再往下跟也没意义了，可以用 `finish` 命令让程序一直运行到从当前函数返回为止：

```bash
(gdb) finish
Run till exit from #0  add_range (low=1, high=10) at main.c:6
0x080483c1 in main () at main.c:14
14		result[0] = add_range(1, 10);
Value returned is $2 = 55
```

返回值是 55，当前正准备执行赋值操作，用 `s` 命令赋值，然后查看 `result` 数组：

```bash
(gdb) s
15		result[1] = add_range(1, 100);
(gdb) p result
$3 = {55, 0, 0, 0, 0, 0, 134513196, 225011984, -1208685768, -1081160480, 
...
  -1208623680}
```

第一个值 55 确实赋给了 `result` 数组的第 0 个元素。下面用 `s` 命令进入第二次 `add_range` 调用，进入之后首先查看参数和局部变量：

```bash
  (gdb) s
  add_range (low=1, high=100) at main.c:6
  6		for (i = low; i <= high; i++)
  (gdb) bt
  #0  add_range (low=1, high=100) at main.c:6
  #1  0x080483db in main () at main.c:15
  (gdb) i locals 
  i = 11
  sum = 55
```

由于局部变量 `i` 和 `sum` 没初始化，所以具有不确定的值，又由于两次调用是挨着的，`i` 和 `sum` 正好取了上次调用时的值，原来这跟[第 3 章「简单函数」第 4 节「全局变量、局部变量和作用域」例 3.7「验证局部变量存储空间的分配和释放」](1-C-语言入门/ch03-简单函数#e3-7)是一样的道理，只不过我这次举的例子设法让局部变量 `sum` 在第一次调用时初值为 0 了。`i` 的初值不是 0 倒没关系，在 `for` 循环中会赋值为 0 的，但 `sum` 如果初值不是 0，累加得到的结果就错了。好了，我们已经找到错误原因，可以退出 `gdb` 修改源代码了。如果我们不想浪费这次调试机会，可以在 `gdb` 中马上把 `sum` 的初值改为 0 继续运行，看看这一处改了之后还有没有别的 Bug：

```bash
(gdb) set var sum=0
(gdb) finish
Run till exit from #0  add_range (low=1, high=100) at main.c:6
0x080483db in main () at main.c:15
15		result[1] = add_range(1, 100);
Value returned is $4 = 5050
(gdb) n
16		printf("result[0]=%d\nresult[1]=%d\n", result[0], result[1]);
(gdb) （直接回车）
result[0]=55
result[1]=5050
17		return 0;
```

这样结果就对了。修改变量的值除了用 `set` 命令之外也可以用 `print` 命令，因为 `print` 命令后面跟的是表达式，而我们知道赋值和函数调用也都是表达式，所以也可以用 `print` 命令修改变量的值或者调用函数：

```bash
(gdb) p result[2]=33
$5 = 33
(gdb) p printf("result[2]=%d\n", result[2])
result[2]=33
$6 = 13
```

我们讲过，`printf` 的返回值表示实际打印的字符数，所以 `$6` 的结果是 13。总结一下本节用到的 `gdb` 命令：

<p id="t10-1">表 10.1. gdb 基本命令 1</p>

| 命令                 | 描述                                                   |
| -------------------- | ------------------------------------------------------ |
| backtrace（或 bt）   | 查看各级函数调用及参数                                 |
| finish               | 连续运行到当前函数返回为止，然后停下来等待命令         |
| frame（或 f） 帧编号 | 选择栈帧                                               |
| info（或 i） locals  | 查看当前栈帧局部变量的值                               |
| list（或 l）         | 列出源代码，接着上次的位置往下列，每次列 10 行         |
| list 行号            | 列出从第几行开始的源代码                               |
| list 函数名          | 列出某个函数的源代码                                   |
| next（或 n）         | 执行下一行语句                                         |
| print（或 p）        | 打印表达式的值，通过表达式可以修改变量的值或者调用函数 |
| quit（或 q）         | 退出 `gdb` 调试环境                                    |
| set var              | 修改变量的值                                           |
| start                | 开始执行程序，停在 `main` 函数第一行语句前面等待命令   |
| step（或 s）         | 执行下一行语句，如果有函数调用则进入到函数中           |

### 1.10.2. 断点

看以下程序：

<p id="e10-2">例 10.2. 断点调试实例</p>

```c
  #include <stdio.h>
  
  int main(void)
  {
  	int sum = 0, i = 0;
  	char input[5];
  
  	while (1) {
  		scanf("%s", input);
  		for (i = 0; input[i] != '\0'; i++)
  			sum = sum*10 + input[i] - '0';
  		printf("input=%d\n", sum);
  	}
  	return 0;
  }
```

这个程序的作用是：首先从键盘读入一串数字存到字符数组 `input` 中，然后转换成整型存到 `sum` 中，然后打印出来，一直这样循环下去。`scanf("%s", input);` 这个调用的功能是等待用户输入一个字符串并回车，`scanf` 把其中第一段非空白（非空格、Tab、换行）的字符串保存到 `input` 数组中，并自动在末尾添加 `'\0'`。接下来的循环从左到右扫描字符串并把每个数字累加到结果中，例如输入是 `"2345"`，则循环累加的过程是 `(((0*10+2)*10+3)*10+4)*10+5=2345`。注意字符型的 `'2'` 要减去 `'0'` 的 ASCII 码才能转换成整数值 2。下面编译运行程序看看有什么问题：

```bash
$ gcc main.c -g -o main
$ ./main 
123
input=123
234
input=123234
（Ctrl-C 退出程序）
$
```

又是这种现象，第一次是对的，第二次就不对。可是这个程序我们并没有忘了赋初值，不仅 `sum` 赋了初值，连不必赋初值的 `i` 都赋了初值。读者先试试只看代码能不能看出错误原因。下面来调试：

```bash
$ gdb main
...
(gdb) start
Breakpoint 1 at 0x80483b5: file main.c, line 5.
Starting program: /home/akaedu/main 
main () at main.c:5
5		int sum = 0, i = 0;
```

有了上一次的经验，`sum` 被列为重点怀疑对象，我们可以用 `display` 命令使得每次停下来的时候都显示当前 `sum` 的值，然后继续往下走：

```bash
(gdb) display sum
1: sum = -1208103488
(gdb) n
9			scanf("%s", input);
1: sum = 0
(gdb) 
123
10			for (i = 0; input[i] != '\0'; i++)
1: sum = 0
```

`undisplay` 命令可以取消跟踪显示，变量 `sum` 的编号是 1，可以用 `undisplay 1` 命令取消它的跟踪显示。这个循环应该没有问题，因为上面第一次输入时打印的结果是正确的。如果不想一步一步走这个循环，可以用 `break` 命令（简写为 `b`）在第 9 行设一个断点（Breakpoint）：

```bash
(gdb) l
5		int sum = 0, i;
6		char input[5];
7	
8		while (1) {
9			scanf("%s", input);
10			for (i = 0; input[i] != '\0'; i++)
11				sum = sum*10 + input[i] - '0';
12			printf("input=%d\n", sum);
13		}
14		return 0;
(gdb) b 9
Breakpoint 2 at 0x80483bc: file main.c, line 9.
```

`break` 命令的参数也可以是函数名，表示在某个函数开头设断点。现在用 `continue` 命令（简写为 `c`）连续运行而非单步运行，程序到达断点会自动停下来，这样就可以停在下一次循环的开头：

```bash
(gdb) c
Continuing.
input=123

Breakpoint 2, main () at main.c:9
9			scanf("%s", input);
1: sum = 123
```

然后输入新的字符串准备转换：

```bash
(gdb) n
234
10			for (i = 0; input[i] != '\0'; i++)
1: sum = 123
```

问题暴露出来了，新的转换应该再次从 0 开始累加，而 `sum` 现在已经是 123 了，原因在于新的循环没有把 `sum` 归零。可见断点有助于快速跳过没有问题的代码，然后在有问题的代码上慢慢走慢慢分析，「断点加单步」是使用调试器的基本方法。至于应该在哪里设置断点，怎么知道哪些代码可以跳过而哪些代码要慢慢走，也要通过对错误现象的分析和假设来确定，以前我们用 `printf` 打印中间结果时也要分析应该在哪里插入 `printf`，打印哪些中间结果，调试的基本思路是一样的。一次调试可以设置多个断点，用 `info` 命令可以查看已经设置的断点：

```bash
(gdb) b 12
Breakpoint 3 at 0x8048411: file main.c, line 12.
(gdb) i breakpoints
Num     Type           Disp Enb Address    What
2       breakpoint     keep y   0x080483c3 in main at main.c:9
	breakpoint already hit 1 time
3       breakpoint     keep y   0x08048411 in main at main.c:12
```

每个断点都有一个编号，可以用编号指定删除某个断点： 

```bash
(gdb) delete breakpoints 2
(gdb) i breakpoints 
Num     Type           Disp Enb Address    What
3       breakpoint     keep y   0x08048411 in main at main.c:12
```

有时候一个断点暂时不用可以禁用掉而不必删除，这样以后想用的时候可以直接启用，而不必重新从代码里找应该在哪一行设断点：

```bash
(gdb) disable breakpoints 3
(gdb) i breakpoints 
Num     Type           Disp Enb Address    What
3       breakpoint     keep n   0x08048411 in main at main.c:12
(gdb) enable 3
(gdb) i breakpoints 
Num     Type           Disp Enb Address    What
3       breakpoint     keep y   0x08048411 in main at main.c:12
(gdb) delete breakpoints 
Delete all breakpoints? (y or n) y
(gdb) i breakpoints
No breakpoints or watchpoints.
```

`gdb` 的断点功能非常灵活，还可以设置断点在满足某个条件时才激活，例如我们仍然在循环开头设置断点，但是仅当 `sum` 不等于 0 时才中断，然后用 `run` 命令（简写为 `r`）重新从程序开头连续运行：

```bash
(gdb) break 9 if sum != 0
Breakpoint 5 at 0x80483c3: file main.c, line 9.
(gdb) i breakpoints 
Num     Type           Disp Enb Address    What
5       breakpoint     keep y   0x080483c3 in main at main.c:9
	stop only if sum != 0
(gdb) r
The program being debugged has been started already.
Start it from the beginning? (y or n) y
Starting program: /home/akaedu/main 
123
input=123

Breakpoint 5, main () at main.c:9
9			scanf("%s", input);
1: sum = 123
```

结果是第一次执行 `scanf` 之前没有中断，第二次却中断了。总结一下本节用到的 `gdb` 命令：

<p id="t10-2">表 10.2. gdb 基本命令 2</p>

| 命令                       | 描述                                     |
| -------------------------- | ---------------------------------------- |
| break（或 b） 行号         | 在某一行设置断点                         |
| break 函数名               | 在某个函数开头设置断点                   |
| break ... if ...           | 设置条件断点                             |
| continue（或 c）           | 从当前位置开始连续运行程序               |
| delete breakpoints 断点号  | 删除断点                                 |
| display 变量名             | 跟踪查看某个变量，每次停下来都显示它的值 |
| disable breakpoints 断点号 | 禁用断点                                 |
| enable 断点号              | 启用断点                                 |
| info（或 i） breakpoints   | 查看当前设置了哪些断点                   |
| run（或 r）                | 从头开始连续运行程序                     |
| undisplay 跟踪显示号       | 取消跟踪显示                             |

### 1.10.3. 观察点

接着上一节的步骤，经过调试我们知道，虽然 `sum` 已经赋了初值 0，但仍需要在 `while (1)` 循环的开头加上 `sum = 0;`：

<p id="e10-3">例 10.3. 观察点调试实例</p>

```c
  #include <stdio.h>
  
  int main(void)
  {
  	int sum = 0, i = 0;
  	char input[5];
  
  	while (1) {
  		sum = 0;
  		scanf("%s", input);
  		for (i = 0; input[i] != '\0'; i++)
  			sum = sum*10 + input[i] - '0';
  		printf("input=%d\n", sum);
  	}
  	return 0;
  }
```

使用 `scanf` 函数是非常凶险的，即使修正了这个 Bug 也还存在很多问题。如果输入的字符串超长了会怎么样？我们知道数组访问越界是不会检查的，所以 `scanf` 会写出界。现象是这样的：

```bash
$ ./main
123
input=123
67
input=67
12345
input=123407
```

下面用调试器看看最后这个诡异的结果是怎么出来的<sup>[21]</sup>。

> <sup>[21]</sup> 不得不承认，在有些平台和操作系统上也未必得到这个结果，产生 Bug 的往往都是一些平台相关的问题，举这样的例子才比较像是真实软件开发中遇到的 Bug，如果您的程序跑不出我这样的结果，那这一节您就凑合着看吧。

```bash
$ gdb main
...
(gdb) start
Breakpoint 1 at 0x80483b5: file main.c, line 5.
Starting program: /home/akaedu/main 
main () at main.c:5
5		int sum = 0, i = 0;
(gdb) n
9			sum = 0;
(gdb) （直接回车）
10			scanf("%s", input);
(gdb) （直接回车）
12345
11			for (i = 0; input[i] != '\0'; i++)
(gdb) p input
$1 = "12345"
```

`input` 数组只有 5 个元素，写出界的是 `scanf` 自动添的 `'\0'`，用 `x` 命令看会更清楚一些：

```bash
(gdb) x/7b input
0xbfb8f0a7:	0x31	0x32	0x33	0x34	0x35	0x00	0x00
```

`x` 命令打印指定存储单元的内容。`7b` 是打印格式，`b` 表示每个字节一组，`7` 表示打印 7 组<sup>[22]</sup>，从 `input` 数组的第一个字节开始连续打印 7 个字节。前 5 个字节是 `input` 数组的存储单元，打印的正是十六进制 ASCII 码的 `'1'` 到 `'5'`，第 6 个字节是写出界的 `'\0'`。根据运行结果，前 4 个字符转成数字都没错，第 5 个错了，也就是 `i` 从 0 到 3 的循环都没错，我们设一个条件断点从 `i` 等于 4 开始单步调试：

> <sup>[22]</sup> 打印结果最左边的一长串数字是内存地址，在[第 17 章「计算机体系结构基础」第 1 节「内存与地址」](2-C-语言本质/ch17-计算机体系结构基础#_1-内存与地址)详细解释，目前可以无视。

```bash
(gdb) l
6		char input[5];
7	
8		while (1) {
9			sum = 0;
10			scanf("%s", input);
11			for (i = 0; input[i] != '\0'; i++)
12				sum = sum*10 + input[i] - '0';
13			printf("input=%d\n", sum);
14		}
15		return 0;
(gdb) b 12 if i == 4
Breakpoint 2 at 0x80483e6: file main.c, line 12.
(gdb) c
Continuing.

Breakpoint 2, main () at main.c:12
12				sum = sum*10 + input[i] - '0';
(gdb) p sum
$2 = 1234
```

现在 `sum` 是 1234 没错，根据运行结果是 123407 我们知道即将进行的这步计算肯定要出错，算出来应该是 12340，那就是说 `input[4]` 肯定不是 `'5'` 了，事实证明这个推理是不严谨的：

```bash
(gdb) x/7b input
0xbfb8f0a7:	0x31	0x32	0x33	0x34	0x35	0x04	0x00
```

`input[4]` 的确是 `0x35`，产生 123407 还有另外一种可能，就是在下一次循环中 123450 不是加上而是减去一个数得到 123407。可现在不是到字符串末尾了吗？怎么会有下一次循环呢？注意到循环控制条件是 `input[i] != '\0'`，而本来应该是 `0x00` 的位置现在莫名其妙地变成了 `0x04`，因此循环不会结束。继续单步：

```bash
(gdb) n
11			for (i = 0; input[i] != '\0'; i++)
(gdb) p sum
$3 = 12345
(gdb) n
12				sum = sum*10 + input[i] - '0';
(gdb) x/7b input
0xbfb8f0a7:	0x31	0x32	0x33	0x34	0x35	0x05	0x00
```

进入下一次循环，原来的 `0x04` 又莫名其妙地变成了 `0x05`，这是怎么回事？这个暂时解释不了，但 123407 这个结果可以解释了，是 `12345*10+0x05-0x30` 得到的，虽然多循环了一次，但下次一定会退出循环了，因为 `0x05` 的后面是 `'\0'`。

`input[4]` 后面那个字节到底是什么时候变的？可以用观察点（Watchpoint）来跟踪。我们知道断点是当程序执行到某一代码行时中断，而观察点是当程序访问某个存储单元时中断，如果我们不知道某个存储单元是在哪里被改动的，这时候观察点尤其有用。下面删除原来设的断点，从头执行程序，重复上次的输入，用 `watch` 命令设置观察点，跟踪 `input[4]` 后面那个字节（可以用 `input[5]` 表示，虽然这是访问越界）：

```bash
(gdb) delete breakpoints 
Delete all breakpoints? (y or n) y
(gdb) start
Breakpoint 1 at 0x80483b5: file main.c, line 5.
Starting program: /home/akaedu/main 
main () at main.c:5
5		int sum = 0, i = 0;
(gdb) n
9			sum = 0;
(gdb) （直接回车）
10			scanf("%s", input);
(gdb) （直接回车）
12345
11			for (i = 0; input[i] != '\0'; i++)
(gdb) watch input[5]
Hardware watchpoint 2: input[5]
(gdb) i watchpoints 
Num     Type           Disp Enb Address    What
2       hw watchpoint  keep y              input[5]
(gdb) c
Continuing.
Hardware watchpoint 2: input[5]

Old value = 0 '\0'
New value = 1 '\001'
0x0804840c in main () at main.c:11
11			for (i = 0; input[i] != '\0'; i++)
(gdb) c
Continuing.
Hardware watchpoint 2: input[5]

Old value = 1 '\001'
New value = 2 '\002'
0x0804840c in main () at main.c:11
11			for (i = 0; input[i] != '\0'; i++)
(gdb) c
Continuing.
Hardware watchpoint 2: input[5]

Old value = 2 '\002'
New value = 3 '\003'
0x0804840c in main () at main.c:11
11			for (i = 0; input[i] != '\0'; i++)
```

已经很明显了，每次都是回到 `for` 循环开头的时候改变了 `input[5]` 的值，而且是每次加 1，而循环变量 `i` 正是在每次回到循环开头之前加 1，原来 `input[5]` 就是变量 `i` 的存储单元，换句话说，`i` 的存储单元是紧跟在 `input` 数组后面的。

修正这个 Bug 对初学者来说有一定难度。如果你发现了这个 Bug 却没想到数组访问越界这一点，也许一时想不出原因，就会先去处理另外一个更容易修正的 Bug：如果输入的不是数字而是字母或别的符号也能算出结果来，这显然是不对的，可以在循环中加上判断条件检查非法字符：

```c
while (1) {
	sum = 0;
	scanf("%s", input);
	for (i = 0; input[i] != '\0'; i++) {
		if (input[i] < '0' || input[i] > '9') {
			printf("Invalid input!\n");
			sum = -1;
			break;
		}
		sum = sum*10 + input[i] - '0';
	}
	printf("input=%d\n", sum);
}
```

然后你会惊喜地发现，不仅输入字母会报错，输入超长也会报错：

```bash
$ ./main
123a
Invalid input!
input=-1
dead
Invalid input!
input=-1
1234578
Invalid input!
input=-1
1234567890abcdef
Invalid input!
input=-1
23
input=23
```

似乎是两个 Bug 一起解决掉了，但这是治标不治本的解决方法。看起来输入超长的错误是不出现了，但只要没有找到根本原因就不可能真的解决掉，等到条件一变，它可能又冒出来了，在下一节你会看到它又以一种新的形式冒出来了。现在请思考一下为什么加上检查非法字符的代码之后输入超长也会报错。最后总结一下本节用到的 `gdb` 命令：

<p id="t10-3">表 10.3. gdb 基本命令 3</p>

| 命令                     | 描述                                                         |
| ------------------------ | ------------------------------------------------------------ |
| watch                    | 设置观察点                                                   |
| info（或 i） watchpoints | 查看当前设置了哪些观察点                                     |
| x                        | 从某个位置开始打印存储单元的内容，全部当成字节来看，而不区分哪个字节属于哪个变量 |

### 1.10.4. 段错误

如果程序运行时出现段错误，用 `gdb` 可以很容易定位到究竟是哪一行引发的段错误，例如这个小程序：

<p id="e10-4">例 10.4. 段错误调试实例一</p>

```c
  #include <stdio.h>
  
  int main(void)
  {
  	int man = 0;
  	scanf("%d", man);
  	return 0;
  }
```

调试过程如下：

```bash
  $ gdb main
  ...
  (gdb) r
  Starting program: /home/akaedu/main 
  123
  
  Program received signal SIGSEGV, Segmentation fault.
  0xb7e1404b in _IO_vfscanf () from /lib/tls/i686/cmov/libc.so.6
  (gdb) bt
  #0  0xb7e1404b in _IO_vfscanf () from /lib/tls/i686/cmov/libc.so.6
  #1  0xb7e1dd2b in scanf () from /lib/tls/i686/cmov/libc.so.6
  #2  0x0804839f in main () at main.c:6
```

在 `gdb` 中运行，遇到段错误会自动停下来，这时可以用命令查看当前执行到哪一行代码了。`gdb` 显示段错误出现在 `_IO_vfscanf` 函数中，用 `bt` 命令可以看到这个函数是被我们的 `scanf` 函数调用的，所以是 `scanf` 这一行代码引发的段错误。仔细观察程序发现是 `man` 前面少了个 `&`。

继续调试上一节的程序，上一节最后提出修正 Bug 的方法是在循环中加上判断条件，如果不是数字就报错退出，不仅输入字母可以报错退出，输入超长的字符串也会报错退出。表面上看这个程序无论怎么运行都不出错了，但假如我们把 `while (1)` 循环去掉，每次执行程序只转换一个数：

<p id="e10-5">例 10.5. 段错误调试实例二</p>

```c
  #include <stdio.h>
  
  int main(void)
  {
  	int sum = 0, i = 0;
  	char input[5];
  
  	scanf("%s", input);
  	for (i = 0; input[i] != '\0'; i++) {
  		if (input[i] < '0' || input[i] > '9') {
  			printf("Invalid input!\n");
  			sum = -1;
  			break;
  		}
  		sum = sum*10 + input[i] - '0';
  	}
  	printf("input=%d\n", sum);
  	return 0;
  }
```

然后输入一个超长的字符串，看看会发生什么：

```bash
$ ./main 
1234567890
Invalid input!
input=-1
```

看起来正常。再来一次，这次输个更长的：

```bash
$ ./main 
1234567890abcdef
Invalid input!
input=-1
Segmentation fault
```

又出段错误了。我们按同样的方法用 `gdb` 调试看看：

```bash
$ gdb main
...
(gdb) r
Starting program: /home/akaedu/main 
1234567890abcdef
Invalid input!
input=-1

Program received signal SIGSEGV, Segmentation fault.
0x0804848e in main () at main.c:19
19	}
(gdb) l
14			}
15			sum = sum*10 + input[i] - '0';
16		}
17		printf("input=%d\n", sum);
18		return 0;
19	}
```

`gdb` 指出，段错误发生在第 19 行。可是这一行什么都没有啊，只有表示 `main` 函数结束的 `}` 括号。这可以算是一条规律，**如果某个函数的局部变量发生访问越界，有可能并不立即产生段错误，而是在函数返回时产生段错误**。

想要写出 Bug-free 的程序是非常不容易的，即使 `scanf` 读入字符串这么一个简单的函数调用都会隐藏着各种各样的错误，有些错误现象是我们暂时没法解释的：为什么变量 `i` 的存储单元紧跟在 `input` 数组后面？为什么同样是访问越界，有时出段错误有时不出段错误？为什么访问越界的段错误在函数返回时才出现？还有最基本的问题，为什么 `scanf` 输入整型变量就必须要加 `&`，否则就出段错误，而输入字符串就不要加 `&`？这些问题在后续章节中都会解释清楚。其实现在讲 `scanf` 这个函数为时过早，读者还不具备充足的基础知识。但还是有必要讲的，学完这一阶段之后读者应该能写出有用的程序了，然而一个只有输出而没有输入的程序算不上是有用的程序，另一方面也让读者认识到，学 C 语言不可能不去了解底层计算机体系结构和操作系统的原理，不了解底层原理连一个 `scanf` 函数都没办法用好，更没有办法保证写出正确的程序。

### 1.10.5. 命令整理

- 基本
  - backtrace（或 bt） 查看各级函数调用及参数
  - finish 连续运行到当前函数返回为止，然后停下来等待命令
  - frame（或 f） 帧编号 选择栈帧
  - info（或 i） locals 查看当前栈帧局部变量的值
  - list（或 l） 列出源代码，接着上次的位置往下列，每次列 10 行
  - list 行号 列出从第几行开始的源代码
  - list 函数名 列出某个函数的源代码
  - next（或 n） 执行下一行语句
  - print（或 p） 打印表达式的值，通过表达式可以修改变量的值或者调用函数
  - quit（或 q） 退出 gdb 调试环境
  - set var 修改变量的值
  - start 开始执行程序，停在 main 函数第一行语句前面等待命令
  - step（或 s） 执行下一行语句，如果有函数调用则进入到函数中
- 断点
  - break（或 b） 行号 在某一行设置断点
  - break 函数名 在某个函数开头设置断点
  - break ... if ... 设置条件断点
  - continue（或 c） 从当前位置开始连续运行程序
  - delete breakpoints 断点号 删除断点
  - display 变量名 跟踪查看某个变量，每次停下来都显示它的值
  - disable breakpoints 断点号 禁用断点
  - enable 断点号 启用断点
  - info（或 i） breakpoints 查看当前设置了哪些断点
  - run（或 r） 从头开始连续运行程序
  - undisplay 跟踪显示号 取消跟踪显示
- 其他
  - watch 设置观察点
  - info（或 i） watchpoints 查看当前设置了哪些观察点
  - x 从某个位置开始打印存储单元的内容，全部当成字节来看，而不区分哪个字节属于哪个变量

## 1.11. 排序与查找

### 1.11.1. 算法的概念

算法（Algorithm）是将一组输入转化成一组输出的一系列计算步骤，其中每个步骤必须能在有限时间内完成。比如[第 5 章第 3 节「递归」习题 1](1-C-语言入门/ch05-深入理解函数#习题-1) 中的 Euclid 算法，输入是两个正整数，输出是它们的最大公约数，计算步骤是取模、比较等操作，这个算法一定能在有限的步骤和时间内完成（想一想为什么？）。再比如将一组数从小到大排序，输入是一组原始数据，输出是排序之后的数据，计算步骤包括比较、移动数据等操作。

算法是用来解决一类计算问题的，注意是一类问题，而不是一个特定的问题。例如，一个排序算法应该能对任意一组数据进行排序，而不是仅对 `int a[] = { 1, 3, 4, 2, 6, 5 };` 这样一组数据排序，如果只需要对这一组数据排序可以写这样一个函数来做：

```c
void sort(void)
{
	a[0] = 1;
	a[1] = 2;
	a[2] = 3;
	a[3] = 4;
	a[4] = 5;
	a[5] = 6;
}
```

这显然不叫算法，因为不具有通用性。由于算法是用来解决一类问题的，它必须能够正确地解决这一类问题中的任何一个实例，这个算法才是正确的。对于排序算法，任意输入一组数据，它必须都能输出正确的排序结果，这个排序算法才是正确的。不正确的算法有两种可能，一是对于该问题的某些输入，该算法会无限计算下去，不会终止，二是对于该问题的某些输入，该算法终止时输出的是错误的结果。有时候不正确的算法也是有用的，如果对于某个问题寻求正确的算法很困难，而某个不正确的算法可以在有限时间内终止，并且能把误差控制在一定范围内，那么这样的算法也是有实际意义的。例如有时候寻找最优解的开销很大，往往会选择能给出次优解的算法。

本章介绍几种典型的排序和查找算法，并围绕这几种算法做时间复杂度分析。学完本章之后如果想进一步学习，可以参考一些全面系统地介绍算法的书，例如 _TAOCP_ 和*算法导论*。

### 1.11.2. 插入排序

插入排序算法类似于玩扑克时抓牌的过程，玩家每拿到一张牌都要插入到手中已有的牌里，使之从小到大排好序。例如（该图出自算法导论）：

<p id="c11-1">图 11.1. 扑克牌的插入排序</p>

![扑克牌的插入排序](./image/sortsearch.sortcards.png)

也许你没有意识到，但其实你的思考过程是这样的：现在抓到一张 7，把它和手里的牌从右到左依次比较，7 比 10 小，应该再往左插，7 比 5 大，好，就插这里。为什么比较了 10 和 5 就可以确定 7 的位置？为什么不用再比较左边的 4 和 2 呢？因为这里有一个重要的前提：手里的牌已经是排好序的。现在我插了 7 之后，手里的牌仍然是排好序的，下次再抓到的牌还可以用这个方法插入。

编程对一个数组进行插入排序也是同样道理，但和插入扑克牌有一点不同，不可能在两个相邻的存储单元之间再插入一个单元，因此要将插入点之后的数据依次往后移动一个单元。排序算法如下：

<p id="e11-1">例 11.1. 插入排序</p>

```c
  #include <stdio.h>

  #define LEN 5
  int a[LEN] = { 10, 5, 2, 4, 7 };

  void insertion_sort(void)
  {
  	int i, j, key;
  	for (j = 1; j < LEN; j++) {
  		printf("%d, %d, %d, %d, %d\n",
  		       a[0], a[1], a[2], a[3], a[4]);
  		key = a[j];
  		i = j - 1;
  		while (i >= 0 && a[i] > key) {
  			a[i+1] = a[i];
  			i--;
  		}
  		a[i+1] = key;
  	}
  	printf("%d, %d, %d, %d, %d\n",
  	       a[0], a[1], a[2], a[3], a[4]);
  }

  int main(void)
  {
  	insertion_sort();
  	return 0;
  }
```

为了更清楚地观察排序过程，我们在每次循环开头插了打印语句，在排序结束后也插了打印语句。程序运行结果是：

```bash
10, 5, 2, 4, 7
5, 10, 2, 4, 7
2, 5, 10, 4, 7
2, 4, 5, 10, 7
2, 4, 5, 7, 10
```

如何严格证明这个算法是正确的？换句话说，只要反复执行该算法的 `for` 循环体，执行 `LEN-1` 次，就一定能把数组 `a` 排好序，而不管数组 `a` 的原始数据是什么，如何证明这一点呢？我们可以借助 Loop Invariant 的概念和数学归纳法来理解循环结构的算法，假如某个判断条件满足以下三条准则，它就称为 Loop Invariant：

1. 第一次执行循环体之前该判断条件为真。
2. 如果「第 N-1 次循环之后（或者说第 N 次循环之前）该判断条件为真」这个前提可以成立，那么就有办法证明第 N 次循环之后该判断条件仍为真。
3. 如果在所有循环结束后该判断条件为真，那么就有办法证明该算法正确地解决了问题。

只要我们找到这个 Loop Invariant，就可以证明一个循环结构的算法是正确的。上述插入排序算法的 Loop Invariant 是这样的判断条件：**第 `j` 次循环之前，子序列 `a[0..j-1]` 是排好序的**。在上面的打印结果中，我把子序列 `a[0..j-1]` 加粗表示。下面我们验证一下 Loop Invariant 的三条准则：

1. 第一次执行循环之前，`j=1`，子序列 `a[0..j-1]` 只有一个元素 `a[0]`，只有一个元素的序列显然是排好序的。
2. 第 `j` 次循环之前，如果「子序列 `a[0..j-1]` 是排好序的」这个前提成立，现在要把 `key=a[j]` 插进去，按照该算法的步骤，把 `a[j-1]`、`a[j-2]`、`a[j-3]` 等等比 `key` 大的元素都依次往后移一个，直到找到合适的位置给 `key` 插入，就能证明循环结束时子序列 `a[0..j]` 是排好序的。就像插扑克牌一样，「手中已有的牌是排好序的」这个前提很重要，如果没有这个前提，就不能证明再插一张牌之后也是排好序的。
3. 当循环结束时，`j=LEN`，如果「子序列 `a[0..j-1]` 是排好序的」这个前提成立，那就是说 `a[0..LEN-1]` 是排好序的，也就是说整个数组 `a` 的 `LEN` 个元素都排好序了。

可见，有了这三条，就可以用数学归纳法证明这个循环是正确的。这和[第 5 章第 3 节「递归」](1-C-语言入门/ch05-深入理解函数#_3-递归)证明递归程序正确性的思想是一致的，这里的第一条就相当于递归的 Base Case，第二条就相当于递归的递推关系。这再次说明了递归和循环是等价的。

### 1.11.3. 算法的时间复杂度分析

解决同一个问题可以有很多种算法，比较评价算法的好坏，一个重要的标准就是算法的时间复杂度。现在研究一下插入排序算法的执行时间，按照习惯，输入长度 `LEN`（以下用 n 表示）。设循环中各条语句的执行时间分别是 c1、c2、c3、c4、c5 这样五个常数<sup>[23]</sup>：

> <sup>[23]</sup> 受内存管理机制的影响，指令的执行时间不一定是常数，但执行时间的上界（Upper Bound）肯定是常数，我们这里假设语句的执行时间是常数只是一个粗略估计。

```c
void insertion_sort(void)                //执行时间
{
	int i, j, key;
	for (j = 1; j < LEN; j++) {
		key = a[j];                          //c1
		i = j - 1;                           //c2
		while (i >= 0 && a[i] > key) {
			a[i+1] = a[i];                   //c3
			i--;                             //c4
		}
		a[i+1] = key;                        //c5
	}
}
```

显然外层 `for` 循环的执行次数是 n-1 次，假设内层的 `while` 循环执行 m 次，则总的执行时间粗略估计是 `(n-1)*(c1+c2+c5+m*(c3+c4))`。当然，`for` 和 `while` 后面 `()` 括号中的赋值和条件判断的执行也需要时间，而我没有设一个常数来表示，这不影响我们的粗略估计。

这里有一个问题，m 不是个常数，也不取决于输入长度 n，而是取决于具体的输入数据。在最好情况下，数组 `a` 的原始数据已经排好序了，`while` 循环一次也不执行，总的执行时间是 `(c1+c2+c5)*n-(c1+c2+c5)`，可以表示成 `an+b` 的形式，是 n 的线性函数（Linear Function）。那么在最坏情况（Worst Case）下又如何呢？所谓最坏情况是指数组 `a` 的原始数据正好是从大到小排好序的，请读者想一想为什么这是最坏情况，然后把上式中的 m 替换掉算一下执行时间是多少。

数组 `a` 的原始数据属于最好和最坏情况的都比较少见，如果原始数据是随机的，可称为平均情况（Average Case）。如果原始数据是随机的，那么每次循环将已排序的子序列 `a[1..j-1]` 与新插入的元素 `key` 相比较，子序列中平均都有一半的元素比 `key` 大而另一半比 `key` 小，请读者把上式中的 m 替换掉算一下执行时间是多少。最后的结论应该是：在最坏情况和平均情况下，总的执行时间都可以表示成 an<sup>2</sup>+bn+c 的形式，是 n 的二次函数（Quadratic Function）。

在分析算法的时间复杂度时，我们更关心最坏情况而不是最好情况，理由如下：

1. 最坏情况给出了算法执行时间的上界，我们可以确信，无论给什么输入，算法的执行时间都不会超过这个上界，这样为比较和分析提供了便利。
2. 对于某些算法，最坏情况是最常发生的情况，例如在数据库中查找某个信息的算法，最坏情况就是数据库中根本不存在该信息，都找遍了也没有，而某些应用场合经常要查找一个信息在数据库中存在不存在。
3. 虽然最坏情况是一种悲观估计，但是对于很多问题，平均情况和最坏情况的时间复杂度差不多，比如插入排序这个例子，平均情况和最坏情况的时间复杂度都是输入长度 n 的二次函数。

比较两个多项式 a<sub>1</sub>n+b<sub>1</sub> 和 a<sub>2</sub>n<sup>2</sup>+b<sub>2</sub>n+c<sub>2</sub> 的值（n 取正整数）可以得出结论：n 的最高次指数是最主要的决定因素，常数项、低次幂项和系数都是次要的。比如 100n+1 和 n<sup>2</sup>+1，虽然后者的系数小，当 n 较小时前者的值较大，但是当 n > 100 时，后者的值就远远大于前者了。如果同一个问题可以用两种算法解决，其中一种算法的时间复杂度为线性函数，另一种算法的时间复杂度为二次函数，当问题的输入长度 n 足够大时，前者明显优于后者。因此我们可以用一种更粗略的方式表示算法的时间复杂度，把系数和低次幂项都省去，线性函数记作 Θ(n)，二次函数记作 Θ(n<sup>2</sup>)。

Θ(g(n)) 表示和 g(n) 同一量级的一类函数，例如所有的二次函数 f(n) 都和 g(n) = n<sup>2</sup> 属于同一量级，都可以用 Θ(n<sup>2</sup>) 来表示，甚至有些不是二次函数的也和 n<sup>2</sup> 属于同一量级，例如 2n<sup>2</sup>+3lgn。「同一量级」这个概念可以用下图来说明（该图出自算法导论）：

<p id="c11-2">图 11.2. Θ-notation</p>

![Θ-notation](./image/sortsearch.theta.png)

如果可以找到两个正的常数 c<sub>1</sub> 和 c<sub>2</sub>，使得 n 足够大的时候（也就是 n≥n0 的时候）f(n) 总是夹在 c<sub>1</sub>g(n) 和 c<sub>2</sub>g(n) 之间，就说 f(n) 和 g(n) 是同一量级的，f(n) 就可以用 Θ(g(n)) 来表示。

以二次函数为例，比如 1/2n<sup>2</sup>-3n，要证明它是属于 Θ(n<sup>2</sup>) 这个集合的，我们必须确定 c<sub>1</sub>、c<sub>2</sub> 和 n<sub>0</sub>，这些常数不随 n 改变，并且当 n ≥ n<sub>0</sub> 以后，c<sub>1</sub>n<sup>2</sup> ≤ 1/2n<sup>2</sup>-3n ≤ c<sub>2</sub>n<sup>2</sup> 总是成立的。为此我们从不等式的每一边都除以 n<sup>2</sup>，得到 c<sub>1</sub> ≤ 1/2-3/n ≤ c<sub>2</sub>。见下图：

<p id="c11-3">图 11.3. 1/2-3/n</p>

![1/2-3/n](./image/sortsearch.fn0.png)

这样就很容易看出来，无论 n 取多少，该函数一定小于 1/2，因此 c<sub>2</sub> = 1/2，当 n = 6 时函数值为 0，n > 6 时该函数都大于 0，可以取 n<sub>0</sub>=7，c<sub>1</sub>=1/14，这样当 n ≥ n<sub>0</sub> 时都有 1/2-3/n ≥ c<sub>1</sub>。通过这个证明过程可以得出结论，当 n 足够大时任何 an<sup>2</sup>+bn+c 都夹在 c<sub>1</sub>n<sup>2</sup> 和 c<sub>2</sub>n<sup>2</sup> 之间，相对于 n<sup>2</sup> 项来说 bn+c 的影响可以忽略，a 可以通过选取合适的 c<sub>1</sub>、c<sub>2</sub> 来补偿。

几种常见的时间复杂度函数按数量级从小到大的顺序依次是：Θ(lgn)，Θ(sqrt(n))，Θ(n)，Θ(nlgn)，Θ(n<sup>2</sup>)，Θ(n<sup>3</sup>)，Θ(2<sup>n</sup>)，Θ(n!)。其中，lgn 通常表示以 10 为底 n 的对数，但是对于 Θ-notation 来说，Θ(lgn) 和 Θ(log<sub>2</sub>n) 并无区别（想一想这是为什么），在算法分析中 lgn 通常表示以 2 为底 n 的对数。可是什么算法的时间复杂度里会出现 lgn 呢？回顾插入排序的时间复杂度分析，无非是循环体的执行时间乘以循环次数，只有加和乘运算，怎么会出来 lg 呢？下一节归并排序的时间复杂度里面就有 lg，请读者留心 lg 运算是从哪出来的。

除了 Θ-notation 之外，表示算法的时间复杂度常用的还有一种 Big-O notation。我们知道插入排序在最坏情况和平均情况下时间复杂度是 Θ(n<sup>2</sup>)，在最好情况下是 Θ(n)，数量级比 Θ(n<sup>2</sup>)要小，那么总结起来在各种情况下插入排序的时间复杂度是 O(n<sup>2</sup>)。Θ 的含义和「等于」类似，而 Big-O 的含义和「小于等于」类似。

### 1.11.4. 归并排序

插入排序算法采取增量式（Incremental）的策略解决问题，每次添一个元素到已排序的子序列中，逐渐将整个数组排序完毕，它的时间复杂度是 O(n<sup>2</sup>)。下面介绍另一种典型的排序算法——归并排序，它采取分而治之（Divide-and-Conquer）的策略，时间复杂度是 Θ(nlgn)。归并排序的步骤如下：

1. Divide：把长度为 n 的输入序列分成两个长度为 n/2 的子序列。
2. Conquer：对这两个子序列分别采用归并排序。
3. Combine：将两个排序好的子序列合并成一个最终的排序序列。

在描述归并排序的步骤时又调用了归并排序本身，可见这是一个递归的过程。

<p id="e11-2">例 11.2. 归并排序</p>

```c
  #include <stdio.h>

  #define LEN 8
  int a[LEN] = { 5, 2, 4, 7, 1, 3, 2, 6 };

  void merge(int start, int mid, int end)
  {
  	int n1 = mid - start + 1;
  	int n2 = end - mid;
  	int left[n1], right[n2];
  	int i, j, k;

  	for (i = 0; i < n1; i++) /* left holds a[start..mid] */
  		left[i] = a[start+i];
  	for (j = 0; j < n2; j++) /* right holds a[mid+1..end] */
  		right[j] = a[mid+1+j];

  	i = j = 0;
  	k = start;
  	while (i < n1 && j < n2)
  		if (left[i] < right[j])
  			a[k++] = left[i++];
  		else
  			a[k++] = right[j++];

  	while (i < n1) /* left[] is not exhausted */
  		a[k++] = left[i++];
  	while (j < n2) /* right[] is not exhausted */
  		a[k++] = right[j++];
  }

  void sort(int start, int end)
  {
  	int mid;
  	if (start < end) {
  		mid = (start + end) / 2;
  		printf("sort (%d-%d, %d-%d) %d %d %d %d %d %d %d %d\n",
  		       start, mid, mid+1, end,
  		       a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
  		sort(start, mid);
  		sort(mid+1, end);
  		merge(start, mid, end);
  		printf("merge (%d-%d, %d-%d) to %d %d %d %d %d %d %d %d\n",
  		       start, mid, mid+1, end,
  		       a[0], a[1], a[2], a[3], a[4], a[5], a[6], a[7]);
  	}
  }

  int main(void)
  {
  	sort(0, LEN-1);
  	return 0;
  }
```

执行结果是：

```bash
sort (0-3, 4-7) 5 2 4 7 1 3 2 6
sort (0-1, 2-3) 5 2 4 7 1 3 2 6
sort (0-0, 1-1) 5 2 4 7 1 3 2 6
merge (0-0, 1-1) to 2 5 4 7 1 3 2 6
sort (2-2, 3-3) 2 5 4 7 1 3 2 6
merge (2-2, 3-3) to 2 5 4 7 1 3 2 6
merge 0-1, 2-3) to 2 4 5 7 1 3 2 6
sort (4-5, 6-7) 2 4 5 7 1 3 2 6
sort (4-4, 5-5) 2 4 5 7 1 3 2 6
merge (4-4, 5-5) to 2 4 5 7 1 3 2 6
sort (6-6, 7-7) 2 4 5 7 1 3 2 6
merge (6-6, 7-7) to 2 4 5 7 1 3 2 6
merge (4-5, 6-7) to 2 4 5 7 1 2 3 6
merge (0-3, 4-7) to 1 2 2 3 4 5 6 7
```

`sort` 函数把 `a[start..end]` 平均分成两个子序列，分别是 `a[start..mid]` 和 `a[mid+1..end]`，对这两个子序列分别递归调用 `sort` 函数进行排序，然后调用 `merge` 函数将排好序的两个子序列合并起来，由于两个子序列都已经排好序了，合并的过程很简单，每次循环取两个子序列中最小的元素进行比较，将较小的元素取出放到最终的排序序列中，如果其中一个子序列的元素已取完，就把另一个子序列剩下的元素都放到最终的排序序列中。为了便于理解程序，我在 `sort` 函数开头和结尾插了打印语句，可以看出调用过程是这样的：

<p id="c11-4">图 11.4. 归并排序调用过程</p>

![归并排序调用过程](./image/sortsearch.mergesort.png)

图中 S 表示 `sort` 函数，M 表示 `merge` 函数，整个控制流程沿虚线所示的方向调用和返回。由于 `sort` 函数递归调用了自己两次，所以各函数之间的调用关系呈树状结构。画这个图只是为了清楚地展现归并排序的过程，读者在理解递归函数时一定不要全部展开来看，而是要抓住 Base Case 和递推关系来理解。我们分析一下归并排序的时间复杂度，以下分析出自算法导论。

首先分析 `merge` 函数的时间复杂度。在 `merge` 函数中演示了 C99 的新特性——可变长数组，当然也可以避免使用这一特性，比如把 `left` 和 `right` 都按最大长度 `LEN` 分配。不管用哪种办法，定义数组并分配存储空间的执行时间都可以看作常数，与数组的长度无关，常数用 Θ-notation 记作 Θ(1)。设子序列 `a[start..mid]` 的长度为 `n1`，子序列 `[mid+1..end]` 的长度为 `n2`，`a[start..end]` 的总长度为 n=n1+n2，则前两个 `for` 循环的执行时间是 Θ(n1+n2)，也就是 Θ(n)，后面三个 `for` 循环合在一起看，每走一次循环就会在最终的排序序列中确定一个元素，最终的排序序列共有 n 个元素，所以执行时间也是 Θ(n)。两个 Θ(n) 再加上若干常数项，`merge` 函数总的执行时间仍是 Θ(n)，其中 n=end-start+1。

然后分析 `sort` 函数的时间复杂度，当输入长度 n = 1，也就是 `start==end` 时，`if` 条件不成立，执行时间为常数 Θ(1)，当输入长度 n > 1 时：

总的执行时间 = 2 × 输入长度为 n/2 的 `sort` 函数的执行时间 + `merge` 函数的执行时间 Θ(n)

设输入长度为 n 的 `sort` 函数的执行时间为 T(n)，综上所述：

![recurrence1](./image/sortsearch.recurrence1.png)

这是一个递推公式（Recurrence），我们需要消去等号右侧的 T(n)，把 T(n) 写成 n 的函数。其实符合一定条件的 Recurrence 的展开有数学公式可以套，这里我们略去严格的数学证明，只是从直观上看一下这个递推公式的结果。当 n=1 时可以设 T(1)=c<sub>1</sub>，当 n>1 时可以设 T(n)=2T(n/2)+c<sub>2</sub>n，我们取 c<sub>1</sub> 和 c<sub>2</sub> 中较大的一个设为 c，把原来的公式改为：

![recurrence2](./image/sortsearch.recurrence2.png)

这样计算出的结果应该是 T(n) 的上界。下面我们把 T(n/2) 展开成 2T(n/4)+cn/2（下图中的 (c)），然后再把 T(n/4) 进一步展开，直到最后全部变成 T(1)=c（下图中的 (d)）：

![calcrecurrence](./image/sortsearch.calcrecurrence.png)

把图 (d) 中所有的项加起来就是总的执行时间。这是一个树状结构，每一层的和都是 cn，共有 lgn+1 层，因此总的执行时间是 cnlgn+cn，相比 nlgn 来说，cn 项可以忽略，因此 T(n) 的上界是 Θ(nlgn)。

如果先前取 c<sub>1</sub> 和 c<sub>2</sub> 中较小的一个设为 c，计算出的结果应该是 T(n) 的下界，然而推导过程一样，结果也是 Θ(nlgn)。既然 T(n) 的上下界都是 Θ(nlgn)，显然 T(n) 就是 Θ(nlgn)。

和插入排序的平均情况相比归并排序更快一些，虽然 `merge` 函数的步骤较多，引入了较大的常数、系数和低次项，但是对于较大的输入长度 n，这些都不是主要因素，归并排序的时间复杂度是 Θ(nlgn)，而插入排序的平均情况是 Θ(n<sup>2</sup>)，这就决定了归并排序是更快的算法。但是不是任何情况下归并排序都优于插入排序呢？哪些情况适用插入排序而不适用归并排序？留给读者思考。

### 1.11.5. 线性查找

有些查找问题要用时间复杂度为 O(n) 的算法来解决。例如写一个 `indexof` 函数，从任意输入字符串中找出某个字母的位置并返回这个位置，如果找不到就返回 `-1`：

<p id="e11-3">例 11.3. 线性查找</p>

```c
  #include <stdio.h>

  char a[]="hello world";

  int indexof(char letter)
  {
  	int i = 0;
  	while (a[i] != '\0') {
  		if (a[i] == letter)
  			return i;
  		i++;
  	}
  	return -1;
  }

  int main(void)
  {
  	printf("%d %d\n", indexof('o'), indexof('z'));
  	return 0;
  }
```

这个实现是最直观和最容易想到的，但它是不是最快的算法呢？我们知道插入排序也比归并排序更容易想到，但通常不如归并排序快。那么现在这个问题——给定一个随机排列的序列，找出其中某个元素的位置——有没有比 O(n) 更快的算法？比如 O(lgn)？请读者思考一下。

### 1.11.6. 折半查找

如果不是从一组随机的序列里查找，而是从一组排好序的序列里找出某个元素的位置，则可以有更快的算法：

<p id="e11-4">例 11.4. 折半查找</p>

```c
  #include <stdio.h>

  #define LEN 8
  int a[LEN] = { 1, 2, 2, 2, 5, 6, 8, 9 };

  int binarysearch(int number)
  {
  	int mid, start = 0, end = LEN - 1;

  	while (start <= end) {
  		mid = (start + end) / 2;
  		if (a[mid] < number)
  			start = mid + 1;
  		else if (a[mid] > number)
  			end = mid - 1;
  		else
  			return mid;
  	}
  	return -1;
  }

  int main(void)
  {
  	printf("%d\n", binarysearch(5));
  	return 0;
  }
```

由于这个序列已经从小到大排好序了，每次取中间的元素和待查找的元素比较，如果中间的元素比待查找的元素小，就说明「如果待查找的元素存在，一定位于序列的后半部分」，这样可以把搜索范围缩小到后半部分，然后再次使用这种算法迭代。这种「每次将搜索范围缩小一半」的思想称为折半查找（Binary Search）。思考一下，这个算法的时间复杂度是多少？

这个算法的思想很简单，不是吗？可是编程珠玑上说作者在课堂上讲完这个算法的思想然后让学生写程序，有 90% 的人写出的程序中有各种各样的 Bug，读者不信的话可以不看书自己写一遍试试。这个算法容易出错的地方很多，比如 `mid = (start + end) / 2;` 这一句，在数学概念上其实是 `mid = ⌊(start + end) / 2⌋`，还有 `start = mid + 1;` 和 `end = mid - 1;`，如果前者写成了 `start = mid;` 或后者写成了 `end = mid;` 那么很可能会导致死循环（想一想什么情况下会死循环）。

怎样才能保证程序的正确性呢？在[本章第 2 节「插入排序」](#_2-插入排序)我们讲过借助 Loop Invariant 证明循环的正确性，`binarysearch` 这个函数的主体也是一个循环，它的 Loop Invariant 可以这样描述：**待查找的元素 number 如果存在于数组 a 之中，那么一定存在于 `a[start..end]` 这个范围之间，换句话说，在这个范围之外的数组 a 的元素中一定不存在 number 这个元素**。以下为了书写方便，我们把这句话表示成 `mustbe(start, end, number)`。可以一边看算法一边做推理：

```c
int binarysearch(int number)
{
	int mid, start = 0, end = LEN - 1;

	/* 假定 a 是排好序的 */
	/* mustbe(start, end, number)，
	 * 因为 a[start..end] 就是整个数组 a[0..LEN-1] */
	while (start <= end) {
	/* mustbe(start, end, number)，因为一开始进入循环时是正确的，
	 * 每次循环也都维护了这个条件 */
		mid = (start + end) / 2;
		if (a[mid] < number)
			/* 既然 a 是排好序的，a[start..mid] 应该都比 number 小，
			 * 所以 mustbe(mid+1, end, number) */
			start = mid + 1;
			/* 维护了 mustbe(start, end, number) */
		else if (a[mid] > number)
			/* 既然 a 是排好序的，a[mid..end] 应该都比 number 大，
			 * 所以 mustbe(start, mid-1, number) */
			end = mid - 1;
			/* 维护了 mustbe(start, end, number) */
		else
			/* a[mid] == number，说明找到了 */
			return mid;
	}
	/*
	 * mustbe(start, end, number) 一直被循环维护着，到这里应该仍然成立，
	 * 在 a[start..end] 范围之外一定不存在 number，
	 * 但现在 a[start..end] 是空序列，在这个范围之外的正是整个数组 a，
	 * 因此整个数组 a 中都不存在 number
	 */
	return -1;
}
```

注意这个算法有一个非常重要的前提——`a` 是排好序的。缺了这个前提，「如果 `a[mid] < number`，那么 `a[start..mid]` 应该都比 `number` 小」这一步推理就不能成立，这个函数就不能正确地完成查找。从更普遍的意义上说，函数的调用者（Caller）和函数的实现者（Callee，被调用者）之间订立了一个契约（Contract），在调用函数之前，Caller 要为 Callee 提供某些条件，比如确保 `a` 是排好序的，确保 `a[start..end]` 都是有效的数组元素而没有访问越界，这称为 Precondition，然后 Callee 对一些 Invariant 进行维护（Maintenance），这些 Invariant 保证了 Callee 在函数返回时能够对 Caller 尽到某些义务，比如确保「如果 `number` 在数组 `a` 中存在，一定能找出来并返回它的位置，如果 `number` 在数组 `a` 中不存在，一定能返回 `-1`」，这称为 Postcondition。如果每个函数的文档都非常清楚地记录了 Precondition、Maintenance 和 Postcondition 是什么，那么每个函数都可以独立编写和测试，整个系统就会易于维护。这种编程思想是由 Eiffel 语言的设计者 Bertrand Meyer 提出来的，称为 Design by Contract（DbC）。

测试一个函数是否正确需要把 Precondition、Maintenance 和 Postcondition 这三方面都测试到，比如 `binarysearch` 这个函数，即使它写得非常正确，既维护了 Invariant 也保证了 Postcondition，如果调用它的 Caller 没有保证 Precondition，最后的结果也还是错的。我们编写几个测试用的 Predicate 函数，然后把相关的测试插入到 `binarysearch` 函数中：

<p id="e11-5">例 11.5. 带有测试代码的折半查找</p>

```c
  #include <stdio.h>
  #include <assert.h>
  
  #define LEN 8
  int a[LEN] = { 1, 2, 2, 2, 5, 6, 8, 9 };
  
  int is_sorted(void)
  {
  	int i;
  	for (i = 1; i < LEN; i++)
  		if (a[i-1] > a[i])
  			return 0;
  	return 1;
  }
  
  int mustbe(int start, int end, int number)
  {
  	int i;
  	for (i = 0; i < start; i++)
  		if (a[i] == number)
  			return 0;
  	for (i = end+1; i < LEN; i++)
  		if (a[i] == number)
  			return 0;
  	return 1;
  }
  
  int contains(int n)
  {
  	int i;
  	for (i = 0; i < LEN; i++)
  		if (a[i] == n)
  			return 1;
  	return 0;
  }
  
  int binarysearch(int number)
  {
  	int mid, start = 0, end = LEN - 1;
  
  	assert(is_sorted()); /* Precondition */
  	while (start <= end) {
  		assert(mustbe(start, end, number)); /* Maintenance */
  		mid = (start + end) / 2;
  		if (a[mid] < number)
  			start = mid + 1;
  		else if (a[mid] > number)
  			end = mid - 1;
  		else {
  			assert(mid >= start && mid <= end
  			       && a[mid] == number) /* Postcondition 1 */
  			return mid;
  		}
  	}
  	assert(!contains(number)); /* Postcondition 2 */
  	return -1;
  }
  
  int main(void)
  {
  	printf("%d\n", binarysearch(5));
  	return 0;
  }
```

`assert` 是头文件 `assert.h` 中的一个宏定义，执行到 `assert(is_sorted())` 这句时，如果 `is_sorted()` 返回值为真，则当什么事都没发生过，继续往下执行，如果 `is_sorted()` 返回值为假（例如把数组的排列顺序改一改），则报错退出程序：

```bash
main: main.c:33: binarysearch: Assertion 'is_sorted()' failed.
Aborted
```

在代码中适当的地方使用断言（Assertion）可以有效地帮助我们测试程序。也许有人会问：我们用几个测试函数来测试 `binarysearch`，那么这几个测试函数又用什么来测试呢？在实际工作中我们要测试的代码绝不会像 `binarysearch` 这么简单，而我们编写的测试函数往往都很简单，比较容易保证正确性，也就是用简单的、不容易出错的代码去测试复杂的、容易出错的代码。

测试代码只在开发和调试时有用，如果正式发布（Release）的软件也要运行这些测试代码就会严重影响性能了，如果在包含 `assert.h` 之前定义一个 `NDEBUG` 宏（表示 No Debug），就可以禁用 `assert.h` 中的 `assert` 宏定义，这样代码中的所有 `assert` 测试都不起作用了：

```c
  #define NDEBUG
  #include <stdio.h>
  #include <assert.h>
  ...
```

注意 `NDEBUG` 和我们以前使用的宏定义有点不同，例如 `#define N 20` 将 `N` 定义为 20，在预处理时把代码中所有的标识符 `N` 替换成 20，而 `#define NDEBUG` 把 `NDEBUG` 定义为空，在预处理时把代码中所有的标识符 `NDEBUG` 替换成空。这样的宏定义主要是为了用 `#ifdef` 等预处理指示测试它定义过没有，而不是为了做替换，所以定义成什么值都无所谓，一般定义成空就足够了。

还有另一种办法，不必修改源文件，在编译命令行加上选项 `-DNDEBUG` 就相当于在源文件开头定义了 `NDEBUG`宏。宏定义和预处理到[第 21 章「预处理」](2-C-语言本质/ch21-预处理)再详细解释，在[第 21 章第 4 节「其它预处理特性」](2-C-语言本质/ch21-预处理#_4-其它预处理特性)将给出 `assert.h` 一种实现。


## 1.12. 栈与队列

### 1.12.1. 数据结构的概念

数据结构（Data Structure）是数据的组织方式。程序中用到的数据都不是孤立的，而是有相互联系的，根据访问数据的需求不同，同样的数据可以有多种不同的组织方式。以前学过的复合类型也可以看作数据的组织方式，把同一类型的数据组织成数组，或者把描述同一对象的各成员组织成结构体。数据的组织方式包含了存储方式和访问方式这两层意思，二者是紧密联系的。例如，数组的各元素是一个挨一个存储的，并且每个元素的大小相同，因此数组可以提供按下标访问的方式，结构体的各成员也是一个挨一个存储的，但是每个成员的大小不同，所以只能用 `.` 运算符加成员名来访问，而不能按下标访问。

本章主要介绍栈和队列这两种数据结构以及它们的应用。从本章的应用实例可以看出，一个问题中数据的存储方式和访问方式就决定了解决问题可以采用什么样的算法，要设计一个算法就要同时设计相应的数据结构来支持这种算法。所以 Pascal 语言的设计者 Niklaus  Wirth 提出：**算法+数据结构=程序**（详见*算法+数据结构=程序*）。

### 1.12.2. 堆栈

在[第 5 章第 3 节「递归」](1-C-语言入门/ch05-深入理解函数#_3-递归)中我们已经对堆栈这种数据结构有了初步认识。堆栈是一组元素的集合，类似于数组，不同之处在于，数组可以按下标随机访问，这次访问 `a[5]` 下次可以访问 `a[1]`，但是堆栈的访问规则被限制为 Push 和 Pop 两种操作，Push（入栈或压栈）向栈顶添加元素，Pop（出栈或弹出）则取出当前栈顶的元素，也就是说，只能访问栈顶元素而不能访问栈中其它元素。如果所有元素的类型相同，堆栈的存储也可以用数组来实现，访问操作可以通过函数接口提供。看以下的示例程序。

<p id="e12-1">例 12.1. 用堆栈实现倒序打印</p>

```c
  #include <stdio.h>
  
  char stack[512];
  int top = 0;
  
  void push(char c)
  {
  	stack[top++] = c;
  }
  
  char pop(void)
  {
  	return stack[--top];
  }
  
  int is_empty(void)
  {
  	return top == 0;
  }
  
  int main(void)
  {
  	push('a');
  	push('b');
  	push('c');
  	
  	while(!is_empty())
  		putchar(pop());
  	putchar('\n');
  
  	return 0;
  }
```

运行结果是 `cba`。运行过程图示如下：

<p id="c12-1">图 12.1. 用堆栈实现倒序打印</p>

![用堆栈实现倒序打印](./image/stackqueue.stack.png)

数组 `stack` 是堆栈的存储空间，变量 `top` 总是保存数组中栈顶的下一个元素的下标，我们说「`top` 总是指向栈顶的下一个元素」，或者把 `top` 叫做栈顶指针（Pointer）。在[第 11 章第 2 节「插入排序」](1-C-语言入门/ch11-排序与查找#_2-插入排序)中介绍了 Loop Invariant 的概念，可以用它检验循环的正确性，这里的「`top` 总是指向栈顶的下一个元素」其实也是一种 Invariant，Push 和 Pop 操作总是维持这个条件不变，这种 Invariant 描述的对象是一个数据结构而不是一个循环，在 DbC 中称为 Class Invariant。Pop 操作的语义是取出栈顶元素，但上例的实现其实并没有清除原来的栈顶元素，只是把 `top` 指针移动了一下，原来的栈顶元素仍然存在那里，这就足够了，因为此后通过 Push 和 Pop 操作不可能再访问到已经取出的元素，下次 Push 操作就会覆盖它。`putchar` 函数的作用是把一个字符打印到屏幕上，和 `printf` 的 `%c` 作用相同。布尔函数 `is_empty` 的作用是防止 Pop 操作访问越界。这里我们预留了足够大的栈空间（512 个元素），其实严格来说 Push 操作之前也应该检查栈是否满了。

在 `main` 函数中，入栈的顺序是 `'a'`、`'b'`、`'c'`，而出栈打印的顺序却是 `'c'`、`'b'`、`'a'`，最后入栈的 `'c'` 最早出来，因此堆栈这种数据结构的特点可以概括为 LIFO（Last In First Out，后进先出）。我们也可以写一个递归函数做倒序打印，利用函数调用的栈帧实现后进先出：

<p id="e12-2">例 12.2. 用递归实现倒序打印</p>

```c
  #include <stdio.h>
  #define LEN 3
  
  char buf[LEN]={'a', 'b', 'c'};
  
  void print_backward(int pos)
  {
       if(pos == LEN)
  	  return;
       print_backward(pos+1);
       putchar(buf[pos]);
  }
  
  int main(void)
  {
       print_backward(0);
       putchar('\n');
       
       return 0;
  }
```

也许你会说，又是堆栈又是递归的，倒序打印一个数组犯得着这么大动干戈吗？写一个简单的循环不就行了：

```c
for (i = LEN-1; i >= 0; i--)
	putchar(buf[i]);
```

对于数组来说确实没必要搞这么复杂，因为数组既可以从前向后访问也可以从后向前访问，甚至可以随机访问，但有些数据结构的访问并没有这么自由，下一节你就会看到这样的数据结构。

### 1.12.3. 深度优先搜索

现在我们用堆栈解决一个有意思的问题，定义一个二维数组：

```c
int maze[5][5] = {
	0, 1, 0, 0, 0,
	0, 1, 0, 1, 0,
	0, 0, 0, 0, 0,
	0, 1, 1, 1, 0,
	0, 0, 0, 1, 0,
};
```

它表示一个迷宫，其中的 1 表示墙壁，0 表示可以走的路，只能横着走或竖着走，不能斜着走，要求编程序找出从左上角到右下角的路线。程序如下：

<p id="e12-3">例 12.3. 用深度优先搜索解迷宫问题</p>

```c
  #include <stdio.h>
  
  #define MAX_ROW 5
  #define MAX_COL 5
  
  struct point { int row, col; } stack[512];
  int top = 0;
  
  void push(struct point p)
  {
  	stack[top++] = p;
  }
  
  struct point pop(void)
  {
  	return stack[--top];
  }
  
  int is_empty(void)
  {
  	return top == 0;
  }
  
  int maze[MAX_ROW][MAX_COL] = {
  	0, 1, 0, 0, 0,
  	0, 1, 0, 1, 0,
  	0, 0, 0, 0, 0,
  	0, 1, 1, 1, 0,
  	0, 0, 0, 1, 0,
  };
  
  void print_maze(void)
  {
  	int i, j;
  	for (i = 0; i < MAX_ROW; i++) {
  		for (j = 0; j < MAX_COL; j++)
  			printf("%d ", maze[i][j]);
  		putchar('\n');
  	}
  	printf("*********\n");
  }
  
  struct point predecessor[MAX_ROW][MAX_COL] = {
  	{{-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}},
  	{{-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}},
  	{{-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}},
  	{{-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}},
  	{{-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}, {-1,-1}},
  };
  
  void visit(int row, int col, struct point pre)
  {
  	struct point visit_point = { row, col };
  	maze[row][col] = 2;
  	predecessor[row][col] = pre;
  	push(visit_point);
  }
  
  int main(void)
  {
  	struct point p = { 0, 0 };
  
  	maze[p.row][p.col] = 2;
  	push(p);	
  	
  	while (!is_empty()) {
  		p = pop();
  		if (p.row == MAX_ROW - 1  /* goal */
  		    && p.col == MAX_COL - 1)
  			break;
  		if (p.col+1 < MAX_COL     /* right */
  		    && maze[p.row][p.col+1] == 0)
  			visit(p.row, p.col+1, p);
  		if (p.row+1 < MAX_ROW     /* down */
  		    && maze[p.row+1][p.col] == 0)
  			visit(p.row+1, p.col, p);
  		if (p.col-1 >= 0          /* left */
  		    && maze[p.row][p.col-1] == 0)
  			visit(p.row, p.col-1, p);
  		if (p.row-1 >= 0          /* up */
  		    && maze[p.row-1][p.col] == 0)
  			visit(p.row-1, p.col, p);
  		print_maze();
  	}
  	if (p.row == MAX_ROW - 1 && p.col == MAX_COL - 1) {
  		printf("(%d, %d)\n", p.row, p.col);
  		while (predecessor[p.row][p.col].row != -1) {
  			p = predecessor[p.row][p.col];
  			printf("(%d, %d)\n", p.row, p.col);
  		}
  	} else
  		printf("No path!\n");
  
  	return 0;
  }
```

运行结果如下：

```bash
2 1 0 0 0 
2 1 0 1 0 
0 0 0 0 0 
0 1 1 1 0 
0 0 0 1 0 
*********
2 1 0 0 0 
2 1 0 1 0 
2 0 0 0 0 
0 1 1 1 0 
0 0 0 1 0 
*********
2 1 0 0 0 
2 1 0 1 0 
2 2 0 0 0 
2 1 1 1 0 
0 0 0 1 0 
*********
2 1 0 0 0 
2 1 0 1 0 
2 2 0 0 0 
2 1 1 1 0 
2 0 0 1 0 
*********
2 1 0 0 0 
2 1 0 1 0 
2 2 0 0 0 
2 1 1 1 0 
2 2 0 1 0 
*********
2 1 0 0 0 
2 1 0 1 0 
2 2 0 0 0 
2 1 1 1 0 
2 2 2 1 0 
*********
2 1 0 0 0 
2 1 0 1 0 
2 2 0 0 0 
2 1 1 1 0 
2 2 2 1 0 
*********
2 1 0 0 0 
2 1 0 1 0 
2 2 2 0 0 
2 1 1 1 0 
2 2 2 1 0 
*********
2 1 0 0 0 
2 1 2 1 0 
2 2 2 2 0 
2 1 1 1 0 
2 2 2 1 0 
*********
2 1 2 0 0 
2 1 2 1 0 
2 2 2 2 0 
2 1 1 1 0 
2 2 2 1 0 
*********
2 1 2 2 0 
2 1 2 1 0 
2 2 2 2 0 
2 1 1 1 0 
2 2 2 1 0 
*********
2 1 2 2 2 
2 1 2 1 0 
2 2 2 2 0 
2 1 1 1 0 
2 2 2 1 0 
*********
2 1 2 2 2 
2 1 2 1 2 
2 2 2 2 0 
2 1 1 1 0 
2 2 2 1 0 
*********
2 1 2 2 2 
2 1 2 1 2 
2 2 2 2 2 
2 1 1 1 0 
2 2 2 1 0 
*********
2 1 2 2 2 
2 1 2 1 2 
2 2 2 2 2 
2 1 1 1 2 
2 2 2 1 0 
*********
2 1 2 2 2 
2 1 2 1 2 
2 2 2 2 2 
2 1 1 1 2 
2 2 2 1 2 
*********
(4, 4)
(3, 4)
(2, 4)
(1, 4)
(0, 4)
(0, 3)
(0, 2)
(1, 2)
(2, 2)
(2, 1)
(2, 0)
(1, 0)
(0, 0)
```

这次堆栈里的元素是结构体类型的，用来表示迷宫中一个点的 x 和 y 座标。我们用一个新的数据结构保存走迷宫的路线，每个走过的点都有一个前趋（Predecessor）点，表示是从哪儿走到当前点的，比如 `predecessor[4][4]` 是座标为 (3, 4) 的点，就表示从 (3, 4) 走到了 (4, 4)，一开始 `predecessor` 的各元素初始化为无效座标 (-1, -1)。在迷宫中探索路线的同时就把路线保存在 `predecessor` 数组中，已经走过的点在 `maze` 数组中记为 2 防止重复走，最后找到终点时就根据 `predecessor` 数组保存的路线从终点打印到起点。为了帮助理解，我把这个算法改写成伪代码（Pseudocode）如下：

```c
将起点标记为已走过并压栈;
while (栈非空) {
	从栈顶弹出一个点 p;
	if (p 这个点是终点)
		break;
	否则沿右、下、左、上四个方向探索相邻的点
	if (和 p 相邻的点有路可走，并且还没走过)
		将相邻的点标记为已走过并压栈，它的前趋就是 p 点;
}
if (p 点是终点) {
	打印p 点的座标;
	while (p 点有前趋) {
		p 点 = p 点的前趋;
		打印 p 点的座标;
	}
} else
	没有路线可以到达终点;
```

我在 `while` 循环的末尾插了打印语句，每探索一步都打印出当前迷宫的状态（标记了哪些点），从打印结果可以看出这种搜索算法的特点是：每次探索完各个方向相邻的点之后，取其中一个相邻的点走下去，一直走到无路可走了再退回来，取另一个相邻的点再走下去。这称为深度优先搜索（DFS，Depth  First Search）。探索迷宫和堆栈变化的过程如下图所示。

<p id="c12-2">图 12.2. 深度优先搜索</p>

![深度优先搜索](./image/stackqueue.dfs.png)

图中各点的编号表示探索顺序，堆栈中保存的应该是座标，我在画图时为了直观就把各点的编号写在堆栈里了。可见正是堆栈后进先出的性质使这个算法具有了深度优先的特点。如果在探索问题的解时走进了死胡同，则需要退回来从另一条路继续探索，这种思想称为回溯（Backtrack），一个典型的例子是很多编程书上都会讲的八皇后问题。

最后我们打印终点的座标并通过 `predecessor` 数据结构找到它的前趋，这样顺藤摸瓜一直打印到起点。那么能不能从起点到终点正向打印路线呢？在上一节我们看到，数组支持随机访问也支持顺序访问，如果在一个循环里打印数组，既可以正向打印也可以反向打印。但 `predecessor` 这种数据结构却有很多限制：

1. 不能随机访问一条路线上的任意点，只能通过一个点找到另一个点，通过另一个点再找第三个点，因此只能顺序访问。
2. 每个点只知道它的前趋是谁，而不知道它的后继（Successor）是谁，所以只能反向顺序访问。

可见，**有什么样的数据结构就决定了可以用什么样的算法**。那为什么不再建一个 `successor` 数组来保存每个点的后继呢？从 DFS 算法的过程可以看出，虽然每个点的前趋只有一个，后继却不止一个，如果我们为每个点只保存一个后继，则无法保证这个后继指向正确的路线。由此可见，**有什么样的算法就决定了可以用什么样的数据结构**。设计算法和设计数据结构这两件工作是紧密联系的。

### 1.12.4. 队列与广度优先搜索

队列也是一组元素的集合，也提供两种基本操作：Enqueue （入队）将元素添加到队尾，Dequeue （出队）从队头取出元素并返回。就像排队买票一样，先来先服务，先入队的人也是先出队的，这种方式称为 FIFO（First In First Out，先进先出），有时候队列本身也被称为 FIFO。

下面我们用队列解决迷宫问题。程序如下：

<p id="e12-4">例 12.4. 用广度优先搜索解迷宫问题</p>

```c
  #include <stdio.h>
  
  #define MAX_ROW 5
  #define MAX_COL 5
  
  struct point { int row, col, predecessor; } queue[512];
  int head = 0, tail = 0;
  
  void enqueue(struct point p)
  {
  	queue[tail++] = p;
  }
  
  struct point dequeue(void)
  {
  	return queue[head++];
  }
  
  int is_empty(void)
  {
  	return head == tail;
  }
  
  int maze[MAX_ROW][MAX_COL] = {
  	0, 1, 0, 0, 0,
  	0, 1, 0, 1, 0,
  	0, 0, 0, 0, 0,
  	0, 1, 1, 1, 0,
  	0, 0, 0, 1, 0,
  };
  
  void print_maze(void)
  {
  	int i, j;
  	for (i = 0; i < MAX_ROW; i++) {
  		for (j = 0; j < MAX_COL; j++)
  			printf("%d ", maze[i][j]);
  		putchar('\n');
  	}
  	printf("*********\n");
  }
  
  void visit(int row, int col)
  {
  	struct point visit_point = { row, col, head-1 };
  	maze[row][col] = 2;
  	enqueue(visit_point);
  }
  
  int main(void)
  {
  	struct point p = { 0, 0, -1 };
  
  	maze[p.row][p.col] = 2;
  	enqueue(p);
  	
  	while (!is_empty()) {
  		p = dequeue();
  		if (p.row == MAX_ROW - 1  /* goal */
  		    && p.col == MAX_COL - 1)
  			break;
  		if (p.col+1 < MAX_COL     /* right */
  		    && maze[p.row][p.col+1] == 0)
  			visit(p.row, p.col+1);
  		if (p.row+1 < MAX_ROW     /* down */
  		    && maze[p.row+1][p.col] == 0)
  			visit(p.row+1, p.col);
  		if (p.col-1 >= 0          /* left */
  		    && maze[p.row][p.col-1] == 0)
  			visit(p.row, p.col-1);
  		if (p.row-1 >= 0          /* up */
  		    && maze[p.row-1][p.col] == 0)
  			visit(p.row-1, p.col);
  		print_maze();
  	}
  	if (p.row == MAX_ROW - 1 && p.col == MAX_COL - 1) {
  		printf("(%d, %d)\n", p.row, p.col);
  		while (p.predecessor != -1) {
  			p = queue[p.predecessor];
  			printf("(%d, %d)\n", p.row, p.col);
  		}
  	} else
  		printf("No path!\n");
  
  	return 0;
  }
```

运行结果如下：

```bash
2 1 0 0 0 
2 1 0 1 0 
0 0 0 0 0 
0 1 1 1 0 
0 0 0 1 0 
*********
2 1 0 0 0 
2 1 0 1 0 
2 0 0 0 0 
0 1 1 1 0 
0 0 0 1 0 
*********
2 1 0 0 0 
2 1 0 1 0 
2 2 0 0 0 
2 1 1 1 0 
0 0 0 1 0 
*********
2 1 0 0 0 
2 1 0 1 0 
2 2 2 0 0 
2 1 1 1 0 
0 0 0 1 0 
*********
2 1 0 0 0 
2 1 0 1 0 
2 2 2 0 0 
2 1 1 1 0 
2 0 0 1 0 
*********
2 1 0 0 0 
2 1 2 1 0 
2 2 2 2 0 
2 1 1 1 0 
2 0 0 1 0 
*********
2 1 0 0 0 
2 1 2 1 0 
2 2 2 2 0 
2 1 1 1 0 
2 2 0 1 0 
*********
2 1 0 0 0 
2 1 2 1 0 
2 2 2 2 2 
2 1 1 1 0 
2 2 0 1 0 
*********
2 1 2 0 0 
2 1 2 1 0 
2 2 2 2 2 
2 1 1 1 0 
2 2 0 1 0 
*********
2 1 2 0 0 
2 1 2 1 0 
2 2 2 2 2 
2 1 1 1 0 
2 2 2 1 0 
*********
2 1 2 0 0 
2 1 2 1 2 
2 2 2 2 2 
2 1 1 1 2 
2 2 2 1 0 
*********
2 1 2 2 0 
2 1 2 1 2 
2 2 2 2 2 
2 1 1 1 2 
2 2 2 1 0 
*********
2 1 2 2 0 
2 1 2 1 2 
2 2 2 2 2 
2 1 1 1 2 
2 2 2 1 0 
*********
2 1 2 2 0 
2 1 2 1 2 
2 2 2 2 2 
2 1 1 1 2 
2 2 2 1 2 
*********
2 1 2 2 2 
2 1 2 1 2 
2 2 2 2 2 
2 1 1 1 2 
2 2 2 1 2 
*********
2 1 2 2 2 
2 1 2 1 2 
2 2 2 2 2 
2 1 1 1 2 
2 2 2 1 2 
*********
(4, 4)
(3, 4)
(2, 4)
(2, 3)
(2, 2)
(2, 1)
(2, 0)
(1, 0)
(0, 0)
```

其实仍然可以像[上一节例 12.3 「用深度优先搜索解迷宫问题」](#e12-3)一样用 `predecessor` 数组表示每个点的前趋，但我想换一种更方便的数据结构，直接在每个点的结构体中加一个成员表示前趋：

```c
struct point { int row, col, predecessor; } queue[512];
int head = 0, tail = 0;
```

变量 `head` 和 `tail` 是队头和队尾指针，`head` 总是指向队头，`tail` 总是指向队尾的下一个元素。每个点的 `predecessor` 成员也是一个指针，指向它的前趋在 `queue` 数组中的位置。如下图所示：

<p id="c12-3">图 12.3. 广度优先搜索的队列数据结构</p>

![广度优先搜索的队列数据结构](./image/stackqueue.bfsqueue.png)

为了帮助理解，我把这个算法改写成伪代码如下：

```c
将起点标记为已走过并入队;
while (队列非空) {
	出队一个点 p;
	if (p 这个点是终点)
		break;
	否则沿右、下、左、上四个方向探索相邻的点
	if (和 p 相邻的点有路可走，并且还没走过)
		将相邻的点标记为已走过并入队，它的前趋就是刚出队的 p 点;
}
if (p 点是终点) {
	打印 p 点的座标;
	while (p 点有前趋) {
		p 点 = p 点的前趋;
		打印 p 点的座标;
	}
} else
	没有路线可以到达终点;
```

从打印的搜索过程可以看出，这个算法的特点是沿各个方向同时展开搜索，每个可以走通的方向轮流往前走一步，这称为广度优先搜索（BFS，Breadth First Search）。探索迷宫和队列变化的过程如下图所示。

<p id="c12-4">图 12.4. 广度优先搜索</p>

![广度优先搜索](./image/stackqueue.bfs.png)

广度优先是一种步步为营的策略，每次都从各个方向探索一步，将前线推进一步，图中的虚线就表示这个前线，队列中的元素总是由前线的点组成的，可见正是队列先进先出的性质使这个算法具有了广度优先的特点。广度优先搜索还有一个特点是可以找到从起点到终点的最短路径，而深度优先搜索找到的不一定是最短路径，比较本节和上一节程序的运行结果可以看出这一点，想一想为什么。

### 1.12.5. 环形队列

比较[本章例 12.3 「用深度优先搜索解迷宫问题」](#e12-3)的栈操作和[例 12.4 「用广度优先搜索解迷宫问题」](#e12-4)的队列操作可以发现，栈操作的 `top` 指针在 Push 时增大而在 Pop 时减小，栈空间是可以重复利用的，而队列的 `head`、`tail` 指针都在一直增大，虽然前面的元素已经出队了，但它所占的存储空间却不能重复利用。在[本章例 12.4 「用广度优先搜索解迷宫问题」](#e12-4)的解法中，出队的元素仍然有用，保存着走过的路径和每个点的前趋，但大多数程序并不是这样使用队列的，一般情况下出队的元素就不再有保存价值了，这些元素的存储空间应该回收利用，由此想到把队列改造成环形队列（Circular Queue）：把 `queue` 数组想像成一个圈，`head` 和 `tail` 指针仍然是一直增大的，当指到数组末尾时就自动回到数组开头，就像两个人围着操场赛跑，沿着它们跑的方向看，从 `head` 到 `tail` 之间是队列的有效元素，从 `tail` 到 `head` 之间是空的存储位置，如果 `head` 追上 `tail` 就表示队列空了，如果 `tail` 追上 `head` 就表示队列的存储空间满了。如下图所示：

<p id="c12-5">图 12.5. 环形队列</p>

![环形队列](./image/stackqueue.circular.png)

# 2. C 语言本质

## 2.1. 计算机中数的表示

### 2.1.1. 为什么计算机用二进制计数

人类的计数方式通常是「逢十进一」，称为十进制（Decimal），大概因为人有十个手指，所以十进制是最自然的计数方式，很多民族的语言文字中都有十个数字，而阿拉伯数字 0 ~ 9 是目前最广泛采用的。

计算机是用数字电路搭成的，数字电路中只有 1 和 0 两种状态，或者可以说计算机只有两个手指，所以对计算机来说二进制（Binary）是最自然的计数方式。根据「逢二进一」的原则，十进制的 1、2、3、4 分别对应二进制的 1、10、11、100。二进制的一位数字称为一个位（Bit），三个 bit 能够表示的最大的二进制数是 111，也就是十进制的 7。不管用哪种计数方式，数的大小并没有变，十进制的 1+1 等于 2，二进制的 1+1 等于 10，二进制的 10 和十进制的 2 大小是相等的。事实上，计算机采用如下的逻辑电路计算两个 bit 的加法：

<p id="c14-1">图 14.1. 1-bit Full Adder</p>

![1-bit Full Adder](./image/number.digitallogic.png)

图的上半部分（出自Wikipedia）的电路称为一位全加器（1-bit Full Adder），图的下半部分是一些逻辑电路符号的图例。我们首先解释这些图例，逻辑电路由门电路（Gate）和导线（Wire）组成，同一条导线上在某一时刻的电压值只能是高和低两种状态之一，分别用 0 和 1 表示。如果两条导线短接在一起则它们的电压值相同，在接点处画一个黑点，如果接点处没有画黑点则表示这两条线并没有短接在一起，只是在画图时无法避免交叉。导线的电压值进入门电路的输入端，经过逻辑运算后在门电路的输出端输出运算结果的电压值，任何复杂的加减乘除运算都可以分解成简单的逻辑运算。AND、OR 和 NOT 运算在[第 4 章第 3 节「布尔代数」](1-C-语言入门/ch04-分支语句#_3-布尔代数)中讲过了，这三种逻辑运算分别用与门、或门和反相器（Inverter）实现。另外几种逻辑运算在这里补充一下。异或（XOR，eXclusive OR）运算的真值表如下：

<p id="t14-1">表 14.1. XOR 的真值表</p>

| A    | B    | A XOR B |
| ---- | ---- | ------- |
| 0    | 0    | 0       |
| 0    | 1    | 1       |
| 1    | 0    | 1       |
| 1    | 1    | 0       |

用一句话概括就是：两个操作数相同则结果为 0，两个操作数不同则结果为 1。与非（NAND）和或非（NOR）运算就是在与、或运算的基础上取反：

<p id="t14-2">表 14.2. NAND 的真值表</p>

| A    | B    | A NAND B |
| ---- | ---- | -------- |
| 0    | 0    | 1        |
| 0    | 1    | 1        |
| 1    | 0    | 1        |
| 1    | 1    | 0        |

<p id="t14-3">表 14.3. NOR 的真值表</p>

| A    | B    | A NOR B |
| ---- | ---- | ------- |
| 0    | 0    | 1       |
| 0    | 1    | 0       |
| 1    | 0    | 0       |
| 1    | 1    | 0       |

如果把与门、或门和反相器组合来实现 NAND 和 NOR 运算，则电路过于复杂了，因此逻辑电路中通常有专用的与非门和或非门。现在我们看看上图中的 AND、OR、XOR 是怎么实现两个 bit 的加法的。A、B 是两个加数，Cin 是低位传上来的进位（Carry），相当于三个加数求和，三个加数都是 0则结果为 0，三个加数都是 1 则结果为 11，即输出位 S 是 1，产生的进位 Cout 也是 1。下面根据加法的规则用真值表列出所有可能的情况：

<p id="t14-4">表 14.4. 1-bit Full Adder 的真值表</p>

| A    | B    | Cin  | Cout | S    |
| ---- | ---- | ---- | ---- | ---- |
| 0    | 0    | 0    | 0    | 0    |
| 0    | 0    | 1    | 0    | 1    |
| 0    | 1    | 0    | 0    | 1    |
| 0    | 1    | 1    | 1    | 0    |
| 1    | 0    | 0    | 0    | 1    |
| 1    | 0    | 1    | 1    | 0    |
| 1    | 1    | 0    | 1    | 0    |
| 1    | 1    | 1    | 1    | 1    |

请读者对照电路图验证一下真值表是否正确。如果把很多个一位全加器串接起来，就成了多位加法器，如下图所示（该图出自 Wikipedia）：

<p id="c14-2">图 14.2. 4-bit Ripple Carry Adder</p>

![4-bit Ripple Carry Adder](./image/number.fulladder.png)

图中的一位全加器用方框表示，上一级全加器的 Cout 连接到下一级全加器的 Cin，让进位像涟漪一样一级一级传开，所以叫做 Ripple Carry Adder，这样就可以把两个 4 bit 二进制数 A3A2A1A0 和 B3B2B1B0 加起来了。在这里介绍 Ripple Carry Adder 只是为了让读者理解计算机是如何通过逻辑运算来做算术运算的，实际上这种加法器效率很低，只能加完了一位再加下一位，更实用、更复杂的加法器可以多个位一起计算，有兴趣的读者可参考*数字逻辑基础*。

### 2.1.2. 不同进制之间的换算

在十进制中，个位的 1 代表 10<sup>0</sup> = 1，十位的 1 代表 10<sup>1</sup>=10，百位的 1 代表 10<sup>2</sup>=100，所以

123 = 1×10<sup>2</sup>+2×10<sup>1</sup>+3×10<sup>0</sup>

同样道理，在二进制中，个位的 1 代表 2<sup>0</sup>=1，十位的 1 代表2<sup>1</sup>=2，百位的 1 代表 2<sup>2</sup>=4，所以

(A<sub>3</sub>A<sub>2</sub>A<sub>1</sub>A<sub>0</sub>)<sub>2</sub> = A<sub>3</sub>×2<sup>3</sup> + A<sub>2</sub>×2<sup>2</sup> + A<sub>1</sub>×2<sup>1</sup> + A<sub>0</sub>×2<sup>0</sup>

如果二进制和十进制数出现在同一个等式中，为了区别我们用 (A<sub>3</sub>A<sub>2</sub>A<sub>1</sub>A<sub>0</sub>)<sub>2</sub> 这种形式表示 (A<sub>3</sub>A<sub>2</sub>A<sub>1</sub>A<sub>0</sub>) 是二进制数，每个数字只能是 0 或 1，其它没有套括号加下标的数仍表示十进制数。对于 (A<sub>3</sub>A<sub>2</sub>A<sub>1</sub>A<sub>0</sub>)<sub>2</sub> 这样一个二进制数，最左边的 A<sub>3</sub> 位称为最高位（MSB，Most Significant Bit），最右边的 A<sub>0</sub> 位称为最低位（LSB，Least Significant Bit）。以后我们遵循这样的惯例：**LSB 称为第 0 位而不是第 1 位，所以如果一个数是 32 位的，则 MSB 是第 31 位**。上式就是从二进制到十进制的换算公式。作为练习，请读者算一下 (1011)<sub>2</sub> 和 (1111)<sub>2</sub> 换算成十进制分别是多少。

下面来看十进制怎么换算成二进制。我们知道

13 = 1×2<sup>3</sup> + 1×2<sup>2</sup> + 0×2<sup>1</sup> + 1×2<sup>0</sup>

所以 13 换算成二进制应该是 (1101)<sub>2</sub>。问题是怎么把 13 分解成等号右边的形式呢？注意到等号右边可以写成

13 = ((((0×2 + 1<sub>3</sub>)×2 + 1<sub>2</sub>)×2 + 0<sub>1</sub>)×2 + 1<sub>0</sub>)

我们将 13 反复除以 2 取余数就可以提取出上式中的 1101 四个数字，为了让读者更容易看清楚是哪个 1 和哪个 0，上式和下式中对应的数字都加了下标：

13÷2 = 6...1<sub>0</sub>
 6÷2 = 3...0<sub>1</sub>
 3÷2 = 1...1<sub>2</sub>
 1÷2 = 0...1<sub>3</sub>

把这四步得到的余数按相反的顺序排列就是 13 的二进制表示，因此这种方法称为**除二反序取余法**。

计算机用二进制表示数，程序员也必须习惯使用二进制，但二进制写起来太啰嗦了，所以通常将二进制数分成每三位一组或者每四位一组，每组用一个数字表示。比如把 (10110010)<sub>2</sub> 从最低位开始每三位分成一组，10、110、010，然后把每组写成一个十进制数字，就是 (262)<sub>8</sub>，这样每一位数字的取值范围是 0 ~ 7，逢八进一，称为八进制（Octal）。类似地，把 (10110010)<sub>2</sub> 分成每四位一组，1011、0010，然后把每组写成一个数字，这个数的低位是 2，高位已经大于 9 了，我们规定用字母 A ~ F 表示 10 ~ 15，这个数可以写成 (B2)<sub>16</sub>，每一位数字的取值范围是 0 ~ F，逢十六进一，称为十六进制（Hexadecimal）。所以，八进制和十六进制是程序员为了书写二进制方便而发明的简便写法，好比草书和正楷的关系一样。

### 2.1.3. 整数的加减运算

我们已经了解了计算机中正整数如何表示，加法如何计算，那么负数如何表示，减法又如何计算呢？本节讨论这些问题。为了书写方便，本节举的例子都用 8 个 bit 表示一个数，实际计算机做整数加减运算的操作数可以是 8 位、16 位、32 位甚至64 位的。

#### 2.1.3.1. Sign and Magnitude 表示法

要用 8 个 bit 表示正数和负数，一种简单的想法是把最高位规定为符号位（Sign Bit），0 表示正 1 表示负，剩下的 7 位表示绝对值的大小，这称为 Sign and Magnitude 表示法。例如 -1 表示成10000001，+1 表示成 00000001。这样用 8 个 bit 表示整数的取值范围是 -2<sup>7</sup>-1 ~ 2<sup>7</sup>-1，即 -127 ~ 127。

采用这种表示法，计算机做加法运算需要处理以下逻辑：

1. 如果两数符号位相同，就把它们的低 7 位相加，符号位不变。如果低 7 位相加时在最高位产生进位，说明结果的绝对值大于 127，超出 7 位所能表示的数值范围，这称为溢出（Overflow）<sup>[24]</sup>，这时通常把计算机中的一个标志位置 1 表示当前运算产生了溢出。
2. 如果两数符号位不同，首先比较它们的低 7 位谁大，然后用大数减小数，结果的符号位和大数相同。

> <sup>[24]</sup> 有时候会进一步细分，把正整数溢出称为上溢（Overflow），负整数溢出称为下溢（Underflow），详见 `strtol(3)`。

那么减法如何计算呢？由于我们规定了负数的表示，可以把减法转换成加法来计算，要计算 a-b，可以先把 b 变号然后和 a 相加，相当于计算 a + (-b)。但如果两个加数的符号位不同就要用大数的绝对值减小数的绝对值，这一步减法计算仍然是免不了的。我们知道加法要进位，减法要借位，计算过程是不同的，所以除了要有[本章第 1 节「为什么计算机用二进制计数」](#_1-为什么计算机用二进制计数)提到的加法器电路之外，还要另外有一套减法器电路。

如果采用 Sign and Magnitude 表示法，计算机做加减运算需要处理很多逻辑： **比较符号位，比较绝对值，加法改减法，减法改加法，小数减大数改成大数减小数……** 这是非常低效率的。还有一个缺点是 0 的表示不唯一，既可以表示成 10000000 也可以表示成 00000000，这进一步增加了逻辑的复杂性，所以我们迫切需要重新设计整数的表示方法使计算过程更简单。

#### 2.1.3.2. 1's Complement 表示法

本节介绍一种二进制补码表示法，为了便于理解，我们先看一个十进制的例子：

167 - 52 = 167 + (-52) = 167 + (999-52) - 1000 + 1 = 167+ 947 - 1000 + 1 = 1114 - 1000 + 1 = 114 + 1 = 115

167 - 52 --> 减法转换成加法 167 + (-52) --> 负数取 9 的补码表示 167 + 947 --> 114 进 1 --> 高位进的 1 加到低位上去，结果为 115。

在这个例子中我们用三位十进制数字表示正数和负数，具体规定如下：

<p id="t14-5">表 14.5. 9's Complement 表示法</p>

| 数值 | 补码表示     |
| ---- | ------------ |
| -499 | 500(999-499) |
| -498 | 501(999-498) |
| ...  | ...          |
| -1   | 998          |
| 0    | 999          |
| 0    | 0            |
| 1    | 1            |
| ...  | ...          |
| 498  | 498          |
| 499  | 499          |

首先 -52 要用 999-52 表示，就是 947，这称为取 9 的补码（9's Complement）；然后把 167 和 947 相加，得到 114 进 1；再把高位进的 1 加到低位上去，得 115，本来应该加 1000，结果加了 1，少加了 999，正好把先前取 9 的补码多加的 999 抵消掉了。 **我们本来要做 167-52 的减法运算，结果变成做 999-52 的减法运算** ，后者显然要容易一些，因为没有借位。这种补码表示法的计算规则用一句话概括就是： **负数用 9 的补码表示，减法转换成加法，计算结果的最高位如果有进位则要加回到最低位上去** 。要验证这条规则得考虑四种情况：

1. 两个正数，相加得正
2. 一正一负，相加得正
3. 一正一负，相加得负
4. 两个负数，相加得负

我们举的例子验证了第二种情况，另外三种情况请读者自己验证，暂时不考虑溢出的问题，稍后会讲到如何判定溢出。

上述规则也适用于二进制： **负数用 1 的补码（1's Complement）表示，减法转换成加法，计算结果的最高位如果有进位则要加回到最低位上去** 。取 1 的补码更简单，连减法都不用做，因为 1-1=0，1-0=1， **取 1 的补码就是把每个 bit 取反，所以 1 的补码也称为反码** 。比如：

```
                                                    (11111111-00000100)
                                                             ↓
00001000 - 00000100 → 00001000 + (-00000100) → 00001000 + 11111011 → 00000011 进 1 
→ 高位进的 1 加到低位上去，结果为 00000100
```

1's Complement 表示法相对于 Sign and Magnitude 表示法的优势是非常明显的： **不需要把符号和绝对值分开考虑，正数和负数的加法都一样算，计算逻辑更简单，甚至连减法器电路都省了，只要有一套加法器电路，再有一套把每个 bit 取反的电路，就可以做加法和减法运算** 。如果 8 个 bit 采用 1's Complement 表示法，负数的取值范围是从 10000000 到 11111111（-127 ~ 0），正数是从 00000000 到 01111111（0 ~ 127），仍然可以根据最高位判断一个数是正是负。 **美中不足的是 0 的表示仍然不唯一，既可以表示成 11111111 也可以表示成 00000000** ，为了解决这最后一个问题，我们引入 2's Complement 表示法。

#### 2.1.3.3. 2's Complement 表示法

2's Complement 表示法规定： **正数不变，负数先取反码再加 1** 。如果 8 个 bit 采用 2's Complement 表示法，负数的取值范围是从 10000000 到 11111111（-128 ~ -1），正数是从 00000000 到 01111111（0 ~ 127）， **也可以根据最高位判断一个数是正是负，并且 0 的表示是唯一的** ，目前绝大多数计算机都采用这种表示法。为什么称为「2的补码」呢？ **因为对一位二进制数 b 取补码就是 1-b+1 = 10-b，相当于从 2 里面减去 b** 。类似地，要表示 -4 需要对 00000100 取补码，11111111 - 00000100 + 1 = 100000000 - 00000100，相当于从 28 里面减去 4。2's Complement 表示法的计算规则有些不同：减法转换成加法，忽略计算结果最高位的进位，不必加回到最低位上去。请读者自己验证上一节提到的四种情况下这条规则都能算出正确结果。

8 个 bit 采用 2's Complement 表示法的取值范围是 -128 ~ 127，如果计算结果超出这个范围就会产生溢出，例如：

<p id="c14-3">图 14.3. 有符号数加法溢出</p>

![有符号数加法溢出](./image/number.overflow.png)

如何判断产生了溢出呢？我们还是分四种情况讨论：如果两个正数相加溢出，结果一定是负数；如果两个负数相加溢出，结果一定是正数；一正一负相加，无论结果是正是负都不可能溢出。

<p id="c14-4">图 14.4. 如何判定溢出</p>

![如何判定溢出](./image/number.overflowp.png)

从上图可以得出结论：**在相加过程中最高位产生的进位和次高位产生的进位如果相同则没有溢出，如果不同则表示有溢出**。逻辑电路的实现可以把这两个进位连接到一个异或门，把异或门的输出连接到溢出标志位。

#### 2.1.3.4. 有符号数和无符号数

前面几节我们用 8 个 bit 表示正数和负数，讲了三种表示法，每种表示法对应一种计算规则，这称为有符号数（Signed Number）；如果 8 个 bit 全部表示正数则取值范围是 0 ~ 255，这称为无符号数（Unsigned Number）。其实计算机做加法时并不区分操作数是有符号数还是无符号数，计算过程都一样，比如上面的例子也可以看作无符号数的加法：

<p id="c14-5">图 14.5. 无符号数加法进位</p>

![无符号数加法进位](./image/number.carry.png)

如果把这两个操作数看作有符号数 -126 和 -8 相加，计算结果是错的，因为产生了溢出；但如果看作无符号数 130 和 248 相加，计算结果是 122 进 1，也就是 122 + 256，这个结果是对的。计算机的加法器在做完计算之后，根据最高位产生的进位设置**进位标志**，同时根据最高位和次高位产生的进位的异或设置**溢出标志**。至于这个加法到底是有符号数加法还是无符号数加法则取决于程序怎么理解了，如果程序把它理解成有符号数加法，下一步就要检查溢出标志，如果程序把它理解成无符号数加法，下一步就要检查进位标志。通常计算机在做算术运算之后还可能设置另外两个标志，如果计算结果的所有 bit 都是零则设置**零标志**，如果计算结果的最高位是 1 则设置**负数标志**，如果程序把计算结果理解成有符号数，也可以检查负数标志判断结果是正是负。

### 2.1.4. 浮点数

浮点数在计算机中的表示是基于科学计数法（Scientific Notation）的，我们知道 32767 这个数用科学计数法可以写成 3.2767×10<sup>4</sup>，3.2767 称为尾数（Mantissa，或者叫 Significand），4 称为指数（Exponent）。浮点数在计算机中的表示与此类似，只不过基数（Radix）是 2 而不是 10。下面我们用一个简单的模型来解释浮点数的基本概念。我们的模型由三部分组成：符号位、指数部分（表示 2 的多少次方）和尾数部分（小数点前面是 0，尾数部分只表示小数点后的数字）。

<p id="c14-6">图 14.6. 一种浮点数格式</p>

![一种浮点数格式](./image/number.float.png)

如果要表示 17 这个数，我们知道 17 = 17.0×10<sup>0</sup> = 0.17×10<sup>2</sup>，类似地，17 = (10001)<sub>2</sub>×2<sup>0</sup> = (0.10001)<sub>2</sub>×2<sup>5</sup>，把尾数的有效数字全部移到小数点后，这样就可以表示为：

<p id="c14-7">图 14.7. 17 的浮点数表示</p>

![17的浮点数表示](./image/number.float17.png)

如果我们要表示 0.25 就遇到新的困难了，因为 0.25 = 1×2<sup>-2</sup> = (0.1)<sub>2</sub>×2<sup>-1</sup>，而我们的模型中指数部分没有规定如何表示负数。我们可以在指数部分规定一个符号位，然而更广泛采用的办法是使用偏移的指数（Biased Exponent）。规定一个偏移值，比如 16，实际的指数要加上这个偏移值再填写到指数部分，这样比 16 大的就表示正指数，比 16 小的就表示负指数。要表示 0.25，指数部分应该填 16-1 = 15：

<p id="c14-8">图 14.8. 0.25 的偏移指数浮点数表示</p>

![0.25的偏移指数浮点数表示](./image/number.biasfloat025.png)

现在还有一个问题需要解决：每个浮点数的表示都不唯一，例如 17 = (0.10001)<sub>2</sub>×2<sup>5</sup> = (0.010001)<sub>2</sub>×2<sup>6</sup>，这样给计算机处理增加了复杂性。为了解决这个问题，我们规定尾数部分的最高位必须是 1，也就是说尾数必须以 0.1 开头，对指数做相应的调整，这称为正规化（Normalize）。由于尾数部分的最高位必须是 1，这个 1 就不必保存了，可以节省出一位来用于提高精度，我们说最高位的 1 是隐含的（Implied）。这样 17 就只有一种表示方法了，指数部分应该是 16 + 5 = 21 = (10101)<sub>2</sub>，尾数部分去掉最高位的 1 是 0001：

<p id="c14-9">图 14.9. 17 的正规化尾数浮点数表示</p>

![17的正规化尾数浮点数表示](./image/number.normalfloat17.png)

两个浮点数相加，首先把小数点对齐然后相加：

<p id="c14-10">图 14.10. 浮点数相加</p>

![浮点数相加](./image/number.addfloat.png)

由于浮点数表示的精度有限，计算结果末尾的 10 两位被舍去了。做浮点运算时要注意精度损失（Significance Loss）问题，有时计算顺序不同也会导致不同的结果，比如 11.0010000 + 0.00000001 + 0.00000001 = 11.0010000 + 0.00000001 = 11.0010000，后面加的两个很小的数全被舍去了，没有对计算结果产生任何影响，但如果调一下计算顺序它们就能影响到计算结果了，0.00000001 + 0.00000001 + 11.0010000 = 0.00000010 + 11.0010000 = 11.0010001。再比如 128.25 = (10000000.01)<sub>2</sub>，需要 10 个有效位，而我们的模型中尾数部分是 8 位，算上隐含的最高位 1 一共有 9 个有效位，那么 128.25 的浮点数表示只能舍去末尾的 1，表示成(10000000.0)<sub>2</sub>，其实跟 128 相等了。在[第 4 章第 2 节「if/else 语句」](1-C-语言入门/ch04-分支语句#_2-ifelse-语句)讲过浮点数不能做精确比较，现在读者应该知道为什么不能精确比较了。

整数运算会产生溢出，浮点运算也会产生溢出，浮点运算的溢出也分上溢和下溢两种，但和整数运算的定义不同。假设整数采用 8 位 2's Complement 表示法，取值范围是 -128 ~ 127，如果计算结果是 -130 则称为下溢，计算结果是 130 则称为上溢。假设按本节介绍的浮点数表示法，取值范围是 -(0.111111111)<sub>2</sub>×2<sup>15</sup> ~ (0.111111111)<sub>2</sub>×2<sup>15</sup>，如果计算结果超出这个范围则称为上溢；如果计算结果未超出这个范围但绝对值太小了，在 -(0.1)<sub>2</sub>×2<sup>-16</sup> ~ (0.1)<sub>2</sub>×2<sup>-16</sup> 之间，那么也同样无法表示，称为下溢。

浮点数是一个相当复杂的话题，不同平台的浮点数表示和浮点运算也有较大差异，本节只是通过这个简单的模型介绍一些基本概念而不深入讨论，理解了这些基本概念有助于你理解浮点数标准，目前业界广泛采用的符点数标准是由 IEEE（Institute of Electrical and Electronics Engineers）制定的 IEEE 754。

最后讨论一个细节问题。我们知道，定义全局变量时如果没有 Initializer 就用 0 初始化，定义数组时如果 Initializer 中提供的元素不够那么剩下的元素也用 0 初始化。例如：

```c
int i;
double d;
double a[10] = { 1.0 };
```

「用 0 初始化」的意思是变量 `i`、变量 `d` 和数组元素 `a[1] ~ a[9]` 的所有字节都用 0 填充，或者说所有 bit 都是 0。无论是用 Sign and Magnitude 表示法、1's Complement 表示法还是 2's Complement 表示法，一个整数的所有 bit 是 0 都表示 0 值，但一个浮点数的所有 bit 是 0 一定表示 0 值吗？严格来说不一定，某种平台可能会规定一个浮点数的所有 bit 是 0 并不表示 0 值，但 *C99 Rationale* 第 6.7.8 节的条款 25 提到：*As far as the committee knows, all machines treat all bits zero as a representation of floating-point zero. But, all bits zero might not be the canonical representation of zero.* 因此在绝大多数平台上，一个浮点数的所有 bit 是 0 就表示 0 值。

## 2.2. 数据类型详解

### 2.2.1. 整型

我们知道，在 C 语言中 char 型占一个字节的存储空间，一个字节通常是 8 个 bit。如果这 8 个 bit 按无符号整数来解释，取值范围是 0 ~ 255，如果按有符号整数来解释，采用 2's Complement 表示法，取值范围是 -128 ~ 127。C 语言规定了 signed 和 unsigned 两个关键字，unsigned char 型表示无符号数，signed char 型表示有符号数。

那么以前我们常用的不带 signed 或 unsigned 关键字的 char 型是无符号数还是有符号数呢？C 标准规定这是 Implementation Defined，编译器可以定义 char 型是无符号的，也可以定义 char 型是有符号的，在该编译器所对应的体系结构上哪种实现效率高就可以采用哪种实现，x86 平台的 `gcc` 定义 char 型是有符号的。这也是 C 标准的 Rationale 之一： **优先考虑效率，而可移植性尚在其次** 。 **这就要求程序员非常清楚这些规则，如果你要写可移植的代码，就必须清楚哪些写法是不可移植的，应该避免使用** 。另一方面，写不可移植的代码有时候也是必要的，比如 Linux 内核代码使用了很多只有 `gcc` 支持的语法特性以得到最佳的执行效率，在写这些代码的时候就没打算用别的编译器编译，也就没考虑可移植性的问题。如果要写不可移植的代码，你也必须清楚代码中的哪些部分是不可移植的，以及为什么要这样写，如果不是为了效率，一般来说就没有理由故意写不可移植的代码。从现在开始，我们会接触到很多 Implementation Defined 的特性， **C 语言与平台和编译器是密不可分的，离开了具体的平台和编译器讨论 C 语言，就只能讨论到本书第一部分的程度了** 。注意，ASCII 码的取值范围是 0 ~ 127，所以不管 char 型是有符号的还是无符号的，存一个 ASCII 码都没有问题，一般来说，如果用 `char` 型存 ASCII 码字符，就不必明确写是 signed 还是 unsigned，如果用 char 型表示 8 位的整数，为了可移植性就必须写明是 signed 还是 unsigned。

> **Implementation-defined、Unspecified 和 Undefined**
> 
> 在 C 标准中没有做明确规定的地方会用 Implementation-defined、Unspecified 或 Undefined 来表述，在本书中有时把这三种情况统称为「未明确定义」的。这三种情况到底有什么不同呢？
> 我们刚才看到一种 Implementation-defined 的情况，C 标准没有明确规定 char 是有符号的还是无符号的，但是要求编译器必须对此做出明确规定，并写在编译器的文档中。
> 而对于 Unspecified 的情况，往往有几种可选的处理方式，C 标准没有明确规定按哪种方式处理，编译器可以自己决定，并且也不必写在编译器的文档中，这样即便用同一个编译器的不同版本来编译也可能得到不同的结果，因为编译器没有在文档中明确写它会怎么处理，那么不同版本的编译器就可以选择不同的处理方式，比如下一章我们会讲到一个函数调用的各个实参表达式按什么顺序求值是 Unspecified 的。
> Undefined 的情况则是完全不确定的，C 标准没规定怎么处理，编译器很可能也没规定，甚至也没做出错处理，有很多 Undefined 的情况编译器是检查不出来的，最终会导致运行时错误，比如数组访问越界就是 Undefined 的。
> 初学者看到这些规则通常会很不舒服，觉得这不是在学编程而是在啃法律条文，结果越学越泄气。是的，C 语言并不像一个数学定理那么完美，现实世界里的东西总是不够完美的。但还好啦，C 程序员已经很幸福了，只要严格遵照 C 标准来写代码，不要去触碰那些阴暗角落，写出来的代码就有很好的可移植性。<del>想想那些可怜的 JavaScript 程序员吧，他们甚至连一个可以遵照的标准都没有，一个浏览器一个样，甚至同一个浏览器的不同版本也差别很大，程序员不得不为每一种浏览器的每一个版本分别写不同的代码。</del>

除了 char 型之外，整型还包括 short int（或者简写为 short）、int、long int（或者简写为 long）、long long int（或者简写为 long long）等几种<sup>[25]</sup>，这些类型都可以加上 signed 或 unsigned 关键字表示有符号或无符号数。其实，对于有符号数在计算机中的表示是 Sign  and Magnitude、1's Complement 还是 2's Complement，C 标准也没有明确规定，也是 Implementation Defined。大多数体系结构都采用 2's Complement 表示法，x86 平台也是如此，从现在开始我们只讨论 2's Complement 表示法的情况。还有一点要注意， **除了 char 型以外的这些类型如果不明确写 signed 或 unsigned 关键字都表示 signed** ，这一点是 C 标准明确规定的，不是 Implementation Defined。

><sup>[25]</sup> 我们在[第 19 章「汇编与 C 之间的关系」第 4 节「结构体和联合体」](2-C-语言本质/ch19-汇编与-C-之间的关系#_4-结构体和联合体)还要介绍一种特殊的整型—— Bit-field。

除了 char 型在 C 标准中明确规定占一个字节之外，其它整型占几个字节都是 Implementation Defined。通常的编译器实现遵守 **ILP32 或 LP64** 规范，如下表所示。

<p id="t15-1">表 15.1. ILP32 和 LP64</p>

| 类型      | ILP32（位数） | LP64（位数） |
| --------- | ------------- | ------------ |
| char      | 8             | 8            |
| short     | 16            | 16           |
| int       | 32            | 32           |
| long      | 32            | 64           |
| long long | 64            | 64           |
| 指针      | 32            | 64           |

ILP32 这个缩写的意思是 int（I）、long（L）和指针（P）类型都占 32 位，通常 32 位计算机的 C 编译器采用这种规范，x86 平台的 `gcc` 也是如此。LP64 是指 long（L）和指针占 64 位，通常 64 位计算机的 C 编译器采用这种规范。指针类型的长度总是和计算机的位数一致，至于什么是计算机的位数，指针又是一种什么样的类型，我们到[第 17 章「计算机体系结构基础」](2-C-语言本质/ch17-计算机体系结构基础)和[第 23 章「指针」](2-C-语言本质/ch23-指针)再分别详细解释。从现在开始本书做以下约定： **在以后的陈述中，缺省平台是 x86 / Linux / gcc，遵循 ILP32，并且 char 是有符号的，我不会每次都加以说明，但说到其它平台时我会明确指出是什么平台** 。

在[第 2 章「常量、变量和表达式」第 2 节「常量」](1-C-语言入门/ch02-常量、变量和表达式#_2-常量)讲过 C 语言的常量有整数常量、字符常量、枚举常量和浮点数常量四种，其实字符常量和枚举常量的类型都是 int 型，因此前三种常量的类型都属于整型。 **整数常量有很多种，不全是 int 型的** ，下面我们详细讨论整数常量。

以前我们只用到十进制的整数常量，其实在 C 语言中也可以用八进制和十六进制的整数常量<sup>[26]</sup>。八进制整数常量以 `0` 开头，后面的数字只能是 0 ~ 7，例如 022，因此十进制的整数常量就不能以 0 开头了，否则无法和八进制区分。十六进制整数常量以 `0x` 或 `0X` 开头，后面的数字可以是 `0 ~ 9`、`a ~ f` 和 `A ~ F`。在[第 2 章「常量、变量和表达式」第 6 节「字符类型与字符编码」](1-C-语言入门/ch02-常量、变量和表达式#_6-字符类型与字符编码)讲过一种转义序列，以 `\` 或 `\x` 加八进制或十六进制数字表示，这种表示方式相当于把八进制和十六进制整数常量开头的 `0` 替换成 `\` 了。

><sup>[26]</sup> 有些编译器（比如 `gcc`）也支持二进制的整数常量，以 `0b` 或 `0B` 开头，比如 `0b0001111`，但二进制的整数常量从未进入 C 标准，只是某些编译器的扩展，所以不建议使用，由于二进制和八进制、十六进制的对应关系非常明显，用八进制或十六进制常量完全可以代替使用二进制常量。

整数常量还可以在末尾加 `u` 或 `U` 表示 unsigned，加 `l` 或 `L` 表示 long，加 `ll` 或 `LL` 表示 long long，例如 `0x1234U`，`98765ULL` 等。但事实上 `u`、`l`、`ll` 这几种后缀和上面讲的 unsigned、long、long long 关键字并不是一一对应的。这个对应关系比较复杂，准确的描述如下表所示（出自 *C99* 条款 6.4.4.1）。

<p id="t15-2">表 15.2. 整数常量的类型</p>

| 后缀                       | 十进制常量                                              | 八进制或十六进制常量                                         |
| -------------------------- | ------------------------------------------------------- | ------------------------------------------------------------ |
| 无                         | int  long int  long long int                            | int  unsigned int  long int  unsigned long int  long long int  unsigned long long int |
| u 或 U                     | unsigned int  unsigned long int  unsigned long long int | unsigned int  unsigned long int  unsigned long long int      |
| l 或 L                     | long int  long long int                                 | long int  unsigned long int  long long int  unsigned long long int |
| 既有 u 或 U，又有 l 或 L   | unsigned long int  unsigned long long int               | unsigned long int  unsigned long long int                    |
| ll 或 LL                   | long long int                                           | long long int  unsigned long long int                        |
| 既有 u 或 U，又有 ll 或 LL | unsigned long long int                                  | unsigned long long int                                       |

给定一个整数常量，比如 `1234U`，那么它应该属于「u 或 U」这一行的「十进制常量」这一列，这个表格单元中列了三种类型 unsigned int、unsigned long int、unsigned long long int，从上到下 **找出第一个足够长的类型** 可以表示 `1234` 这个数，那么它就是这个整数常量的类型，如果 int 是 32 位的那么 unsigned int 就可以表示。

再比如 `0xffff0000`，应该属于第一行「无」的第二列「八进制或十六进制常量」，这一列有六种类型 int、unsigned int、long int、unsigned long int、long long int、unsigned long long int，第一个类型 int 表示不了 `0xffff0000` 这么大的数，我们写这个十六进制常量是要表示一个正数，而它的 MSB（第 31 位）是 1，如果按有符号 int 类型来解释就成了负数了，第二个类型 unsigned int 可以表示这个数，所以这个十六进制常量的类型应该算 unsigned int。所以请注意， **`0x7fffffff` 和 `0xffff0000` 这两个常量虽然看起来差不多，但前者是 int 型，而后者是 unsigned int 型** 。

讲一个有意思的问题。我们知道 x86 平台上 int 的取值范围是 -2147483648 ~ 2147483647，那么用 `printf("%d\n", -2147483648);` 打印 int 类型的下界有没有问题呢？如果用 **`gcc main.c -std=c99` 编译会有警告信息** ： `warning: format ‘%d’ expects type ‘int’, but argument 2 has type ‘long long int’`。这是因为， **虽然 -2147483648 这个数值能够用 int 型表示，但在 C 语言中却没法写出对应这个数值的 int 型常量，C 编译器会把它当成一个整数常量 2147483648 和一个负号运算符组成的表达式，而整数常量 2147483648 已经超过了 `int` 型的取值范围， 在 x86 平台上 int 和 long 的取值范围相同 ，所以这个常量也超过了 long 型的取值范围** ，根据上表第一行「无」的第一列「十进制常量」，这个整数常量应该算 long long 型的，前面再加个负号组成的表达式仍然是 long long 型，而 `printf` 的 `%d` 转换说明要求后面的参数是 int 型，所以编译器报警告。之所以编译命令要加 `-std=c99` 选项是因为 **C99 以前对于整数常量的类型规定和上表有一些出入** ，即使不加这个选项也会报警告，但警告信息不准确，读者可以试试。如果改成 `printf("%d\n", -2147483647-1);` 编译器就不会报警告了，`-` 号运算符的两个操作数 -2147483647 和 1 都是 int 型，计算结果也应该是 int 型，并且它的值也没有超出 int 型的取值范围；或者改成 `printf("%lld\n", -2147483648);` 也可以，转换说明 `%lld` 告诉 `printf` 后面的参数是 long long 型，有些转换说明格式目前还没讲到，详见[第 25 章「C 标准库」第 2.9 节「格式化 I/O 函数」](2-C-语言本质/ch25-C-标准库#_格式化-IO-函数)。

怎么样，整数常量没有你原来想的那么简单吧。再看一个不简单的问题。`long long i = 1234567890 * 1234567890;` 编译时会有警告信息： `warning: integer overflow in expression`。1234567890 是 int 型，两个 int 型相乘的表达式仍然是 int 型，而乘积已经超过 int 型的取值范围了，因此提示计算结果溢出。如果改成 `long long i = 1234567890LL * 1234567890;`，其中一个常量是 long long 型，另一个常量也会先转换成 long long 型再做乘法运算，两数相乘的表达式也是 long long 型，编译器就不会报警告了。有关类型转换的规则将在[本章第 3 节「类型转换」](#_类型转换)详细介绍。

### 2.2.2. 浮点型

C 标准规定的浮点型有 float、double、long double，和整型一样，既没有规定每种类型占多少字节，也没有规定采用哪种表示形式。浮点数的实现在各种平台上差异很大，有的处理器有浮点运算单元（FPU，Floating Point Unit），称为硬浮点（Hard-float）实现；有的处理器没有浮点运算单元，只能做整数运算，需要用整数运算来模拟浮点运算，称为软浮点（Soft-float）实现。 **大部分平台的浮点数实现遵循 IEEE 754 ，float 型通常是 32 位，double 型通常是 64 位。**

long double 型通常是比 double 型精度更高的类型，但各平台的实现有较大差异。在 x86 平台上，大多数编译器实现的 long double 型是 80 位，因为  **x86 的浮点运算单元具有 80 位精度** ，`gcc` 实现的 long double 型是 12 字节（96位），这是为了 **对齐到 4 字节边界** （在[第 19 章「汇编与 C 之间的关系」第 4 节「结构体和联合体」](2-C-语言本质/ch19-汇编与-C-之间的关系#_4-结构体和联合体)详细讨论对齐的问题），也有些编译器实现的 long double 型和 double 型精度相同，没有充分利用 x86 浮点运算单元的精度。其它体系结构的浮点运算单元的精度不同，编译器实现也会不同，例如 PowerPC 上的 long double 型通常是 128 位。

以前我们只用到最简单的浮点数常量，例如 3.14，现在看看浮点数常量还有哪些写法。由于浮点数在计算机中的表示是基于科学计数法的，所以浮点数常量也可以写成科学计数法的形式，尾数和指数之间用 e 或 E 隔开，例如 314e-2 表示 314×10<sup>-2</sup>，注意这种表示形式基数是 10 <sup>[27]</sup>，如果尾数的小数点左边或右边没有数字则表示这一部分为零，例如 3.e-1，.987等等。浮点数也可以加一个后缀，例如 3.14f、.01L，浮点数的后缀和类型之间的对应关系比较简单，没有后缀的浮点数常量是 double 型的，有后缀 f 或 F 的浮点数常量是 float 型的，有后缀 l 或 L 的浮点数常量是 long double 型的。

> <sup>[27]</sup> C99 引入一种新的十六进制浮点数表示，基数是 2，本书不做详细介绍。

### 2.2.3. 类型转换

如果有人问 C 语法规则中最复杂的是哪一部分，我一定会说是类型转换。从上面两节可以看出，有符号、无符号整数和浮点数加起来有那么多种类型，每两种类型之间都要定义一个转换规则，转换规则的数量自然很庞大，更何况由于各种体系结构对于整数和浮点数的实现很不相同，很多类型转换的情况都是 C 标准未做明确规定的阴暗角落。虽然我们写代码时不会故意去触碰这些阴暗角落，但有时候会不小心犯错，所以了解一些未明确规定的情况还是有必要的，可以在出错时更容易分析错误原因。本节分成几小节，首先介绍哪些情况下会发生类型转换，会把什么类型转成什么类型，然后介绍编译器如何处理这样的类型转换。

#### 2.2.3.1. Integer Promotion

在一个表达式中，凡是可以使用 int 或 unsigned int 类型做右值的地方也都可以使用有符号或无符号的 char 型、short 型和 Bit-field。如果原始类型的取值范围都能用 int 型表示，则其类型被提升为 int，如果原始类型的取值范围用 int 型表示不了，则提升为 unsigned int 型，这称为 Integer Promotion。做 Integer Promotion 只影响上述几种类型的值，对其它类型无影响。C99 规定 Integer Promotion 适用于以下几种情况：

1. 如果一个函数的形参类型未知，例如使用了 Old Style C 风格的函数声明（详见[第 3 章「简单函数」第 2 节「自定义函数」](1-C-语言入门/ch03-简单函数#_2-自定义函数)），或者函数的参数列表中有 ...，那么调用函数时要对相应的实参做 Integer Promotion，此外，相应的实参如果是 float 型的也要被提升为 double 型，这条规则称为 Default Argument Promotion。我们知道 `printf` 的参数列表中有 `...`，除了第一个形参之外，其它形参的类型都是未知的，比如有这样的代码：
	
	```c
	char ch = 'A';
	printf("%c", ch);
	```
	
	`ch` 要被提升为 int 型之后再传给 `printf`。

2. 算术运算中的类型转换。有符号或无符号的 char 型、short 型和 Bit-field 在做算术运算之前首先要做 Integer Promotion，然后才能参与计算。例如：
	
	```c
	unsigned char c1 = 255, c2 = 2;
	int n = c1 + c2;
	```
	
	计算表达式 `c1 + c2` 的过程其实是先把 `c1` 和 `c2` 提升为 int 型然后再相加（unsigned char 的取值范围是 0 ~ 255，完全可以用 int 表示，所以提升为 int 就可以了，不需要提升为 unsigned int），整个表达式的值也是 int 型，最后的结果是 257。假如没有这个提升的过程，`c1 + c2` 就溢出了，溢出会得到什么结果是 Undefined，在大多数平台上会把进位截掉，得到的结果应该是 1。

	除了 + 号之外还有哪些运算符在计算之前需要做 Integer Promotion 呢？我们在下一小节先介绍 Usual Arithmetic Conversion 规则，然后再解答这个问题。

#### 2.2.3.2. Usual Arithmetic Conversion

两个算术类型的操作数做算术运算，比如 `a + b`，如果两边操作数的类型不同，编译器会自动做类型转换，使两边类型相同之后才做运算，这称为 Usual Arithmetic Conversion。转换规则如下：

1. 如果有一边的类型是 long double，则把另一边也转成 long double。
2. 否则，如果有一边的类型是 double，则把另一边也转成 double。
3. 否则，如果有一边的类型是 float，则把另一边也转成 float。
4. 否则，两边应该都是整型，首先按上一小节讲过的规则对 `a` 和 `b` 做 Integer Promotion，然后如果类型仍不相同，则需要继续转换。首先我们规定 char、short、int、long、long long 的转换级别（Integer Conversion Rank）一个比一个高，同一类型的有符号和无符号数具有相同的 Rank。转换规则如下：
	1. 如果两边都是有符号数，或者都是无符号数，那么较低 Rank 的类型转换成较高 Rank 的类型。例如 unsigned int 和 unsigned long 做算术运算时都转成 unsigned long。
	2. 否则，如果一边是无符号数另一边是有符号数，无符号数的 Rank 不低于有符号数的 Rank，则把有符号数转成另一边的无符号类型。例如 unsigned long 和 int 做算术运算时都转成 unsigned long，unsigned long 和 long 做算术运算时也都转成 unsigned long。
	3. 剩下的情况是：一边有符号另一边无符号，并且无符号数的 Rank 低于有符号数的 Rank。这时又分为两种情况，如果这个有符号数类型能够覆盖这个无符号数类型的取值范围，则把无符号数转成另一边的有符号类型。例如遵循 LP64 的平台上 unsigned int 和 long 在做算术运算时都转成 long。
	4. 否则，也就是这个有符号数类型不足以覆盖这个无符号数类型的取值范围，则把两边都转成有符号数的 Rank 对应的无符号类型。例如在遵循 ILP32 的平台上 unsigned int 和 long 在做算术运算时都转成 unsigned long。

可见有符号和无符号整数的转换规则是十分复杂的，虽然这是有明确规定的，不属于阴暗角落，但为了程序的可读性不应该依赖这些规则来写代码。我讲这些规则，不是为了让你用，而是为了让你了解有符号数和无符号数混用会非常麻烦，从而避免触及这些规则，并且在程序出错时记得往这上面找原因。所以这些规则不需要牢记，但要知道有这么回事，以便在用到的时候能找到我书上的这一段。

到目前为止我们学过的 `+  - * / % > < >= <= == !=` 运算符都需要做 Usual Arithmetic  Conversion，因为都要求两边操作数的类型一致，在下一章会介绍几种新的运算符也需要做 Usual Arithmetic  Conversion。单目运算符 `+ - ~` 只有一个操作数，移位运算符 `<<  >>` 两边的操作数类型不要求一致，这些运算不需要做 Usual Arithmetic Conversion，但也需要做 Integer Promotion，运算符 `~ << >>` 将在下一章介绍。

#### 2.2.3.3. 由赋值产生的类型转换

如果赋值或初始化时等号两边的类型不相同，则编译器会把等号右边的类型转换成等号左边的类型再做赋值。例如 `int c = 3.14;`，编译器会把右边的 double 型转成 int 型再赋给变量 `c`。

我们知道，函数调用传参的过程相当于定义形参并且用实参对其做初始化，函数返回的过程相当于定义一个临时变量并且用 `return` 的表达式对其做初始化，所以由赋值产生的类型转换也适用于这两种情况。例如一个函数的原型是 `int foo(int, int);`，则调用 `foo(3.1, 4.2)` 时会自动把两个 double 型的实参转成 int 型赋给形参，如果这个函数定义中有返回语句 `return 1.2;`，则返回值 `1.2` 会自动转成 int 型再返回。

在函数调用和返回过程中发生的类型转换往往容易被忽视，因为函数原型和函数调用并没有写在一起。例如 `char c = getchar();`，看到这一句往往会想当然地认为 `getchar` 的返回值是 char 型，而事实上 `getchar` 的返回值是 int 型，这样赋值会引起类型转换，可能产生 Bug，我们在[第 25 章「C 标准库」第 2.5 节「以字节为单位的 I/O函数」](2-C-语言本质/ch25-C-标准库#_25-以字节为单位的-IO-函数)详细讨论这个问题。

#### 2.2.3.4. 强制类型转换

以上三种情况通称为隐式类型转换（Implicit Conversion，或者叫 Coercion），编译器根据它自己的一套规则将一种类型自动转换成另一种类型。除此之外，程序员也可以通过类型转换运算符（Cast Operator）自己规定某个表达式要转换成何种类型，这称为显式类型转换（Explicit Conversion）或强制类型转换（Type Cast）。例如计算表达式 `(double)3 + i`，首先将整数 3 强制转换成 double 型（值为 3.0），然后和整型变量 `i` 相加，这时适用 Usual Arithmetic Conversion 规则，首先把 `i` 也转成 double 型，然后两者相加，最后整个表达式也是 double 型的。这里的 `(double)` 就是一个类型转换运算符，这种运算符由一个类型名套 `()` 括号组成，属于单目运算符，后面的 3 是这个运算符的操作数。注意操作数的类型必须是标量类型，转换之后的类型必须是标量类型或者 `void` 型。

#### 2.2.3.5. 编译器如何处理类型转换

以上几小节介绍了哪些情况下会发生类型转换，并且明确了每种情况下会把什么类型转成什么类型，本节介绍编译器如何处理任意两种类型之间的转换。现在要把一个 M 位的类型（值为 X）转换成一个 N 位的类型，所有可能的情况如下表所示。

<p id="t15-3">表 15.3. 如何做类型转换</p>

| 待转换的类型                                 | M > N 的情况                                                 | M == N 的情况                                                | M < N 的情况      |
| -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ----------------- |
| signed integer to signed integer             | 如果 X 在目标类型的取值范围内则值不变，否则 Implementation-defined | 值不变                                                       | 值不变            |
| unsigned integer to signed integer           | 如果 X 在目标类型的取值范围内则值不变，否则 Implementation-defined | 如果 X 在目标类型的取值范围内则值不变，否则 Implementation-defined | 值不变            |
| signed integer to unsigned integer           | X % 2<sup>N</sup>                                            | X % 2<sup>N</sup>                                            | X % 2<sup>N</sup> |
| unsigned integer to unsigned integer         | X % 2<sup>N</sup>                                            | 值不变                                                       | 值不变            |
| floating-point to signed or unsigned integer | Truncate toward Zero，如果 X 的整数部分超出目标类型的取值范围则 Undefined |                                                              |                   |
| signed or unsigned integer to floating-point | 如果 X 在目标类型的取值范围内则值不变，但有可能损失精度，如果 X 超出目标类型的取值范围则 Undefined |                                                              |                   |
| floating-point to floating-point             | 如果 X 在目标类型的取值范围内则值不变，但有可能损失精度，如果 X 超出目标类型的取值范围则 Undefined | 值不变                                                       | 值不变            |

注意上表中的 **X % 2<sup>N</sup>**，我想表达的意思是「把 X 加上或者减去 2<sup>N</sup> 的整数倍，使结果落入 [0, 2<sup>N-1</sup>] 的范围内」，当 X 是负数时运算结果也得是正数，即运算结果和除数同号而不是和被除数同号，这不同于 C 语言 % 运算的定义。写程序时不要故意用上表中的规则，尤其不要触碰 Implementation-defined 和 Undefined 的情况，但程序出错时可以借助上表分析错误原因。

下面举几个例子说明上表的用法。比如把 double 型转换成 short 型，对应表中的「floating-point to signed or unsigned integer」，如果原值在 (-32769.0, 32768.0) 之间则截掉小数部分得到转换结果，否则产生溢出，结果是 Undefined，例如对于 `short s = 32768.4;` 这个语句 `gcc` 会报警告。

比如把 int 型转换成 `unsigned short` 型，对应表中的「signed integer to unsigned integer」，如果原值是正的，则把它除以 216 取模，其实就是取它的低 16 位，如果原值是负的，则加上 216 的整数倍，使结果落在 [0, 65535] 之间。

比如把 int 类型转换成 short 类型，对应表中的「signed integer to signed integer」，如果原值在 [-32768, 32767] 之间则值不变，否则产生溢出，结果是 Implementation-defined，例如对于 `short s = -32769;` 这个语句 `gcc` 会报警告。

最后一个例子，把 short 型转换成 int 型，对应表中的「signed integer to signed integer」，转换之后应该值不变。那怎么维持值不变呢？是不是在高位补 16 个 0 就行了呢？如果原值是 -1，十六进制表示就是 ffff，要转成 int 型的 -1 需要变成 ffffffff，因此需要在高位补 16 个 1 而不是 16 个 0。换句话说，要维持值不变，在高位补 1 还是补 0 取决于原来的符号位，这称为符号扩展（Sign Extension）。

### 2.2.4. 代码的可移植性

#### 2.2.4.1. 基本说明

- C 标准的 Rationale 之一：
  - **优先考虑效率，而可移植性尚在其次** 
  - **这就要求程序员非常清楚这些规则，如果你要写可移植的代码，就必须清楚哪些写法是不可移植的，应该避免使用** 

- 实例： 不带 signed 或 unsigned 关键字的 char 型是无符号数还是有符号数?
  - C 标准规定这是 Implementation Defined， **编译器可以定义 char 型是无符号的，也可以定义 char 型是有符号的** 
  - 在该编译器所对应的体系结构上哪种实现效率高就可以采用哪种实现
    > x86 平台的 `gcc` 定义 char 型是有符号的。
  - ASCII 码的取值范围是 0 ~ 127，所以不管 char 型是有符号的还是无符号的，存一个 ASCII 码都没有问题，
  - 一般来说，如果用 `char` 型存 ASCII 码字符，就不必明确写是 signed 还是 unsigned
  - 如果用 char 型表示 8 位的整数， **为了可移植性就必须写明是 signed 还是 unsigned** 。

- 不可移植性代码
  - 另一方面，写不可移植的代码有时候也是必要的
  - 比如 Linux 内核代码使用了很多只有 `gcc` 支持的语法特性以得到最佳的执行效率，在写这些代码的时候就没打算用别的编译器编译，也就没考虑可移植性的问题。
  - 如果要写不可移植的代码，你也必须清楚代码中的哪些部分是不可移植的，以及为什么要这样写，如果不是为了效率，一般来说就没有理由 **故意** 写不可移植的代码。

#### 2.2.4.2. Implementation-defined、Unspecified 和 Undefined

- 在 C 标准中没有做明确规定的地方会用以下三种情况来表述，
  - Implementation-defined
    - C 标准没有明确规定 char 是有符号的还是无符号的
    - 但是要求编译器必须对此做出明确规定，并写在编译器的文档中。
  - Unspecified 
    - 对于 Unspecified 的情况，往往有几种可选的处理方式
    - C 标准没有明确规定按哪种方式处理，编译器可以自己决定，并且也不必写在编译器的文档中，这样即便用同一个编译器的不同版本来编译也可能得到不同的结果
    - 因为编译器没有在文档中明确写它会怎么处理，那么不同版本的编译器就可以选择不同的处理方式
    - 比如一个函数调用的各个实参表达式按什么顺序求值是 Unspecified 的。
  - Undefined 
    - Undefined 的情况则是完全不确定的，C 标准没规定怎么处理，编译器很可能也没规定，甚至也没做出错处理，
    - 有很多 Undefined 的情况编译器是检查不出来的，最终会导致运行时错误，比如数组访问越界就是 Undefined 的。
- 我们会接触到很多 Implementation Defined 的特性，
- **C 语言与平台和编译器是密不可分的，离开了具体的平台和编译器讨论 C 语言，就只能讨论到本书第一部分的程度了** 

## 2.3. 运算符详解

本章介绍很多前面没有讲过的运算符，重点是位运算，然后引出一个重要的概念 Sequence Point，在最后一节总结 C 语言各种运算符的优先级和结合性。

### 2.3.1. 位运算

整数在计算机中用二进制的位来表示，C 语言提供一些运算符可以直接操作整数中的位，称为位运算，这些运算符的操作数都必须是整型的。在以后的学习中你会发现，有些信息利用整数中的某几个位来存储，要访问这些位，仅仅有对整数的操作是不够的，必须借助位运算，例如[附录 A 第 2 节「Unicode 和 UTF-8」](附录-A-字符编码#_2-unicode-和-utf-8)介绍的 UTF-8 编码就是如此，学完本节之后你应该能自己写出 UTF-8 的编码和解码程序。本节首先介绍各种位运算符，然后介绍与位运算有关的编程技巧。

#### 2.3.1.1. 按位与、或、异或、取反运算

在[第 4 章「分支语句」第 3 节「布尔代数」](1-C-语言入门/ch04-分支语句#_3-布尔代数)讲过逻辑与、或、非运算，并列出了真值表，对于整数中的位也可以做与、或、非运算，C 语言提供了按位与（Bitwise AND）运算符 `&`、按位或（Bitwise OR）运算符 `|` 和按位取反（Bitwise NOT）运算符 `~`，此外还有按位异或（Bitwise XOR）运算符 `^`，我们在[第 14 章「计算机中数的表示」第 1 节「为什么计算机用二进制计数」](2-C-语言本质/ch14-计算机中数的表示#_1-为什么计算机用二进制计数)讲过异或运算。下面用二进制的形式举几个例子。

<p id="c16-1">图 16.1. 位运算</p>

![位运算](./image/op.bitwise.png)

注意，`&`、`|`、`^` 运算符都是要做 Usual  Arithmetic Conversion 的（其中有一步是 Integer Promotion），`~` 运算符也要做 Integer  Promotion，所以在 C 语言中其实并不存在 8 位整数的位运算，操作数在做位运算之前都至少被提升为 int 型了，上面用 8 位整数举例只是为了书写方便。比如：

```c
unsigned char c = 0xfc;
unsigned int i = ~c;
```

计算过程是这样的：常量 `0xfc` 是 int 型的，赋给 `c` 要转成 unsigned char，值不变；`c` 的十六进制表示是 fc，计算 `~c` 时先提升为整型（`000000fc`）然后取反，最后结果是 `ffffff03`。注意，如果把 `~c` 看成是 8 位整数的取反，最后结果就得 3 了，这就错了。为了避免出错，一是尽量避免不同类型之间的赋值，二是每一步计算都要按上一章讲的类型转换规则仔细检查。

#### 2.3.1.2. 移位运算

移位运算符（Bitwise Shift）包括左移 `<<` 和右移 `>>`。左移将一个整数的各二进制位全部左移若干位，例如 `0xcfffffff3<<2` 得到 `0x3fffffcc`：

<p id="c16-2">图 16.2. 左移运算</p>

![左移运算](./image/op.shiftleft.png)

最高两位的 `11` 被移出去了，最低两位又补了两个 `0`，其它位依次左移两位。但要注意，移动的位数必须小于左操作数的总位数，比如上面的例子，左边是 unsigned int 型，如果左移的位数大于等于 32 位，则结果是 Undefined。移位运算符不同于 `+ - * / ==` 等运算符，两边操作数的类型不要求一致，但两边操作数都要做 Integer Promotion，整个表达式的类型和左操作数提升后的类型相同。

复习一下[第 14 章「计算机中数的表示」第 2 节「不同进制之间的换算」](2-C-语言本质/ch14-计算机中数的表示#_2-不同进制之间的换算)讲过的知识可以得出结论，**在一定的取值范围内，将一个整数左移 1 位相当于乘以 2**。比如二进制 11（十进制 3）左移一位变成 110，就是 6，再左移一位变成 1100，就是 12。读者可以自己验证这条规律对有符号数和无符号数都成立，对负数也成立。当然，如果左移改变了最高位（符号位），那么结果肯定不是乘以 2 了，所以我加了个前提「在一定的取值范围内」。由于计算机做移位比做乘法快得多，编译器可以利用这一点做优化，比如看到源代码中有 `i * 8`，可以编译成移位指令而不是乘法指令。

当操作数是无符号数时，右移运算的规则和左移类似，例如 `0xcfffffff3>>2` 得到 `0x33fffffc`：

<p id="c16-3">图 16.3. 右移运算</p>

![右移运算](./image/op.shiftright.png)

最低两位的 `11` 被移出去了，最高两位又补了两个 `0`，其它位依次右移两位。和左移类似，移动的位数也必须小于左操作数的总位数，否则结果是 Undefined。在一定的取值范围内，将一个整数右移 1 位相当于除以 2，小数部分截掉。

当操作数是有符号数时，右移运算的规则比较复杂：

- 如果是正数，那么高位移入 0
- 如果是负数，那么高位移入 1 还是 0 不一定，这是 Implementation-defined 的。对于 x86 平台的 `gcc` 编译器，最高位移入 1，也就是仍保持负数的符号位，这种处理方式对负数仍然保持了「右移 1 位相当于除以 2」的性质。

综上所述，由于类型转换和移位等问题，用有符号数做位运算是很不方便的，所以，**建议只对无符号数做位运算，以减少出错的可能**。

#### 2.3.1.3. 掩码

如果要对一个整数中的某些位进行操作，怎样表示这些位在整数中的位置呢？可以用掩码（Mask）来表示。比如掩码 `0x0000ff00` 表示对一个 32 位整数的 8 ~ 15 位进行操作，举例如下。

1. 取出 8 ~ 15 位。
	
	```c
	unsigned int a, b, mask = 0x0000ff00;
	a = 0x12345678;
	b = (a & mask) >> 8; /* 0x00000056 */
	```
	
	这样也可以达到同样的效果：
	
	```c
	b = (a >> 8) & ~(~0U << 8);
	```
	
2. 将 8 ~ 15 位清 0。
	
	```c
	unsigned int a, b, mask = 0x0000ff00;
	a = 0x12345678;
	b = a & ~mask; /* 0x12340078 */
	```
	
3. 将 8 ~ 15 位置 1。
	
	```c
	unsigned int a, b, mask = 0x0000ff00;
	a = 0x12345678;
	b = a | mask; /* 0x1234ff78 */
	```

#### 2.3.1.4. 异或运算的一些特性

1. 一个数和自己做异或的结果是 0。如果需要一个常数 0，x86 平台的编译器可能会生成这样的指令：`xorl %eax, %eax`。不管 `eax` 寄存器里的值原来是多少，做异或运算都能得到 0，这条指令比同样效果的 `movl $0, %eax` 指令快，因为前者只需要在 CPU 内部计算，而后者需要访问内存，在[下一章第 5 节「Memory Hierarchy」](2-C-语言本质/ch17-计算机体系结构基础#_5-memory-hierarchy)详细介绍。
2. 从异或的真值表可以看出，不管是 0 还是 1，和 0 做异或保持原值不变，和 1 做异或得到原值的相反值。可以利用这个特性配合掩码实现某些位的翻转，例如：
	
	```c
	unsigned int a, b, mask = 1U << 6;
	a = 0x12345678;
	b = a ^ mask; /* flip the 6th bit */
	```
3. 如果 a1 ^ a2 ^ a3 ^ ... ^ an 的结果是 1，则表示 a1、a2、a3...an 之中 1 的个数为奇数个，否则为偶数个。这条性质可用于奇偶校验（Parity Check），比如在串口通信过程中，每个字节的数据都计算一个校验位，数据和校验位一起发送出去，这样接收方可以根据校验位粗略地判断接收到的数据是否有误。
4. x ^ x ^ y == y，因为 x ^ x == 0，0 ^ y == y。这个性质有什么用呢？我们来看这样一个问题：交换两个变量的值，不得借助额外的存储空间，所以就不能采用 `temp = a; a = b; b = temp;` 的办法了。利用位运算可以这样做交换：
	
	```c
	a = a ^ b;
	b = b ^ a;
	a = a ^ b;
	```

分析一下这个过程。为了避免混淆，把 a 和 b 的初值分别记为 a<sub>0</sub> 和 b<sub>0</sub>。第一行，`a = a<sub>0</sub> ^ b<sub>0</sub>`；第二行，把 a 的新值代入，得到 `b = b<sub>0</sub> ^ a<sub>0</sub> ^ b<sub>0</sub>`，等号右边的 b<sub>0</sub> 相当于上面公式中的 x，a<sub>0</sub> 相当于 y，所以结果为 a<sub>0</sub>；第三行，把 a 和 b 的新值代入，得到 `a = a<sub>0</sub> ^ b<sub>0</sub> ^ a<sub>0</sub>`，结果为 b<sub>0</sub>。注意这个过程不能把同一个变量自己跟自己交换，而利用中间变量 `temp` 则可以交换。

---

- 拓展：
  - 请在网上查找有关 RAID（Redundant Array of Independent Disks，独立磁盘冗余阵列）的资料，理解其实现原理，其实就是利用了本节的性质 3 和 4。
  - 交换两个变量的值，不得借助额外的存储空间，除了本节讲的方法之外你还能想出什么方法？本节讲的方法不能把同一个变量自己跟自己交换，你的方法有没有什么局限性？

### 2.3.2. 其它运算符

#### 2.3.2.1. 复合赋值运算符

复合赋值运算符（Compound Assignment Operator）包括 `*=` `/=` `%=` `+=` `-=` `<<=` `>>=` `&=` `^=` `|=`，一边做运算一边赋值。例如 `a += 1` 相当于 `a = a + 1`。但有一点细微的差别，前者对表达式 `a` 只求值一次，而后者求值两次，如果 `a` 是一个复杂的表达式，求值一次和求值两次的效率是不同的，例如 `a[i+j] += 1` 和 `a[i+j] = a[i+j] + 1`。那么仅仅是效率上的差别吗？对于没有 Side Effect 的表达式，求值一次和求值两次的结果是一样的，但对于有 Side Effect 的表达式则不一定，例如 `a[foo()] += 1` 和 `a[foo()] = a[foo()] + 1`，如果 `foo()` 函数调用有 Side Effect，比如会打印一条消息，那么前者只打印一次，而后者打印两次。

在[第 6 章第 3 节「for 语句」](1-C-语言入门/ch06-循环语句#_3-for-语句)讲自增、自减运算符时说 `++i` 相当于 `i = i + 1`，其实更准确地说应该是等价于 `i += 1`，表达式 `i` 只求值一次，而 `--i` 等价于 `i -= 1`。

#### 2.3.2.2. 条件运算符

条件运算符（Conditional Operator）是 C 语言中唯一一个三目运算符（Ternary Operator），带三个操作数，它的形式是 `表达式1 ? 表达式2 : 表达式3`，这个运算符所组成的整个表达式的值等于 `表达式2` 或 `表达式3` 的值，取决于 `表达式1` 的值是否为真，可以把它想像成这样的函数：

```c
if (表达式1)
	return 表达式2;
else
	return 表达式3;
```

`表达式1` 相当于 `if` 语句的控制表达式，因此它的值必须是标量类型，而 `表达式2`和 `表达式3` 相当于同一个函数在不同情况下的返回值，因此它们的类型要求一致，也要做 Usual Arithmetic Conversion。

下面举个例子，定义一个函数求两个参数中较大的一个。

```c
int max(int a, int b)
{
	return (a > b) ? a : b;
}
```

#### 2.3.2.3. 逗号运算符

逗号运算符（Comma Operator）也是一种双目运算符，它的形式是 `表达式1, 表达式2`，两个表达式不要求类型一致，左边的 `表达式1` 先求值，求完了直接把值丢掉，再求右边 `表达式2` 的值作为整个表达式的值。逗号运算符是左结合的，类似于 `+ - * /` 运算符，根据组合规则可以写出 `表达式1, 表达式2, 表达式3, ..., 表达式n` 这种形式，`表达式1, 表达式2` 可以看作一个子表达式，先求 `表达式1` 的值，然后求 `表达式2` 的值作为这个子表达式的值，然后这个值再和 `表达式3` 组成一个更大的表达式，求 `表达式3` 的值作为这个更大的表达式的值，依此类推，整个计算过程就是从左到右依次求值，最后一个表达式的值成为整个表达式的值。

注意，函数调用时各实参之间也是用逗号隔开，这种逗号是分隔符而不是逗号运算符。但可以这样使用逗号运算符：

```c
f(a, (t=3, t+2), c)
```

传给函数 `f` 的参数有三个，其中第二个参数的值是表达式 `t+2` 的值。

#### 2.3.2.4. sizeof 运算符与 typedef 类型声明

`sizeof` 是一个很特殊的运算符，它有两种形式：`sizeof 表达式` 和 `sizeof(类型名)`。这个运算符很特殊，`sizeof 表达式` 中的子表达式并不求值，而只是根据类型转换规则求得子表达式的类型，然后把这种类型所占的字节数作为整个表达式的值。有些人喜欢写成 `sizeof(表达式)` 的形式也可以，这里的括号和 `return(1);` 的括号一样，不起任何作用。但另外一种形式 `sizeof(类型名)` 的括号则是必须写的，整个表达式的值也是这种类型所占的字节数。

比如用 `sizeof` 运算符求一个数组的长度：

```c
int a[12];
printf("%d\n", sizeof a/sizeof a[0]);
```

在上面这个例子中，由于 `sizeof 表达式` 中的子表达式不需要求值，所以不需要到运行时才计算，事实上在编译时就知道 `sizeof a` 的值是 48，`sizeof a[0]` 的值是 4，所以在编译时就已经把 `sizeof a/sizeof a[0]` 替换成常量 12 了，这是一个常量表达式。

`sizeof` 运算符的结果是 `size_t` 类型的，这个类型定义在 `stddef.h` 头文件中，不过你的代码中只要不出现 `size_t` 这个类型名就不用包含这个头文件，比如像上面的例子就不用包含这个头文件。C 标准规定 `size_t` 是一种无符号整型，编译器可以用 `typedef` 做一个类型声明：

```c
typedef unsigned long size_t;
```

那么 `size_t` 就代表 unsigned long 型。不同平台的编译器可能会根据自己平台的具体情况定义 `size_t` 所代表的类型，比如有的平台定义为 unsigned long 型，有的平台定义为 unsigned long long 型，C 标准规定 `size_t` 这个名字就是为了隐藏这些细节，使代码具有可移植性。所以注意不要把 `size_t` 类型和它所代表的真实类型混用，例如：

```c
unsigned long x;
size_t y;
x = y;
```

如果在一种 ILP32 平台上定义 `size_t` 代表 unsigned long long 型，这段代码把 `y` 赋给 `x` 时就把高位截掉了，结果可能是错的。

`typedef` 这个关键字用于给某种类型起个新名字，比如上面的 `typedef` 声明可以这么看：去掉 `typedef` 就成了一个变量声明 `unsigned long size_t;`，`size_t` 是一个变量名，类型是 unsigned long，那么加上 `typedef` 之后，`size_t` 就是一个类型名，就代表 unsigned long 类型。再举个例子：

```c
typedef char array_t[10];
array_t a;
```

这相当于声明 `char a[10];`。类型名也遵循标识符的命名规则，并且通常加个 `_t` 后缀表示 Type。

### 2.3.3. Side Effect 与 Sequence Point

如果你只想规规矩矩地写代码，那么基本用不着看这一节。本节的内容基本上是钻牛角尖儿的，除了 Short-circuit 比较实用，其它写法都应该避免使用。但没办法，有时候不是你想钻牛角尖儿，而是有人逼你去钻牛角尖儿。这是我们的学员在找工作笔试时碰到的问题：

```c
int a=0;
a = (++a)+(++a)+(++a)+(++a);
```

据我了解，似乎很多公司都有出这种笔试题的恶趣味。答案应该是 Undefined，我甚至有些怀疑出题人是否真的知道答案。下面我来解释为什么是 Undefined。

我们知道，调用一个函数可能产生 Side  Effect，使用某些运算符（`++ -- =` 复合赋值）也会产生 Side Effect，如果一个表达式中隐含着多个 Side  Effect，究竟哪个先发生哪个后发生呢？C 标准规定代码中的某些点是 Sequence Point，当执行到一个 Sequence  Point 时，在此之前的 Side Effect 必须全部作用完毕，在此之后的 Side Effect 必须一个都没发生。至于两个 Sequence  Point 之间的多个 Side Effect 哪个先发生哪个后发生则没有规定，编译器可以任意选择各 Side  Effect 的作用顺序。下面详细解释各种 Sequence Point。

1. 调用一个函数时，在所有准备工作做完之后、函数调用开始之前是 Sequence Point。比如调用 `foo(f(), g())` 时，`foo`、`f()`、`g()` 这三个表达式哪个先求值哪个后求值是 Unspecified，但是必须都求值完了才能做最后的函数调用，所以 `f()`和`g()` 的 Side Effect 按什么顺序发生不一定，但必定在这些 Side Effect 全部作用完之后才开始调用 `foo` 函数。
2. 条件运算符 `?:`、逗号运算符、逻辑与 `&&`、逻辑或 `||` 的第一个操作数求值之后是 Sequence Point。我们刚讲过条件运算符和逗号运算符，条件运算符要根据 `表达式1` 的值是否为真决定下一步求 `表达式2` 还是 `表达式3` 的值，如果决定求 `表达式2` 的值，`表达式3` 就不会被求值了，反之也一样，`,` 运算符也是这样，`表达式1` 求值结束才继续求 `表达式2` 的值。<br>
   逻辑与和逻辑或早在[第 4 章「分支语句」第 3 节「布尔代数」](1-C-语言入门/ch04-分支语句#_3-布尔代数)就讲了，但在初学阶段我一直回避它们的操作数求值顺序问题。这两个运算符和条件运算符类似，先求左操作数的值，然后根据这个值是否为真，右操作数可能被求值，也可能不被求值。比如[第 8 章例 8.5 「剪刀石头布」](1-C-语言入门/ch08-数组#e8-5)这个程序中的这几句：
	
	```c
	ret = scanf("%d", &man);
	if (ret != 1 || man < 0 || man > 2) {
		printf("Invalid input! Please input 0, 1 or 2.\n");
		continue;
	}
	```

	其实可以写得更简单（类似于 *K&R* 的简洁风格）：
	
	```c
	if (scanf("%d", &man) != 1 || man < 0 || man > 2) {
		printf("Invalid input! Please input 0, 1 or 2.\n");
		continue;
	}
	```
	
	这个控制表达式的求值顺序是：先求 `scanf("%d", &man) = 1` 的值，如果 `scanf` 调用失败，则返回值不等于 1 成立，`||` 运算有一个操作数为真则整个表达式为真，这时直接执行下一句 `printf`，根本不会再去求 `man < 0` 或 `man > 2` 的值；如果 `scanf` 调用成功，则读入的数保存在变量 `man` 中，并且返回值等于 1，那么说它不等于 1 就不成立了，第一个 `||` 运算的左操作数为假，就会去求右操作数 `man < 0` 的值作为整个表达式的值，这时变量 `man` 的值正是 `scanf` 读上来的值，我们判断它是否在 [0, 2] 之间，如果 `man < 0` 不成立，则整个表达式 `scanf("%d", &man) != 1 || man < 0 ` 的值为假，也就是第二个 `||` 运算的左操作数为假，所以最后求右操作数 `man > 2` 的值作为整个表达式的值。
	`&&` 运算与此类似，`a && b` 的计算过程是：首先求表达式 `a` 的值，如果 `a` 的值是假则整个表达式的值是假，不会再去求 `b` 的值；如果 `a` 的值是真，则下一步求 `b` 的值作为整个表达式的值。所以，`a && b` 相当于 「if a then b」，而 `a || b` 相当于「if not a then b」。这种特性称为 Short-circuit，很多人喜欢利用 Short-circuit 特性简化代码。
3. 在一个完整的声明末尾是 Sequence Point，所谓完整的声明是指这个声明不是另外一个声明的一部分。比如声明 `int a[10], b[20];`，在 `a[10]` 末尾是 Sequence Point，在 `b[20]` 末尾也是。
4. 在一个完整的表达式末尾是 Sequence Point，所谓完整的表达式是指这个表达式不是另外一个表达式的一部分。所以如果有 `f(); g();` 这样两条语句，`f()` 和 `g()` 是两个完整的表达式，`f()` 的 Side Effect 必定在 `g()` 之前发生。
5. 在库函数即将返回时是 Sequence Point。这条规则似乎可以包含在上一条规则里面，因为函数返回时必然会结束掉一个完整的表达式。而事实上很多库函数是以宏定义的形式实现的（[第 21 章第 2.1 节「函数式宏定义」]()），并不是真正的函数，所以才需要有这条规则。
	还有两种 Sequence Point 和某些 C 标准库函数的执行过程相关，此处从略，有兴趣的读者可参考 [C99]()的 Annex C。

现在可以分析一下本节开头的例子了。`a = (++a)+(++a)+(++a)+(++a);` 的结果之所以是 Undefined，因为在这个表达式中有五个 Side Effect 都在改变 `a` 的值，这些 Side Effect 按什么顺序发生不一定，只知道在整个表达式求值结束时一定都发生了。比如现在求第二个 `++a` 的值，这时第一个、第三个、第四个 `++a` 的 Side Effect 发生了没有，`a` 的值被加过几次了，这些都不确定，所以第二个 `++a` 的值也不确定。这行代码用不同平台的不同编译器来编译结果是不同的，甚至在同一平台上用同一编译器的不同版本来编译也可能不同。

写表达式应遵循的原则一： `*` 在两个 Sequence Point 之间，同一个变量的值只允许被改变一次 `*`。仅有这一条原则还不够，例如 `a[i++] = i;` 的变量 `i` 只改变了一次，但结果仍是 Undefined，因为等号左边改 `i` 的值，等号右边读 `i` 的值，到底是先改还是先读？这个读写顺序是不确定的。但为什么 `i = i + 1;` 就没有歧义呢？虽然也是等号左边改 `i` 的值，等号右边读 `i` 的值，但你不读出 `i` 的值就没法计算 `i + 1`，那拿什么去改 `i` 的值呢？所以这个读写顺序是确定的。写表达式应遵循的原则二：`*` 如果在两个 Sequence Point 之间既要读一个变量的值又要改它的值，只有在读写顺序确定的情况下才可以这么写 `*`。

### 2.3.4. 运算符总结

到此为止，除了和指针相关的运算符还没讲之外，其它运算符都讲过了，是时候做一个总结了。

运算符 `+  - * / % > < >= <= == != & | ^` 以及各种复合赋值运算符要求两边的操作数类型一致，条件运算符 `?:` 要求后两个操作数类型一致，这些运算符在计算之前都需要做 Usual Arithmetic Conversion。

下面按优先级从高到低的顺序总结一下 C 语言的运算符，每一条所列的各运算符具有相同的优先级，对于同一优先级的多个运算符按什么顺序计算也有说明，双目运算符就简单地用「左结合」或「右结合」来说明了。和指针有关的运算符 `* & ->` 也在这里列出来了，到[第 23 章「指针」](2-C-语言本质/ch23-指针)再详细解释。

1. 标识符、常量、字符串和用 `()` 括号套起来的表达式是组成表达式的最基本单元，在运算中做操作数，优先级最高。
2. 后缀运算符，包括数组取下标 `[]`、函数调用 `()`、结构体取成员 `.`、指向结构体的指针取成员 `->`、后缀自增 `++`、后缀自减 `--`。如果一个操作数后面有多个后缀，按照离操作数从近到远的顺序（也就是从左到右）依次计算，比如 `a.name++`，先算 `a.name`，再 `++`，这里的 `.name` 应该看成 `a` 的一个后缀，而不是把 `.` 看成双目运算符。
3. 单目运算符，包括前缀自增 `++`、前缀自减 `--`、`sizeof`、类型转换 `()`、取地址运算 `&`、指针间接寻址 `*`、正号 `+`、负号 `-`、按位取反 `~`、逻辑非 `!`。如果一个操作数前面有多个前缀，按照离操作数从近到远的顺序（也就是从右到左）依次计算，比如 `!~a`，先算 `~a`，再求 `!`。
4. 乘 `*`、除 `/`、模 `%` 运算符。这三个运算符是左结合的。
5. 加 `+`、减 `-`运算符。左结合。
6. 移位运算符 `<<` 和 `>>`。左结合。
7. 关系运算符 `< > <= >=`。左结合。
8. 相等性运算符 `==` 和 `!=`。左结合。
9. 按位与 `&`。左结合。
10. 按位异或 `^`。左结合。
11. 按位或 `|`。左结合。
12. 逻辑与 `&&`。左结合。
13. 逻辑或 `||`。左结合。
14. 条件运算符 `:?`。在[第 4 章「分支语句」第 2 节「if/else语句」](1-C-语言入门/ch04-分支语句?id=_2-ifelse-语句)讲过 Dangling-else 问题，条件运算符也有类似的问题。例如 `a ? b : c ? d : e` 是看成 `(a ? b : c) ? d : e` 还是 `a ? b : (c ? d : e)` 呢？C 语言规定是后者。
15. 赋值=和各种复合赋值（`*=` `/=` `%=` `+=` `-=` `<<=` `>>=` `&=` `^=` `|=`）。在双目运算符中只有赋值和复合赋值是右结合的。
16. 逗号运算符。左结合。

*K&R* 第 2 章也有这样一个列表，但是对于结合性解释得不够清楚。左结合和右结合这两个概念只对双目运算符有意义，对于前缀、后缀和三目运算符我单独做了说明。C 语言表达式的详细语法规则可以参考 *C99* 的 Annex A.2，其实语法规则并不是用优先级和结合性这两个概念来表述的，有一些细节用优先级和结合性是表达不了的，只有看 *C99* 才能了解完整的语法规则。

#### 2.3.4.1. 习题

1. 以下代码得到的 `sum` 是 `0xffff`，对吗？
	
	```c
	int i = 0;
	unsigned int sum = 0;
	for (; i < 16; i++)
		sum = sum + 1U<<i;
	```

## 2.4. 计算机体系结构基础

现代计算机都是基于 Von Neumann 体系结构的，不管是嵌入式系统、PC 还是服务器。这种体系结构的主要特点是：CPU（CPU，Central Processing Unit，中央处理器，或简称处理器 Processor）和内存（Memory）是计算机的两个主要组成部分，内存中保存着数据和指令，CPU 从内存中取指令（Fetch）执行，其中有些指令让 CPU 做运算，有些指令让 CPU 读写内存中的数据。本章简要介绍组成计算机的 CPU、内存和设备以及它们之间的关系，为后续章节的学习打下基础。

### 2.4.1. 内存与地址

<p id="c17-1">图 17.1. 邮箱的地址</p>

![邮箱的地址](./image/arch.pobox.png)

我们都见过像这样挂在墙上的很多个邮箱，每个邮箱有一个房间编号，根据房间编号找到相应的邮箱投入信件或取出信件。内存与此类似，每个内存单元有一个地址（Address），内存地址是从 0 开始编号的整数，CPU 通过地址找到相应的内存单元，取其中的指令或者读写其中的数据。与邮箱不同的是，一个地址所对应的内存单元不能存很多东西，只能存一个字节，以前讲过的 int、float 等多字节的数据类型保存在内存中要占用连续的多个地址，这种情况下数据的地址是它所占内存单元的起始地址。

### 2.4.2. CPU

CPU 总是周而复始地做同一件事：从内存取指令，然后解释执行它，然后再取下一条指令，再解释执行。CPU最核心的功能单元包括：

- 寄存器（Register），是 CPU 内部的高速存储器，像内存一样可以存取数据，但比访问内存快得多。随后的几章我们会详细介绍 x86 的寄存器 `eax`、`esp`、`eip` 等等，有些寄存器只能用于某种特定的用途，比如 `eip` 用作程序计数器，这称为特殊寄存器（Special-purpose Register），而另外一些寄存器可以用在各种运算和读写内存的指令中，比如 `eax` 寄存器，这称为通用寄存器（General-purpose Register）。
- 程序计数器（PC，Program Counter），是一种特殊寄存器，保存着 CPU 取下一条指令的地址，CPU 按程序计数器保存的地址去内存中取指令然后解释执行，这时程序计数器保存的地址会自动加上该指令的长度，指向内存中的下一条指令。
- 指令译码器（Instruction Decoder）。CPU 取上来的指令由若干个字节组成，这些字节中有些位表示内存地址，有些位表示寄存器编号，有些位表示这种指令做什么操作，是加减乘除还是读写内存，指令译码器负责解释这条指令的含义，然后调动相应的执行单元去执行它。
- 算术逻辑单元（ALU，Arithmetic and Logic Unit）。如果译码器将一条指令解释为运算指令，就调动算术逻辑单元去做运算，比如加减乘除、位运算、逻辑运算。指令中会指示运算结果保存到哪里，可能保存到寄存器中，也可能保存到内存中。
- 地址和数据总线（Bus）。CPU 和内存之间用地址总线、数据总线和控制线连接起来，每条线上有 1 和 0 两种状态。如果在执行指令过程中需要访问内存，比如从内存读一个数到寄存器，执行过程可以想像成这样：

<p id="c17-2">图 17.2. 访问内存读数据的过程</p>

![访问内存读数据的过程](./image/arch.readmem.png)

1. CPU 内部将寄存器对接到数据总线上，使寄存器的每一位对接到一条数据线，等待接收数据。
2. CPU 通过控制线发一个读请求，并且将内存地址通过地址线发给内存。
3. 内存收到地址和读请求之后，将相应的内存单元对接到数据总线的另一端，这样，内存单元每一位的 1 或 0 状态通过一条数据线到达 CPU 寄存器中相应的位，就完成了数据传送。

往内存里写数据的过程与此类似，只是数据线上的传输方向相反。

上图中画了 32 条地址线和 32 条数据线，CPU 寄存器也是 32 位，可以说这种体系结构是 32 位的，比如 x86 就是这样的体系结构，目前主流的处理器是 32 位或 64 位的。地址线、数据线和 CPU 寄存器的位数通常是一致的，从上图可以看出数据线和 CPU 寄存器的位数应该一致，另外有些寄存器（比如程序计数器）需要保存一个内存地址，因而地址线和 CPU 寄存器的位数也应该一致。处理器的位数也称为字长，字（Word）这个概念用得比较混乱，在有些上下文中指 16 位，在有些上下文中指 32 位（这种情况下 16 位被称为半字 Half Word），在有些上下文中指处理器的字长，如果处理器是 32 位那么一个字就是 32 位，如果处理器是 64 位那么一个字就是 64 位。32 位计算机有 32 条地址线，地址空间（Address Space）从 `0x00000000` 到 `0xffffffff`，共 4GB，而 64 位计算机有更大的地址空间。

最后还要说明一点，本节所说的地址线、数据线是指 CPU 的内总线，是直接和 CPU 的执行单元相连的，内总线经过 MMU 和总线接口的转换之后引出到芯片引脚才是外总线，外地址线和外数据线的位数都有可能和内总线不同，例如 32 位处理器的外地址总线可寻址的空间可以大于 4GB，到[本章第 4 节「MMU」](#_4-MMU)再详细解释。

我们结合[第 1 章「程序的基本概念」表 1.1 「一个语句的三种表示」](1-C-语言入门/ch01-程序的基本概念#t1-1)看一下 CPU 取指执行的过程。

<p id="c17-3">图 17.3. CPU 的取指执行过程</p>

![CPU的取指执行过程](./image/arch.von.png)

1. `eip` 寄存器指向地址 `0x80483a2`，CPU 从这里开始取一条 5 个字节的指令，然后 `eip` 寄存器指向下一条指令的起始地址 `0x80483a7`。
2. CPU 对这 5 个字节译码，得知这条指令要求从地址 `0x804a01c` 开始取 4 个字节保存到 `eax` 寄存器。
3. 执行指令，读内存，取上来的数是 `3`，保存到`eax`寄存器。注意，地址 `0x804a01c` ~ `0x804a01f` 里存储的四个字节不能按地址从低到高的顺序看成 `0x03000000`，而要按地址从高到低的顺序看成 `0x00000003`。也就是说，对于多字节的整数类型，低地址保存的是整数的低位，这称为小端（Little  Endian）字节序（Byte Order）。x86 平台是小端字节序的，而另外一些平台规定低地址保存整数的高位，称为大端（Big Endian）字节序。
4. CPU 从 `eip` 寄存器指向的地址取一条 3 个字节的指令，然后 `eip` 寄存器指向下一条指令的起始地址 `0x80483aa`。
5. CPU 对这 3 个字节译码，得知这条指令要求把 `eax` 寄存器的值加 1，结果仍保存到 `eax` 寄存器。
6. 执行指令，现在 `eax` 寄存器中的数是 4。
7. CPU 从 `eip` 寄存器指向的地址取一条 5 个字节的指令，然后 `eip` 寄存器指向下一条指令的起始地址 `0x80483af`。
8. CPU 对这 5 个字节译码，得知这条指令要求把 `eax` 寄存器的值保存到从地址 `0x804a018` 开始的 4 个字节。
9. 执行指令，把 4 这个值保存到从地址 `0x804a018` 开始的 4 个字节（按小端字节序保存）。

### 2.4.3. 设备

CPU 执行指令除了访问内存之外还要访问很多设备（Device），如键盘、鼠标、硬盘、显示器等，那么它们和 CPU 之间如何连接呢？如下图所示。

<p id="c17-4">图 17.4. 设备</p>

![设备](./image/arch.box.png)

有些设备像内存芯片一样连接到处理器的地址总线和数据总线，正因为地址线和数据线上可以挂多个设备和内存芯片所以才叫「总线」，但不同的设备和内存芯片应该占不同的地址范围。访问这种设备就像访问内存一样，按地址读写即可，但和访问内存不同的是，往一个地址写数据只是给设备发一个命令，数据不一定要保存，而从一个地址读数据也不一定是读先前保存在这个地址的数据，而是得到设备的当前状态。设备中可供读写访问的单元通常称为设备寄存器（注意和 CPU 寄存器不是一回事），操作设备的过程就是读写这些设备寄存器的过程，比如向串口发送寄存器里写数据，串口设备就会把数据发送出去，读串口接收寄存器的值，就可以读取串口设备接收到的数据。

还有一些设备集成在处理器芯片中。在上图中，从 CPU 核引出的地址和数据总线有一端经总线接口引出到芯片引脚上了，还有一端没有引出，而是接到芯片内部集成的设备上，无论是在 CPU 外部接总线的设备还是在 CPU 内部接总线的设备都有各自的地址范围，都可以像访问内存一样访问，很多体系结构（比如 ARM）采用这种方式操作设备，称为**内存映射 I/O（Memory-mapped I/O）**。但是 x86 比较特殊，x86 对于设备有独立的端口地址空间，CPU 核需要引出额外的地址线来连接片内设备（和访问内存所用的地址线不同），访问设备寄存器时用特殊的 `in` / `out` 指令，而不是和访问内存用同样的指令，这种方式称为**端口 I/O（Port I/O）**。

从 CPU 的角度来看，访问设备只有内存映射 I/O 和端口 I/O 两种，要么像内存一样访问，要么用一种专用的指令访问。其实访问设备是相当复杂的，计算机的设备五花八门，各种设备的性能要求都不一样，有的要求带宽大，有的要求响应快，有的要求热插拔，于是出现了各种适应不同要求的设备总线，比如 PCI、AGP、USB、1394、SATA 等等，这些设备总线并不直接和 CPU 相连，CPU 通过内存映射 I/O 或端口 I/O 访问相应的总线控制器，通过总线控制器再去访问挂在总线上的设备。所以上图中标有「设备」的框可能是实际的设备，也可能是设备总线的控制器。

在 x86 平台上，硬盘是挂在 IDE、SATA 或 SCSI 总线上的设备，保存在硬盘上的程序是不能被 CPU 直接取指令执行的，操作系统在执行程序时会把它从硬盘拷贝到内存，这样 CPU 才能取指令执行，这个过程称为加载（Load）。程序加载到内存之后，成为操作系统调度执行的一个任务，就称为进程（Process）。进程和程序不是一一对应的。一个程序可以多次加载到内存，成为同时运行的多个进程，例如可以同时开多个终端窗口，每个窗口都运行一个 Shell 进程，而它们对应的程序都是磁盘上的 `/bin/bash` 文件。

操作系统（Operating System）本身也是一段保存在磁盘上的程序，计算机在启动时执行一段固定的启动代码（称为 Bootloader）首先把操作系统从磁盘加载到内存，然后执行操作系统中的代码把用户需要的其它程序加载到内存。操作系统和其它用户程序的不同之处在于：操作系统是常驻内存的，而其它用户程序则不一定，用户需要运行哪个程序，操作系统就把它加载到内存，用户不需要哪个程序，操作系统就把它终止掉，释放它所占的内存。操作系统最核心的功能是管理进程调度、管理内存的分配使用和管理各种设备，做这些工作的程序称为内核（Kernel），在我的系统上内核程序是 `/boot/vmlinuz-2.6.28-13-generic` 文件，它在计算机启动时加载到内存并常驻内存。广义上操作系统的概念还包括一些必不可少的用户程序，比如 Shell 是每个 Linux 系统必不可少的，而 Office 办公套件则是可有可无的，所以前者也属于广义上操作系统的范畴，而后者属于应用软件。

访问设备还有一点和访问内存不同。内存只是保存数据而不会产生新的数据，如果 CPU 不去读它，它也不需要主动提供数据给 CPU，所以内存总是被动地等待被读或者被写。而设备往往会自己产生数据，并且需要主动通知 CPU 来读这些数据，例如敲键盘产生一个输入字符，用户希望计算机马上响应自己的输入，这就要求键盘设备主动通知 CPU 来读这个字符并做相应处理，给用户响应。这是由中断（Interrupt）机制实现的，每个设备都有一条中断线，通过中断控制器连接到 CPU，当设备需要主动通知 CPU 时就引发一个中断信号，CPU 正在执行的指令将被打断，程序计数器会指向某个固定的地址（这个地址由体系结构定义），于是 CPU 从这个地址开始取指令（或者说跳转到这个地址），执行中断服务程序（ISR，Interrupt  Service Routine），完成中断处理之后再返回先前被打断的地方执行后续指令。比如某种体系结构规定发生中断时跳转到地址 `0x00000010` 执行，那么就要事先把一段 ISR 程序加载到这个地址，ISR 程序是内核代码的一部分，在这段代码中首先判断是哪个设备引发了中断，然后调用该设备的中断处理函数做进一步处理。

由于各种设备的操作方法各不相同，每种设备都需要专门的设备驱动程序（Device Driver），一个操作系统为了支持广泛的设备就需要有大量的设备驱动程序，事实上 Linux 内核源代码中绝大部分是设备驱动程序。设备驱动程序通常是内核里的一组函数，通过读写设备寄存器实现对设备的初始化、读、写等操作，有些设备还要提供一个中断处理函数供 ISR 调用。

### 2.4.4. MMU

现代操作系统普遍采用虚拟内存管理（Virtual Memory Management）机制，这需要处理器中的MMU（Memory Management Unit，内存管理单元）提供支持，本节简要介绍 MMU 的作用。

首先引入两个概念，虚拟地址和物理地址。如果处理器没有 MMU，或者有 MMU 但没有启用，CPU 执行单元发出的内存地址将直接传到芯片引脚上，被内存芯片（以下称为物理内存，以便与虚拟内存区分）接收，这称为物理地址（Physical Address，以下简称 PA），如下图所示。

<p id="c17-5">图 17.5. 物理地址</p>

![物理地址](./image/arch.pabox.png)

如果处理器启用了 MMU，CPU 执行单元发出的内存地址将被 MMU 截获，从 CPU 到 MMU 的地址称为虚拟地址（Virtual Address，以下简称 VA），而 MMU 将这个地址翻译成另一个地址发到 CPU 芯片的外部地址引脚上，也就是将 VA 映射成 PA，如下图所示。

<p id="c17-6">图 17.6. 虚拟地址</p>

![虚拟地址](./image/arch.vabox.png)

如果是 32 位处理器，则内地址总线是 32 位的，与 CPU 执行单元相连（图中只是示意性地画了 4 条地址线），而经过 MMU 转换之后的外地址总线则不一定是 32 位的。也就是说，虚拟地址空间和物理地址空间是独立的，32 位处理器的虚拟地址空间是 4GB，而物理地址空间既可以大于也可以小于 4GB。

MMU 将 VA 映射到 PA 是以页（Page）为单位的，32 位处理器的页尺寸通常是 4KB。例如，MMU 可以通过一个映射项将 VA 的一页 `0xb7001000` ~ `0xb7001fff` 映射到 PA 的一页 `0x2000` ~ `0x2fff`，如果 CPU 执行单元要访问虚拟地址 `0xb7001008`，则实际访问到的物理地址是 `0x2008`。物理内存中的页称为物理页面或者页帧（Page  Frame）。虚拟内存的哪个页面映射到物理内存的哪个页帧是通过页表（Page Table）来描述的，页表保存在物理内存中，MMU 会查找页表来确定一个VA应该映射到什么 PA。

操作系统和MMU是这样配合的：

1. 操作系统在初始化或分配、释放内存时会执行一些指令在物理内存中填写页表，然后用指令设置 MMU，告诉 MMU 页表在物理内存中的什么位置。
2. 设置好之后，CPU 每次执行访问内存的指令都会自动引发 MMU 做查表和地址转换操作，地址转换操作由硬件自动完成，不需要用指令控制 MMU 去做。

我们在程序中使用的变量和函数都有各自的地址，程序被编译后，这些地址就成了指令中的地址，指令中的地址被 CPU 解释执行，就成了 CPU 执行单元发出的内存地址，所以在启用 MMU 的情况下，程序中使用的地址都是虚拟地址，都会引发 MMU 做查表和地址转换操作。那为什么要设计这么复杂的内存管理机制呢？多了一层 VA 到 PA 的转换到底换来了什么好处？*All  problems in computer science can be solved by another level of  indirection.* 还记得这句话吗？多了一层间接必然是为了解决什么问题的，等讲完了必要的预备知识之后，将在[第 20 章第 5 节「虚拟内存管理」](2-C-语言本质/ch20-链接详解#_5-虚拟内存管理)讨论虚拟内存管理机制的作用。

MMU 除了做地址转换之外，还提供内存保护机制。各种体系结构都有用户模式（User Mode）和特权模式（Privileged Mode）之分，操作系统可以在页表中设置每个内存页面的访问权限，有些页面不允许访问，有些页面只有在 CPU 处于特权模式时才允许访问，有些页面在用户模式和特权模式都可以访问，访问权限又分为可读、可写和可执行三种。这样设定好之后，当 CPU 要访问一个 VA 时，MMU 会检查 CPU 当前处于用户模式还是特权模式，访问内存的目的是读数据、写数据还是取指令，如果和操作系统设定的页面权限相符，就允许访问，把它转换成 PA，否则不允许访问，产生一个异常（Exception）。异常的处理过程和中断类似，不同的是中断由外部设备产生而异常由 CPU内部产生，中断产生的原因和 CPU 当前执行的指令无关，而异常的产生就是由于 CPU 当前执行的指令出了问题，例如访问内存的指令被 MMU 检查出权限错误，除法指令的除数为 0 等都会产生异常。

<p id="c17-7">图 17.7. 处理器模式</p>

![处理器模式](./image/arch.cpumode.png)

通常操作系统把虚拟地址空间划分为用户空间和内核空间，例如 x86 平台的 Linux 系统虚拟地址空间是 `0x00000000` ~ `0xffffffff`，前 3GB（`0x00000000` ~ `0xbfffffff`）是用户空间，后 1GB（`0xc0000000` ~ `0xffffffff`）是内核空间。用户程序加载到用户空间，在用户模式下执行，不能访问内核中的数据，也不能跳转到内核代码中执行。这样可以保护内核，如果一个进程访问了非法地址，顶多这一个进程崩溃，而不会影响到内核和整个系统的稳定性。CPU 在产生中断或异常时不仅会跳转到中断或异常服务程序，还会自动切换模式，从用户模式切换到特权模式，因此从中断或异常服务程序可以跳转到内核代码中执行。事实上，整个内核就是由各种中断和异常处理程序组成的。总结一下：在正常情况下处理器在用户模式执行用户程序，在中断或异常情况下处理器切换到特权模式执行内核程序，处理完中断或异常之后再返回用户模式继续执行用户程序。

段错误我们已经遇到过很多次了，它是这样产生的：

1. 用户程序要访问的一个 VA，经 MMU 检查无权访问。
2. MMU 产生一个异常，CPU 从用户模式切换到特权模式，跳转到内核代码中执行异常服务程序。
3. 内核把这个异常解释为段错误，把引发异常的进程终止掉。

### 2.4.5. Memory Hierarchy

硬盘、内存、CPU 寄存器，还有本节要讲的 Cache，这些都是存储器，计算机为什么要有这么多种存储器呢？这些存储器各自有什么特点？这是本节要讨论的问题。

由于硬件技术的限制，我们可以制造出容量很小但很快的存储器，也可以制造出容量很大但很慢的存储器，但不可能两边的好处都占着，不可能制造出访问速度又快容量又大的存储器。因此，现代计算机都把存储器分成若干级，称为 Memory Hierarchy，按照离 CPU 由近到远的顺序依次是 CPU 寄存器、Cache、内存、硬盘，越靠近 CPU 的存储器容量越小但访问速度越快，下图给出了各种存储器的容量和访问速度的典型值。

<p id="c17-8">图 17.8. Memory Hierarchy</p>

![Memory Hierarchy](./image/arch.memhie.png)

<p id="t17-1">表 17.1. Memory Hierarchy</p>

| 存储器类型 | 位于哪里                                                     | 存储容量                                                     | 半导体工艺                                                   | 访问时间                                                     | 如何访问                                                     |
| ---------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| CPU 寄存器 | 位于 CPU 执行单元中。                                        | CPU 寄存器通常只有几个到几十个，每个寄存器的容量取决于 CPU 的字长，所以一共只有几十到几百字节。 | 「寄存器」这个名字就是一种数字电路的名字，它由一组触发器（Flip-flop）组成，每个触发器保存一个 Bit 的数据，可以做存取和移位等操作。计算机掉电时寄存器中保存的数据会丢失。 | 寄存器是访问速度最快的存储器，典型的访问时间是几纳秒。       | 使用哪个寄存器，如何使用寄存器，这些都是由指令决定的。       |
| Cache      | 和 MMU 一样位于 CPU 核中。                                   | Cache 通常分为几级，最典型的是如上图所示的两级 Cache，一级 Cache 更靠近CPU 执行单元，二级 Cache 更靠近物理内存，通常一级 Cache 有几十到几百KB，二级 Cache 有几百 KB 到几 MB。 | Cache 和内存都是由 RAM（Random Access Memory）组成的，可以根据地址随机访问，计算机掉电时 RAM 中保存的数据会丢失。不同的是，Cache 通常由 SRAM（Static RAM，静态 RAM）组成，而内存通常由 DRAM（Dynamic RAM，动态 RAM）组成。DRAM 电路比SRAM 简单，存储容量可以做得更大，但 DRAM 的访问速度比 SRAM 慢。 | 典型的访问时间是几十纳秒。| Cache 缓存最近访问过的内存数据，由于 Cache 的访问速度是内存的几十倍，所以有效利用 Cache 可以大大提高计算机的整体性能。一级 Cache 是这样工作的：CPU 执行单元要访问内存时首先发出 VA，Cache 利用 VA 查找相应的数据有没有被缓存，如果 Cache 中有就不需要访问物理内存了，如果是读操作就直接将 Cache 中的数据传给 CPU 寄存器，如果是写操作就直接改写到 Cache 中；如果 Cache 没有缓存该数据，就去物理内存中取数据，但并不是要哪个字节就取哪个字节，而是把相邻的几十个字节都取上来缓存着，以备下次用到，这称为一个 Cache Line，典型的 Cache Line 大小是 32 ~ 256 字节。如果计算机还配置了二级缓存，则在访问物理内存之前先用 PA 去二级缓存中查找。一级缓存是用 VA 寻址的，二级缓存是用 PA 寻址的，这是它们的区别。Cache 所做的工作是由硬件自动完成的，而不是像寄存器一样由指令决定先做什么后做什么。 |
| 内存       | 位于 CPU 外的芯片，与 CPU 通过地址和数据总线相连。           | 典型的存储容量是几百 MB 到几 GB。                            | 由 DRAM 组成，详见上面关于 Cache 的说明。                    | 典型的访问时间是几百纳秒。                                   | 内存是通过地址来访问的，在启用 MMU 的情况下，程序指令中的地址是 VA，而访问内存用的是 PA，它们之间的映射关系由操作系统维护。 |
| 硬盘       | 位于设备总线上，并不直接和 CPU 相连，CPU 通过设备总线的控制器访问硬盘。 | 典型的存储容量是几百 GB 到几 TB。                            | 硬盘由磁性介质和磁头组成，访问硬盘时存在机械运动，磁头要移动，磁性介质要旋转，机械运动的速度很难提高到电子的速度，所以访问速度很受限制。保存在硬盘上的数据掉电后不会丢失。 | 典型的访问时间是几毫秒，是寄存器访问时间的 10<sup>6</sup> 倍。 | 由驱动程序操作设备总线控制器去访问。由于硬盘的访问速度较慢，操作系统通常一次从硬盘上读几个页面到内存中缓存起来，如果这几个页面后来都被程序访问到了，那么这一次读硬盘的时间就可以分摊（Amortize）给程序的多次访问了。 |

对这个表格总结如下。

- 寄存器、Cache 和内存中的数据都是掉电丢失的，这称为易失性存储器（Volatile Memory），与之相对的，硬盘是一种非易失性存储器（Non-volatile Memory）。
- 除了访问寄存器由程序指令直接控制之外，访问其它存储器都不是由指令直接控制的，有些是硬件自动完成的，有些是操作系统配合硬件完成的。
- Cache 从内存取数据时会预取一个 Cache Line 缓存起来，操作系统从硬盘读数据时会预读几个页面缓存起来，都是希望这些数据以后会被程序访问到。大多数程序的行为都具有局部性（Locality）的特点：它们会花费大量的时间反复执行一小段代码（例如循环），或者反复访问一个很小的地址范围中的数据（例如访问一个数组）。所以预读缓存的办法是很有效的：CPU 取一条指令，我把和它相邻的指令也都缓存起来，CPU 很可能马上就会取到；CPU 访问一个数据，我把和它相邻的数据也都缓存起来，CPU 很可能马上就会访问到。设想有两台计算机，一台有 256KB 的 Cache，另一台没有 Cache，两台计算机的内存都是 512MB 的，硬盘都是 100GB 的，虽然多出来 256KB 的 Cache 与内存、硬盘的容量相比微不足道，但访问 Cache 比访问内存、硬盘快几个数量级，由于局部性原理，CPU 大部分时间是在和 Cache 打交道，有 Cache 的计算机明显会快很多。高速存储器的容量只能做得很小，却能显著提升计算机的性能，这就是 Memory  Hierarchy 的意义所在。

## 2.5. x86 汇编程序基础

要彻底搞清楚 C 语言的原理，就必须深入到指令一层去理解。你写一行 C 代码，编译器会生成什么样的指令，要做到心中有数。本章介绍汇编程序的一些基础知识。汇编不是本书的重点，本书要求读者能看懂基本的汇编程序而不要求会写汇编程序，[下一章](2-C-语言本质/ch19-汇编与-C-之间的关系)将在汇编的基础上讨论 C 语言的原理。

### 2.5.1. 最简单的汇编程序

<p id="e18-1">例 18.1. 最简单的汇编程序</p>

```asm6502
  #PURPOSE: Simple program that exits and returns a
  #	  status code back to the Linux kernel
  #
  #INPUT:   none
  #
  #OUTPUT:  returns a status code. This can be viewed
  #	  by typing
  #
  #	  echo $?
  #
  #	  after running the program
  #
  #VARIABLES:
  #	  %eax holds the system call number
  #	  %ebx holds the return status
  #
   .section .data
  
   .section .text
   .globl _start
  _start:
   movl $1, %eax  # this is the linux kernel command
                  # number (system call) for exiting
                  # a program
  
   movl $4, %ebx  # this is the status number we will
                  # return to the operating system.
                  # Change this around and it will
                  # return different things to
                  # echo $?
  
   int $0x80      # this wakes up the kernel to run
                  # the exit command
```

把这个程序保存成文件 `hello.s` （汇编程序通常以 `.s` 作为文件名后缀），用汇编器（Assembler）`as` 把汇编程序中的助记符翻译成机器指令，生成目标文件 `hello.o`：

```bash
$ as hello.s -o hello.o
```

然后用链接器（Linker，或 Link Editor）`ld` 把目标文件 `hello.o` 链接成可执行文件`hello`：

```bash
$ ld hello.o -o hello
```

为什么用汇编器翻译成机器指令了还不行，还要有一个链接的步骤呢？链接主要有两个作用，一是修改目标文件中的信息，对地址做重定位，在[本章第 5.2 节「可执行文件」](2-C-语言本质/ch18-x86-汇编程序基础#_52-可执行文件)详细解释，二是把多个目标文件合并成一个可执行文件，在[第 19 章「汇编与 C 之间的关系」第 2 节「main 函数和启动例程」](2-C-语言本质/ch19-汇编与-C-之间的关系#_2-main-函数和启动例程)详细解释。我们这个例子虽然只有一个目标文件，但也需要经过链接才能成为可执行文件。

现在执行这个程序，它只做了一件事就是退出，退出状态是 4，[第 3 章「简单函数」第 2 节「自定义函数」](1-C-语言入门/ch03-简单函数#_2-自定义函数)讲过在 Shell 中可以用特殊变量 `$?` 得到上一条命令的退出状态：

```bash
$ ./hello
$ echo $?
4
```

所以这段汇编代码相当于在 C 程序的 `main` 函数中 `return 4;`。为什么会相当呢？我们在[第 19 章「汇编与 C 之间的关系」第 2 节「main 函数和启动例程」](2-C-语言本质/ch19-汇编与-C-之间的关系#_2-main-函数和启动例程)详细解释。

下面逐行分析这个汇编程序。首先，`#`号表示单行注释，类似于 C 语言的 `//` 注释。

```asm6502
 .section .data
```

汇编程序中以 `.` 开头的名称并不是指令的助记符，不会被翻译成机器指令，而是给汇编器一些特殊指示，称为汇编指示（Assembler Directive）或伪操作（Pseudo-operation），由于它不是真正的指令所以加个「伪」字。`.section` 指示把代码划分成若干个段（Section），程序被操作系统加载执行时，每个段被加载到不同的地址，操作系统对不同的页面设置不同的读、写、执行权限。`.data` 段保存程序的数据，是可读可写的，相当于 C 程序的全局变量。本程序中没有定义数据，所以 `.data` 段是空的。

```asm6502
 .section .text
```

`.text` 段保存代码，是只读和可执行的，后面那些指令都属于 `.text` 段。

```asm6502
 .globl _start
```

`_start` 是一个符号（Symbol），符号在汇编程序中代表一个地址，可以用在指令中，汇编程序经过汇编器的处理之后，所有的符号都被替换成它所代表的地址值。在 C 语言中我们通过变量名访问一个变量，其实就是读写某个地址的内存单元，我们通过函数名调用一个函数，其实就是跳转到该函数第一条指令所在的地址，所以变量名和函数名都是符号，本质上是代表内存地址的。

`.globl` 指示告诉汇编器，`_start` 这个符号要被链接器用到，所以要在目标文件的符号表中标记它是一个全局符号（在[本章第 5.1 节「目标文件」](#_51-目标文件)详细解释）。`_start` 就像 C 程序的 `main` 函数一样特殊，是整个程序的入口，链接器在链接时会查找目标文件中的 `_start` 符号代表的地址，把它设置为整个程序的入口地址，所以每个汇编程序都要提供一个 `_start` 符号并且用 `.globl` 声明。如果一个符号没有用 `.globl` 声明，就表示这个符号不会被链接器用到。

```asm6502
_start:
```

这里定义了 `_start` 符号，汇编器在翻译汇编程序时会计算每个数据对象和每条指令的地址，当看到这样一个符号定义时，就把它后面一条指令的地址作为这个符号所代表的地址。而 `_start` 这个符号又比较特殊，它所代表的地址是整个程序的入口地址，所以下一条指令 `movl $1, %eax` 就成了程序中第一条被执行的指令。

```asm6502
 movl $1, %eax
```

这是一条数据传送指令，这条指令要求 CPU 内部产生一个数字1并保存到 `eax` 寄存器中。`mov` 的后缀 `l` 表示 `long`，说明是 32 位的传送指令。这条指令不要求 CPU 读内存，`1` 这个数是在 CPU 内部产生的，称为立即数（Immediate）。在汇编程序中，立即数前面要加 `$`，寄存器名前面要加 `%`，以便跟符号名区分开。以后我们会看到 `mov` 指令还有另外几种形式，但数据传送方向都是一样的，第一个操作数总是源操作数，第二个操作数总是目标操作数。

```asm6502
 movl $4, %ebx
```

和上一条指令类似，生成一个立即数 `4` 并保存到 `ebx` 寄存器中。

```asm6502
 int $0x80
```

前两条指令都是为这条指令做准备的，执行这条指令时发生以下动作：

1. `int` 指令称为软中断指令，可以用这条指令故意产生一个异常，上一章讲过，异常的处理和中断类似，CPU 从用户模式切换到特权模式，然后跳转到内核代码中执行异常处理程序。
2. `int` 指令中的立即数 `0x80` 是一个参数，在异常处理程序中要根据这个参数决定如何处理，在 Linux 内核中 `int $0x80` 这种异常称为系统调用（System Call）。内核提供了很多系统服务供用户程序使用，但这些系统服务不能像库函数（比如 `printf`）那样调用，因为在执行用户程序时 CPU 处于用户模式，不能直接调用内核函数，所以需要通过系统调用切换 CPU 模式，经由异常处理程序进入内核，用户程序只能通过寄存器传几个参数，之后就要按内核设计好的代码路线走，而不能由用户程序随心所欲，想调哪个内核函数就调哪个内核函数，这样可以保证系统服务被安全地调用。在调用结束之后，CPU 再切换回用户模式，继续执行 `int $0x80` 的下一条指令，在用户程序看来就像函数调用和返回一样。
3. `eax` 和 `ebx` 的值是传递给系统调用的两个参数。`eax` 的值是系统调用号，Linux 的各种系统调用都是由 `int $0x80` 指令引发的，内核需要通过 `eax` 判断用户要调哪个系统调用，`_exit` 的系统调用号是 `1`。`ebx` 的值是传给 `_exit` 的参数，表示退出状态。大多数系统调用完成之后会返回用户空间继续执行后面的指令，而 `_exit` 系统调用比较特殊，它会终止掉当前进程，而不是返回用户空间继续执行。

#### 2.5.1.1. x86 汇编的两种语法：intel 语法和 AT&T 语法

x86 汇编一直存在两种不同的语法，在 intel 的官方文档中使用 intel 语法，Windows 也使用 intel 语法，而 UNIX 平台的汇编器一直使用 AT&T 语法，所以本书使用 AT&T 语法。`movl %edx,%eax` 这条指令如果用 intel 语法来写，就是 `mov eax,edx`，寄存器名不加 `%` 号，源操作数和目标操作数的位置互换，字长也不是用指令的后缀l表示而是用另外的方式表示。本书不详细讨论这两种语法之间的区别，读者可以参考 *Assembly HOWTO*。

介绍 x86 汇编的书很多，UNIX 平台的书都采用 AT&T 语法，例如 *GroudUp*，其它书一般采用 intel 语法，例如 *x86 Assembly*。

### 2.5.2. x86 的寄存器

x86 的通用寄存器有 `eax`、`ebx`、`ecx`、`edx`、`edi`、`esi`。这些寄存器在大多数指令中是可以任意选用的，比如 `movl` 指令可以把一个立即数传送到 `eax` 中，也可传送到 `ebx` 中。但也有一些指令规定只能用其中某个寄存器做某种用途，例如除法指令 `idivl` 要求被除数在 `eax` 寄存器中，`edx` 寄存器必须是 `0`，而除数可以在任意寄存器中，计算结果的商数保存在 `eax` 寄存器中（覆盖原来的被除数），余数保存在 `edx` 寄存器中。也就是说，通用寄存器对于某些特殊指令来说也不是通用的。

x86 的特殊寄存器有 `ebp`、`esp`、`eip`、`eflags`。`eip` 是程序计数器，`eflags` 保存着计算过程中产生的标志位，其中包括[第 14 章「计算机中数的表示」第 3 节「整数的加减运算」](2-C-语言本质/ch14-计算机中数的表示#_3-整数的加减运算)讲过的进位标志、溢出标志、零标志和负数标志，在 intel 的手册中这几个标志位分别称为 CF、OF、ZF、SF。`ebp` 和 `esp` 用于维护函数调用的栈帧，在[第 19 章「汇编与 C 之间的关系」第 1 节「函数调用」](2-C-语言本质/ch19-汇编与-C-之间的关系#_1-函数调用)详细讨论。

### 2.5.3. 第二个汇编程序

<p id="e18-2">例 18.2. 求一组数的最大值的汇编程序</p>

```asm6502
  #PURPOSE: This program finds the maximum number of a
  #	  set of data items.
  #
  #VARIABLES: The registers have the following uses:
  #
  # %edi - Holds the index of the data item being examined
  # %ebx - Largest data item found
  # %eax - Current data item
  #
  # The following memory locations are used:
  #
  # data_items - contains the item data. A 0 is used
  # to terminate the data
  #
   .section .data
  data_items: 		#These are the data items
   .long 3,67,34,222,45,75,54,34,44,33,22,11,66,0
  
   .section .text
   .globl _start
  _start:
   movl $0, %edi  	# move 0 into the index register
   movl data_items(,%edi,4), %eax # load the first byte of data
   movl %eax, %ebx 	# since this is the first item, %eax is
  			# the biggest
  
  start_loop: 		# start loop
   cmpl $0, %eax  	# check to see if we've hit the end
   je loop_exit
   incl %edi 		# load next value
   movl data_items(,%edi,4), %eax
   cmpl %ebx, %eax 	# compare values
   jle start_loop 	# jump to loop beginning if the new
   			# one isn't bigger
   movl %eax, %ebx 	# move the value as the largest
   jmp start_loop 	# jump to loop beginning
  
  loop_exit:
   # %ebx is the status code for the _exit system call
   # and it already has the maximum number
   movl $1, %eax  	#1 is the _exit() syscall
   int $0x80
  ```
  
  汇编、链接、运行：
  
  ```bash
  $ as max.s -o max.o
  $ ld max.o -o max
  $ ./max
  $ echo $?
```

这个程序在一组数中找到一个最大的数，并把它作为程序的退出状态。这组数在 `.data` 段给出：

```asm6502
data_items:
 .long 3,67,34,222,45,75,54,34,44,33,22,11,66,0
```

`.long` 指示声明一组数，每个数占 32 位，相当于 C 语言中的数组。这个数组开头定义了一个符号 `data_items`，汇编器会把数组的首地址作为 `data_items` 符号所代表的地址，`data_items` 类似于 C 语言中的数组名。`data_items` 这个标号没有用 `.globl` 声明，因为它只在这个汇编程序内部使用，链接器不需要用到这个名字。除了 `.long` 之外，常用的数据声明还有：

- `.byte`，也是声明一组数，每个数占 8 位
- `.ascii`，例如 `.ascii "Hello world"`，声明 11 个数，取值为相应字符的 ASCII 码。注意，和 C 语言不同，这样声明的字符串末尾是没有 `'\0'` 字符的，如果需要以 `'\0'` 结尾可以声明为 `.ascii "Hello world\0"`。

`data_items` 数组的最后一个数是 `0`，我们在一个循环中依次比较每个数，碰到 `0` 的时候让循环终止。在这个循环中：

- `edi` 寄存器保存数组中的当前位置，每次比较完一个数就把 `edi` 的值加1，指向数组中的下一个数。
- `ebx` 寄存器保存到目前为止找到的最大值，如果发现有更大的数就更新 `ebx` 的值。
- `eax` 寄存器保存当前要比较的数，每次更新 `edi` 之后，就把下一个数读到 `eax` 中。

```assembly
_start:
 movl $0, %edi
```

初始化 `edi`，指向数组的第 0 个元素。

```asm6502
 movl data_items(,%edi,4), %eax
```

这条指令把数组的第 0 个元素传送到 `eax` 寄存器中。`data_items` 是数组的首地址，`edi` 的值是数组的下标，4 表示数组的每个元素占 4 字节，那么数组中第 `edi` 个元素的地址应该是 `data_items + edi * 4`，写在指令中就是 `data_items(,%edi,4)`，这种地址表示方式在下一节还会详细解释。

```asm6502
 movl %eax, %ebx
```

`ebx` 的初始值也是数组的第 0 个元素。下面我们进入一个循环，循环的开头定义一个符号 `start_loop`，循环的末尾之后定义一个符号 `loop_exit`。

```asm6502
start_loop:
 cmpl $0, %eax
 je loop_exit
```

比较 `eax` 的值是不是 0，如果是 0 就说明到达数组末尾了，就要跳出循环。`cmpl` 指令将两个操作数相减，但计算结果并不保存，只是根据计算结果改变 `eflags` 寄存器中的标志位。如果两个操作数相等，则计算结果为 0，`eflags` 中的 ZF 位置 1。`je` 是一个条件跳转指令，它检查 `eflags` 中的 ZF 位，ZF 位为 1 则发生跳转，ZF 位为 0 则不跳转，继续执行下一条指令。可见比较指令和条件跳转指令是配合使用的，前者改变标志位，后者根据标志位决定是否跳转。`je` 可以理解成 *jump if equal*，如果参与比较的两数相等则跳转。

```asm6502
 incl %edi
 movl data_items(,%edi,4), %eax
```

将 `edi` 的值加 `1`，把数组中的下一个数传送到 `eax` 寄存器中。

```asm6502
 cmpl %ebx, %eax
 jle start_loop
```

把当前数组元素 `eax` 和目前为止找到的最大值 `ebx` 做比较，如果前者小于等于后者，则最大值没有变，跳转到循环开头比较下一个数，否则继续执行下一条指令。`jle` 表示 *jump if less than or equal*。

```asm6502
 movl %eax, %ebx
 jmp start_loop
```

更新了最大值 `ebx` 然后跳转到循环开头比较下一个数。`jmp` 是一个无条件跳转指令，什么条件也不判断，直接跳转。`loop_exit` 符号后面的指令调 `_exit` 系统调用退出程序。

### 2.5.4. 寻址方式

通过上一节的例子我们了解到，访问内存时在指令中可以用多种方式表示内存地址，比如可以用数组基地址、元素长度和下标三个量来表示，增加了寻址的灵活性。本节介绍 x86 常用的几种寻址方式（Addressing Mode）。内存寻址在指令中可以表示成如下的通用格式：

```
ADDRESS_OR_OFFSET(%BASE_OR_OFFSET,%INDEX,MULTIPLIER)
```

它所表示的地址可以这样计算出来：

```
FINAL ADDRESS = ADDRESS_OR_OFFSET + BASE_OR_OFFSET + MULTIPLIER * INDEX
```

其中 `ADDRESS_OR_OFFSET` 和 `MULTIPLIER` 必须是常数，`BASE_OR_OFFSET` 和 `INDEX` 必须是寄存器。在有些寻址方式中会省略这 4 项中的某些项，相当于这些项是 0。

- 直接寻址（Direct Addressing Mode）。只使用 `ADDRESS_OR_OFFSET` 寻址，例如 `movl ADDRESS, %eax` 把 `ADDRESS` 地址处的 32 位数传送到 `eax` 寄存器。
- 变址寻址（Indexed Addressing Mode） 。上一节的 `movl data_items(,%edi,4), %eax` 就属于这种寻址方式，用于访问数组元素比较方便。
- 间接寻址（Indirect Addressing Mode）。只使用 `BASE_OR_OFFSET` 寻址，例如 `movl (%eax), %ebx`，把 `eax` 寄存器的值看作地址，把内存中这个地址处的 32 位数传送到 `ebx` 寄存器。注意和 `movl %eax, %ebx` 区分开。
- 基址寻址（Base Pointer Addressing Mode）。只使用 `ADDRESS_OR_OFFSET` 和 `BASE_OR_OFFSET` 寻址，例如 `movl 4(%eax), %ebx`，用于访问结构体成员比较方便，例如一个结构体的基地址保存在 `eax` 寄存器中，其中一个成员在结构体内的偏移量是 4 字节，要把这个成员读上来就可以用这条指令。
- 立即数寻址（Immediate Mode）。就是指令中有一个操作数是立即数，例如 `movl $12, %eax`中的`$12` ，这其实跟寻址没什么关系，但也算作一种寻址方式。
- 寄存器寻址（Register Addressing Mode）。就是指令中有一个操作数是寄存器，例如 `movl $12, %eax` 中的 `%eax`，这跟内存寻址没什么关系，但也算作一种寻址方式。在汇编程序中寄存器用助记符来表示，在机器指令中则要用几个 Bit 表示寄存器的编号，这几个 Bit 也可以看作寄存器的地址，但是和内存地址不在一个地址空间。

### 2.5.5. ELF文件

ELF 文件格式是一个开放标准，各种 UNIX 系统的可执行文件都采用 ELF 格式，它有三种不同的类型：

- 可重定位的目标文件（Relocatable，或者 Object File）
- 可执行文件（Executable）
- 共享库（Shared Object，或者 Shared Library）

共享库留到[第 20 章「链接详解」第 4 节「共享库」](2-C-语言本质/ch20-链接详解#_4-共享库)再详细介绍，本节我们以[本章第 3 节例 18.2 「求一组数的最大值的汇编程序」](#e18-2)为例讨论目标文件和可执行文件的格式。现在详细解释一下这个程序的汇编、链接、运行过程：

1. 写一个汇编程序保存成文本文件 `max.s`。
2. 汇编器读取这个文本文件转换成目标文件 `max.o`，目标文件由若干个 Section 组成，我们在汇编程序中声明的 `.section` 会成为目标文件中的 Section，此外汇编器还会自动添加一些 Section（比如符号表）。
3. 然后链接器把目标文件中的 Section 合并成几个 Segment<sup>[28]</sup>，生成可执行文件 `max`。
4. 最后加载器（Loader）根据可执行文件中的 Segment 信息加载运行这个程序。

> <sup>[28]</sup> Segment 也可以翻译成「段」，为了避免混淆，在本书中只把 Section 称为段，而 Segment 直接用英文。

ELF 格式提供了两种不同的视角，链接器把 ELF 文件看成是 Section 的集合，而加载器把 ELF 文件看成是 Segment 的集合。如下图所示。

<p id="c18-1">图 18.1. ELF 文件</p>

![ELF文件](./image/asm.elfoverview.png)

左边是从链接器的视角来看 ELF 文件，开头的 ELF  Header 描述了体系结构和操作系统等基本信息，并指出 Section Header Table 和 Program Header Table 在文件中的什么位置，Program Header Table 在链接过程中用不到，所以是可有可无的，Section Header Table 中保存了所有 Section 的描述信息，通过 Section Header  Table 可以找到每个 Section 在文件中的位置。右边是从加载器的视角来看 ELF 文件，开头是 ELF Header，Program Header Table 中保存了所有 Segment 的描述信息，Section Header Table 在加载过程中用不到，所以是可有可无的。从上图可以看出，一个 Segment 由一个或多个 Section 组成，这些 Section 加载到内存时具有相同的访问权限。有些 Section 只对链接器有意义，在运行时用不到，也不需要加载到内存，那么就不属于任何 Segment。注意 Section  Header Table 和 Program Header Table 并不是一定要位于文件的开头和结尾，其位置由 ELF  Header 指出，上图这么画只是为了清晰。

目标文件需要链接器做进一步处理，所以一定有 Section Header Table；可执行文件需要加载运行，所以一定有 Program Header Table；而共享库既要加载运行，又要在加载时做动态链接，所以既有 Section Header Table 又有 Program Header Table。

#### 2.5.5.1. 目标文件

下面用 `readelf` 工具读出目标文件 `max.o` 的 ELF Header 和 Section Header Table，然后我们逐段分析。

```bash
$ readelf -a max.o 
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              REL (Relocatable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x0
  Start of program headers:          0 (bytes into file)
  Start of section headers:          200 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           0 (bytes)
  Number of program headers:         0
  Size of section headers:           40 (bytes)
  Number of section headers:         8
  Section header string table index: 5
...
```

ELF Header 中描述了操作系统是 UNIX，体系结构是 80386。Section Header Table 中有 8 个 Section Header，从文件地址 `200`（`0xc8`）开始，每个 Section  Header 占 40 字节，共 320 字节，到文件地址 `0x207` 结束。这个目标文件没有 Program  Header。文件地址是这样定义的：文件开头第一个字节的地址是 0，然后每个字节占一个地址。

```bash
...
Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        00000000 000034 00002a 00  AX  0   0  4
  [ 2] .rel.text         REL             00000000 0002b0 000010 08      6   1  4
  [ 3] .data             PROGBITS        00000000 000060 000038 00  WA  0   0  4
  [ 4] .bss              NOBITS          00000000 000098 000000 00  WA  0   0  4
  [ 5] .shstrtab         STRTAB          00000000 000098 000030 00      0   0  1
  [ 6] .symtab           SYMTAB          00000000 000208 000080 10      7   7  4
  [ 7] .strtab           STRTAB          00000000 000288 000028 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

There are no section groups in this file.

There are no program headers in this file.
...
```

从 Section Header 中读出各 Section 的描述信息，其中 `.text` 和 `.data` 是我们在汇编程序中声明的 Section，而其它 Section 是汇编器自动添加的。`Addr` 是这些段加载到内存中的地址（我们讲过程序中的地址都是虚拟地址），加载地址要在链接时填写，现在空缺，所以是全 0。`Off` 和 `Size` 两列指出了各 Section 的文件地址，比如 `.data` 段从文件地址 0x60 开始，一共 0x38 个字节，回去翻一下程序，`.data` 段定义了 14 个 4 字节的整数，一共是 56 个字节，也就是 0x38。根据以上信息可以描绘出整个目标文件的布局。

<p id="t18-1">表 18.1. 目标文件的布局</p>

| 起始文件地址 | Section 或 Header      |
| ------------ | -------------------- |
| 0            | ELF Header           |
| 0x34         | `.text`              |
| 0x60         | `.data`              |
| 0x98         | `.bss`（此段为空）   |
| 0x98         | `.shstrtab`          |
| 0xc8         | Section Header Table |
| 0x208        | `.symtab`            |
| 0x288        | `.strtab`            |
| 0x2b0        | `.rel.text`          |

这个文件不大，我们直接用 `hexdump` 工具把目标文件的字节全部打印出来看。

```bash
$ hexdump -C max.o 
00000000  7f 45 4c 46 01 01 01 00  00 00 00 00 00 00 00 00  |.ELF............|
00000010  01 00 03 00 01 00 00 00  00 00 00 00 00 00 00 00  |................|
00000020  c8 00 00 00 00 00 00 00  34 00 00 00 00 00 28 00  |........4.....(.|
00000030  08 00 05 00 bf 00 00 00  00 8b 04 bd 00 00 00 00  |................|
00000040  89 c3 83 f8 00 74 10 47  8b 04 bd 00 00 00 00 39  |.....t.G.......9|
00000050  d8 7e ef 89 c3 eb eb b8  01 00 00 00 cd 80 00 00  |.~..............|
00000060  03 00 00 00 43 00 00 00  22 00 00 00 de 00 00 00  |....C...".......|
00000070  2d 00 00 00 4b 00 00 00  36 00 00 00 22 00 00 00  |-...K...6..."...|
00000080  2c 00 00 00 21 00 00 00  16 00 00 00 0b 00 00 00  |,...!...........|
00000090  42 00 00 00 00 00 00 00  00 2e 73 79 6d 74 61 62  |B.........symtab|
000000a0  00 2e 73 74 72 74 61 62  00 2e 73 68 73 74 72 74  |..strtab..shstrt|
000000b0  61 62 00 2e 72 65 6c 2e  74 65 78 74 00 2e 64 61  |ab..rel.text..da|
000000c0  74 61 00 2e 62 73 73 00  00 00 00 00 00 00 00 00  |ta..bss.........|
000000d0  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
*
000000f0  1f 00 00 00 01 00 00 00  06 00 00 00 00 00 00 00  |................|
00000100  34 00 00 00 2a 00 00 00  00 00 00 00 00 00 00 00  |4...*...........|
00000110  04 00 00 00 00 00 00 00  1b 00 00 00 09 00 00 00  |................|
00000120  00 00 00 00 00 00 00 00  b0 02 00 00 10 00 00 00  |................|
00000130  06 00 00 00 01 00 00 00  04 00 00 00 08 00 00 00  |................|
00000140  25 00 00 00 01 00 00 00  03 00 00 00 00 00 00 00  |%...............|
00000150  60 00 00 00 38 00 00 00  00 00 00 00 00 00 00 00  |`...8...........|
00000160  04 00 00 00 00 00 00 00  2b 00 00 00 08 00 00 00  |........+.......|
00000170  03 00 00 00 00 00 00 00  98 00 00 00 00 00 00 00  |................|
00000180  00 00 00 00 00 00 00 00  04 00 00 00 00 00 00 00  |................|
00000190  11 00 00 00 03 00 00 00  00 00 00 00 00 00 00 00  |................|
000001a0  98 00 00 00 30 00 00 00  00 00 00 00 00 00 00 00  |....0...........|
000001b0  01 00 00 00 00 00 00 00  01 00 00 00 02 00 00 00  |................|
000001c0  00 00 00 00 00 00 00 00  08 02 00 00 80 00 00 00  |................|
000001d0  07 00 00 00 07 00 00 00  04 00 00 00 10 00 00 00  |................|
000001e0  09 00 00 00 03 00 00 00  00 00 00 00 00 00 00 00  |................|
000001f0  88 02 00 00 28 00 00 00  00 00 00 00 00 00 00 00  |....(...........|
00000200  01 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000210  00 00 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |................|
00000220  00 00 00 00 03 00 01 00  00 00 00 00 00 00 00 00  |................|
00000230  00 00 00 00 03 00 03 00  00 00 00 00 00 00 00 00  |................|
00000240  00 00 00 00 03 00 04 00  01 00 00 00 00 00 00 00  |................|
00000250  00 00 00 00 00 00 03 00  0c 00 00 00 0e 00 00 00  |................|
00000260  00 00 00 00 00 00 01 00  17 00 00 00 23 00 00 00  |............#...|
00000270  00 00 00 00 00 00 01 00  21 00 00 00 00 00 00 00  |........!.......|
00000280  00 00 00 00 10 00 01 00  00 64 61 74 61 5f 69 74  |.........data_it|
00000290  65 6d 73 00 73 74 61 72  74 5f 6c 6f 6f 70 00 6c  |ems.start_loop.l|
000002a0  6f 6f 70 5f 65 78 69 74  00 5f 73 74 61 72 74 00  |oop_exit._start.|
000002b0  08 00 00 00 01 02 00 00  17 00 00 00 01 02 00 00  |................|
000002c0
```

左边一列是文件地址，中间是每个字节的十六进制表示，右边是把这些字节解释成 ASCII 码所对应的字符。中间有一个 `*` 号表示省略的部分全是 0。`.data` 段对应的是这一块：

```
...bash
00000060  03 00 00 00 43 00 00 00  22 00 00 00 de 00 00 00  |....C...".......|
00000070  2d 00 00 00 4b 00 00 00  36 00 00 00 22 00 00 00  |-...K...6..."...|
00000080  2c 00 00 00 21 00 00 00  16 00 00 00 0b 00 00 00  |,...!...........|
00000090  42 00 00 00 00 00 00 00
...
```

`.data` 段将被原封不动地加载到内存中，下一小节会看到 `.data` 段被加载到内存地址 `0x080490a0` ~ `0x080490d7`。

`.shstrtab` 和 `.strtab` 这两个 Section 中存放的都是 ASCII 码：

```bash
...
                                   00 2e 73 79 6d 74 61 62  |B.........symtab|
000000a0  00 2e 73 74 72 74 61 62  00 2e 73 68 73 74 72 74  |..strtab..shstrt|
000000b0  61 62 00 2e 72 65 6c 2e  74 65 78 74 00 2e 64 61  |ab..rel.text..da|
000000c0  74 61 00 2e 62 73 73 00                           |ta..bss.........|
...
                                   00 64 61 74 61 5f 69 74  |.........data_it|
00000290  65 6d 73 00 73 74 61 72  74 5f 6c 6f 6f 70 00 6c  |ems.start_loop.l|
000002a0  6f 6f 70 5f 65 78 69 74  00 5f 73 74 61 72 74 00  |oop_exit._start.|
...
```

可见 `.shstrtab` 段保存着各 Section 的名字，`.strtab` 段保存着程序中用到的符号的名字。每个名字都是以 `'\0'` 结尾的字符串。

我们知道，C 语言的全局变量如果在代码中没有初始化，就会在程序加载时用 0 初始化。这种数据属于 `.bss` 段，在加载时它和 `.data` 段一样都是可读可写的数据，但是在 ELF 文件中 `.data` 段需要占用一部分空间保存初始值，而 `.bss` 段则不需要。也就是说，`.bss` 段在文件中只占一个 Section Header 而没有对应的 Section，程序加载时 `.bss` 段占多大内存空间在 Section Header 中描述。在我们这个例子中没有用到 `.bss` 段，在[第 19 章「汇编与 C 之间的关系」第 3 节「变量的存储布局」](2-C-语言本质/ch19-汇编与-C-之间的关系#_3-变量的存储布局)会看到这样的例子。

我们继续分析 `readelf` 输出的最后一部分，是从 `.rel.text` 和 `.symtab` 这两个 Section 中读出的信息。

```bash
...
Relocation section '.rel.text' at offset 0x2b0 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00000008  00000201 R_386_32          00000000   .data
00000017  00000201 R_386_32          00000000   .data

There are no unwind sections in this file.

Symbol table '.symtab' contains 8 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 00000000     0 SECTION LOCAL  DEFAULT    1 
     2: 00000000     0 SECTION LOCAL  DEFAULT    3 
     3: 00000000     0 SECTION LOCAL  DEFAULT    4 
     4: 00000000     0 NOTYPE  LOCAL  DEFAULT    3 data_items
     5: 0000000e     0 NOTYPE  LOCAL  DEFAULT    1 start_loop
     6: 00000023     0 NOTYPE  LOCAL  DEFAULT    1 loop_exit
     7: 00000000     0 NOTYPE  GLOBAL DEFAULT    1 _start

No version information found in this file.
```

`.rel.text` 告诉链接器指令中的哪些地方需要做重定位，在下一小节详细讨论。

`.symtab` 是符号表。`Ndx` 列是每个符号所在的 Section 编号，例如符号 `data_items` 在第 3 个 Section 里（也就是 `.data` 段），各 Section 的编号见 Section Header Table。`Value` 列是每个符号所代表的地址，在目标文件中，符号地址都是相对于该符号所在 Section 的相对地址，比如 `data_items` 位于 `.data` 段的开头，所以地址是 0，`_start` 位于 `.text` 段的开头，所以地址也是 0，但是 `start_loop` 和 `loop_exit` 相对于 `.text` 段的地址就不是 0 了。从 `Bind` 这一列可以看出 `_start` 这个符号是 `GLOBAL` 的，而其它符号是 `LOCAL` 的，`GLOBAL` 符号是在汇编程序中用 `.globl `指示声明过的符号。

现在剩下 `.text` 段没有分析，`objdump` 工具可以把程序中的机器指令反汇编（Disassemble），那么反汇编的结果是否跟原来写的汇编代码一模一样呢？我们对比分析一下。

```bash
$ objdump -d max.o

max.o:     file format elf32-i386


Disassembly of section .text:

00000000 <_start>:
   0:	bf 00 00 00 00       	mov    $0x0,%edi
   5:	8b 04 bd 00 00 00 00 	mov    0x0(,%edi,4),%eax
   c:	89 c3                	mov    %eax,%ebx

0000000e <start_loop>:
   e:	83 f8 00             	cmp    $0x0,%eax
  11:	74 10                	je     23 <loop_exit>
  13:	47                   	inc    %edi
  14:	8b 04 bd 00 00 00 00 	mov    0x0(,%edi,4),%eax
  1b:	39 d8                	cmp    %ebx,%eax
  1d:	7e ef                	jle    e <start_loop>
  1f:	89 c3                	mov    %eax,%ebx
  21:	eb eb                	jmp    e <start_loop>

00000023 <loop_exit>:
  23:	b8 01 00 00 00       	mov    $0x1,%eax
  28:	cd 80                	int    $0x80
```

左边是机器指令的字节，右边是反汇编结果。显然，所有的符号都被替换成地址了，比如 `je     23`，注意没有加 `$` 的数表示内存地址，而不表示立即数。这条指令后面的 `<loop_exit>` 并不是指令的一部分，而是反汇编器从 `.symtab` 和 `.strtab` 中查到的符号名称，写在后面是为了有更好的可读性。目前所有指令中用到的符号地址都是相对地址，下一步链接器要修改这些指令，把其中的地址都改成加载时的内存地址，这些指令才能正确执行。

#### 2.5.5.2. 可执行文件

现在我们按上一节的步骤分析可执行文件 `max`，看看链接器都做了什么改动。

```bash
$ readelf -a max
ELF Header:
  Magic:   7f 45 4c 46 01 01 01 00 00 00 00 00 00 00 00 00 
  Class:                             ELF32
  Data:                              2's complement, little endian
  Version:                           1 (current)
  OS/ABI:                            UNIX - System V
  ABI Version:                       0
  Type:                              EXEC (Executable file)
  Machine:                           Intel 80386
  Version:                           0x1
  Entry point address:               0x8048074
  Start of program headers:          52 (bytes into file)
  Start of section headers:          256 (bytes into file)
  Flags:                             0x0
  Size of this header:               52 (bytes)
  Size of program headers:           32 (bytes)
  Number of program headers:         2
  Size of section headers:           40 (bytes)
  Number of section headers:         6
  Section header string table index: 3

Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
  [ 0]                   NULL            00000000 000000 000000 00      0   0  0
  [ 1] .text             PROGBITS        08048074 000074 00002a 00  AX  0   0  4
  [ 2] .data             PROGBITS        080490a0 0000a0 000038 00  WA  0   0  4
  [ 3] .shstrtab         STRTAB          00000000 0000d8 000027 00      0   0  1
  [ 4] .symtab           SYMTAB          00000000 0001f0 0000a0 10      5   6  4
  [ 5] .strtab           STRTAB          00000000 000290 000040 00      0   0  1
Key to Flags:
  W (write), A (alloc), X (execute), M (merge), S (strings)
  I (info), L (link order), G (group), x (unknown)
  O (extra OS processing required) o (OS specific), p (processor specific)

There are no section groups in this file.

Program Headers:
  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align
  LOAD           0x000000 0x08048000 0x08048000 0x0009e 0x0009e R E 0x1000
  LOAD           0x0000a0 0x080490a0 0x080490a0 0x00038 0x00038 RW  0x1000

 Section to Segment mapping:
  Segment Sections...
   00     .text 
   01     .data 

There is no dynamic section in this file.

There are no relocations in this file.

There are no unwind sections in this file.

Symbol table '.symtab' contains 10 entries:
   Num:    Value  Size Type    Bind   Vis      Ndx Name
     0: 00000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 08048074     0 SECTION LOCAL  DEFAULT    1 
     2: 080490a0     0 SECTION LOCAL  DEFAULT    2 
     3: 080490a0     0 NOTYPE  LOCAL  DEFAULT    2 data_items
     4: 08048082     0 NOTYPE  LOCAL  DEFAULT    1 start_loop
     5: 08048097     0 NOTYPE  LOCAL  DEFAULT    1 loop_exit
     6: 08048074     0 NOTYPE  GLOBAL DEFAULT    1 _start
     7: 080490d8     0 NOTYPE  GLOBAL DEFAULT  ABS __bss_start
     8: 080490d8     0 NOTYPE  GLOBAL DEFAULT  ABS _edata
     9: 080490d8     0 NOTYPE  GLOBAL DEFAULT  ABS _end

No version information found in this file.
```

在 ELF Header 中，`Type` 改成了 `EXEC`，由目标文件变成可执行文件了，`Entry point address` 改成了 0x8048074（这是 `_start` 符号的地址），还可以看出，多了两个 Program Header，少了两个 Section Header。

在 Section Header Table 中，`.text` 和 `.data` 段的加载地址分别改成了 0x08048074 和 0x080490a0。`.bss` 段没有用到，所以被删掉了。`.rel.text` 段就是用于链接过程的，做完链接就没用了，所以也删掉了。

多出来的 Program Header Table 描述了两个 Segment 的信息。`.text` 段和前面的 ELF Header、Program Header Table 一起组成一个 Segment（`FileSiz` 指出总长度是 0x9e），`.data` 段组成另一个 Segment（总长度是 0x38）。`VirtAddr` 列指出第一个 Segment 加载到虚拟地址 0x08048000（注意在 x86 平台上后面的 `PhysAddr` 列是没有意义的，并不代表实际的物理地址），第二个 Segment 加载到地址 0x080490a0。`Flg` 列指出第一个 Segment 的访问权限是可读可执行，第二个 Segment 的访问权限是可读可写。最后一列 `Align` 的值 0x1000（4K）是 x86 平台的内存页面大小。在加载时文件也要按内存页面大小分成若干页，文件中的一页对应内存中的一页，对应关系如下图所示。

<p id="c18-2">图 18.2. 文件和加载地址的对应关系</p>

![文件和加载地址的对应关系](./image/asm.load.png)

这个可执行文件很小，总共也不超过一页大小，但是两个 Segment 必须加载到内存中两个不同的页面，因为 MMU 的权限保护机制是以页为单位的，一个页面只能设置一种权限。此外还规定每个 Segment 在文件页面内偏移多少加载到内存页面仍然要偏移多少，比如第二个 Segment 在文件中的偏移是 `0xa0`，在内存页面 `0x08049000` 中的偏移仍然是 0xa0，所以从 0x080490a0 开始，这样规定是为了简化链接器和加载器的实现。从上图也可以看出 `.text` 段的加载地址应该是 `0x08048074`，`_start` 符号位于 `.text` 段的开头，所以 `_start` 符号的地址也是 `0x08048074`，从符号表中可以验证这一点。

原来目标文件符号表中的 `Value` 都是相对地址，现在都改成绝对地址了。此外还多了三个符号 `__bss_start`、`_edata` 和 `_end`，这些符号在链接脚本中定义，被链接器添加到可执行文件中，链接脚本在[第 20 章「链接详解」第 1 节「多目标文件的链接」](2-C-语言本质/ch20-链接详解#_1-多目标文件的链接)介绍。

再看一下反汇编的结果：

```bash
$ objdump -d max

max:     file format elf32-i386


Disassembly of section .text:

08048074 <_start>:
 8048074:	bf 00 00 00 00       	mov    $0x0,%edi
 8048079:	8b 04 bd a0 90 04 08 	mov    0x80490a0(,%edi,4),%eax
 8048080:	89 c3                	mov    %eax,%ebx

08048082 <start_loop>:
 8048082:	83 f8 00             	cmp    $0x0,%eax
 8048085:	74 10                	je     8048097 <loop_exit>
 8048087:	47                   	inc    %edi
 8048088:	8b 04 bd a0 90 04 08 	mov    0x80490a0(,%edi,4),%eax
 804808f:	39 d8                	cmp    %ebx,%eax
 8048091:	7e ef                	jle    8048082 <start_loop>
 8048093:	89 c3                	mov    %eax,%ebx
 8048095:	eb eb                	jmp    8048082 <start_loop>

08048097 <loop_exit>:
 8048097:	b8 01 00 00 00       	mov    $0x1,%eax
 804809c:	cd 80                	int    $0x80
```

指令中的相对地址都改成绝对地址了。我们仔细检查一下改了哪些地方。首先看跳转指令，原来目标文件的指令是这样：

```asm6502
...
  11:	74 10                	je     23 <loop_exit>
...
  1d:	7e ef                	jle    e <start_loop>
...
  21:	eb eb                	jmp    e <start_loop>
...
```

现在改成了这样：

```asm6502
...
 8048085:	74 10                	je     8048097 <loop_exit>
...
 8048091:	7e ef                	jle    8048082 <start_loop>
...
 8048095:	eb eb                	jmp    8048082 <start_loop>
...
```

改了吗？其实只是反汇编的结果不同了，指令的机器码根本没变。为什么不用改指令就能跳转到新的地址呢？因为跳转指令中指定的是相对于当前指令向前或向后跳多少字节，而不是指定一个完整的内存地址，内存地址有 32 位，这些跳转指令只有 16 位，显然也不可能指定一个完整的内存地址，这称为相对跳转。这种相对跳转指令只有 16 位，只能在当前指令前后的一个小范围内跳转，不可能跳得太远，也有的跳转指令指定一个完整的内存地址，可以跳到任何地方，这称绝对跳转，在[第 20 章「链接详解」第 4.2 节「动态链接的过程」](2-C-语言本质/ch20-链接详解#_42-动态链接的过程)我们会看到这样的例子。

再看内存访问指令，原来目标文件的指令是这样：

```asm6502
...
   5:	8b 04 bd 00 00 00 00 	mov    0x0(,%edi,4),%eax
...
  14:	8b 04 bd 00 00 00 00 	mov    0x0(,%edi,4),%eax
...
```

现在改成了这样：

```asm6502
...
 8048079:	8b 04 bd a0 90 04 08 	mov    0x80490a0(,%edi,4),%eax
...
 8048088:	8b 04 bd a0 90 04 08 	mov    0x80490a0(,%edi,4),%eax
...
```

指令中的地址原本是 0x00000000，现在改成了 0x080409a0（注意是小端字节序）。那么链接器怎么知道要改这两处呢？是根据目标文件中的 `.rel.text` 段提供的重定位信息来改的：

```asm6502
...
Relocation section '.rel.text' at offset 0x2b0 contains 2 entries:
 Offset     Info    Type            Sym.Value  Sym.Name
00000008  00000201 R_386_32          00000000   .data
00000017  00000201 R_386_32          00000000   .data
...
```

第一列 `Offset` 的值就是 `.text` 段需要改的地方，在 `.text` 段中的相对地址是 8 和 0x17，正是这两条指令中 `00 00 00 00` 的位置。


## 2.6. 汇编与 C 之间的关系

上一章我们学习了汇编的一些基础知识，本章我们进一步研究 C 程序编译之后的汇编是什么样的，C 语言的各种语法分别对应什么样的指令，从而更深入地理解 C 语言。`gcc` 还提供了一种扩展语法可以在 C 程序中内嵌汇编指令，这在内核代码中很常见，本章也会简要介绍这种用法。

### 2.6.1. 函数调用

我们用下面的代码来研究函数调用的过程。

<p id="e19-1">例 19.1. 研究函数的调用过程</p>

```c
int bar(int c, int d)
{
	int e = c + d;
	return e;
}

int foo(int a, int b)
{
	return bar(a, b);
}

int main(void)
{
	foo(2, 3);
	return 0;
}
```

如果在编译时加上 `-g` 选项（在[第 10 章「gdb」](1-C-语言入门/ch10-gdb)讲过 `-g` 选项），那么用 `objdump` 反汇编时可以把 C 代码和汇编代码穿插起来显示，这样 C 代码和汇编代码的对应关系看得更清楚。反汇编的结果很长，以下只列出我们关心的部分。

```bash
$ gcc main.c -g
$ objdump -dS a.out 
...
08048394 <bar>:
int bar(int c, int d)
{
 8048394:	55                   	push   %ebp
 8048395:	89 e5                	mov    %esp,%ebp
 8048397:	83 ec 10             	sub    $0x10,%esp
	int e = c + d;
 804839a:	8b 55 0c             	mov    0xc(%ebp),%edx
 804839d:	8b 45 08             	mov    0x8(%ebp),%eax
 80483a0:	01 d0                	add    %edx,%eax
 80483a2:	89 45 fc             	mov    %eax,-0x4(%ebp)
	return e;
 80483a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 80483a8:	c9                   	leave  
 80483a9:	c3                   	ret    

080483aa <foo>:

int foo(int a, int b)
{
 80483aa:	55                   	push   %ebp
 80483ab:	89 e5                	mov    %esp,%ebp
 80483ad:	83 ec 08             	sub    $0x8,%esp
	return bar(a, b);
 80483b0:	8b 45 0c             	mov    0xc(%ebp),%eax
 80483b3:	89 44 24 04          	mov    %eax,0x4(%esp)
 80483b7:	8b 45 08             	mov    0x8(%ebp),%eax
 80483ba:	89 04 24             	mov    %eax,(%esp)
 80483bd:	e8 d2 ff ff ff       	call   8048394 <bar>
}
 80483c2:	c9                   	leave  
 80483c3:	c3                   	ret    

080483c4 <main>:

int main(void)
{
 80483c4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 80483c8:	83 e4 f0             	and    $0xfffffff0,%esp
 80483cb:	ff 71 fc             	pushl  -0x4(%ecx)
 80483ce:	55                   	push   %ebp
 80483cf:	89 e5                	mov    %esp,%ebp
 80483d1:	51                   	push   %ecx
 80483d2:	83 ec 08             	sub    $0x8,%esp
	foo(2, 3);
 80483d5:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
 80483dc:	00 
 80483dd:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 80483e4:	e8 c1 ff ff ff       	call   80483aa <foo>
	return 0;
 80483e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
 80483ee:	83 c4 08             	add    $0x8,%esp
 80483f1:	59                   	pop    %ecx
 80483f2:	5d                   	pop    %ebp
 80483f3:	8d 61 fc             	lea    -0x4(%ecx),%esp
 80483f6:	c3                   	ret   
...
```

要查看编译后的汇编代码，其实还有一种办法是 `gcc -S main.c`，这样只生成汇编代码 `main.s`，而不生成二进制的目标文件。

整个程序的执行过程是 `main` 调用 `foo`，`foo` 调用 `bar`，我们用 `gdb` 跟踪程序的执行，直到 `bar` 函数中的 `int e = c + d;` 语句执行完毕准备返回时，这时在 `gdb` 中打印函数栈帧。

```bash
  (gdb) start
  ...
  main () at main.c:14
  14		foo(2, 3);
  (gdb) s
  foo (a=2, b=3) at main.c:9
  9		return bar(a, b);
  (gdb) s
  bar (c=2, d=3) at main.c:3
  3		int e = c + d;
  (gdb) disassemble 
  Dump of assembler code for function bar:
  0x08048394 <bar+0>:	push   %ebp
  0x08048395 <bar+1>:	mov    %esp,%ebp
  0x08048397 <bar+3>:	sub    $0x10,%esp
  0x0804839a <bar+6>:	mov    0xc(%ebp),%edx
  0x0804839d <bar+9>:	mov    0x8(%ebp),%eax
  0x080483a0 <bar+12>:	add    %edx,%eax
  0x080483a2 <bar+14>:	mov    %eax,-0x4(%ebp)
  0x080483a5 <bar+17>:	mov    -0x4(%ebp),%eax
  0x080483a8 <bar+20>:	leave  
  0x080483a9 <bar+21>:	ret    
  End of assembler dump.
  (gdb) si
  0x0804839d	3		int e = c + d;
  (gdb) si
  0x080483a0	3		int e = c + d;
  (gdb) si
  0x080483a2	3		int e = c + d;
  (gdb) si
  4		return e;
  (gdb) si
  5	}
  (gdb) bt
  #0  bar (c=2, d=3) at main.c:5
  #1  0x080483c2 in foo (a=2, b=3) at main.c:9
  #2  0x080483e9 in main () at main.c:14
  (gdb) info registers 
  eax            0x5	5
  ecx            0xbff1c440	-1074674624
  edx            0x3	3
  ebx            0xb7fe6ff4	-1208061964
  esp            0xbff1c3f4	0xbff1c3f4
  ebp            0xbff1c404	0xbff1c404
  esi            0x8048410	134513680
  edi            0x80482e0	134513376
  eip            0x80483a8	0x80483a8 <bar+20>
  eflags         0x200206	[ PF IF ID ]
  cs             0x73	115
  ss             0x7b	123
  ds             0x7b	123
  es             0x7b	123
  fs             0x0	0
  gs             0x33	51
  (gdb) x/20 $esp
  0xbff1c3f4:	0x00000000	0xbff1c6f7	0xb7efbdae	0x00000005
  0xbff1c404:	0xbff1c414	0x080483c2	0x00000002	0x00000003
  0xbff1c414:	0xbff1c428	0x080483e9	0x00000002	0x00000003
  0xbff1c424:	0xbff1c440	0xbff1c498	0xb7ea3685	0x08048410
  0xbff1c434:	0x080482e0	0xbff1c498	0xb7ea3685	0x00000001
  (gdb)
```

这里又用到几个新的 `gdb` 命令。`disassemble` 可以反汇编当前函数或者指定的函数，单独用 `disassemble` 命令是反汇编当前函数，如果 `disassemble` 命令后面跟函数名或地址则反汇编指定的函数。以前我们讲过 `step` 命令可以一行代码一行代码地单步调试，而这里用到的 `si` 命令可以一条指令一条指令地单步调试。`info registers` 可以显示所有寄存器的当前值。在 `gdb` 中表示寄存器名时前面要加个 `$`，例如 `p $esp` 可以打印 `esp` 寄存器的值，在上例中 `esp` 寄存器的值是 `0xbff1c3f4`，所以 `x/20 $esp` 命令查看内存中从 `0xbff1c3f4` 地址开始的 20 个 32 位数。在执行程序时，操作系统为进程分配一块栈空间来保存函数栈帧，`esp` 寄存器总是指向栈顶，在 x86 平台上这个栈是从高地址向低地址增长的，我们知道每次调用一个函数都要分配一个栈帧来保存参数和局部变量，现在我们详细分析这些数据在栈空间的布局，根据 `gdb` 的输出结果图示如下<sup>[29]</sup>：

> <sup>[29]</sup> Linux 内核为每个新进程指定的栈空间的起始地址都会有些不同，所以每次运行这个程序得到的地址都不一样，但通常都是 `0xbf??????` 这样一个地址。

<p id="c19-1">图 19.1. 函数栈帧</p>

![函数栈帧](./image/asmc.stackframe.png)

图中每个小方格表示 4 个字节的内存单元，例如 `b: 3` 这个小方格占的内存地址是 `0xbf822d20 ~ 0xbf822d23`，我把地址写在每个小方格的下边界线上，是为了强调该地址是内存单元的起始地址。我们从 `main` 函数的这里开始看起：

```asm6502
	foo(2, 3);
 80483d5:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
 80483dc:	00 
 80483dd:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
 80483e4:	e8 c1 ff ff ff       	call   80483aa <foo>
	return 0;
 80483e9:	b8 00 00 00 00       	mov    $0x0,%eax
```

要调用函数 `foo` 先要把参数准备好，第二个参数保存在 `esp+4` 指向的内存位置，第一个参数保存在 `esp` 指向的内存位置，可见参数是从右向左依次压栈的。然后执行 `call` 指令，这个指令有两个作用：

1. `foo` 函数调用完之后要返回到 `call` 的下一条指令继续执行，所以把 `call` 的下一条指令的地址 0x80483e9 压栈，同时把 `esp` 的值减 4，`esp` 的值现在是 0xbf822d18。
2. 修改程序计数器 `eip`，跳转到 `foo` 函数的开头执行。

现在看 `foo` 函数的汇编代码：

```asm6502
int foo(int a, int b)
{
 80483aa:	55                   	push   %ebp
 80483ab:	89 e5                	mov    %esp,%ebp
 80483ad:	83 ec 08             	sub    $0x8,%esp
```

`push %ebp` 指令把 `ebp` 寄存器的值压栈，同时把 `esp` 的值减 4。`esp` 的值现在是 0xbf822d14，下一条指令把这个值传送给 `ebp` 寄存器。这两条指令合起来是把原来 `ebp` 的值保存在栈上，然后又给 `ebp` 赋了新值。在每个函数的栈帧中，`ebp` 指向栈底，而 `esp` 指向栈顶，在函数执行过程中 `esp` 随着压栈和出栈操作随时变化，而 `ebp` 是不动的，函数的参数和局部变量都是通过 `ebp` 的值加上一个偏移量来访问，例如 `foo` 函数的参数 `a` 和 `b` 分别通过 `ebp+8` 和 `ebp+12` 来访问。所以下面的指令把参数 `a` 和 `b` 再次压栈，为调用 `bar` 函数做准备，然后把返回地址压栈，调用 `bar` 函数：

```asm6502
	return bar(a, b);
 80483b0:	8b 45 0c             	mov    0xc(%ebp),%eax
 80483b3:	89 44 24 04          	mov    %eax,0x4(%esp)
 80483b7:	8b 45 08             	mov    0x8(%ebp),%eax
 80483ba:	89 04 24             	mov    %eax,(%esp)
 80483bd:	e8 d2 ff ff ff       	call   8048394 <bar>
```

现在看 `bar` 函数的指令：

```asm6502
int bar(int c, int d)
{
 8048394:	55                   	push   %ebp
 8048395:	89 e5                	mov    %esp,%ebp
 8048397:	83 ec 10             	sub    $0x10,%esp
	int e = c + d;
 804839a:	8b 55 0c             	mov    0xc(%ebp),%edx
 804839d:	8b 45 08             	mov    0x8(%ebp),%eax
 80483a0:	01 d0                	add    %edx,%eax
 80483a2:	89 45 fc             	mov    %eax,-0x4(%ebp)
```

这次又把 `foo` 函数的 `ebp` 压栈保存，然后给 `ebp` 赋了新值，指向 `bar` 函数栈帧的栈底，通过 `ebp+8` 和 `ebp+12` 分别可以访问参数 `c` 和 `d`。`bar` 函数还有一个局部变量 `e`，可以通过 `ebp-4` 来访问。所以后面几条指令的意思是把参数 `c` 和 `d` 取出来存在寄存器中做加法，计算结果保存在 `eax` 寄存器中，再把 `eax` 寄存器存回局部变量 `e` 的内存单元。

在 `gdb` 中可以用 `bt` 命令和 `frame` 命令查看每层栈帧上的参数和局部变量，现在可以解释它的工作原理了：如果我当前在 `bar` 函数中，我可以通过 `ebp` 找到 `bar` 函数的参数和局部变量，也可以找到 `foo` 函数的 `ebp` 保存在栈上的值，有了 `foo` 函数的 `ebp`，又可以找到它的参数和局部变量，也可以找到 `main` 函数的 `ebp` 保存在栈上的值，因此各层函数栈帧通过保存在栈上的 `ebp` 的值串起来了。

现在看 `bar` 函数的返回指令：

```asm6502
	return e;
 80483a5:	8b 45 fc             	mov    -0x4(%ebp),%eax
}
 80483a8:	c9                   	leave  
 80483a9:	c3                   	ret
```

`bar` 函数有一个 `int` 型的返回值，这个返回值是通过 `eax` 寄存器传递的，所以首先把 `e` 的值读到 `eax` 寄存器中。然后执行 `leave` 指令，这个指令是函数开头的 `push %ebp` 和 `mov %esp,%ebp` 的逆操作：

1. 把 `ebp` 的值赋给 `esp`，现在 `esp` 的值是 0xbf822d04。
2. 现在 `esp` 所指向的栈顶保存着 `foo` 函数栈帧的 `ebp`，把这个值恢复给 `ebp`，同时 `esp` 增加 4，`esp` 的值变成 0xbf822d08。

最后是 `ret` 指令，它是 `call` 指令的逆操作：

1. 现在 `esp` 所指向的栈顶保存着返回地址，把这个值恢复给 `eip`，同时 `esp` 增加 4，`esp` 的值变成 0xbf822d0c。
2. 修改了程序计数器 `eip`，因此跳转到返回地址 0x80483c2 继续执行。

地址 0x80483c2 处是 `foo` 函数的返回指令：

```asm6502
 80483c2:	c9                   	leave  
 80483c3:	c3                   	ret
```

重复同样的过程，又返回到了 `main` 函数。注意函数调用和返回过程中的这些规则：

1. 参数压栈传递，并且是从右向左依次压栈。
2. `ebp` 总是指向当前栈帧的栈底。
3. 返回值通过 `eax` 寄存器传递。

这些规则并不是体系结构所强加的，`ebp` 寄存器并不是必须这么用，函数的参数和返回值也不是必须这么传，只是操作系统和编译器选择了以这样的方式实现C代码中的函数调用，这称为 Calling Convention，Calling Convention 是操作系统二进制接口规范（ABI，Application Binary Interface）的一部分。

### 2.6.2. main 函数和启动例程

为什么汇编程序的入口是 `_start`，而 C 程序的入口是 `main` 函数呢？本节就来解释这个问题。在讲[上章例 18.1 「最简单的汇编程序」](2-C-语言本质/ch18-x86-汇编程序基础#e18-1)时，我们的汇编和链接步骤是：

```bash
$ as hello.s -o hello.o
$ ld hello.o -o hello
```

以前我们常用 `gcc main.c -o main` 命令编译一个程序，其实也可以分三步做，第一步生成汇编代码，第二步生成目标文件，第三步生成可执行文件：

```bash
$ gcc -S main.c
$ gcc -c main.s
$ gcc main.o
```

`-S` 选项生成汇编代码，`-c` 选项生成目标文件，此外在[第 8 章「数组」第 2 节「数组应用实例：统计随机数」](1-C-语言入门/ch08-数组#_2-数组应用实例：统计随机数)还讲过 `-E` 选项只做预处理而不编译，如果不加这些选项则 `gcc` 执行完整的编译步骤，直到最后链接生成可执行文件为止。如下图所示。

<p id="c19-2">图 19.2. gcc 命令的选项</p>

![gcc 命令的选项](./image/asmc.gcc.png)

这些选项都可以和 `-o` 搭配使用，给输出的文件重新命名而不使用 `gcc` 默认的文件名（`xxx.c`、`xxx.s`、`xxx.o` 和 `a.out`），例如 `gcc main.o -o main` 将 `main.o` 链接成可执行文件 `main`。先前由汇编代码[上章例 18.1 「最简单的汇编程序」](2-C-语言本质/ch18-x86-汇编程序基础#e18-1)生成的目标文件 `hello.o` 我们是用 `ld` 来链接的，可不可以用 `gcc` 链接呢？试试看。

```bash
$ gcc hello.o -o hello
hello.o: In function `_start':
(.text+0x0): multiple definition of `_start'
/usr/lib/gcc/i486-linux-gnu/4.3.2/../../../../lib/crt1.o:(.text+0x0): first defined here
/usr/lib/gcc/i486-linux-gnu/4.3.2/../../../../lib/crt1.o: In function `_start':
(.text+0x18): undefined reference to `main'
collect2: ld returned 1 exit status
```

提示两个错误：一是 `_start` 有多个定义，一个定义是由我们的汇编代码提供的，另一个定义来自 `/usr/lib/crt1.o`；二是 `crt1.o` 的 `_start` 函数要调用 `main` 函数，而我们的汇编代码中没有提供 `main` 函数的定义。从最后一行还可以看出这些错误提示是由 `ld` 给出的。由此可见，如果我们用 `gcc` 做链接，`gcc` 其实是调用 `ld` 将目标文件 `crt1.o` 和我们的 `hello.o` 链接在一起。`crt1.o` 里面已经提供了 `_start` 入口点，我们的汇编程序中再实现一个 `_start` 就是多重定义了，链接器不知道该用哪个，只好报错。另外，`crt1.o` 提供的 `_start` 需要调用 `main` 函数，而我们的汇编程序中没有实现 `main` 函数，所以报错。

如果目标文件是由 C 代码编译生成的，用 `gcc` 做链接就没错了，整个程序的入口点是 `crt1.o` 中提供的 `_start`，它首先做一些初始化工作（以下称为启动例程，Startup Routine），然后调用 C 代码中提供的 `main` 函数。所以，以前我们说 `main` 函数是程序的入口点其实不准确，`_start` 才是真正的入口点，而 `main` 函数是被 `_start` 调用的。

我们继续研究上一节的[本章例 19.1 「研究函数的调用过程」](#e19-1)。如果分两步编译，第二步 `gcc main.o -o main` 其实是调用 `ld` 做链接的，相当于这样的命令：

```bash
$ ld /usr/lib/crt1.o /usr/lib/crti.o main.o -o main -lc -dynamic-linker /lib/ld-linux.so.2
```

也就是说，除了 `crt1.o` 之外其实还有 `crti.o`，这两个目标文件和我们的 `main.o` 链接在一起生成可执行文件 `main`。`-lc` 表示需要链接 `libc` 库，在[第 3 章「简单函数」第 1 节「数学函数」](1-C-语言入门/ch03-简单函数#_1-数学函数)讲过 `-lc` 选项是 `gcc` 默认的，不用写，而对于 `ld` 则不是默认选项，所以要写上。`-dynamic-linker /lib/ld-linux.so.2` 指定动态链接器是 `/lib/ld-linux.so.2`，稍后会解释什么是动态链接。

那么 `crt1.o` 和 `crti.o` 里面都有什么呢？我们可以用 `readelf` 命令查看。在这里我们只关心符号表，如果只看符号表，可以用 `readelf` 命令的 `-s` 选项，也可以用 `nm` 命令。

```bash
$ nm /usr/lib/crt1.o 
00000000 R _IO_stdin_used
00000000 D __data_start
         U __libc_csu_fini
         U __libc_csu_init
         U __libc_start_main
00000000 R _fp_hw
00000000 T _start
00000000 W data_start
         U main
$ nm /usr/lib/crti.o
         U _GLOBAL_OFFSET_TABLE_
         w __gmon_start__
00000000 T _fini
00000000 T _init
```

`U main` 这一行表示 `main` 这个符号在 `crt1.o` 中用到了，但是没有定义（U 表示Undefined），因此需要别的目标文件提供一个定义并且和 `crt1.o` 链接在一起。具体来说，在 `crt1.o` 中要用到 `main` 这个符号所代表的地址，例如有一条指令是 `push $符号 main 所代表的地址`，但不知道这个地址是多少，所以在 `crt1.o` 中这条指令暂时写成 `push $0x0`，等到和 `main.o` 链接成可执行文件时就知道这个地址是多少了，比如是 0x80483c4，那么可执行文件 `main` 中的这条指令就被链接器改成了 `push $0x80483c4`。链接器在这里起到符号解析（Symbol Resolution）的作用，在[上章第 5.2 节「可执行文件」]()我们看到链接器起到重定位的作用，这两种作用都是通过修改指令中的地址实现的，链接器也是一种编辑器，`vi` 和 `emacs` 编辑的是源文件，而链接器编辑的是目标文件，所以链接器也叫 Link Editor。`T _start` 这一行表示 `_start` 这个符号在 `crt1.o` 中提供了定义，这个符号的类型是代码（T 表示 Text）。我们从上面的输出结果中选取几个符号用图示说明它们之间的关系：

<p id="c19-3">图 19.3. C 程序的链接过程</p>

![C 程序的链接过程](./image/asmc.link.png)

其实上面我们写的 `ld` 命令做了很多简化，`gcc` 在链接时还用到了另外几个目标文件，所以上图多画了一个框，表示组成可执行文件 `main` 的除了 `main.o`、`crt1.o` 和 `crti.o` 之外还有其它目标文件，本书不做深入讨论，用 `gcc` 的 `-v` 选项可以了解详细的编译过程：

```bash
$ gcc -v main.c -o main
Using built-in specs.
Target: i486-linux-gnu
...
 /usr/lib/gcc/i486-linux-gnu/4.3.2/cc1 -quiet -v main.c -D_FORTIFY_SOURCE=2 -quiet -dumpbase main.c -mtune=generic -auxbase main -version -fstack-protector -o /tmp/ccRGDpua.s
...
 as -V -Qy -o /tmp/ccidnZ1d.o /tmp/ccRGDpua.s
...
 /usr/lib/gcc/i486-linux-gnu/4.3.2/collect2 --eh-frame-hdr -m elf_i386 --hash-style=both -dynamic-linker /lib/ld-linux.so.2 -o main -z relro /usr/lib/gcc/i486-linux-gnu/4.3.2/../../../../lib/crt1.o /usr/lib/gcc/i486-linux-gnu/4.3.2/../../../../lib/crti.o /usr/lib/gcc/i486-linux-gnu/4.3.2/crtbegin.o -L/usr/lib/gcc/i486-linux-gnu/4.3.2 -L/usr/lib/gcc/i486-linux-gnu/4.3.2 -L/usr/lib/gcc/i486-linux-gnu/4.3.2/../../../../lib -L/lib/../lib -L/usr/lib/../lib -L/usr/lib/gcc/i486-linux-gnu/4.3.2/../../.. /tmp/ccidnZ1d.o -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed -lgcc_s --no-as-needed /usr/lib/gcc/i486-linux-gnu/4.3.2/crtend.o /usr/lib/gcc/i486-linux-gnu/4.3.2/../../../../lib/crtn.o
```

链接生成的可执行文件 `main` 中包含了各目标文件所定义的符号，通过反汇编可以看到这些符号的定义：

```bash
$ objdump -d main
main:     file format elf32-i386


Disassembly of section .init:

08048274 <_init>:
 8048274:	55                   	push   %ebp
 8048275:	89 e5                	mov    %esp,%ebp
 8048277:	53                   	push   %ebx
...
Disassembly of section .text:

080482e0 <_start>:
 80482e0:	31 ed                	xor    %ebp,%ebp
 80482e2:	5e                   	pop    %esi
 80482e3:	89 e1                	mov    %esp,%ecx
...
08048394 <bar>:
 8048394:	55                   	push   %ebp
 8048395:	89 e5                	mov    %esp,%ebp
 8048397:	83 ec 10             	sub    $0x10,%esp
...
080483aa <foo>:
 80483aa:	55                   	push   %ebp
 80483ab:	89 e5                	mov    %esp,%ebp
 80483ad:	83 ec 08             	sub    $0x8,%esp
...
080483c4 <main>:
 80483c4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 80483c8:	83 e4 f0             	and    $0xfffffff0,%esp
 80483cb:	ff 71 fc             	pushl  -0x4(%ecx)
...
Disassembly of section .fini:

0804849c <_fini>:
 804849c:	55                   	push   %ebp
 804849d:	89 e5                	mov    %esp,%ebp
 804849f:	53                   	push   %ebx
```

`crt1.o` 中的未定义符号 `main` 在 `main.o` 中定义了，所以链接在一起就没问题了。`crt1.o` 还有一个未定义符号 `__libc_start_main` 在其它几个目标文件中也没有定义，所以在可执行文件 `main` 中仍然是个未定义符号。这个符号是在 `libc` 中定义的，`libc` 并不像其它目标文件一样链接到可执行文件 `main` 中，而是在运行时做动态链接：

1. 操作系统在加载执行 `main` 这个程序时，首先查看它有没有需要动态链接的未定义符号。
2. 如果需要做动态链接，就查看这个程序指定了哪些共享库（我们用 `-lc` 指定了 `libc`）以及用什么动态链接器来做动态链接（我们用 `-dynamic-linker /lib/ld-linux.so.2` 指定了动态链接器）。
3. 动态链接器在共享库中查找这些符号的定义，完成链接过程。

了解了这些原理之后，现在我们来看 `_start` 的反汇编：

```asm6502
...
Disassembly of section .text:

080482e0 <_start>:
 80482e0:       31 ed                   xor    %ebp,%ebp
 80482e2:       5e                      pop    %esi
 80482e3:       89 e1                   mov    %esp,%ecx
 80482e5:       83 e4 f0                and    $0xfffffff0,%esp
 80482e8:       50                      push   %eax
 80482e9:       54                      push   %esp
 80482ea:       52                      push   %edx
 80482eb:       68 00 84 04 08          push   $0x8048400
 80482f0:       68 10 84 04 08          push   $0x8048410
 80482f5:       51                      push   %ecx
 80482f6:       56                      push   %esi
 80482f7:       68 c4 83 04 08          push   $0x80483c4
 80482fc:       e8 c3 ff ff ff          call   80482c4 <__libc_start_main@plt>
...
```

首先将一系列参数压栈，然后调用 `libc` 的库函数 `__libc_start_main` 做初始化工作，其中最后一个压栈的参数 `push   $0x80483c4` 是 `main` 函数的地址，`__libc_start_main` 在完成初始化工作之后会调用 `main` 函数。由于 `__libc_start_main` 需要动态链接，所以这个库函数的指令在可执行文件 `main` 的反汇编中肯定是找不到的，然而我们找到了这个：

```asm6502
Disassembly of section .plt:
...
080482c4 <__libc_start_main@plt>:
 80482c4:       ff 25 04 a0 04 08       jmp    *0x804a004
 80482ca:       68 08 00 00 00          push   $0x8
 80482cf:       e9 d0 ff ff ff          jmp    80482a4 <_init+0x30>
```

这三条指令位于 `.plt` 段而不是 `.text` 段，`.plt` 段协助完成动态链接的过程。我们将在下一章详细讲解动态链接的过程。

`main` 函数最标准的原型应该是 `int main(int argc, char *argv[])`，也就是说启动例程会传两个参数给 `main` 函数，这两个参数的含义我们学了指针以后再解释。我们到目前为止都把 `main` 函数的原型写成 `int main(void)`，这也是 C 标准允许的，如果你认真分析了上一节的习题，你就应该知道，多传了参数而不用是没有问题的，少传了参数却用了则会出问题。

由于 `main` 函数是被启动例程调用的，所以从 `main` 函数 `return` 时仍返回到启动例程中，`main` 函数的返回值被启动例程得到，如果将启动例程表示成等价的 C 代码（实际上启动例程一般是直接用汇编写的），则它调用 `main` 函数的形式是：

```bash
exit(main(argc, argv));
```

也就是说，启动例程得到 `main` 函数的返回值后，会立刻用它做参数调用 `exit` 函数。`exit` 也是 `libc` 中的函数，它首先做一些清理工作，然后调用上一章讲过的 `_exit` 系统调用终止进程，`main` 函数的返回值最终被传给 `_exit` 系统调用，成为进程的退出状态。我们也可以在 `main` 函数中直接调用 `exit` 函数终止进程而不返回到启动例程，例如：

```c
 #include <stdlib.h>
 
 int main(void)
 {
 	exit(4);
 }
```

这样和 `int main(void) { return 4; }` 的效果是一样的。在 Shell 中运行这个程序并查看它的退出状态：

```bash
$ ./a.out 
$ echo $?
4
```

按照惯例，退出状态为 `0` 表示程序执行成功，退出状态非 `0` 表示出错。注意，退出状态只有 8 位，而且被 Shell 解释成无符号数，如果将上面的代码改为 `exit(-1);` 或 `return -1;`，则运行结果为

```bash
$ ./a.out 
$ echo $?
255
```

注意，如果声明一个函数的返回值类型是 `int`，函数中每个分支控制流程必须写 `return` 语句指定返回值，如果缺了 `return` 则返回值不确定（想想这是为什么），编译器通常是会报警告的，但如果某个分支控制流程调用了 `exit` 或 `_exit` 而不写 `return`，编译器是允许的，因为它都没有机会返回了，指不指定返回值也就无所谓了。使用 `exit` 函数需要包含头文件 `stdlib.h`，而使用 `_exit` 函数需要包含头文件 `unistd.h`，以后还要详细解释这两个函数。

### 2.6.3. 变量的存储布局

首先看下面的例子：

<p id="e19-2">例 19.2. 研究变量的存储布局</p>

```c
  #include <stdio.h>
  
  const int A = 10;
  int a = 20;
  static int b = 30;
  int c;
  
  int main(void)
  {
  	static int a = 40;
  	char b[] = "Hello world";
  	register int c = 50;
  
  	printf("Hello world %d\n", c);
  
  	return 0;
  }
```

我们在全局作用域和 `main` 函数的局部作用域各定义了一些变量，并且引入一些新的关键字 `const`、`static`、`register` 来修饰变量，那么这些变量的存储空间是怎么分配的呢？我们编译之后用 `readelf` 命令看它的符号表，了解各变量的地址分布。注意在下面的清单中我把符号表按地址从低到高的顺序重新排列了，并且只截取我们关心的那几行。

```bash
$ gcc main.c -g
$ readelf -a a.out
...
    68: 08048540     4 OBJECT  GLOBAL DEFAULT   15 A
    69: 0804a018     4 OBJECT  GLOBAL DEFAULT   23 a
    52: 0804a01c     4 OBJECT  LOCAL  DEFAULT   23 b
    53: 0804a020     4 OBJECT  LOCAL  DEFAULT   23 a.1589
    81: 0804a02c     4 OBJECT  GLOBAL DEFAULT   24 c
...
```

变量 A 用 `const` 修饰，表示 A 是只读的，不可修改，它被分配的地址是 0x8048540，从 `readelf` 的输出可以看到这个地址位于 `.rodata` 段：

```bash
Section Headers:
  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al
...
  [13] .text             PROGBITS        08048360 000360 0001bc 00  AX  0   0 16
...
  [15] .rodata           PROGBITS        08048538 000538 00001c 00   A  0   0  4
...
  [23] .data             PROGBITS        0804a010 001010 000014 00  WA  0   0  4
  [24] .bss              NOBITS          0804a024 001024 00000c 00  WA  0   0  4
...
```

它在文件中的地址是 0x538 ~ 0x554，我们用 `hexdump` 命令看看这个段的内容：

```bash
$ hexdump -C a.out
...
00000530  5c fe ff ff 59 5b c9 c3  03 00 00 00 01 00 02 00  |\...Y[..........|
00000540  0a 00 00 00 48 65 6c 6c  6f 20 77 6f 72 6c 64 20  |....Hello world |
00000550  25 64 0a 00 00 00 00 00  00 00 00 00 00 00 00 00  |%d..............|
...
```

其中 0x540 地址处的 `0a 00 00 00` 就是变量 A。我们还看到程序中的字符串字面值 `"Hello world %d\n"` 分配在 `.rodata` 段的末尾，在[第 8 章「数组」第 4 节「字符串」](1-C-语言入门/ch08-数组#_4-字符串)说过字符串字面值是只读的，相当于在全局作用域定义了一个 `const` 数组：

```c
const char helloworld[] = {'H', 'e', 'l', 'l', 'o', ' ',
		 	'w', 'o', 'r', 'l', 'd', ' ', '%', 'd', '\n', '\0'};
```

程序加载运行时，`.rodata` 段和 `.text` 段通常合并到一个 Segment 中，操作系统将这个 Segment 的页面只读保护起来，防止意外的改写。这一点从 `readelf` 的输出也可以看出来：

```bash
 Section to Segment mapping:
  Segment Sections...
   00     
   01     .interp 
   02     .interp .note.ABI-tag .hash .gnu.hash .dynsym .dynstr .gnu.version .gnu.version_r .rel.dyn .rel.plt .init .plt .text .fini .rodata .eh_frame 
   03     .ctors .dtors .jcr .dynamic .got .got.plt .data .bss 
   04     .dynamic 
   05     .note.ABI-tag 
   06     
   07     .ctors .dtors .jcr .dynamic .got 
```

注意，像 `A` 这种 `const` 变量在定义时必须初始化。因为只有初始化时才有机会给它一个值，一旦定义之后就不能再改写了，也就是不能再赋值了。

从上面 `readelf` 的输出可以看到 `.data` 段从地址 0x804a010 开始，长度是 0x14，也就是到地址 0x804a024 结束。在 `.data` 段中有三个变量，`a`，`b` 和 `a.1589`。

`a` 是一个 `GLOBAL` 的符号，而 `b` 被 `static` 关键字修饰了，导致它成为一个 `LOCAL` 的符号，所以 `static` 在这里的作用是声明 `b` 这个符号为 `LOCAL` 的，不被链接器处理，在下一章我们会看到，如果把多个目标文件链接在一起，`LOCAL` 的符号只能在某一个目标文件中定义和使用，而不能定义在一个目标文件中却在另一个目标文件中使用。一个函数定义前面也可以用 `static` 修饰，表示这个函数名符号是 `LOCAL` 的。

还有一个 `a.1589` 是什么呢？它就是 `main` 函数中的 `static int a`。函数中的 `static` 变量不同于以前我们讲的局部变量，它并不是在调用函数时分配，在函数返回时释放，而是像全局变量一样静态分配，所以用 *static* （静态）这个词。另一方面，函数中的 `static` 变量的作用域和以前讲的局部变量一样，只在函数中起作用，比如 `main` 函数中的 `a` 这个变量名只在 `main` 函数中起作用，在别的函数中说变量 `a` 就不是指它了，所以编译器给它的符号名加了一个后缀，变成 `a.1589`，以便和全局变量 `a` 以及其它函数的变量 `a` 区分开。

`.bss` 段从地址 0x804a024 开始（紧挨着 `.data` 段），长度为 0xc，也就是到地址 0x804a030 结束。变量 `c` 位于这个段。从上面的 `readelf` 输出可以看到，`.data` 和 `.bss` 在加载时合并到一个 Segment 中，这个 Segment 是可读可写的。`.bss` 段和 `.data` 段的不同之处在于，`.bss` 段在文件中不占存储空间，在加载时这个段用 0 填充。所以我们在[第 3 章「简单函数」第 4 节「全局变量、局部变量和作用域」](1-C-语言入门/ch03-简单函数#_4-全局变量、局部变量和作用域)讲过，全局变量如果不初始化则初值为 0，同理可以推断，`static` 变量（不管是函数里的还是函数外的）如果不初始化则初值也是 0，也分配在 `.bss` 段。

现在还剩下函数中的 `b` 和 `c` 这两个变量没有分析。上一节我们讲过函数的参数和局部变量是分配在栈上的，`b` 是数组也一样，也是分配在栈上的，我们看 `main` 函数的反汇编代码：

```bash
$ objdump -dS a.out
...
        char b[]="Hello world";
 8048430:       c7 45 ec 48 65 6c 6c    movl   $0x6c6c6548,-0x14(%ebp)
 8048437:       c7 45 f0 6f 20 77 6f    movl   $0x6f77206f,-0x10(%ebp)
 804843e:       c7 45 f4 72 6c 64 00    movl   $0x646c72,-0xc(%ebp)
        register int c = 50;
 8048445:       b8 32 00 00 00          mov    $0x32,%eax

        printf("Hello world %d\n", c);
 804844a:       89 44 24 04             mov    %eax,0x4(%esp)
 804844e:       c7 04 24 44 85 04 08    movl   $0x8048544,(%esp)
 8048455:       e8 e6 fe ff ff          call   8048340 <printf@plt>
...
```

可见，给 `b` 初始化用的这个字符串 `"Hello world"` 并没有分配在 `.rodata` 段，而是直接写在指令里了，通过三条 `movl` 指令把 12 个字节写到栈上，这就是 `b` 的存储空间，如下图所示。

<p id="c19-4">图 19.4. 数组的存储布局</p>

![数组的存储布局](./image/asmc.array.png)

注意，虽然栈是从高地址向低地址增长的，但数组总是从低地址向高地址排列的，按从低地址到高地址的顺序依次是 `b[0]`、`b[1]`、`b[2]`……这样，

数组元素 `b[n]` 的地址  =  数组的基地址（`b` 做右值就表示这个基地址） + n × 每个元素的字节数

当 n=0 时，元素 `b[0]` 的地址就是数组的基地址，因此数组下标要从 0 开始而不是从 1 开始。

变量 `c` 并没有在栈上分配存储空间，而是直接存在 `eax` 寄存器里，后面调用 `printf` 也是直接从 `eax` 寄存器里取出 `c` 的值当参数压栈，这就是 `register` 关键字的作用，指示编译器尽可能分配一个寄存器来存储这个变量。我们还看到调用 `printf` 时对于 `"Hello world %d\n"` 这个参数压栈的是它在 `.rodata` 段中的首地址，而不是把整个字符串压栈，所以在[第 8 章「数组」第 4 节「字符串」](1-C-语言入门/ch08-数组#_4-字符串)中说过，字符串在使用时可以看作数组名，如果做右值则表示数组首元素的地址（或者说指向数组首元素的指针），我们以后讲指针还要继续讨论这个问题。

以前我们用「全局变量」和「局部变量」这两个概念，主要是从作用域上区分的，现在看来用这两个概念给变量分类太笼统了，需要进一步细分。我们总结一下相关的 C 语法。

作用域（Scope）这个概念适用于所有标识符，而不仅仅是变量，C 语言的作用域分为以下几类：

- 函数作用域（Function Scope），标识符在整个函数中都有效。只有语句标号属于函数作用域。标号在函数中不需要先声明后使用，在前面用一个 `goto` 语句也可以跳转到后面的某个标号，但仅限于同一个函数之中。
- 文件作用域（File Scope），标识符从它声明的位置开始直到这个程序文件<sup>[30]</sup>的末尾都有效。例如上例中 `main` 函数外面的 `A`、`a`、`b`、`c`，还有 `main` 也算，`printf` 其实是在 `stdio.h` 中声明的，被包含到这个程序文件中了，所以也算文件作用域的。
- 块作用域（Block Scope），标识符位于一对 `{}` 括号中（函数体或语句块），从它声明的位置开始到右}括号之间有效。例如上例中 `main` 函数里的 `a`、`b`、`c`。此外，函数定义中的形参也算块作用域的，从声明的位置开始到函数末尾之间有效。
- 函数原型作用域（Function Prototype Scope），标识符出现在函数原型中，这个函数原型只是一个声明而不是定义（没有函数体），那么标识符从声明的位置开始到在这个原型末尾之间有效。例如 `int foo(int a, int b);` 中的 `a` 和 `b`。

> <sup>[30]</sup> 为了容易阅读，这里我用了「程序文件」这个不严格的叫法。如果有文件 `a.c` 包含了 `b.h` 和 `c.h`，那么我所说的「程序文件」指的是经过预处理把 `b.h` 和 `c.h` 在 `a.c` 中展开之后生成的代码，在 C 标准中称为编译单元（Translation Unit）。每个编译单元可以分别编译成一个 `.o` 目标文件，最后这些目标文件用链接器链接到一起，成为一个可执行文件。C 标准中大量使用一些非常不通俗的名词，除了编译单元之外，还有编译器叫 Translator，变量叫 Object，本书不会采用这些名词，因为我不是在写 C 标准。

对属于同一命名空间（Name Space）的重名标识符，内层作用域的标识符将覆盖外层作用域的标识符，例如局部变量名在它的函数中将覆盖重名的全局变量。命名空间可分为以下几类：

- 语句标号单独属于一个命名空间。例如在函数中局部变量和语句标号可以重名，互不影响。由于使用标号的语法和使用其它标识符的语法都不一样，编译器不会把它和别的标识符弄混。
- `struct`，`enum` 和 `union`（下一节介绍 `union`）的类型 Tag 属于一个命名空间。由于 Tag 前面总是带 `struct`，`enum` 或 `union` 关键字，所以编译器不会把它和别的标识符弄混。
- `struct` 和 `union` 的成员名属于一个命名空间。由于成员名总是通过 `.` 或 `->` 运算符来访问而不会单独使用，所以编译器不会把它和别的标识符弄混。
- 所有其它标识符，例如变量名、函数名、宏定义、`typedef` 的类型名、`enum` 成员等等都属于同一个命名空间。如果有重名的话，宏定义覆盖所有其它标识符，因为它在预处理阶段而不是编译阶段处理，除了宏定义之外其它几类标识符按上面所说的规则处理，内层作用域覆盖外层作用域。

标识符的链接属性（Linkage）有三种：

- 外部链接（External Linkage），如果最终的可执行文件由多个程序文件链接而成，一个标识符在任意程序文件中即使声明多次也都代表同一个变量或函数，则这个标识符具有 External Linkage。具有 External Linkage 的标识符编译后在符号表中是 `GLOBAL` 的符号。例如上例中 `main` 函数外面的 `a` 和 `c`，`main` 和 `printf`也算。
- 内部链接（Internal Linkage），如果一个标识符在某个程序文件中即使声明多次也都代表同一个变量或函数，则这个标识符具有 Internal Linkage。例如上例中 `main` 函数外面的 `b`。如果有另一个 `foo.c` 程序和 `main.c` 链接在一起，在 `foo.c` 中也声明一个 `static int b;`，则那个 `b` 和这个 `b` 不代表同一个变量。具有 Internal Linkage 的标识符编译后在符号表中是 `LOCAL` 的符号，但 `main` 函数里面那个 `a` 不能算 Internal Linkage 的，因为即使在同一个程序文件中，在不同的函数中声明多次，也不代表同一个变量。
- 无链接（No Linkage）。除以上情况之外的标识符都属于 No Linkage 的，例如函数的局部变量，以及不表示变量和函数的其它标识符。

存储类修饰符（Storage Class Specifier）有以下几种关键字，可以修饰变量或函数声明：

- `static`，用它修饰的变量的存储空间是静态分配的，用它修饰的文件作用域的变量或函数具有 Internal Linkage。
- `auto`，用它修饰的变量在函数调用时自动在栈上分配存储空间，函数返回时自动释放，例如上例中 `main` 函数里的 `b` 其实就是用 `auto` 修饰的，只不过 `auto` 可以省略不写，`auto` 不能修饰文件作用域的变量。
- `register`，编译器对于用 `register` 修饰的变量会尽可能分配一个专门的寄存器来存储，但如果实在分配不开寄存器，编译器就把它当 `auto` 变量处理了，`register` 不能修饰文件作用域的变量。现在一般编译器的优化都做得很好了，它自己会想办法有效地利用 CPU 的寄存器，所以现在 `register` 关键字也用得比较少了。
- `extern`，上面讲过，链接属性是根据一个标识符多次声明时是不是代表同一个变量或函数来分类的，`extern` 关键字就用于多次声明同一个标识符，下一章再详细介绍它的用法。
- `typedef`，在[第 16 章「运算符详解」第 2.4 节「sizeof 运算符与 typedef 类型声明」](2-C-语言本质/ch16-运算符详解#_24-sizeof-运算符与-typedef-类型声明)讲过这个关键字，它并不是用来修饰变量的，而是定义一个类型名。在那一节也讲过，看 `typedef` 声明怎么看呢，首先去掉 `typedef` 把它看成变量声明，看这个变量是什么类型的，那么 `typedef` 就定义了一个什么类型，也就是说，`typedef` 在语法结构中出现的位置和前面几个关键字一样，也是修饰变量声明的，所以从语法（而不是语义）的角度把它和前面几个关键字归类到一起。

注意，上面介绍的 `const` 关键字不是一个 Storage Class Specifier，虽然看起来它也修饰一个变量声明，但是在以后介绍的更复杂的声明中 `const` 在语法结构中允许出现的位置和 Storage Class Specifier 是不完全相同的。`const` 和以后要介绍的 `restrict` 和 `volatile` 关键字属于同一类语法元素，称为类型限定符（Type Qualifier）。

变量的生存期（Storage Duration，或者 Lifetime）分为以下几类：

- 静态生存期（Static Storage Duration），具有外部或内部链接属性，或者被 `static` 修饰的变量，在程序开始执行时分配和初始化一次，此后便一直存在直到程序结束。这种变量通常位于 `.rodata`，`.data` 或 `.bss` 段，例如上例中 `main` 函数外的 `A`，`a`，`b`，`c`，以及 `main` 函数里的 `a`。
- 自动生存期（Automatic Storage Duration），链接属性为无链接并且没有被 `static` 修饰的变量，这种变量在进入块作用域时在栈上或寄存器中分配，在退出块作用域时释放。例如上例中 `main` 函数里的 `b` 和 `c`。
- 动态分配生存期（Allocated Storage Duration），以后会讲到调用 `malloc` 函数在进程的堆空间中分配内存，调用 `free` 函数可以释放这种存储空间。

### 2.6.4. 结构体和联合体

我们继续用反汇编的方法研究一下 C 语言的结构体：

<p id="e19-3">例 19.3. 研究结构体</p>

```c
  #include <stdio.h>
  
  int main(int argc, char** argv)
  {
  	struct {
  		char a;
  		short b;
  		int c;
  		char d;
  	} s;
  
  	s.a = 1;
  	s.b = 2;
  	s.c = 3;
  	s.d = 4;
  	printf("%u\n", sizeof(s));
  
  	return 0;
  }
```

`main` 函数中几条语句的反汇编结果如下：

```asm6502
        s.a = 1;
 80483d5:       c6 45 f0 01             movb   $0x1,-0x10(%ebp)
        s.b = 2;
 80483d9:       66 c7 45 f2 02 00       movw   $0x2,-0xe(%ebp)
        s.c = 3;
 80483df:       c7 45 f4 03 00 00 00    movl   $0x3,-0xc(%ebp)
        s.d = 4;
 80483e6:       c6 45 f8 04             movb   $0x4,-0x8(%ebp)
```

从访问结构体成员的指令可以看出，结构体的四个成员在栈上是这样排列的：

<p id="c19-5">图 19.5. 结构体的存储布局</p>

![结构体的存储布局](./image/asmc.struct.png)

虽然栈是从高地址向低地址增长的，但结构体成员也是从低地址向高地址排列的，这一点和数组类似。但有一点和数组不同，结构体的各成员并不是一个紧挨一个排列的，中间有空隙，称为填充（Padding），不仅如此，在这个结构体的末尾也有三个字节的填充，所以 `sizeof(s)` 的值是 12。注意，`printf` 的 `%u` 转换说明表示无符号数，`sizeof` 的值是 `size_t` 类型的，是某种无符号整型。

为什么编译器要这样处理呢？有一个知识点我此前一直回避没讲，那就是大多数计算机体系统结构对于访问内存的指令是有限制的，在 32 位平台上，访问 4 字节的指令（比如上面的 `movl`）所访问的内存地址应该是 4 的整数倍，访问两字节的指令（比如上面的 `movw`）所访问的内存地址应该是两字节的整数倍，这称为对齐（Alignment）。以前举的所有例子中的内存访问指令都满足这个限制条件，读者可以回头检验一下。如果指令所访问的内存地址没有正确对齐会怎么样呢？在有些平台上将不能访问内存，而是引发一个异常，在 x86 平台上倒是仍然能访问内存，但是不对齐的指令执行效率比对齐的指令要低，所以编译器在安排各种变量的地址时都会考虑到对齐的问题。对于本例中的结构体，编译器会把它的基地址对齐到4字节边界，也就是说，`ebp-0x10` 这个地址一定是4的整数倍。`s.a` 占一个字节，没有对齐的问题。`s.b` 占两个字节，如果 `s.b` 紧挨在 `s.a` 后面，它的地址就不能是两字节的整数倍了，所以编译器会在结构体中插入一个填充字节，使 `s.b` 的地址也是两字节的整数倍。`s.c` 占 4 字节，紧挨在 `s.b` 的后面就可以了，因为 `ebp-0xc` 这个地址也是 4 的整数倍。那么为什么 `s.d` 的后面也要有填充位填充到 4 字节边界呢？这是为了便于安排这个结构体后面的变量的地址，假如用这种结构体类型组成一个数组，那么后一个结构体只需和前一个结构体紧挨着排列就可以保证它的基地址仍然对齐到4字节边界了，因为在前一个结构体的末尾已经有了填充字节。事实上，C 标准规定数组元素必须紧挨着排列，不能有空隙，这样才能保证每个元素的地址可以按「基地址 + n × 元素大小」简单计算出来。

合理设计结构体各成员的排列顺序可以节省存储空间，例如上例中的结构体改成这样就可以避免产生填充字节：

```c
struct {
	char a;
	char d;
	short b;
	int c;
} s;
```

此外，`gcc` 提供了一种扩展语法可以消除结构体中的填充字节：

```c
struct {
	char a;
	short b;
	int c;
	char d;
} __attribute__((packed)) s;
```

这样就不能保证结构体成员的对齐了，在访问 `b` 和 `c` 的时候可能会有效率问题，所以除非有特别的理由，一般不要使用这种语法。

以前我们使用的数据类型都是占几个字节，最小的类型也要占一个字节，而在结构体中还可以使用 Bit-field 语法定义只占几个 bit 的成员。下面这个例子出自[王聪的网站](www.wangcong.org)：

<p id="e19-4">例 19.4. Bit-field</p>

```c
  #include <stdio.h>
  
  typedef struct {
  	unsigned int one:1;
  	unsigned int two:3;
  	unsigned int three:10;
  	unsigned int four:5;
  	unsigned int :2;
  	unsigned int five:8;
  	unsigned int six:8;
  } demo_type;
  
  int main(void)
  {
  	demo_type s = { 1, 5, 513, 17, 129, 0x81 };
  	printf("sizeof demo_type = %u\n", sizeof(demo_type));
  	printf("values: s=%u,%u,%u,%u,%u,%u\n",
  	       s.one, s.two, s.three, s.four, s.five, s.six);
  
  	return 0;
  }
```

`s` 这个结构体的布局如下图所示：

<p id="c19-6">图 19.6. Bit-field 的存储布局</p>

![Bit-field 的存储布局](./image/asmc.bitfield.png)

Bit-field 成员的类型可以是 int 或 unsigned int，表示有符号数或无符号数，但不表示它像普通的 int 型一样占 4 个字节，它后面的数字是几就表示它占多少个 bit，也可以像 `unsigned int :2;` 这样定义一个未命名的 Bit-field，即使不写未命名的 Bit-field，编译器也有可能在两个成员之间插入填充位，如上图的 `five` 和 `six` 之间，这样 `six` 这个成员就刚好单独占一个字节了，访问效率会比较高，这个结构体的末尾还填充了 3 个字节，以便对齐到 4 字节边界。以前我们说过 x86 的 Byte Order 是小端的，从上图中 `one` 和 `two` 的排列顺序可以看出，如果对一个字节再细分，则字节中的 Bit Order 也是小端的，因为排在结构体前面的成员（靠近低地址一边的成员）取字节中的低位。关于如何排列 Bit-field 在 C 标准中没有详细的规定，这跟 Byte  Order、Bit  Order、对齐等问题都有关，不同的平台和编译器可能会排列得很不一样，要编写可移植的代码就不能假定 Bit-field 是按某一种固定方式排列的。Bit-field 在驱动程序中是很有用的，因为经常需要单独操作设备寄存器中的一个或几个 bit，但一定要小心使用，首先弄清楚每个 Bit-field 和实际 bit 的对应关系。

和前面几个例子不一样，在上例中我没有给出反汇编结果，直接画了个图说这个结构体的布局是这样的，那我有什么证据这么说呢？上例的反汇编结果比较繁琐，我们可以通过另一种手段得到这个结构体的内存布局。C 语言还有一种类型叫联合体，用关键字 `union` 定义，其语法类似于结构体，例如：

<p id="e19-5">例 19.5. 联合体</p>

```c
  #include <stdio.h>
  
  typedef union {
  	struct {
  		unsigned int one:1;
  		unsigned int two:3;
  		unsigned int three:10;
  		unsigned int four:5;
  		unsigned int :2;
  		unsigned int five:8;
  		unsigned int six:8;
  	} bitfield;
  	unsigned char byte[8];
  } demo_type;
  
  int main(void)
  {
  	demo_type u = {{ 1, 5, 513, 17, 129, 0x81 }};
  	printf("sizeof demo_type = %u\n", sizeof(demo_type));
  	printf("values: u=%u,%u,%u,%u,%u,%u\n",
  	       u.bitfield.one, u.bitfield.two, u.bitfield.three,
  	       u.bitfield.four, u.bitfield.five, u.bitfield.six);
  	printf("hex dump of u: %x %x %x %x %x %x %x %x \n",
  	       u.byte[0], u.byte[1], u.byte[2], u.byte[3],
  	       u.byte[4], u.byte[5], u.byte[6], u.byte[7]);
  
  	return 0;
  }
```

一个联合体的各个成员占用相同的内存空间，联合体的长度等于其中最长成员的长度。比如 `u` 这个联合体占 8 个字节，如果访问成员 `u.bitfield`，则把这 8 个字节看成一个由 Bit-field 组成的结构体，如果访问成员 `u.byte`，则把这 8 个字节看成一个数组。联合体如果用 Initializer 初始化，则只初始化它的第一个成员，例如 `demo_type u = {{ 1, 5, 513, 17, 129, 0x81 }};` 初始化的是 `u.bitfield`，但是通过 `u.bitfield` 的成员看不出这 8 个字节的内存布局，而通过 `u.byte` 数组就可以看出每个字节分别是多少了。

- 拓展
  - 编写一个程序，测试运行它的平台是大端还是小端字节序。

### 2.6.5. C 内联汇编

用 C 写程序比直接用汇编写程序更简洁，可读性更好，但效率可能不如汇编程序，因为 C 程序毕竟要经由编译器生成汇编代码，尽管现代编译器的优化已经做得很好了，但还是不如手写的汇编代码。另外，有些平台相关的指令必须手写，在 C 语言中没有等价的语法，因为 C 语言的语法和概念是对各种平台的抽象，而各种平台特有的一些东西就不会在 C 语言中出现了，例如 x86 是端口 I/O，而 C 语言就没有这个概念，所以 `in/out` 指令必须用汇编来写。

C 语言简洁易读，容易组织规模较大的代码，而汇编效率高，而且写一些特殊指令必须用汇编，为了把这两方面的好处都占全了，`gcc` 提供了一种扩展语法可以在 C 代码中使用内联汇编（Inline Assembly）。最简单的格式是 `__asm__("assembly code");`，例如 `__asm__("nop");` ，`nop` 这条指令什么都不做，只是让 CPU 空转一个指令执行周期。如果需要执行多条汇编指令，则应该用 `\n\t` 将各条指令分隔开，例如：

```asm6502
__asm__("movl $1, %eax\n\t"
	"movl $4, %ebx\n\t"
	"int $0x80");
```

通常 C 代码中的内联汇编需要和 C 的变量建立关联，需要用到完整的内联汇编格式：

```asm6502
__asm__(assembler template 
	: output operands                  /* optional */
	: input operands                   /* optional */
	: list of clobbered registers      /* optional */
	);
```

这种格式由四部分组成，第一部分是汇编指令，和上面的例子一样，第二部分和第三部分是约束条件，第二部分指示汇编指令的运算结果要输出到哪些 C 操作数中，C 操作数应该是左值表达式，第三部分指示汇编指令需要从哪些 C 操作数获得输入，第四部分是在汇编指令中被修改过的寄存器列表，指示编译器哪些寄存器的值在执行这条 `__asm__` 语句时会改变。后三个部分都是可选的，如果有就填写，没有就空着只写个 `:` 号。例如：

<p id="e19-6">例 19.6. 内联汇编</p>

```c
  #include <stdio.h>
  
  int main() 
  {
          int a = 10, b;
  
  	__asm__("movl %1, %%eax\n\t"
  		"movl %%eax, %0\n\t"
  		:"=r"(b)        /* output */
  		:"r"(a)         /* input */
  		:"%eax"         /* clobbered register */
  		);
  	printf("Result: %d, %d\n", a, b);
  	return 0;
  }
```

这个程序将变量 `a` 的值赋给 `b`。`"r"(a)` 指示编译器分配一个寄存器保存变量 `a` 的值，作为汇编指令的输入，也就是指令中的 `%1`（按照约束条件的顺序，`b` 对应 `%0`，`a` 对应 `1%`），至于 `%1` 究竟代表哪个寄存器则由编译器自己决定。汇编指令首先把 `%1` 所代表的寄存器的值传给 `eax`（为了和 `%1` 这种占位符区分，`eax` 前面要求加两个 `%` 号），然后把 `eax` 的值再传给 `%0` 所代表的寄存器。`"=r"(b)` 就表示把 `%0` 所代表的寄存器的值输出给变量 `b`。在执行这两条指令的过程中，寄存器 `eax` 的值被改变了，所以把 `"%eax"` 写在第四部分，告诉编译器在执行这条 `__asm__` 语句时 `eax` 要被改写，所以在此期间不要用 `eax` 保存其它值。

我们看一下这个程序的反汇编结果：

```bash
        __asm__("movl %1, %%eax\n\t"
 80483dc:       8b 55 f8                mov    -0x8(%ebp),%edx
 80483df:       89 d0                   mov    %edx,%eax
 80483e1:       89 c2                   mov    %eax,%edx
 80483e3:       89 55 f4                mov    %edx,-0xc(%ebp)
                "movl %%eax, %0\n\t"
                :"=r"(b)        /* output */
                :"r"(a)         /* input */
                :"%eax"         /* clobbered register */
                );
```

可见 `%0` 和 `%1` 都代表 `edx` 寄存器，首先把变量 `a`（位于 `ebp-8` 的位置）的值传给 `edx` 然后执行内联汇编的两条指令，然后把 `edx` 的值传给 `b`（位于 `ebp-12` 的位置）。

关于内联汇编就介绍这么多，本书不做深入讨论。

### 2.6.6. volatile 限定符

现在探讨一下编译器优化会对生成的指令产生什么影响，在此基础上介绍 C 语言的 `volatile` 限定符。看下面的例子。

<p id="e19-7">例 19.7. volatile 限定符</p>

```c
/* artificial device registers */
unsigned char recv;
unsigned char send;

/* memory buffer */
unsigned char buf[3];

int main(void)
{
	buf[0] = recv;
	buf[1] = recv;
	buf[2] = recv;
	send = ~buf[0];
	send = ~buf[1];
	send = ~buf[2];

	return 0;
}
```

我们用 `recv` 和 `send` 这两个全局变量来模拟设备寄存器。假设某种平台采用内存映射 I/O，串口发送寄存器和串口接收寄存器位于固定的内存地址，而 `recv` 和 `send` 这两个全局变量也有固定的内存地址，所以在这个例子中把它们假想成串口接收寄存器和串口发送寄存器。在 `main` 函数中，首先从串口接收三个字节存到 `buf` 中，然后把这三个字节取反，依次从串口发送出<sup>[31]</sup>。我们查看这段代码的反汇编结果：

> <sup>[31]</sup> 实际的串口设备通常有一些标志位指示是否有数据到达以及是否可以发送下一个字节的数据，通常要先查询这些标志位再做读写操作，在这个例子中我们抓主要矛盾，忽略这些细节。

```bash
        buf[0] = recv;
 80483a2:       0f b6 05 19 a0 04 08    movzbl 0x804a019,%eax
 80483a9:       a2 1a a0 04 08          mov    %al,0x804a01a
        buf[1] = recv;
 80483ae:       0f b6 05 19 a0 04 08    movzbl 0x804a019,%eax
 80483b5:       a2 1b a0 04 08          mov    %al,0x804a01b
        buf[2] = recv;
 80483ba:       0f b6 05 19 a0 04 08    movzbl 0x804a019,%eax
 80483c1:       a2 1c a0 04 08          mov    %al,0x804a01c
        send = ~buf[0];
 80483c6:       0f b6 05 1a a0 04 08    movzbl 0x804a01a,%eax
 80483cd:       f7 d0                   not    %eax
 80483cf:       a2 18 a0 04 08          mov    %al,0x804a018
        send = ~buf[1];
 80483d4:       0f b6 05 1b a0 04 08    movzbl 0x804a01b,%eax
 80483db:       f7 d0                   not    %eax
 80483dd:       a2 18 a0 04 08          mov    %al,0x804a018
        send = ~buf[2];
 80483e2:       0f b6 05 1c a0 04 08    movzbl 0x804a01c,%eax
 80483e9:       f7 d0                   not    %eax
 80483eb:       a2 18 a0 04 08          mov    %al,0x804a018
```

`movz` 指令把字长较短的值存到字长较长的存储单元中，存储单元的高位用 0 填充。该指令可以有 `b`（byte）、`w`（word）、`l`（long）三种后缀，分别表示单字节、两字节和四字节。比如 `movzbl 0x804a019,%eax` 表示把地址 0x804a019 处的一个字节存到 `eax` 寄存器中，而 `eax` 寄存器是四字节的，高三字节用 0 填充，而下一条指令 `mov    %al,0x804a01a` 中的 `al` 寄存器正是 `eax` 寄存器的低字节，把这个字节存到地址 0x804a01a 处的一个字节中。可以用不同的名字单独访问 x86 寄存器的低 8 位、次低 8 位、低 16 位或者完整的 32 位，以 `eax` 为例，`al` 表示低 8 位，`ah` 表示次低 8 位，`ax` 表示低 16 位，如下图所示。

<p id="c19-7">图 19.7. eax 寄存器</p>

![eax寄存器](./image/asmc.eax.png)

但如果指定优化选项 `-O` 编译，反汇编的结果就不一样了：

```bash
$ gcc main.c -g -O
$ objdump -dS a.out|less
...
        buf[0] = recv;
 80483ae:       0f b6 05 19 a0 04 08    movzbl 0x804a019,%eax
 80483b5:       a2 1a a0 04 08          mov    %al,0x804a01a
        buf[1] = recv;
 80483ba:       a2 1b a0 04 08          mov    %al,0x804a01b
        buf[2] = recv;
 80483bf:       a2 1c a0 04 08          mov    %al,0x804a01c
        send = ~buf[0];
        send = ~buf[1];
        send = ~buf[2];
 80483c4:       f7 d0                   not    %eax
 80483c6:       a2 18 a0 04 08          mov    %al,0x804a018
...
```

前三条语句从串口接收三个字节，而编译生成的指令显然不符合我们的意图：只有第一条语句从内存地址 0x804a019 读一个字节到寄存器 `eax` 中，然后从寄存器 `al` 保存到 `buf[0]`，后两条语句就不再从内存地址 0x804a019 读取，而是直接把寄存器 `al` 的值保存到 `buf[1]` 和 `buf[2]`。后三条语句把 `buf` 中的三个字节取反再发送到串口，编译生成的指令也不符合我们的意图：只有最后一条语句把 `eax` 的值取反写到内存地址 0x804a018 了，前两条语句形同虚设，根本不生成指令。

为什么编译器优化的结果会错呢？因为编译器并不知道 0x804a018 和 0x804a019 是设备寄存器的地址，把它们当成普通的内存单元了。如果是普通的内存单元，只要程序不去改写它，它就不会变，可以先把内存单元里的值读到寄存器缓存起来，以后每次用到这个值就直接从寄存器读取，这样效率更高，我们知道读寄存器远比读内存要快。另一方面，如果对一个普通的内存单元连续做三次写操作，只有最后一次的值会保存到内存单元中，所以前两次写操作是多余的，可以优化掉。访问设备寄存器的代码这样优化就错了，因为设备寄存器往往具有以下特性：

- 设备寄存器中的数据不需要改写就可以自己发生变化，每次读上来的值都可能不一样。
- 连续多次向设备寄存器中写数据并不是在做无用功，而是有特殊意义的。

用优化选项编译生成的指令明显效率更高，但使用不当会出错，为了避免编译器自作聪明，把不该优化的也优化了，程序员应该明确告诉编译器哪些内存单元的访问是不能优化的，在 C 语言中可以用 `volatile` 限定符修饰变量，就是告诉编译器，即使在编译时指定了优化选项，每次读这个变量仍然要老老实实从内存读取，每次写这个变量也仍然要老老实实写回内存，不能省略任何步骤。我们把代码的开头几行改成：

```c
/* artificial device registers */
volatile unsigned char recv;
volatile unsigned char send;
```

然后指定优化选项 `-O` 编译，查看反汇编的结果：

```bash
        buf[0] = recv;
 80483a2:       0f b6 05 19 a0 04 08    movzbl 0x804a019,%eax
 80483a9:       a2 1a a0 04 08          mov    %al,0x804a01a
        buf[1] = recv;
 80483ae:       0f b6 15 19 a0 04 08    movzbl 0x804a019,%edx
 80483b5:       88 15 1b a0 04 08       mov    %dl,0x804a01b
        buf[2] = recv;
 80483bb:       0f b6 0d 19 a0 04 08    movzbl 0x804a019,%ecx
 80483c2:       88 0d 1c a0 04 08       mov    %cl,0x804a01c
        send = ~buf[0];
 80483c8:       f7 d0                   not    %eax
 80483ca:       a2 18 a0 04 08          mov    %al,0x804a018
        send = ~buf[1];
 80483cf:       f7 d2                   not    %edx
 80483d1:       88 15 18 a0 04 08       mov    %dl,0x804a018
        send = ~buf[2];
 80483d7:       f7 d1                   not    %ecx
 80483d9:       88 0d 18 a0 04 08       mov    %cl,0x804a018
```

确实每次读 `recv` 都从内存地址 0x804a019 读取，每次写 `send` 也都写到内存地址 0x804a018 了。值得注意的是，每次写 `send` 并不需要取出 `buf` 中的值，而是取出先前缓存在寄存器 `eax`、`edx`、`ecx` 中的值，做取反运算然后写下去，这是因为 `buf` 并没有用 `volatile` 限定，读者可以试着在 `buf` 的定义前面也加上 `volatile`，再优化编译，再查看反汇编的结果。

`gcc` 的编译优化选项有 `-O0`、`-O`、`-O1`、`-O2`、`-O3`、`-Os` 几种。`-O0` 表示不优化，这是缺省的选项。`-O1`、`-O2` 和 `-O3` 这几个选项一个比一个优化得更多，编译时间也更长。`-O` 和 `-O1` 相同。`-Os` 表示为缩小目标文件的尺寸而优化。具体每种选项做了哪些优化请参考 `gcc(1)` 的 Man Page。

从上面的例子还可以看到，如果在编译时指定了优化选项，源代码和生成指令的次序可能无法对应，甚至有些源代码可能不对应任何指令，被彻底优化掉了。这一点在用 `gdb` 做源码级调试时尤其需要注意（做指令级调试没关系），在为调试而编译时不要指定优化选项，否则可能无法一步步跟踪源代码的执行过程。

有了 `volatile` 限定符，是可以防止编译器优化对设备寄存器的访问，但是对于有 Cache 的平台，仅仅这样还不够，还是无法防止 Cache 优化对设备寄存器的访问。在访问普通的内存单元时，Cache 对程序员是透明的，比如执行了 `movzbl 0x804a019,%eax` 这样一条指令，我们并不知道 `eax` 的值是真的从内存地址 0x804a019 读到的，还是从 Cache 中读到的，如果 Cache 已经缓存了这个地址的数据就从 Cache 读，如果 Cache 没有缓存就从内存读，这些步骤都是硬件自动做的，而不是用指令控制 Cache 去做的，程序员写的指令中只有寄存器、内存地址，而没有 Cache，程序员甚至不需要知道 Cache 的存在。同样道理，如果执行了 `mov    %al,0x804a01a` 这样一条指令，我们并不知道寄存器的值是真的写回内存了，还是只写到了 Cache 中，以后再由 Cache 写回内存，即使只写到了 Cache 中而暂时没有写回内存，下次读 0x804a01a 这个地址时仍然可以从 Cache 中读到上次写的数据。然而，在读写设备寄存器时 Cache 的存在就不容忽视了，如果串口发送和接收寄存器的内存地址被 Cache 缓存了会有什么问题呢？如下图所示。

<p id="c19-8">图 19.8. 串口发送和接收寄存器被 Cache 缓存会有什么问题</p>

![串口发送和接收寄存器被 Cache 缓存会有什么问题](./image/asmc.nocache.png)

如果串口发送寄存器的地址被 Cache 缓存，CPU 执行单元对串口发送寄存器做写操作都写到 Cache 中去了，串口发送寄存器并没有及时得到数据，也就不能及时发送，CPU 执行单元先后发出的 1、2、3 三个字节都会写到 Cache 中的同一个单元，最后 Cache 中只保存了第 3 个字节，如果这时 Cache 把数据写回到串口发送寄存器，只能把第 3 个字节发送出去，前两个字节就丢失了。与此类似，如果串口接收寄存器的地址被 Cache 缓存，CPU 执行单元在读第 1 个字节时，Cache 会从串口接收寄存器读上来缓存，然而串口接收寄存器后面收到的 2、3 两个字节 Cache 并不知道，因为 Cache 把串口接收寄存器当作普通内存单元，并且相信内存单元中的数据是不会自己变的，以后每次读串口接收寄存器时，Cache 都会把缓存的第 1 个字节提供给 CPU 执行单元。

通常，有 Cache 的平台都有办法对某一段地址范围禁用 Cache，一般是在页表中设置的，可以设定哪些页面允许 Cache 缓存，哪些页面不允许 Cache 缓存，MMU 不仅要做地址转换和访问权限检查，也要和 Cache 协同工作。

除了设备寄存器需要用 `volatile` 限定之外，当一个全局变量被同一进程中的多个控制流程访问时也要用 `volatile` 限定，比如信号处理函数和多线程。

## 2.7. 链接详解

### 2.7.1. 多目标文件的链接

现在我们把[第 12 章「栈与队列」例 12.1「用堆栈实现倒序打印」](1-C-语言入门/ch12-栈与队列#e12-1)拆成两个程序文件，`stack.c` 实现堆栈，而 `main.c` 使用堆栈：

```c
/* stack.c */
char stack[512];
int top = -1;

void push(char c)
{
	stack[++top] = c;
}

char pop(void)
{
	return stack[top--];
}

int is_empty(void)
{
	return top == -1;
}
```

这段程序和原来有点不同，在[第 12 章「栈与队列」例 12.1「用堆栈实现倒序打印」](1-C-语言入门/ch12-栈与队列#e12-1)中 `top` 总是指向栈顶元素的下一个元素，而在这段程序中 `top` 总是指向栈顶元素，所以要初始化成 `-1` 才表示空堆栈，这两种堆栈使用习惯都很常见。

```c
/* main.c */
#include <stdio.h>

int a, b = 1;

int main(void)
{
	push('a');
	push('b');
	push('c');
	
	while(!is_empty())
		putchar(pop());
	putchar('\n');

	return 0;
}
```

`a` 和 `b` 这两个变量没有用，只是为了顺便说明链接过程才加上的。编译的步骤和以前一样，可以一步编译：

```bash
$ gcc main.c stack.c -o main
```

也分可以多步编译：

```bash
$ gcc -c main.c
$ gcc -c stack.c
$ gcc main.o stack.o -o main
```

如果按照[上章第 2 节「main 函数和启动例程」](2-C-语言本质/ch19-汇编与-C-之间的关系#_2-main-函数和启动例程)的做法，用 `nm` 命令查看目标文件的符号表，会发现 `main.o` 中有未定义的符号 `push`、`pop`、`is_empty`、`putchar`，前三个符号在 `stack.o` 中实现了，链接生成可执行文件 `main` 时可以做符号解析，而 `putchar` 是 `libc` 的库函数，在可执行文件 `main` 中仍然是未定义的，要在程序运行时做动态链接。

我们通过 `readelf -a main` 命令可以看到，`main` 的 `.bss` 段合并了 `main.o` 和 `stack.o` 的 `.bss` 段，其中包含了变量 `a` 和 `stack`，`main` 的 `.data` 段也合并了 `main.o` 和 `stack.o` 的 `.data` 段，其中包含了变量 `b` 和 `top`，`main` 的 `.text` 段合并了 `main.o` 和 `stack.o` 的 `.text` 段，包含了各函数的定义。如下图所示。

<p id="c20-1">图 20.1. 多目标文件的链接</p>

![多目标文件的链接](./image/link.multiobj.png)

为什么在可执行文件 `main` 的每个段中来自 `main.o` 的变量或函数都在前面，而来自 `stack.o` 的变量或函数都在后面呢？我们可以试试把 `gcc` 命令中的两个目标文件反过来写：

```bash
$ gcc stack.o main.o -o main
```

结果正如我们所预料的，可执行文件 `main` 的每个段中来自 `main.o` 的变量或函数都排到后面了。实际上链接的过程是由一个链接脚本（Linker Script）控制的，链接脚本决定了给每个段分配什么地址，如何对齐，哪个段在前，哪个段在后，哪些段合并到同一个 Segment，另外链接脚本还要插入一些符号到最终生成的文件中，例如 `__bss_start`、`_edata`、`_end` 等。如果用 `ld` 做链接时没有用 `-T` 选项指定链接脚本，则使用 `ld` 的默认链接脚本，默认链接脚本可以用 `ld --verbose` 命令查看（由于比较长，只列出一些片断）：

```bash
$ ld --verbose
...
using internal linker script:
==================================================
/* Script for -z combreloc: combine and sort reloc sections */
OUTPUT_FORMAT("elf32-i386", "elf32-i386",
	      "elf32-i386")
OUTPUT_ARCH(i386)
ENTRY(_start)
...
SECTIONS
{
  /* Read-only sections, merged into text segment: */
  PROVIDE (__executable_start = 0x08048000); . = 0x08048000 + SIZEOF_HEADERS;
  .interp         : { *(.interp) }
  .note.gnu.build-id : { *(.note.gnu.build-id) }
  .hash           : { *(.hash) }
  .gnu.hash       : { *(.gnu.hash) }
  .dynsym         : { *(.dynsym) }
  .dynstr         : { *(.dynstr) }
  .gnu.version    : { *(.gnu.version) }
  .gnu.version_d  : { *(.gnu.version_d) }
  .gnu.version_r  : { *(.gnu.version_r) }
  .rel.dyn        :
...
  .rel.plt        : { *(.rel.plt) }
...
  .init           :
...
  .plt            : { *(.plt) }
  .text           :
...
  .fini           :
...
  .rodata         : { *(.rodata .rodata.* .gnu.linkonce.r.*) }
...
  .eh_frame       : ONLY_IF_RO { KEEP (*(.eh_frame)) }
...
  /* Adjust the address for the data segment.  We want to adjust up to
     the same address within the page on the next page up.  */
  . = ALIGN (CONSTANT (MAXPAGESIZE)) - ((CONSTANT (MAXPAGESIZE) - .) & (CONSTANT (MAXPAGESIZE) - 1)); . = DATA_SEGMENT_ALIGN (CONSTANT (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));
...
  .ctors          :
...
  .dtors          :
...
  .jcr            : { KEEP (*(.jcr)) }
...
  .dynamic        : { *(.dynamic) }
  .got            : { *(.got) }
...
  .got.plt        : { *(.got.plt) }
  .data           :
...
  _edata = .; PROVIDE (edata = .);
  __bss_start = .;
  .bss            :
...
  _end = .; PROVIDE (end = .);
  . = DATA_SEGMENT_END (.);
  /* Stabs debugging sections.  */
...
  /* DWARF debug sections.
     Symbols in the DWARF debugging sections are relative to the beginning
     of the section so we begin them at 0.  */
...
}


==================================================
```

`ENTRY(_start)` 说明 `_start` 是整个程序的入口点，因此 `_start` 是入口点并不是规定死的，是可以改用其它函数做入口点的。

`PROVIDE (__executable_start = 0x08048000); . = 0x08048000 + SIZEOF_HEADERS;` 是 Text Segment 的起始地址，这个 Segment 包含后面列出的那些段，`.plt`、`.text`、`.rodata` 等等。每个段的描述格式都是「段名 : { 组成 }」，例如 `.plt : { *(.plt) }`，左边表示最终生成的文件的 `.plt` 段，右边表示所有目标文件的 `.plt` 段，意思是最终生成的文件的 `.plt` 段由各目标文件的 `.plt` 段组成。

`.  = ALIGN (CONSTANT (MAXPAGESIZE)) - ((CONSTANT (MAXPAGESIZE) - .) &  (CONSTANT (MAXPAGESIZE) - 1)); . = DATA_SEGMENT_ALIGN (CONSTANT  (MAXPAGESIZE), CONSTANT (COMMONPAGESIZE));` 是 Data Segment 的起始地址，要做一系列的对齐操作，这个 Segment 包含后面列出的那些段，`.got`、`.data`、`.bss`等等。

Data Segment 的后面还有其它一些 Segment，主要是调试信息。关于链接脚本就介绍这么多，本书不做深入讨论。

### 2.7.2. 定义和声明

#### 2.7.2.1. extern 和 static 关键字

在上一节我们把两个程序文件放在一起编译链接，`main.c` 用到的函数 `push`、`pop` 和 `is_empty` 由 `stack.c` 提供，其实有一点小问题，我们用 `-Wall` 选项编译 `main.c` 可以看到：

```bash
$ gcc -c main.c -Wall
main.c: In function ‘main’:
main.c:8: warning: implicit declaration of function ‘push’
main.c:12: warning: implicit declaration of function ‘is_empty’
main.c:13: warning: implicit declaration of function ‘pop’
```

这个问题我们在[第 3 章「简单函数」第 2 节「自定义函数」](1-C-语言入门/ch03-简单函数#_2-自定义函数)讨论过，由于编译器在处理函数调用代码时没有找到函数原型，只好根据函数调用代码做隐式声明，把这三个函数声明为：

```c
int push(char);
int pop(void);
int is_empty(void);
```

现在你应该比学[第 3 章「简单函数」第 2 节「自定义函数」](1-C-语言入门/ch03-简单函数#_2-自定义函数)的时候更容易理解这条规则了。为什么编译器在处理函数调用代码时需要有函数原型？因为必须知道参数的类型和个数以及返回值的类型才知道生成什么样的指令。为什么隐式声明靠不住呢？因为隐式声明是从函数调用代码推导而来的，而事实上函数定义的形参类型可能跟函数调用代码传的实参类型并不一致，如果函数定义带有可变参数（例如 `printf`），那么从函数调用代码也看不出来这个函数带有可变参数，另外，从函数调用代码也看不出来返回值应该是什么类型，所以隐式声明只能规定返回值都是 int 型的。既然隐式声明靠不住，那编译器为什么不自己去找函数定义，而非要让我们在调用之前写函数原型呢？因为编译器往往不知道去哪里找函数定义，像上面的例子，我让编译器编译 `main.c`，而这几个函数的定义却在 `stack.c` 里，编译器又怎么会知道呢？所以编译器只能通过隐式声明来猜测函数原型，这种猜测往往会出错，但在比较简单的情况下还算可用，比如上一节的例子这么编译过去了也能得到正确结果。

现在我们在 `main.c` 中声明这几个函数的原型：

```c
/* main.c */
#include <stdio.h>

extern void push(char);
extern char pop(void);
extern int is_empty(void);

int main(void)
{
	push('a');
	push('b');
	push('c');
	
	while(!is_empty())
		putchar(pop());
	putchar('\n');

	return 0;
}
```

这样编译器就不会报警告了。在这里 `extern` 关键字表示这个标识符具有 External Linkage。External Linkage 的定义在上一章讲过，但现在应该更容易理解了，`push` 这个标识符具有 External Linkage 指的是：如果把 `main.c` 和 `stack.c` 链接在一起，如果 `push` 在 `main.c` 和 `stack.c` 中都有声明（在 `stack.c` 中的声明同时也是定义），那么这些声明指的是同一个函数，链接之后是同一个 `GLOBAL` 符号，代表同一个地址。函数声明中的 `extern` 也可以省略不写，不写 `extern` 的函数声明也表示这个函数具有 External Linkage。

如果用 `static` 关键字修饰一个函数声明，则表示该标识符具有 Internal Linkage，例如有以下两个程序文件：

```c
/* foo.c */
static void foo(void) {}
/* main.c */
void foo(void);
int main(void) { foo(); return 0; }
```

编译链接在一起会出错：

```bash
$ gcc foo.c main.c
/tmp/ccRC2Yjn.o: In function `main':
main.c:(.text+0x12): undefined reference to `foo'
collect2: ld returned 1 exit status
```

虽然在 `foo.c` 中定义了函数 `foo`，但这个函数只具有 Internal Linkage，只有在 `foo.c` 中多次声明才表示同一个函数，而在 `main.c` 中声明就不表示它了。如果把 `foo.c` 编译成目标文件，函数名 `foo` 在其中是一个 `LOCAL` 的符号，不参与链接过程，所以在链接时，`main.c` 中用到一个 External Linkage 的 `foo` 函数，链接器却找不到它的定义在哪儿，无法确定它的地址，也就无法做符号解析，只好报错。**凡是被多次声明的变量或函数，必须有且只有一个声明是定义，如果有多个定义，或者一个定义都没有，链接器就无法完成链接**。

以上讲了用 `static` 和 `extern` 修饰函数声明的情况。现在来看用它们修饰变量声明的情况。仍然用 `stack.c` 和 `main.c` 的例子，如果我想在 `main.c` 中直接访问 `stack.c` 中定义的变量 `top`，则可以用 `extern` 声明它：

```c
/* main.c */
#include <stdio.h>

void push(char);
char pop(void);
int is_empty(void);
extern int top;

int main(void)
{
	push('a');
	push('b');
	push('c');
	printf("%d\n", top);
	
	while(!is_empty())
		putchar(pop());
	putchar('\n');
	printf("%d\n", top);

	return 0;
}
```

变量 `top` 具有 External Linkage，它的存储空间是在 `stack.c` 中分配的，所以 `main.c` 中的变量声明 `extern int top;` 不是变量定义，因为它不分配存储空间。以上函数和变量声明也可以写在 `main` 函数体里面，使所声明的标识符具有块作用域：

```c
int main(void)
{
	void push(char);
	char pop(void);
	int is_empty(void);
	extern int top;

	push('a');
	push('b');
	push('c');
	printf("%d\n", top);
	
	while(!is_empty())
		putchar(pop());
	putchar('\n');
	printf("%d\n", top);

	return 0;
}
```

注意，变量声明和函数声明有一点不同，函数声明的 `extern` 可写可不写，而变量声明如果不写 `extern` 意思就完全变了，如果上面的例子不写 `extern` 就表示在 `main` 函数中定义一个局部变量 `top`。另外要注意，`stack.c` 中的定义是 `int top = -1;`，而 `main.c` 中的声明不能加 Initializer，如果上面的例子写成 `extern int top = -1;` 则编译器会报错。

在 `main.c` 中可以通过变量声明来访问 `stack.c` 中的变量 `top`，但是从实现 `stack.c` 这个模块的角度来看，`top` 这个变量是不希望被外界访问到的，变量 `top` 和 `stack` 都属于这个模块的内部状态，外界应该只允许通过 `push` 和 `pop` 函数来改变模块的内部状态，这样才能保证堆栈的 LIFO 特性，如果外界可以随机访问 `stack` 或者随便修改 `top`，那么堆栈的状态就乱了。那怎么才能阻止外界访问 `top` 和 `stack` 呢？答案就是用 `static` 关键字把它们声明为 Internal Linkage 的：

```c
/* stack.c */
static char stack[512];
static int top = -1;

void push(char c)
{
	stack[++top] = c;
}

char pop(void)
{
	return stack[top--];
}

int is_empty(void)
{
	return top == -1;
}
```

这样，即使在 `main.c` 中用 `extern` 声明也访问不到 `stack.c` 的变量 `top` 和 `stack`。从而保护了 `stack.c` 模块的内部状态，这也是一种封装（Encapsulation）的思想。

用 `static` 关键字声明具有 Internal Linkage 的函数也是出于这个目的。在一个模块中，有些函数是提供给外界使用的，也称为导出（Export）给外界使用，这些函数声明为 External Linkage 的。有些函数只在模块内部使用而不希望被外界访问到，则声明为 Internal Linkage 的。

#### 2.7.2.2. 头文件

我们继续前面关于 `stack.c` 和 `main.c` 的讨论。`stack.c` 这个模块封装了 `top` 和 `stack` 两个变量，导出了 `push`、`pop`、`is_empty` 三个函数接口，已经设计得比较完善了。但是使用这个模块的每个程序文件都要写三个函数声明也是很麻烦的，假设又有一个 `foo.c`也使用这个模块，`main.c` 和 `foo.c` 中各自要写三个函数声明。重复的代码总是应该尽量避免的，以前我们通过各种办法把重复的代码提取出来，比如在[第 8 章「数组」第 2 节「数组应用实例：统计随机数」](1-C-语言入门/ch08-数组#_2-数组应用实例：统计随机数)讲过用宏定义避免硬编码的问题，这次有什么办法呢？答案就是可以自己写一个头文件 `stack.h`：

```c
/* stack.h */
#ifndef STACK_H
#define STACK_H
extern void push(char);
extern char pop(void);
extern int is_empty(void);
#endif
```

这样在 `main.c` 中只需包含这个头文件就可以了，而不需要写三个函数声明：

```c
/* main.c */
#include <stdio.h>
#include "stack.h"

int main(void)
{
	push('a');
	push('b');
	push('c');
	
	while(!is_empty())
		putchar(pop());
	putchar('\n');

	return 0;
}
```

首先说为什么 `#include <stdio.h>` 用角括号，而 `#include "stack.h"` 用引号。对于用角括号包含的头文件，`gcc` 首先查找 `-I` 选项指定的目录，然后查找系统的头文件目录（通常是 `/usr/include`，在我的系统上还包括 `/usr/lib/gcc/i486-linux-gnu/4.3.2/include`）；而对于用引号包含的头文件，`gcc` 首先查找包含头文件的 `.c` 文件所在的目录，然后查找 `-I` 选项指定的目录，然后查找系统的头文件目录。

假如三个代码文件都放在当前目录下：

```bash
$ tree
.
|-- main.c
|-- stack.c
`-- stack.h

0 directories, 3 files
```

则可以用 `gcc -c main.c` 编译，`gcc` 会自动在 `main.c` 所在的目录中找到 `stack.h`。假如把 `stack.h` 移到一个子目录下：

```bash
$ tree
.
|-- main.c
`-- stack
    |-- stack.c
    `-- stack.h

1 directory, 3 files
```

则需要用 `gcc -c main.c -Istack` 编译。用 `-I` 选项告诉 `gcc` 头文件要到子目录 `stack` 里找。

在 `#include` 预处理指示中可以使用相对路径，例如把上面的代码改成 `#include "stack/stack.h"`，那么编译时就不需要加 `-Istack` 选项了，因为 `gcc` 会自动在 `main.c` 所在的目录中查找，而头文件相对于 `main.c` 所在目录的相对路径正是 `stack/stack.h`。

在 `stack.h` 中我们又看到两个新的预处理指示 `#ifndef STACK_H` 和 `#endif`，意思是说，如果 `STACK_H` 这个宏没有定义过，那么从 `#ifndef` 到 `#endif` 之间的代码就包含在预处理的输出结果中，否则这一段代码就不出现在预处理的输出结果中。`stack.h` 这个头文件的内容整个被 `#ifndef` 和 `#endif` 括起来了，如果在包含这个头文件时 `STACK_H` 这个宏已经定义过了，则相当于这个头文件里什么都没有，包含了一个空文件。这有什么用呢？假如 `main.c` 包含了两次 `stack.h`：

```c
...
#include "stack.h"
#include "stack.h"

int main(void)
{
...
```

则第一次包含 `stack.h` 时并没有定义 `STACK_H` 这个宏，因此头文件的内容包含在预处理的输出结果中：

```c
...
#define STACK_H
extern void push(char);
extern char pop(void);
extern int is_empty(void);
#include "stack.h"

int main(void)
{
...
```

其中已经定义了 `STACK_H` 这个宏，因此第二次再包含 `stack.h` 就相当于包含了一个空文件，这就避免了头文件的内容被重复包含。这种保护头文件的写法称为 Header Guard，以后我们每写一个头文件都要加上 Header Guard，宏定义名就用头文件名的大写形式，这是规范的做法。

那为什么需要防止重复包含呢？谁会把一个头文件包含两次呢？像上面那么明显的错误没人会犯，但有时候重复包含的错误并不是那么明显的。比如：

```c
#include "stack.h"
#include "foo.h"
```

然而 `foo.h` 里又包含了 `bar.h`，`bar.h` 里又包含了 `stack.h`。在规模较大的项目中头文件包含头文件的情况很常见，经常会包含四五层，这时候重复包含的问题就很难发现了。比如在我的系统头文件目录 `/usr/include` 中，`errno.h` 包含了 `bits/errno.h`，后者又包含了 `linux/errno.h`，后者又包含了 `asm/errno.h`，后者又包含了 `asm-generic/errno.h`。

另外一个问题是，就算我是重复包含了头文件，那有什么危害么？像上面的三个函数声明，在程序中声明两次也没有问题，对于具有 External Linkage 的函数，声明任意多次也都代表同一个函数。重复包含头文件有以下问题：

1. 一是使预处理的速度变慢了，要处理很多本来不需要处理的头文件。
2. 二是如果有 `foo.h` 包含 `bar.h`，`bar.h` 又包含 `foo.h` 的情况，预处理器就陷入死循环了（其实编译器都会规定一个包含层数的上限）。
3. 三是头文件里有些代码不允许重复出现，虽然变量和函数允许多次声明（只要不是多次定义就行），但头文件里有些代码是不允许多次出现的，比如 `typedef` 类型定义和结构体 Tag 定义等，在一个程序文件中只允许出现一次。

还有一个问题，既然要 `#include` 头文件，那我不如直接在 `main.c` 中 `#include "stack.c"` 得了。这样把 `stack.c` 和 `main.c` 合并为同一个程序文件，相当于又回到最初的[第 12 章「栈与队列」例 12.1「用堆栈实现倒序打印」](1-C-语言入门/ch12-栈与队列#e12-1)了。当然这样也能编译通过，但是在一个规模较大的项目中不能这么做，假如又有一个 `foo.c` 也要使用 `stack.c` 这个模块怎么办呢？如果在 `foo.c` 里面也 `#include "stack.c"`，就相当于 `push`、`pop`、`is_empty` 这三个函数在 `main.c` 和 `foo.c` 中都有定义，那么 `main.c` 和 `foo.c` 就不能链接在一起了。如果采用包含头文件的办法，那么这三个函数只在 `stack.c` 中定义了一次，最后可以把 `main.c`、`stack.c`、`foo.c` 链接在一起。如下图所示：

<p id="c20-2">图 20.2. 为什么要包含头文件而不是 .c 文件</p>

![为什么要包含头文件而不是.c文件](./image/link.includeh.png)

同样道理，头文件中的变量和函数声明一定不能是定义。如果头文件中出现变量或函数定义，这个头文件又被多个 `.c` 文件包含，那么这些 `.c` 文件就不能链接在一起了。

#### 2.7.2.3. 定义和声明的详细规则

以上两节关于定义和声明只介绍了最基本的规则，在写代码时掌握这些基本规则就够用了，但其实C语言关于定义和声明还有很多复杂的规则，在分析错误原因或者维护规模较大的项目时需要了解这些规则。本节的两个表格出自 *Standard C*。

首先看关于函数声明的规则。

<p id="t20-1">表 20.1. Storage Class 关键字对函数声明的作用</p>

| Storage Class | File Scope Declaration       | Block Scope Declaration         |
| ------------- | ---------------------------- | ------------------------------- |
| none          | previous linkage  can define | previous linkage  cannot define |
| extern        | previous linkage  can define | previous linkage  cannot define |
| static        | internal linkage  can define | N/A                             |

以前我们说「`extern` 关键字表示这个标识符具有 External Linkage」其实是不准确的，准确地说应该是 Previous  Linkage。Previous Linkage 的定义是：这次声明的标识符具有什么样的 Linkage 取决于前一次声明，这前一次声明具有相同的标识符名，而且必须是文件作用域的声明，如果在程序文件中找不到前一次声明（这次声明是第一次声明），那么这个标识符具有 External Linkage。例如在一个程序文件中在文件作用域两次声明同一个函数：

```c
static int f(void); /* internal linkage */
extern int f(void); /* previous linkage */
```

则这里的 `extern` 修饰的标识符具有 Interanl Linkage 而不是 External Linkage。从上表的前两行可以总结出我们先前所说的规则「函数声明加不加 `extern` 关键字都一样」。上表也说明了在文件作用域允许定义函数，在块作用域不允许定义函数，或者说函数定义不能嵌套。另外，在块作用域中不允许用 `static` 关键字声明函数。

关于变量声明的规则要复杂一些：

<p id="t20-2">表 20.2. Storage Class关键字对变量声明的作用</p>

| Storage Class | File Scope Declaration                                       | Block Scope Declaration                                      |
| ------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| none          | external linkage  static duration  static initializer  tentative definition | no linkage  automatic duration  dynamic initializer  definition |
| extern        | previous linkage  static duration  no initializer[*]  not a definition | previous linkage  static duration  no initializer  not a definition |
| static        | internal linkage  static duration  static initializer  tentative definition | no linkage  static duration  static initializer  definition  |

上表的每个单元格里分成四行，分别描述变量的链接属性、生存期，以及这种变量如何初始化，是否算变量定义。链接属性有 External  Linkage、Internal Linkage、No Linkage 和 Previous Linkage 四种情况，生存期有 Static  Duration 和 Automatic Duration 两种情况，请参考本章和上一章的定义。初始化有 Static  Initializer 和 Dynamic  Initializer 两种情况，前者表示 Initializer 中只能使用常量表达式，表达式的值必须在编译时就能确定，后者表示 Initializer 中可以使用任意的右值表达式，表达式的值可以在运行时计算。是否算变量定义有三种情况，Definition（算变量定义）、Not  a Definition（不算变量定义）和 Tentative Definition（暂定的变量定义）。什么叫「暂定的变量定义」呢？一个变量声明具有文件作用域，没有 Storage Class 关键字修饰，或者用 `static` 关键字修饰，那么如果它有 Initializer 则编译器认为它就是一个变量定义，如果它没有 Initializer 则编译器暂定它是变量定义，如果程序文件中有这个变量的明确定义就用明确定义，如果程序文件没有这个变量的明确定义，就用这个暂定的变量定义<sup>[32]</sup>，这种情况下变量以 0 初始化。在 *C99* 中有一个例子：

```c
int i1 = 1; // definition, external linkage
static int i2 = 2; // definition, internal linkage
extern int i3 = 3; // definition, external linkage
int i4; // tentative definition, external linkage
static int i5; // tentative definition, internal linkage
int i1; // valid tentative definition, refers to previous
int i2; // 6.2.2 renders undefined, linkage disagreement
int i3; // valid tentative definition, refers to previous
int i4; // valid tentative definition, refers to previous
int i5; // 6.2.2 renders undefined, linkage disagreement
extern int i1; // refers to previous, whose linkage is external
extern int i2; // refers to previous, whose linkage is internal
extern int i3; // refers to previous, whose linkage is external
extern int i4; // refers to previous, whose linkage is external
extern int i5; // refers to previous, whose linkage is internal
```

变量 `i2` 和 `i5` 第一次声明为 Internal Linkage，第二次又声明为 External Linkage，这是不允许的，编译器会报错。注意上表中标有 `[*]` 的单元格，对于文件作用域的 `extern` 变量声明，C99 是允许带 Initializer 的，并且认为它是一个定义，但是 `gcc` 对于这种写法会报警告，为了兼容性应避免这种写法。

> <sup>[32]</sup> 由于本书没有提及将不完全类型进行组合的问题，所以这条规则被我简化了，真正的规则还要复杂一些。读者可以参考 C99 中有关 Incomplete Type 和 Composite Type 的条款。Tentative Definition 的完整定义在 C99 的 6.9.2 节条款 2。

### 2.7.3. 静态库

有时候需要把一组代码编译成一个库，这个库在很多项目中都要用到，例如 `libc` 就是这样一个库，我们在不同的程序中都会用到 `libc` 中的库函数（例如 `printf`），也会用到 `libc` 中的变量（例如以后要讲到的 `environ` 变量）。本节介绍怎么创建这样一个库。

我们继续用 `stack.c` 的例子。为了便于理解，我们把 `stack.c` 拆成四个程序文件（虽然实际上没太大必要），把 `main.c` 改得简单一些，头文件 `stack.h` 不变，本节用到的代码如下所示：

```c
/* stack.c */
char stack[512];
int top = -1;
/* push.c */
extern char stack[512];
extern int top;

void push(char c)
{
	stack[++top] = c;
}
/* pop.c */
extern char stack[512];
extern int top;

char pop(void)
{
	return stack[top--];
}
/* is_empty.c */
extern int top;

int is_empty(void)
{
	return top == -1;
}
/* stack.h */
#ifndef STACK_H
#define STACK_H
extern void push(char);
extern char pop(void);
extern int is_empty(void);
#endif
/* main.c */
#include <stdio.h>
#include "stack.h"

int main(void)
{
	push('a');
	return 0;
}
```

这些文件的目录结构是：

```bash
$ tree
.
|-- main.c
`-- stack
    |-- is_empty.c
    |-- pop.c
    |-- push.c
    |-- stack.c
    `-- stack.h

1 directory, 6 files
```

我们把 `stack.c`、`push.c`、`pop.c`、`is_empty.c` 编译成目标文件：

```bash
$ gcc -c stack/stack.c stack/push.c stack/pop.c stack/is_empty.c
```

然后打包成一个静态库 `libstack.a`：

```bash
$ ar rs libstack.a stack.o push.o pop.o is_empty.o
ar: creating libstack.a
```

库文件名都是以 `lib` 开头的，静态库以 `.a` 作为后缀，表示 Archive。`ar` 命令类似于 `tar` 命令，起一个打包的作用，但是把目标文件打包成静态库只能用 `ar` 命令而不能用 `tar` 命令。选项 `r` 表示将后面的文件列表添加到文件包，如果文件包不存在就创建它，如果文件包中已有同名文件就替换成新的。`s` 是专用于生成静态库的，表示为静态库创建索引，这个索引被链接器使用。`ranlib` 命令也可以为静态库创建索引，以上命令等价于：

```bash
$ ar r libstack.a stack.o push.o pop.o is_empty.o
$ ranlib libstack.a
```

然后我们把 `libstack.a` 和 `main.c` 编译链接在一起：

```bash
$ gcc main.c -L. -lstack -Istack -o main
```

`-L` 选项告诉编译器去哪里找需要的库文件，`-L.` 表示在当前目录找。`-lstack` 告诉编译器要链接 `libstack` 库，`-I` 选项告诉编译器去哪里找头文件。注意，即使库文件就在当前目录，编译器默认也不会去找的，所以 `-L.` 选项不能少。编译器默认会找的目录可以用 `-print-search-dirs` 选项查看：

```bash
$ gcc -print-search-dirs
install: /usr/lib/gcc/i486-linux-gnu/4.3.2/
programs: =/usr/lib/gcc/i486-linux-gnu/4.3.2/:/usr/lib/gcc/i486-linux-gnu/4.3.2/:/usr/lib/gcc/i486-linux-gnu/:/usr/lib/gcc/i486-linux-gnu/4.3.2/:/usr/lib/gcc/i486-linux-gnu/:/usr/libexec/gcc/i486-linux-gnu/4.3.2/:/usr/libexec/gcc/i486-linux-gnu/:/usr/lib/gcc/i486-linux-gnu/4.3.2/:/usr/lib/gcc/i486-linux-gnu/:/usr/lib/gcc/i486-linux-gnu/4.3.2/../../../../i486-linux-gnu/bin/i486-linux-gnu/4.3.2/:/usr/lib/gcc/i486-linux-gnu/4.3.2/../../../../i486-linux-gnu/bin/
libraries: =/usr/lib/gcc/i486-linux-gnu/4.3.2/:/usr/lib/gcc/i486-linux-gnu/4.3.2/:/usr/lib/gcc/i486-linux-gnu/4.3.2/../../../../i486-linux-gnu/lib/i486-linux-gnu/4.3.2/:/usr/lib/gcc/i486-linux-gnu/4.3.2/../../../../i486-linux-gnu/lib/../lib/:/usr/lib/gcc/i486-linux-gnu/4.3.2/../../../i486-linux-gnu/4.3.2/:/usr/lib/gcc/i486-linux-gnu/4.3.2/../../../../lib/:/lib/i486-linux-gnu/4.3.2/:/lib/../lib/:/usr/lib/i486-linux-gnu/4.3.2/:/usr/lib/../lib/:/usr/lib/gcc/i486-linux-gnu/4.3.2/../../../../i486-linux-gnu/lib/:/usr/lib/gcc/i486-linux-gnu/4.3.2/../../../:/lib/:/usr/lib/
```

其中的 `libraries` 就是库文件的搜索路径列表，各路径之间用 `:` 号隔开。编译器会在这些搜索路径以及 `-L` 选项指定的路径中查找用 `-l` 选项指定的库，比如 `-lstack`，编译器会首先找有没有共享库 `libstack.so`，如果有就链接它，如果没有就找有没有静态库 `libstack.a`，如果有就链接它。所以编译器是优先考虑共享库的，如果希望编译器只链接静态库，可以指定 `-static` 选项。

那么链接共享库和链接静态库有什么区别呢？在[上章第 2 节「main 函数和启动例程」](2-C-语言本质/ch19-汇编与-C-之间的关系#_2-main-函数和启动例程)讲过，在链接 `libc` 共享库时只是指定了动态链接器和该程序所需要的库文件，并没有真的做链接，可执行文件 `main` 中调用的 `libc` 库函数仍然是未定义符号，要在运行时做动态链接。而在链接静态库时，链接器会把静态库中的目标文件取出来和可执行文件真正链接在一起。我们通过反汇编看上一步生成的可执行文件 `main`：

```bash
$ objdump -d main
...
08048394 <main>:
 8048394:       8d 4c 24 04             lea    0x4(%esp),%ecx
 8048398:       83 e4 f0                and    $0xfffffff0,%esp
 804839b:       ff 71 fc                pushl  -0x4(%ecx)
...
080483c0 <push>:
 80483c0:       55                      push   %ebp
 80483c1:       89 e5                   mov    %esp,%ebp
 80483c3:       83 ec 04                sub    $0x4,%esp
```

有意思的是，`main.c` 只调用了 `push` 这一个函数，所以链接生成的可执行文件中也只有 `push` 而没有 `pop` 和 `is_empty`。这是使用静态库的一个好处，链接器可以从静态库中只取出需要的部分来做链接。如果是直接把那些目标文件和 `main.c` 编译链接在一起：

```bash
$ gcc main.c stack.o push.o pop.o is_empty.o -Istack -o main
```

则没有用到的函数也会链接进来。当然另一个好处就是使用静态库只需写一个库文件名，而不需要写一长串目标文件名。

### 2.7.4. 共享库

#### 2.7.4.1. 编译、链接、运行

组成共享库的目标文件和一般的目标文件有所不同，在编译时要加 `-fPIC` 选项，例如：

```bash
$ gcc -c -fPIC stack/stack.c stack/push.c stack/pop.c stack/is_empty.c
```

`-f` 后面跟一些编译选项，`PIC` 是其中一种，表示生成位置无关代码（Position Independent Code）。那么用 `-fPIC` 生成的目标文件和一般的目标文件有什么不同呢？下面分析这个问题。

我们知道一般的目标文件称为 Relocatable，在链接时可以把目标文件中各段的地址做重定位，重定位时需要修改指令。我们先不加 `-fPIC` 选项编译生成目标文件：

```bash
$ gcc -c -g stack/stack.c stack/push.c stack/pop.c stack/is_empty.c
```

由于接下来要用 `objdump -dS` 把反汇编指令和源代码穿插起来分析，所以用 `-g` 选项加调试信息。注意，加调试信息必须在编译每个目标文件时用 `-g` 选项，而不能只在最后编译生成可执行文件时用 `-g` 选项。反汇编查看 `push.o`：

```bash
$ objdump -dS push.o 

push.o:     file format elf32-i386


Disassembly of section .text:

00000000 <push>:
/* push.c */
extern char stack[512];
extern int top;

void push(char c)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	83 ec 04             	sub    $0x4,%esp
   6:	8b 45 08             	mov    0x8(%ebp),%eax
   9:	88 45 fc             	mov    %al,-0x4(%ebp)
	stack[++top] = c;
   c:	a1 00 00 00 00       	mov    0x0,%eax
  11:	83 c0 01             	add    $0x1,%eax
  14:	a3 00 00 00 00       	mov    %eax,0x0
  19:	8b 15 00 00 00 00    	mov    0x0,%edx
  1f:	0f b6 45 fc          	movzbl -0x4(%ebp),%eax
  23:	88 82 00 00 00 00    	mov    %al,0x0(%edx)
}
  29:	c9                   	leave  
  2a:	c3                   	ret
```

指令中凡是用到 `stack` 和 `top` 的地址都用 0x0 表示，准备在重定位时修改。再看 `readelf` 输出的 `.rel.text` 段的信息：

```bash
Relocation section '.rel.text' at offset 0x848 contains 4 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
0000000d  00001001 R_386_32          00000000   top
00000015  00001001 R_386_32          00000000   top
0000001b  00001001 R_386_32          00000000   top
00000025  00001101 R_386_32          00000000   stack
```

标出了指令中有四处需要在重定位时修改。下面编译链接成可执行文件之后再做反汇编分析：

```bash
$ gcc -g main.c stack.o push.o pop.o is_empty.o -Istack -o main
$ objdump -dS main
...
080483c0 <push>:
/* push.c */
extern char stack[512];
extern int top;

void push(char c)
{
 80483c0:       55                      push   %ebp
 80483c1:       89 e5                   mov    %esp,%ebp
 80483c3:       83 ec 04                sub    $0x4,%esp
 80483c6:       8b 45 08                mov    0x8(%ebp),%eax
 80483c9:       88 45 fc                mov    %al,-0x4(%ebp)
        stack[++top] = c;
 80483cc:       a1 10 a0 04 08          mov    0x804a010,%eax
 80483d1:       83 c0 01                add    $0x1,%eax
 80483d4:       a3 10 a0 04 08          mov    %eax,0x804a010
 80483d9:       8b 15 10 a0 04 08       mov    0x804a010,%edx
 80483df:       0f b6 45 fc             movzbl -0x4(%ebp),%eax
 80483e3:       88 82 40 a0 04 08       mov    %al,0x804a040(%edx)
}
 80483e9:       c9                      leave  
 80483ea:       c3                      ret    
 80483eb:       90                      nop    
...
```

原来指令中的 0x0 被修改成了 0x804a010 和 0x804a040，这样做了重定位之后，各段的加载地址就定死了，因为在指令中使用了绝对地址。

现在看用 `-fPIC` 编译生成的目标文件有什么不同：

```bash
$ gcc -c -g -fPIC stack/stack.c stack/push.c stack/pop.c stack/is_empty.c
$ objdump -dS push.o

push.o:     file format elf32-i386


Disassembly of section .text:

00000000 <push>:
/* push.c */
extern char stack[512];
extern int top;

void push(char c)
{
   0:	55                   	push   %ebp
   1:	89 e5                	mov    %esp,%ebp
   3:	53                   	push   %ebx
   4:	83 ec 04             	sub    $0x4,%esp
   7:	e8 fc ff ff ff       	call   8 <push+0x8>
   c:	81 c3 02 00 00 00    	add    $0x2,%ebx
  12:	8b 45 08             	mov    0x8(%ebp),%eax
  15:	88 45 f8             	mov    %al,-0x8(%ebp)
	stack[++top] = c;
  18:	8b 83 00 00 00 00    	mov    0x0(%ebx),%eax
  1e:	8b 00                	mov    (%eax),%eax
  20:	8d 50 01             	lea    0x1(%eax),%edx
  23:	8b 83 00 00 00 00    	mov    0x0(%ebx),%eax
  29:	89 10                	mov    %edx,(%eax)
  2b:	8b 83 00 00 00 00    	mov    0x0(%ebx),%eax
  31:	8b 08                	mov    (%eax),%ecx
  33:	8b 93 00 00 00 00    	mov    0x0(%ebx),%edx
  39:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
  3d:	88 04 0a             	mov    %al,(%edx,%ecx,1)
}
  40:	83 c4 04             	add    $0x4,%esp
  43:	5b                   	pop    %ebx
  44:	5d                   	pop    %ebp
  45:	c3                   	ret    

Disassembly of section .text.__i686.get_pc_thunk.bx:

00000000 <__i686.get_pc_thunk.bx>:
   0:	8b 1c 24             	mov    (%esp),%ebx
   3:	c3                   	ret
```

指令中用到的 `stack` 和 `top` 的地址不再以 0x0 表示，而是以 `0x0(%ebx)` 表示，但其中还是留有 0x0 准备做进一步修改。再看 `readelf` 输出的 `.rel.text` 段：

```bash
Relocation section '.rel.text' at offset 0x94c contains 6 entries:
 Offset     Info    Type            Sym.Value  Sym. Name
00000008  00001202 R_386_PC32        00000000   __i686.get_pc_thunk.bx
0000000e  0000130a R_386_GOTPC       00000000   _GLOBAL_OFFSET_TABLE_
0000001a  00001403 R_386_GOT32       00000000   top
00000025  00001403 R_386_GOT32       00000000   top
0000002d  00001403 R_386_GOT32       00000000   top
00000035  00001503 R_386_GOT32       00000000   stack
```

`top` 和 `stack` 对应的记录类型不再是 `R_386_32` 了，而是 `R_386_GOT32`，有什么区别呢？我们先编译生成共享库再做反汇编分析：

```bash
$ gcc -shared -o libstack.so stack.o push.o pop.o is_empty.o
$ objdump -dS libstack.so
...
0000047c <push>:
/* push.c */
extern char stack[512];
extern int top;

void push(char c)
{
 47c:	55                   	push   %ebp
 47d:	89 e5                	mov    %esp,%ebp
 47f:	53                   	push   %ebx
 480:	83 ec 04             	sub    $0x4,%esp
 483:	e8 ef ff ff ff       	call   477 <__i686.get_pc_thunk.bx>
 488:	81 c3 6c 1b 00 00    	add    $0x1b6c,%ebx
 48e:	8b 45 08             	mov    0x8(%ebp),%eax
 491:	88 45 f8             	mov    %al,-0x8(%ebp)
	stack[++top] = c;
 494:	8b 83 f4 ff ff ff    	mov    -0xc(%ebx),%eax
 49a:	8b 00                	mov    (%eax),%eax
 49c:	8d 50 01             	lea    0x1(%eax),%edx
 49f:	8b 83 f4 ff ff ff    	mov    -0xc(%ebx),%eax
 4a5:	89 10                	mov    %edx,(%eax)
 4a7:	8b 83 f4 ff ff ff    	mov    -0xc(%ebx),%eax
 4ad:	8b 08                	mov    (%eax),%ecx
 4af:	8b 93 f8 ff ff ff    	mov    -0x8(%ebx),%edx
 4b5:	0f b6 45 f8          	movzbl -0x8(%ebp),%eax
 4b9:	88 04 0a             	mov    %al,(%edx,%ecx,1)
}
 4bc:	83 c4 04             	add    $0x4,%esp
 4bf:	5b                   	pop    %ebx
 4c0:	5d                   	pop    %ebp
 4c1:	c3                   	ret    
 4c2:	90                   	nop    
 4c3:	90                   	nop    
...
```

和先前的结果不同，指令中的 `0x0(%ebx)` 被修改成 `-0xc(%ebx)` 和 `-0x8(%ebx)`，而不是修改成绝对地址。所以共享库各段的加载地址并没有定死，可以加载到任意位置，因为指令中没有使用绝对地址，因此称为位置无关代码。另外，注意这几条指令：

```asm6502
 494:	8b 83 f4 ff ff ff    	mov    -0xc(%ebx),%eax
 49a:	8b 00                	mov    (%eax),%eax
 49c:	8d 50 01             	lea    0x1(%eax),%edx
```

和先前的指令对比一下：

```asm6502
 80483cc:       a1 10 a0 04 08          mov    0x804a010,%eax
 80483d1:       83 c0 01                add    $0x1,%eax
```

可以发现，`-0xc(%ebx)` 这个地址并不是变量 `top` 的地址，这个地址的内存单元中又保存了另外一个地址，这另外一个地址才是变量 `top` 的地址，所以 `mov    -0xc(%ebx),%eax` 是把变量 `top` 的地址传给 `eax`，而 `mov    (%eax),%eax` 才是从 `top` 的地址中取出 `top` 的值传给 `eax`。`lea    0x1(%eax),%edx` 是把 `top` 的值加 1 存到 `edx` 中，如下图所示：

<p id="c20-3">图 20.3. 间接寻址</p>

![间接寻址](./image/link.indirect.png)

`top` 和 `stack` 的绝对地址保存在一个地址表中，而指令通过地址表做间接寻址，因此避免了将绝对地址写死在指令中，这也是一种避免硬编码的策略。

现在把 `main.c` 和共享库编译链接在一起，然后运行：

```bash
$ gcc main.c -g -L. -lstack -Istack -o main
$ ./main 
./main: error while loading shared libraries: libstack.so: cannot open shared object file: No such file or directory
```

结果出乎意料，编译的时候没问题，由于指定了 `-L.` 选项，编译器可以在当前目录下找到 `libstack.so`，而运行时却说找不到 `libstack.so`。那么运行时在哪些路径下找共享库呢？我们先用 `ldd` 命令查看可执行文件依赖于哪些共享库：

```bash
$ ldd main
	linux-gate.so.1 =>  (0xb7f5c000)
	libstack.so => not found
	libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb7dcf000)
	/lib/ld-linux.so.2 (0xb7f42000)
```

`ldd` 模拟运行一遍 `main`，在运行过程中做动态链接，从而得知这个可执行文件依赖于哪些共享库，每个共享库都在什么路径下，加载到进程地址空间的什么地址。`/lib/ld-linux.so.2` 是动态链接器，它的路径是在编译链接时指定的，我们在[上章第 2 节「main 函数和启动例程」](2-C-语言本质/ch19-汇编与-C-之间的关系?id=_2-main-函数和启动例程)讲过 `gcc` 在做链接时用 `-dynamic-linker` 指定动态链接器的路径，它也像其它共享库一样加载到进程的地址空间中。`libc.so.6` 的路径 `/lib/tls/i686/cmov/libc.so.6` 是由动态链接器 `ld-linux.so.2` 在做动态链接时搜索到的，而 `libstack.so` 的路径没有找到。`linux-gate.so.1` 这个共享库其实并不存在于文件系统中，它是由内核虚拟出来的共享库，所以它没有对应的路径，它负责处理系统调用。总之，共享库的搜索路径由动态链接器决定，从 `ld.so(8)` 的 Man Page 可以查到共享库路径的搜索顺序：

1. 首先在环境变量 `LD_LIBRARY_PATH` 所记录的路径中查找。
2. 然后从缓存文件 `/etc/ld.so.cache` 中查找。这个缓存文件由 `ldconfig` 命令读取配置文件 `/etc/ld.so.conf` 之后生成，稍后详细解释。
3. 如果上述步骤都找不到，则到默认的系统路径中查找，先是 /usr/lib 然后是 /lib。

先试试第一种方法，在运行 `main` 时通过环境变量 `LD_LIBRARY_PATH` 把当前目录添加到共享库的搜索路径：

```bash
$ LD_LIBRARY_PATH=. ./main
```

这种方法只适合在开发中临时用一下，通常 `LD_LIBRARY_PATH` 是不推荐使用的，尽量不要设置这个环境变量，理由可以参考 *Why LD_LIBRARY_PATH is bad*。

再试试第二种方法，这是最常用的方法。把 `libstack.so` 所在目录的绝对路径（比如 /home/akaedu/somedir）添加到 `/etc/ld.so.conf` 中（该文件中每个路径占一行），然后运行 `ldconfig`：

```bash
$ sudo ldconfig -v
...
/home/akaedu/somedir:
        libstack.so -> libstack.so
/lib:
        libe2p.so.2 -> libe2p.so.2.3
        libncursesw.so.5 -> libncursesw.so.5.6
...
/usr/lib:
        libkdeinit_klauncher.so -> libkdeinit_klauncher.so
        libv4l2.so.0 -> libv4l2.so.0
...
/usr/lib64:
/lib/tls: (hwcap: 0x8000000000000000)
/usr/lib/sse2: (hwcap: 0x0000000004000000)
...
/usr/lib/tls: (hwcap: 0x8000000000000000)
...
/usr/lib/i686: (hwcap: 0x0008000000000000)
/usr/lib/i586: (hwcap: 0x0004000000000000)
...
/usr/lib/i486: (hwcap: 0x0002000000000000)
...
/lib/tls/i686: (hwcap: 0x8008000000000000)
/usr/lib/i686/cmov: (hwcap: 0x0008000000008000)
...
/lib/tls/i686/cmov: (hwcap: 0x8008000000008000)
```

`ldconfig` 命令除了处理 `/etc/ld.so.conf` 中配置的目录之外，还处理一些默认目录，如 `/lib`、`/usr/lib` 等，处理之后生成 `/etc/ld.so.cache` 缓存文件，动态链接器就从这个缓存中搜索共享库。hwcap 是 x86 平台的 Linux 特有的一种机制，系统检测到当前平台是 i686 而不是 i586 或 i486，所以在运行程序时使用 i686 的库，这样可以更好地发挥平台的性能，也可以利用一些新的指令，所以上面 `ldd` 命令的输出结果显示动态链接器搜索到的 `libc` 是 `/lib/tls/i686/cmov/libc.so.6`，而不是 `/lib/libc.so.6`。现在再用 `ldd` 命令查看，`libstack.so` 就能找到了：

```bash
$ ldd main
	linux-gate.so.1 =>  (0xb809c000)
	libstack.so => /home/akaedu/somedir/libstack.so (0xb806a000)
	libc.so.6 => /lib/tls/i686/cmov/libc.so.6 (0xb7f0c000)
	/lib/ld-linux.so.2 (0xb8082000)
```

第三种方法就是把 `libstack.so` 拷到 `/usr/lib` 或 `/lib` 目录，这样可以确保动态链接器能找到这个共享库。

其实还有第四种方法，在编译可执行文件 `main` 的时候就把 `libstack.so` 的路径写死在可执行文件中：

```bash
$ gcc main.c -g -L. -lstack -Istack -o main -Wl,-rpath,/home/akaedu/somedir
```

`-Wl,-rpath,/home/akaedu/somedir` 表示 `-rpath /home/akaedu/somedir` 是由 `gcc` 传递给链接器的选项。可以看到 `readelf` 的结果多了一条 `rpath` 记录：

```bash
$ readelf -a main
...
Dynamic section at offset 0xf10 contains 23 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libstack.so]
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000f (RPATH)                      Library rpath: [/home/akaedu/somedir]
...
```

还可以看出，可执行文件运行时需要哪些共享库也都记录在 `.dynamic` 段中。当然 `rpath` 这种办法也是不推荐的，把共享库的路径定死了，失去了灵活性。

#### 2.7.4.2. 动态链接的过程

本节研究一下在 `main.c` 中调用共享库的函数 `push` 是如何实现的。首先反汇编看一下 `main` 的指令：

```bash
$ objdump -dS main
...
Disassembly of section .plt:

080483a8 <__gmon_start__@plt-0x10>:
 80483a8:	ff 35 f8 9f 04 08    	pushl  0x8049ff8
 80483ae:	ff 25 fc 9f 04 08    	jmp    *0x8049ffc
 80483b4:	00 00                	add    %al,(%eax)
...
080483d8 <push@plt>:
 80483d8:	ff 25 08 a0 04 08    	jmp    *0x804a008
 80483de:	68 10 00 00 00       	push   $0x10
 80483e3:	e9 c0 ff ff ff       	jmp    80483a8 <_init+0x30>

Disassembly of section .text:
...
080484a4 <main>:
/* main.c */
#include <stdio.h>
#include "stack.h"

int main(void)
{
 80484a4:	8d 4c 24 04          	lea    0x4(%esp),%ecx
 80484a8:	83 e4 f0             	and    $0xfffffff0,%esp
 80484ab:	ff 71 fc             	pushl  -0x4(%ecx)
 80484ae:	55                   	push   %ebp
 80484af:	89 e5                	mov    %esp,%ebp
 80484b1:	51                   	push   %ecx
 80484b2:	83 ec 04             	sub    $0x4,%esp
	push('a');
 80484b5:	c7 04 24 61 00 00 00 	movl   $0x61,(%esp)
 80484bc:	e8 17 ff ff ff       	call   80483d8 <push@plt>
...
```

和[本章第 3 节「静态库」](#_3-静态库)链接静态库不同，`push` 函数没有链接到可执行文件中。而且 `call   80483d8 <push@plt>` 这条指令调用的也不是 `push` 函数的地址。共享库是位置无关代码，在运行时可以加载到任意地址，其加载地址只有在动态链接时才能确定，所以在 `main` 函数中不可能直接通过绝对地址调用 `push` 函数，也是通过间接寻址来找 `push` 函数的。对照着上面的指令，我们用 `gdb` 跟踪一下：

```bash
$ gdb main
...
(gdb) start
Breakpoint 1 at 0x80484b5: file main.c, line 7.
Starting program: /home/akaedu/somedir/main 
main () at main.c:7
7		push('a');
(gdb) si
0x080484bc	7		push('a');
(gdb) si
0x080483d8 in push@plt ()
Current language:  auto; currently asm
```

跳转到 `.plt` 段中，现在将要执行一条 `jmp    *0x804a008` 指令，我们看看 0x804a008 这个地址里存的是什么：

```bash
(gdb) x 0x804a008
0x804a008 <_GLOBAL_OFFSET_TABLE_+20>:	0x080483de
```

原来就是下一条指令 `push   $0x10` 的地址。继续跟踪下去：

```bash
(gdb) si
0x080483de in push@plt ()
(gdb) si
0x080483e3 in push@plt ()
(gdb) si
0x080483a8 in ?? ()
(gdb) si
0x080483ae in ?? ()
(gdb) si
0xb806a080 in ?? () from /lib/ld-linux.so.2
```

最终进入了动态链接器 `/lib/ld-linux.so.2`，在其中完成动态链接的过程并调用 `push` 函数，我们不深入这些细节了，直接用 `finish` 命令返回到 `main` 函数：

```bash
(gdb) finish
Run till exit from #0  0xb806a080 in ?? () from /lib/ld-linux.so.2
main () at main.c:8
8		return 0;
Current language:  auto; currently c
```

这时再看看 0x804a008 这个地址里存的是什么：

```bash
(gdb) x 0x804a008
0x804a008 <_GLOBAL_OFFSET_TABLE_+20>:	0xb803f47c
(gdb) x 0xb803f47c
0xb803f47c <push>:	0x53e58955
```

动态链接器已经把 `push` 函数的地址存在这里了，所以下次再调用 `push` 函数就可以直接从 `jmp    *0x804a008` 指令跳到它的地址，而不必再进入 `/lib/ld-linux.so.2` 做动态链接了。

#### 2.7.4.3. 共享库的命名惯例

你可能已经注意到了，系统的共享库通常带有符号链接，例如：

```bash
$ ls -l  /lib
...
-rwxr-xr-x  1 root root 1315024 2009-01-09 22:10 libc-2.8.90.so
lrwxrwxrwx  1 root root      14 2008-07-04 05:58 libcap.so.1 -> libcap.so.1.10
-rw-r--r--  1 root root   10316 2007-08-01 03:20 libcap.so.1.10
lrwxrwxrwx  1 root root      14 2008-11-01 08:55 libcap.so.2 -> libcap.so.2.10
-rw-r--r--  1 root root   13792 2008-06-12 21:39 libcap.so.2.10
...
lrwxrwxrwx  1 root root      14 2009-01-13 09:28 libc.so.6 -> libc-2.8.90.so
...
$ ls -l /usr/lib/libc.so
-rw-r--r-- 1 root root 238 2009-01-09 21:59 /usr/lib/libc.so
```

按照共享库的命名惯例，每个共享库有三个文件名：real name、soname 和 linker name。真正的库文件（而不是符号链接）的名字是 real name，包含完整的共享库版本号。例如上面的 `libcap.so.1.10`、`libc-2.8.90.so` 等。

soname 是一个符号链接的名字，只包含共享库的主版本号，主版本号一致即可保证库函数的接口一致，因此应用程序的 `.dynamic` 段只记录共享库的 soname，只要 soname 一致，这个共享库就可以用。例如上面的 `libcap.so.1` 和 `libcap.so.2` 是两个主版本号不同的 `libcap`，有些应用程序依赖于 `libcap.so.1`，有些应用程序依赖于 `libcap.so.2`，但对于依赖 `libcap.so.1` 的应用程序来说，真正的库文件不管是 `libcap.so.1.10` 还是 `libcap.so.1.11` 都可以用，所以使用共享库可以很方便地升级库文件而不需要重新编译应用程序，这是静态库所没有的优点。注意 `libc` 的版本编号有一点特殊，`libc-2.8.90.so` 的主版本号是 6 而不是 2 或 2.8。

linker name 仅在编译链接时使用，`gcc` 的 `-L` 选项应该指定 linker name 所在的目录。有的 linker name 是库文件的一个符号链接，有的 linker name 是一段链接脚本。例如上面的 `libc.so` 就是一个 linker name，它是一段链接脚本：

```bash
$ cat /usr/lib/libc.so
/* GNU ld script
   Use the shared library, but some functions are only in
   the static library, so try that secondarily.  */
OUTPUT_FORMAT(elf32-i386)
GROUP ( /lib/libc.so.6 /usr/lib/libc_nonshared.a  AS_NEEDED ( /lib/ld-linux.so.2 ) )
```

下面重新编译我们的 `libstack`，指定它的 soname：

```bash
$ gcc -shared -Wl,-soname,libstack.so.1 -o libstack.so.1.0 stack.o push.o pop.o is_empty.o
```

这样编译生成的库文件是 `libstack.so.1.0`，是 real name，但这个库文件中记录了它的 soname 是 `libstack.so.1`：

```bash
$ readelf -a libstack.so.1.0
...
Dynamic section at offset 0xf10 contains 22 entries:
  Tag        Type                         Name/Value
 0x00000001 (NEEDED)                     Shared library: [libc.so.6]
 0x0000000e (SONAME)                     Library soname: [libstack.so.1]
...
```

如果把 `libstack.so.1.0` 所在的目录加入 `/etc/ld.so.conf` 中，然后运行 `ldconfig` 命令，`ldconfig` 会自动创建一个 soname 的符号链接：

```bash
$ sudo ldconfig
$ ls -l libstack*
lrwxrwxrwx 1 root    root       15 2009-01-21 17:52 libstack.so.1 -> libstack.so.1.0
-rwxr-xr-x 1 akaedu  akaedu  10142 2009-01-21 17:49 libstack.so.1.0
```

但这样编译链接 `main.c` 却会报错：

```bash
$ gcc main.c -L. -lstack -Istack -o main
/usr/bin/ld: cannot find -lstack
collect2: ld returned 1 exit status
```

注意，要做这个实验，你得把先前编译的 `libstack` 共享库、静态库都删掉，如果先前拷到 `/lib` 或者 `/usr/lib` 下了也删掉，只留下 `libstack.so.1.0` 和 `libstack.so.1`，这样你会发现编译器不认这两个名字，因为编译器只认 linker name。可以先创建一个 linker name 的符号链接，然后再编译就没问题了：

```bash
$ ln -s libstack.so.1.0 libstack.so
$ gcc main.c -L. -lstack -Istack -o main
```

### 2.7.5. 虚拟内存管理

我们知道操作系统利用体系结构提供的 VA 到 PA 的转换机制实现虚拟内存管理。有了共享库的基础知识之后，现在我们可以进一步理解虚拟内存管理了。首先分析一个例子：

```bash
$ ps
  PID TTY          TIME CMD
29977 pts/0    00:00:00 bash
30032 pts/0    00:00:00 ps
$ cat /proc/29977/maps 
08048000-080f4000 r-xp 00000000 08:15 688142     /bin/bash
080f4000-080f9000 rw-p 000ac000 08:15 688142     /bin/bash
080f9000-080fe000 rw-p 080f9000 00:00 0 
09283000-09497000 rw-p 09283000 00:00 0          [heap]
b7ca8000-b7cb2000 r-xp 00000000 08:15 581665     /lib/tls/i686/cmov/libnss_files-2.8.90.so
b7cb2000-b7cb3000 r--p 00009000 08:15 581665     /lib/tls/i686/cmov/libnss_files-2.8.90.so
b7cb3000-b7cb4000 rw-p 0000a000 08:15 581665     /lib/tls/i686/cmov/libnss_files-2.8.90.so
...
b7e15000-b7f6d000 r-xp 00000000 08:15 581656     /lib/tls/i686/cmov/libc-2.8.90.so
b7f6d000-b7f6f000 r--p 00158000 08:15 581656     /lib/tls/i686/cmov/libc-2.8.90.so
b7f6f000-b7f70000 rw-p 0015a000 08:15 581656     /lib/tls/i686/cmov/libc-2.8.90.so
...
b7fbd000-b7fd7000 r-xp 00000000 08:15 565466     /lib/ld-2.8.90.so
b7fd7000-b7fd8000 r-xp b7fd7000 00:00 0          [vdso]
b7fd8000-b7fd9000 r--p 0001a000 08:15 565466     /lib/ld-2.8.90.so
b7fd9000-b7fda000 rw-p 0001b000 08:15 565466     /lib/ld-2.8.90.so
bfac5000-bfada000 rw-p bffeb000 00:00 0          [stack]
```

用 `ps` 命令查看当前终端下的进程，得知 `bash` 进程的 id 是 29977，然后用 `cat /proc/29977/maps` 命令查看它的虚拟地址空间。`/proc` 目录中的文件并不是真正的磁盘文件，而是由内核虚拟出来的文件系统，当前系统中运行的每个进程在 `/proc` 下都有一个子目录，目录名就是进程的 id，查看目录下的文件可以得到该进程的相关信息。此外，用 `pmap 29977` 命令也可以得到类似的输出结果。

<p id="c20-4">图 20.4. 进程地址空间</p>

![进程地址空间](./image/link.addrspace.png)

在[第 17 章「计算机体系结构基础」第 4 节「MMU」](2-C-语言本质/ch17-计算机体系结构基础?id=_4-mmu)讲过，x86 平台的虚拟地址空间是 0x0000  0000~0xffff ffff，大致上前 3GB（0x0000 0000 ~ 0xbfff ffff）是用户空间，后 1GB（0xc000  0000~0xffff ffff）是内核空间，在这里得到了印证。0x0804 8000-0x080f 4000 是从 `/bin/bash` 加载到内存的，访问权限为 `r-x`，表示 Text Segment，包含 `.text` 段、`.rodata` 段、`.plt` 段等。0x080f 4000 - 0x080f 9000 也是从 `/bin/bash` 加载到内存的，访问权限为 `rw-`，表示 Data Segment，包含 `.data` 段、`.bss` 段等。

0x0928 3000-0x0949 7000 不是从磁盘文件加载到内存的，这段空间称为堆（Heap），以后会讲到用 `malloc` 函数动态分配内存是在这里分配的。从 0xb7ca 8000 开始是共享库的映射空间，每个共享库也分为几个 Segment，每个 Segment 有不同的访问权限。可以看到，从堆空间的结束地址（0x0949 7000）到共享库映射空间的起始地址（0xb7ca 8000）之间有很大的地址空洞，在动态分配内存时堆空间是可以向高地址增长的。堆空间的地址上限（0x09497000）称为 Break，堆空间要向高地址增长就要抬高 Break，映射新的虚拟内存页面到物理内存，这是通过系统调用 `brk` 实现的，`malloc` 函数也是调用 `brk` 向内核请求分配内存的。

`/lib/ld-2.8.90.so` 就是动态链接器 `/lib/ld-linux.so.2`，后者是前者的符号链接。标有 `[vdso]` 的地址范围是 `linux-gate.so.1` 的映射空间，我们讲过这个共享库是由内核虚拟出来的。0xbfac  5000 - 0xbfad  a000是栈空间，其中高地址的部分保存着进程的环境变量和命令行参数，低地址的部分保存函数栈帧，栈空间是向低地址增长的，但显然没有堆空间那么大的可供增长的余地，因为实际的应用程序动态分配大量内存的并不少见，但是有几十层深的函数调用并且每层调用都有很多局部变量的非常少见。总之，栈空间是可能用尽的，并且比堆空间更容易用尽，在[第 5 章「深入理解函数」第 3 节「递归」](1-C-语言入门/ch05-深入理解函数?id=_3-递归)讲过，无穷递归会用尽栈空间最终导致段错误。

虚拟内存管理起到了什么作用呢？可以从以下几个方面来理解。

第一，虚拟内存管理可以控制物理内存的访问权限。物理内存本身是不限制访问的，任何地址都可以读写，而操作系统要求不同的页面具有不同的访问权限，这是利用 CPU 模式和 MMU 的内存保护机制实现的。例如，Text Segment被只读保护起来，防止被错误的指令意外改写，内核地址空间也被保护起来，防止在用户模式下执行错误的指令意外改写内核数据。这样，执行错误指令或恶意代码的破坏能力受到了限制，顶多使当前进程因段错误终止，而不会影响整个系统的稳定性。

第二，虚拟内存管理最主要的作用是让每个进程有独立的地址空间。所谓独立的地址空间是指，不同进程中的同一个 VA 被 MMU 映射到不同的 PA，并且在某一个进程中访问任何地址都不可能访问到另外一个进程的数据，这样使得任何一个进程由于执行错误指令或恶意代码导致的非法内存访问都不会意外改写其它进程的数据，不会影响其它进程的运行，从而保证整个系统的稳定性。另一方面，每个进程都认为自己独占整个虚拟地址空间，这样链接器和加载器的实现会比较容易，不必考虑各进程的地址范围是否冲突。

继续前面的实验，再打开一个终端窗口，看一下这个新的 `bash` 进程的地址空间，可以发现和先前的 `bash` 进程地址空间的布局差不多：

```bash
$ ps
  PID TTY          TIME CMD
30697 pts/1    00:00:00 bash
30749 pts/1    00:00:00 ps
$ cat /proc/30697/maps
08048000-080f4000 r-xp 00000000 08:15 688142     /bin/bash
080f4000-080f9000 rw-p 000ac000 08:15 688142     /bin/bash
080f9000-080fe000 rw-p 080f9000 00:00 0 
082d7000-084f9000 rw-p 082d7000 00:00 0          [heap]
b7cf1000-b7cfb000 r-xp 00000000 08:15 581665     /lib/tls/i686/cmov/libnss_files-2.8.90.so
b7cfb000-b7cfc000 r--p 00009000 08:15 581665     /lib/tls/i686/cmov/libnss_files-2.8.90.so
b7cfc000-b7cfd000 rw-p 0000a000 08:15 581665     /lib/tls/i686/cmov/libnss_files-2.8.90.so
...
b7e5e000-b7fb6000 r-xp 00000000 08:15 581656     /lib/tls/i686/cmov/libc-2.8.90.so
b7fb6000-b7fb8000 r--p 00158000 08:15 581656     /lib/tls/i686/cmov/libc-2.8.90.so
b7fb8000-b7fb9000 rw-p 0015a000 08:15 581656     /lib/tls/i686/cmov/libc-2.8.90.so
...
b8006000-b8020000 r-xp 00000000 08:15 565466     /lib/ld-2.8.90.so
b8020000-b8021000 r-xp b8020000 00:00 0          [vdso]
b8021000-b8022000 r--p 0001a000 08:15 565466     /lib/ld-2.8.90.so
b8022000-b8023000 rw-p 0001b000 08:15 565466     /lib/ld-2.8.90.so
bff0e000-bff23000 rw-p bffeb000 00:00 0          [stack]
```

该进程也占用了 0x0000  0000-0xbfff ffff 的地址空间，Text Segment 也是 0x0804 8000-0x080f 4000，Data Segment 也是 0x080f 4000-0x080f 9000，和先前的进程一模一样，因为这些地址是在编译链接时写进 `/bin/bash` 这个可执行文件的，两个进程都加载它。这两个进程在同一个系统中同时运行着，它们的 Data  Segment 占用相同的 VA，但是两个进程各自干各自的事情，显然 Data  Segment 中的数据应该是不同的，相同的 VA 怎么会有不同的数据呢？因为它们被映射到不同的 PA。如下图所示。

<p id="c20-5">图 20.5. 进程地址空间是独立的</p>

![进程地址空间是独立的](./image/link.sepva.png)

从图中还可以看到，两个进程都是 `bash` 进程，Text Segment 是一样的，并且 Text Segment 是只读的，不会被改写，因此操作系统会安排两个进程的 Text  Segment 共享相同的物理页面。由于每个进程都有自己的一套 VA 到 PA 的映射表，整个地址空间中的任何 VA 都在每个进程自己的映射表中查找相应的 PA，因此不可能访问到其它进程的地址，也就没有可能意外改写其它进程的数据。

另外，注意到两个进程的共享库加载地址并不相同，共享库的加载地址是在运行时决定的，而不是写在 `/bin/bash` 这个可执行文件中。但即使如此，也不影响两个进程共享相同物理页面中的共享库，当然，只有只读的部分是共享的，可读可写的部分不共享。

使用共享库可以大大节省内存。比如 `libc`，系统中几乎所有的进程都映射 `libc`到自己的进程地址空间，而 `libc` 的只读部分在物理内存中只需要存在一份，就可以被所有进程共享，这就是「共享库」这个名称的由来了。

现在我们也可以理解为什么共享库必须是位置无关代码了。比如 `libc`，不同的进程虽然共享 `libc` 所在的物理页面，但这些物理页面被映射到各进程的虚拟地址空间时却位于不同的地址，所以要求 `libc` 的代码不管加载到什么地址都能正确执行。

第三，VA 到 PA 的映射会给分配和释放内存带来方便，物理地址不连续的几块内存可以映射成虚拟地址连续的一块内存。比如要用 `malloc` 分配一块很大的内存空间，虽然有足够多的空闲物理内存，却没有足够大的**连续**空闲内存，这时就可以分配多个不连续的物理页面而映射到连续的虚拟地址范围。如下图所示。

<p id="c20-6">图 20.6. 不连续的 PA 可以映射为连续的 VA</p>

![不连续的 PA 可以映射为连续的 VA](./image/link.discontpa.png)

第四，一个系统如果同时运行着很多进程，为各进程分配的内存之和可能会大于实际可用的物理内存，虚拟内存管理使得这种情况下各进程仍然能够正常运行。因为各进程分配的只不过是虚拟内存的页面，这些页面的数据可以映射到物理页面，也可以临时保存到磁盘上而不占用物理页面，在磁盘上临时保存虚拟内存页面的可能是一个磁盘分区，也可能是一个磁盘文件，称为交换设备（Swap  Device）。当物理内存不够用时，将一些不常用的物理页面中的数据临时保存到交换设备，然后这个物理页面就认为是空闲的了，可以重新分配给进程使用，这个过程称为换出（Page out）。如果进程要用到被换出的页面，就从交换设备再加载回物理内存，这称为换入（Page in）。换出和换入操作统称为换页（Paging），因此：

系统中可分配的内存总量 = 物理内存的大小 + 交换设备的大小

如下图所示。第一张图是换出，将物理页面中的数据保存到磁盘，并解除地址映射，释放物理页面。第二张图是换入，从空闲的物理页面中分配一个，将磁盘暂存的页面加载回内存，并建立地址映射。

<p id="c20-6">图 20.7. 换页</p>

![换页](./image/link.swap.png)

## 2.8. 预处理

### 2.8.1. 预处理的步骤

现在我们全面了解一下 C 编译器做语法解析之前的预处理步骤：

1. 把[第 2 章「常量、变量和表达式」第 2 节「常量」](1-C-语言入门/ch02-常量、变量和表达式#_2-常量)提到过的三连符替换成相应的单字符。
2. 把用`\`字符续行的多行代码接成一行。例如：
	
	```c
	#define STR "hello, "\
			"world"
	```
	
	经过这个预处理步骤之后接成一行：
	
	```c
	#define STR "hello, "		"world"
	```
	
	这种续行的写法要求`\`后面紧跟换行，中间不能有其它空白字符。
3. 把注释（不管是单行注释还是多行注释）都替换成一个空格。
4. 经过以上两步之后去掉了一些换行，有的换行在续行过程中去掉了，有的换行在多行注释之中，也随着注释一起去掉了，剩下的代码行称为逻辑代码行。然后预处理器把逻辑代码行划分成 Token和空白字符，这时的 Token 称为预处理 Token，包括标识符、整数常量、浮点数常量、字符常量、字符串、运算符和其它符号。继续上面的例子，两个源代码行被接成一个逻辑代码行，然后这个逻辑代码行被划分成 Token 和空白字符：`#`，`define`，空格，`STR`，空格，`"hello, "`，Tab，Tab，`"world"`。
5. 在 Token 中识别出预处理指示，做相应的预处理动作，如果遇到 `#include` 预处理指示，则把相应的源文件包含进来，并对源文件做以上 1 - 4 步预处理。如果遇到宏定义则做宏展开。
	我们早在[第 8 章「数组」第 2 节「数组应用实例：统计随机数」](1-C-语言入门/ch08-数组#_2-数组应用实例：统计随机数)就认识了预处理指示这个概念，现在给出它的严格定义。一条预处理指示由一个逻辑代码行组成，以 `#` 开头，后面跟若干个预处理 Token，在预处理指示中允许使用的空白字符只有空格和 Tab。
6. 找出字符常量或字符串中的转义序列，用相应的字节来替换它，比如把 `\n` 替换成字节 `0x0a`。
7. 把相邻的字符串连接起来。继续上面的例子，如果代码中有：
	
	```c
	printf(
		STR);
	```

	经过第 4 步处理划分成以下 Token：`printf`，`(`，换行，Tab，`STR`，`)`，`;`，换行。经过第 5 步宏展开后变成以下 Token：`printf`，`(`，换行，Tab，`"hello, "`，Tab，Tab，`"world"`，`)`，`;`，换行。然后把相邻的字符串连接起来，变成以下 Token：`printf`，`(`，换行，Tab，`"hello, world"`，`)`，`;`，换行。
8. 经过以上处理之后，把空白字符丢掉，把 Token 交给 C 编译器做语法解析，这时就不再是预处理 Token，而称为 C Token了。这里丢掉的空白字符包括空格、换行、水平 Tab、垂直 Tab、分页符。继续上面的例子，最后交给 C 编译器做语法解析的 Token 是：`printf`，`(`，`"hello, world"`，`)`，`;`。注意，把一个预处理指示写成多行要用 `\` 续行，因为根据定义，一条预处理指示只能由一个逻辑代码行组成，而把 C 代码写成多行则不需要用 `\` 续行，因为换行在 C 代码中只不过是一种空白字符，在做语法解析时所有空白字符都已经丢掉了。

### 2.8.2. 宏定义

较大的项目都会用大量的宏定义来组织代码，你可以看看 `/usr/include` 下面的头文件中用了多少个宏定义。看起来宏展开就是做个替换而已，其实里面有比较复杂的规则，C 语言有很多复杂但不常用的语法规则本书并不涉及，但有关宏展开的语法规则本节却力图做全面讲解，因为它很重要也很常用。

#### 2.8.2.1. 函数式宏定义

以前我们用过的 `#define N 20` 或 `#define STR "hello, world"` 这种宏定义可以称为变量式宏定义（Object-like Macro），宏定义名可以像变量一样在代码中使用。另外一种宏定义可以像函数调用一样在代码中使用，称为函数式宏定义（Function-like Macro）。例如编辑一个文件 `main.c`：

```c
#define MAX(a, b) ((a)>(b)?(a):(b))
k = MAX(i&0x0f, j&0x0f)
```

我们想看第二行的表达式展开成什么样，可以用 `gcc` 的 `-E` 选项或 `cpp` 命令，尽管这个 C 程序不合语法，但没关系，我们只做预处理而不编译，不会检查程序是否符合 C 语法。

```bash
$ cpp main.c
# 1 "main.c"
# 1 "<built-in>"
# 1 "<command-line>"
# 1 "main.c"

k = ((i&0x0f)>(j&0x0f)?(i&0x0f):(j&0x0f))
```

就像函数调用一样，把两个实参分别替换到宏定义中形参 `a` 和 `b` 的位置。注意这种函数式宏定义和真正的函数调用有什么不同：

1. 函数式宏定义的参数没有类型，预处理器只负责做形式上的替换，而不做参数类型检查，所以传参时要格外小心。
2. 调用真正函数的代码和调用函数式宏定义的代码编译生成的指令不同。如果 `MAX` 是个真正的函数，那么它的函数体 `return a > b ? a : b;` 要编译生成指令，代码中出现的每次调用也要编译生成传参指令和 `call` 指令。而如果 `MAX` 是个函数式宏定义，这个宏定义本身倒不必编译生成指令，但是代码中出现的每次调用编译生成的指令都相当于一个函数体，而不是简单的几条传参指令和 `call` 指令。所以，使用函数式宏定义编译生成的目标文件会比较大。
3. 定义这种宏要格外小心，如果上面的定义写成 `#define MAX(a, b) (a>b?a:b)`，省去内层括号，则宏展开就成了 `k = (i&0x0f>j&0x0f?i&0x0f:j&0x0f)`，运算的优先级就错了。同样道理，这个宏定义的外层括号也是不能省的，想一想为什么。
4. 调用函数时先求实参表达式的值再传给形参，如果实参表达式有 Side Effect，那么这些 Side Effect 只发生一次。例如 `MAX(++a, ++b)`，如果 `MAX` 是个真正的函数，`a` 和 `b` 只增加一次。但如果 `MAX` 是上面那样的宏定义，则要展开成 `k = ((++a)>(++b)?(++a):(++b))`，`a` 和 `b` 就不一定是增加一次还是两次了。
5. 即使实参没有 Side Effect，使用函数式宏定义也往往会导致较低的代码执行效率。下面举一个极端的例子，也是个很有意思的例子。

<p id="e21-1">例 21.1. 函数式宏定义</p>

```c
#define MAX(a, b) ((a)>(b)?(a):(b))

int a[] = { 9, 3, 5, 2, 1, 0, 8, 7, 6, 4 };

int max(int n)
{
	return n == 0 ? a[0] : MAX(a[n], max(n-1));
}

int main(void)
{
	max(9);
	return 0;
}
```

这段代码从一个数组中找出最大的数，如果 `MAX` 是个真正的函数，这个算法就是从前到后遍历一遍数组，时间复杂度是 Θ(n)，而现在 `MAX` 是这样一个函数式宏定义，思考一下这个算法的时间复杂度是多少？

尽管函数式宏定义和真正的函数相比有很多缺点，但只要小心使用还是会显著提高代码的执行效率，毕竟省去了分配和释放栈帧、传参、传返回值等一系列工作，因此那些简短并且被频繁调用的函数经常用函数式宏定义来代替实现。例如 C 标准库的很多函数都提供两种实现，一种是真正的函数实现，一种是宏定义实现，这一点以后还要详细解释。

函数式宏定义经常写成这样的形式（取自内核代码 `include/linux/pm.h`）：

```c
#define device_init_wakeup(dev,val) \
        do { \
                device_can_wakeup(dev) = !!(val); \
                device_set_wakeup_enable(dev,val); \
        } while(0)
```

为什么要用 `do { ... } while(0)` 括起来呢？不括起来会有什么问题呢？

```c
#define device_init_wakeup(dev,val) \
                device_can_wakeup(dev) = !!(val); \
                device_set_wakeup_enable(dev,val);

if (n > 0)
	device_init_wakeup(d, v);
```

这样宏展开之后，函数体的第二条语句不在 `if` 条件中。那么简单地用 `{ ... }` 括起来组成一个语句块不行吗？

```c
#define device_init_wakeup(dev,val) \
                { device_can_wakeup(dev) = !!(val); \
                device_set_wakeup_enable(dev,val); }

if (n > 0)
	device_init_wakeup(d, v);
else
	continue;
```

问题出在 `device_init_wakeup(d, v);` 末尾的 `;` 号，如果不允许写这个 `;` 号，看起来不像个函数调用，可如果写了这个 `;` 号，宏展开之后就有语法错误，`if` 语句被这个 `;` 号结束掉了，没法跟 `else` 配对。因此，`do { ... } while(0)` 是一种比较好的解决办法。

如果在一个程序文件中重复定义一个宏，C 语言规定这些重复的宏定义必须一模一样。例如这样的重复定义是允许的：

```c
#define OBJ_LIKE (1 - 1)
#define OBJ_LIKE /* comment */ (1/* comment */-/* comment */  1)/* comment */
```

在定义的前后多些空白（空格、Tab、注释）没有关系，在定义之中多些空白或少些空白也没有关系，但在定义之中有空白和没有空白被认为是不同的，所以这样的重复定义是不允许的：

```c
#define OBJ_LIKE (1 - 1)
#define OBJ_LIKE (1-1)
```

如果需要重新定义一个宏，和原来的定义不同，可以先用 `#undef` 取消原来的定义，再重新定义，例如：

```c
#define X 3
... /* X is 3 */
#undef X
... /* X has no definition */
#define X 2
... /* X is 2 */
```

#### 2.8.2.2. 内联函数

C99 引入一个新关键字 `inline`，用于定义内联函数（inline function）。这种用法在内核代码中很常见，例如 `include/linux/rwsem.h`中：

```c
static inline void down_read(struct rw_semaphore *sem)
{
        might_sleep();
        rwsemtrace(sem,"Entering down_read");
        __down_read(sem);
        rwsemtrace(sem,"Leaving down_read");
}
```

`inline` 关键字告诉编译器，这个函数的调用要尽可能快，可以当普通的函数调用实现，也可以用宏展开的办法实现。我们做个实验，把上一节的例子改一下：

<p id="e21-2">例 21.2. 内联函数</p>

```c
inline int MAX(int a, int b)
{
	return a > b ? a : b;
}

int a[] = { 9, 3, 5, 2, 1, 0, 8, 7, 6, 4 };

int max(int n)
{
	return n == 0 ? a[0] : MAX(a[n], max(n-1));
}

int main(void)
{
	max(9);
	return 0;
}
```

按往常的步骤编译然后反汇编：

```bash
$ gcc main.c -g
$ objdump -dS a.out
...
int max(int n)
{
 8048369:       55                      push   %ebp
 804836a:       89 e5                   mov    %esp,%ebp
 804836c:       83 ec 0c                sub    $0xc,%esp
        return n == 0 ? a[0] : MAX(a[n], max(n-1));
 804836f:       83 7d 08 00             cmpl   $0x0,0x8(%ebp)
 8048373:       75 0a                   jne    804837f <max+0x16>
 8048375:       a1 c0 95 04 08          mov    0x80495c0,%eax
 804837a:       89 45 fc                mov    %eax,-0x4(%ebp)
 804837d:       eb 29                   jmp    80483a8 <max+0x3f>
 804837f:       8b 45 08                mov    0x8(%ebp),%eax
 8048382:       83 e8 01                sub    $0x1,%eax
 8048385:       89 04 24                mov    %eax,(%esp)
 8048388:       e8 dc ff ff ff          call   8048369 <max>
 804838d:       89 c2                   mov    %eax,%edx
 804838f:       8b 45 08                mov    0x8(%ebp),%eax
 8048392:       8b 04 85 c0 95 04 08    mov    0x80495c0(,%eax,4),%eax
 8048399:       89 54 24 04             mov    %edx,0x4(%esp)
 804839d:       89 04 24                mov    %eax,(%esp)
 80483a0:       e8 9f ff ff ff          call   8048344 <MAX>
 80483a5:       89 45 fc                mov    %eax,-0x4(%ebp)
 80483a8:       8b 45 fc                mov    -0x4(%ebp),%eax
}
...
```

可以看到 `MAX` 是作为普通函数调用的。如果指定优化选项编译，然后反汇编：

```bash
$ gcc main.c -g -O
$ objdump -dS a.out
...
int max(int n)
{
 8048355:       55                      push   %ebp
 8048356:       89 e5                   mov    %esp,%ebp
 8048358:       53                      push   %ebx
 8048359:       83 ec 04                sub    $0x4,%esp
 804835c:       8b 5d 08                mov    0x8(%ebp),%ebx
        return n == 0 ? a[0] : MAX(a[n], max(n-1));
 804835f:       85 db                   test   %ebx,%ebx
 8048361:       75 07                   jne    804836a <max+0x15>
 8048363:       a1 a0 95 04 08          mov    0x80495a0,%eax
 8048368:       eb 18                   jmp    8048382 <max+0x2d>
 804836a:       8d 43 ff                lea    -0x1(%ebx),%eax
 804836d:       89 04 24                mov    %eax,(%esp)
 8048370:       e8 e0 ff ff ff          call   8048355 <max>
inline int MAX(int a, int b)
{
        return a > b ? a : b;
 8048375:       8b 14 9d a0 95 04 08    mov    0x80495a0(,%ebx,4),%edx
 804837c:       39 d0                   cmp    %edx,%eax
 804837e:       7d 02                   jge    8048382 <max+0x2d>
 8048380:       89 d0                   mov    %edx,%eax
int a[] = { 9, 3, 5, 2, 1, 0, 8, 7, 6, 4 };

int max(int n)
{
        return n == 0 ? a[0] : MAX(a[n], max(n-1));
}
 8048382:       83 c4 04                add    $0x4,%esp
 8048385:       5b                      pop    %ebx
 8048386:       5d                      pop    %ebp
 8048387:       c3                      ret    
...
```

可以看到，并没有 `call` 指令调用 `MAX` 函数，`MAX` 函数的指令是内联在 `max` 函数中的，由于源代码和指令的次序无法对应，`max` 和 `MAX` 函数的源代码也交错在一起显示。

#### 2.8.2.3. #、## 运算符和可变参数

在函数式宏定义中，`#` 运算符用于创建字符串，`#` 运算符后面应该跟一个形参（中间可以有空格或 Tab），例如：

```c
#define STR(s) # s
STR(hello 	world)
```

用 `cpp` 命令预处理之后是 `"hello␣world"`，自动用 `"` 号把实参括起来成为一个字符串，并且实参中的连续多个空白字符被替换成一个空格。

再比如：

```c
#define STR(s) #s
fputs(STR(strncmp("ab\"c\0d", "abc", '\4"')
	== 0) STR(: @\n), s);
```

预处理之后是 `fputs("strncmp(\"ab\\\"c\\0d\", \"abc\", '\\4\"') == 0" ": @\n", s);`，注意如果实参中包含字符常量或字符串，则宏展开之后字符串的界定符 `"` 要替换成 `\"`，字符常量或字符串中的 `\` 和 `"` 字符要替换成 `\\` 和 `\"`。

在宏定义中可以用 `##` 运算符把前后两个预处理 Token 连接成一个预处理 Token，和 `#` 运算符不同，`##` 运算符不仅限于函数式宏定义，变量式宏定义也可以用。例如：

```c
#define CONCAT(a, b) a##b
CONCAT(con, cat)
```

预处理之后是 `concat`。再比如，要定义一个宏展开成两个 `#` 号，可以这样定义：

```c
#define HASH_HASH # ## #
```

中间的 `##` 是运算符，宏展开时前后两个 `#` 号被这个运算符连接在一起。注意中间的两个空格是不可少的，如果写成 `####`，会被划分成 `##` 和 `##` 两个 Token，而根据定义 `##` 运算符用于连接前后两个预处理 Token，不能出现在宏定义的开头或末尾，所以会报错。

我们知道 `printf` 函数带有可变参数，函数式宏定义也可以带可变参数，同样是在参数列表中用 `...` 表示可变参数。例如：

```c
#define showlist(...) printf(#__VA_ARGS__)
#define report(test, ...) ((test)?printf(#test):\
	printf(__VA_ARGS__))
showlist(The first, second, and third items.);
report(x>y, "x is %d but y is %d", x, y);
```

预处理之后变成：

```c
printf("The first, second, and third items.");
((x>y)?printf("x>y"): printf("x is %d but y is %d", x, y));
```

在宏定义中，可变参数的部分用 `__VA_ARGS__` 表示，实参中对应 `...` 的几个参数可以看成一个参数替换到宏定义中 `__VA_ARGS__` 所在的地方。

调用函数式宏定义允许传空参数，这一点和函数调用不同，通过下面几个例子理解空参数的用法。

```c
#define FOO() foo
FOO()
```

预处理之后变成 `foo`。`FOO` 在定义时不带参数，在调用时也不允许传参数给它。

```c
#define FOO(a) foo##a
FOO(bar)
FOO()
```

预处理之后变成：

```c
foobar
foo
```

`FOO` 在定义时带一个参数，在调用时必须传一个参数给它，如果不传参数则表示传了一个空参数。

```c
#define FOO(a, b, c) a##b##c
FOO(1,2,3)
FOO(1,2,)
FOO(1,,3)
FOO(,,3)
```

预处理之后变成：

```c
123
12
13
3
```

`FOO` 在定义时带三个参数，在调用时也必须传三个参数给它，空参数的位置可以空着，但必须给够三个参数，`FOO(1,2)` 这样的调用是错误的。

```c
#define FOO(a, ...) a##__VA_ARGS__
FOO(1)
FOO(1,2,3,)
```

预处理之后变成：

```c
1
12,3,
```

`FOO(1)` 这个调用相当于可变参数部分传了一个空参数，`FOO(1,2,3,)` 这个调用相当于可变参数部分传了三个参数，第三个是空参数。

`gcc` 有一种扩展语法，如果 `##` 运算符用在 `__VA_ARGS__` 前面，除了起连接作用之外还有特殊的含义，例如内核代码 `net/netfilter/nf_conntrack_proto_sctp.c` 中的：

```c
#define DEBUGP(format, ...) printk(format, ## __VA_ARGS__)
```

`printk` 这个内核函数相当于 `printf`，也带有格式化字符串和可变参数，由于内核不能调用 `libc` 的函数，所以另外实现了一个打印函数。这个函数式宏定义可以这样调用：`DEBUGP("info no. %d", 1)`。也可以这样调用：`DEBUGP("info")`。后者相当于可变参数部分传了一个空参数，但展开后并不是 `printk("info",)`，而是 `printk("info")`，当 `__VA_ARGS` 是空参数时，`##` 运算符把它前面的 `,` 号「吃」掉了。

#### 2.8.2.4. 宏展开的步骤

以上举的宏展开的例子都是最简单的，有些宏展开的过程要做多次替换，例如：

```c
#define sh(x) printf("n" #x "=%d, or %d\n",n##x,alt[x])
#define sub_z  26
sh(sub_z)
```

`sh(sub_z)` 要用 `sh(x)` 这个宏定义来展开，形参 `x` 对应的实参是 `sub_z`，替换过程如下：

1. `#x` 要替换成 `"sub_z"`。
2. `n##x` 要替换成 `nsub_z`。
3. 除了带 `#` 和 `##` 运算符的参数之外，其它参数在替换之前要对实参本身做充分的展开，所以应该先把 `sub_z` 展开成 26 再替换到 `alt[x]` 中 `x` 的位置。
4. 现在展开成了 `printf("n" "sub_z" "=%d, or %d\n",nsub_z,alt[26])`，所有参数都替换完了，这时编译器会再扫描一遍，再找出可以展开的宏定义来展开，假设 `nsub_z` 或 `alt` 是变量式宏定义，这时会进一步展开。

再举一个例子：

```c
#define x 3
#define f(a) f(x * (a))
#undef x
#define x 2
#define g f
#define t(a) a

t(t(g)(0) + t)(1);
```

展开的步骤是：

1. 先把 `g` 展开成 `f` 再替换到 `#define t(a) a` 中，得到 `t(f(0) + t)(1);`。
2. 根据 `#define f(a) f(x * (a))`，得到 `t(f(x * (0)) + t)(1);`。
3. 把 `x` 替换成 2，得到 `t(f(2 * (0)) + t)(1);`。注意，一开始定义 `x` 为 3，但是后来用 `#undef x` 取消了 `x` 的定义，又重新定义 `x` 为2。当处理到 `t(t(g)(0) + t)(1);` 这一行代码时 `x` 已经定义成 2 了，所以用 2 来替换。还要注意一点，现在得到的 `t(f(2 * (0)) + t)(1);` 中仍然有 `f`，但不能再次根据 `#define f(a) f(x * (a))` 展开了，`f(2 * (0))` 就是由展开 `f(0)` 得到的，这里面再遇到 `f` 就不展开了，这样规定可以避免无穷展开（类似于无穷递归），因此我们可以放心地使用递归定义，例如 `#define a a[0]`，`#define a a.member` 等。
4. 根据 `#define t(a) a`，最终展开成 `f(2 * (0)) + t(1);`。这时不能再展开 `t(1)` 了，因为这里的 `t` 就是由展开 `t(f(2 * (0)) + t)` 得到的，所以不能再展开了。

### 2.8.3. 条件预处理指示

我们在[上章第 2.2 节「头文件」](2-C-语言本质/ch20-链接详解#_22-头文件)中见过 Header Guard 的用法：

```c
#ifndef HEADER_FILENAME
#define HEADER_FILENAME
/* body of header */
#endif
```

条件预处理指示也常用于源代码的配置管理，例如：

```c
#if MACHINE == 68000
    int x;
#elif MACHINE == 8086
    long x;
#else    /* all others */
    #error UNKNOWN TARGET MACHINE
#endif
```

假设这段程序是为多种平台编写的，在 68000 平台上需要定义 `x` 为 `int` 型，在 8086 平台上需要定义 `x` 为 `long` 型，对其它平台暂不提供支持，就可以用条件预处理指示来写。如果在预处理这段代码之前，`MACHINE` 被定义为 68000，则包含 `intx;` 这段代码；否则如果 `MACHINE` 被定义为 8086，则包含 `long x;` 这段代码；否则（`MACHINE` 没有定义，或者定义为其它值），包含 `#error UNKNOWN TARGET MACHINE` 这段代码，编译器遇到这个预处理指示就报错退出，错误信息就是 `UNKNOWN TARGET MACHINE`。

如果要为 8086 平台编译这段代码，有几种可选的办法：

1. 手动编辑代码，在前面添一行 `#define MACHINE 8086`。这样做的缺点是难以管理，如果这个项目中有很多源文件都需要定义 `MACHINE`，每次要为 8086 平台编译就得把这些定义全部改成 8086，每次要为 68000 平台编译就得把这些定义全部改成 68000。
2. 在所有需要配置的源文件开头包含一个头文件，在头文件中定义 `#define MACHINE 8086`，这样只需要改一个头文件就可以影响所有包含它的源文件。通常这个头文件由配置工具生成，比如在 Linux 内核源代码的目录下运行 `make menuconfig` 命令可以出来一个配置菜单，在其中配置的选项会自动转换成头文件 `include/linux/autoconf.h` 中的宏定义。

	举一个具体的例子，在内核配置菜单中用回车键和方向键进入 `Device Drivers ---> Network device support`，然后用空格键选中 `Network device support`（菜单项左边的 `[ ]` 括号内会出现一个 `*` 号），然后保存退出，会生成一个名为 `.config` 的隐藏文件，其内容类似于：

	```c
	...
	#
	# Network device support
	#
	CONFIG_NETDEVICES=y
	# CONFIG_DUMMY is not set
	# CONFIG_BONDING is not set
	# CONFIG_EQUALIZER is not set
	# CONFIG_TUN is not set
	...
	```

	然后运行 `make` 命令编译内核，这时根据 `.config` 文件生成头文件 `include/linux/autoconf.h`，其内容类似于：

	```c
	...
	/*
	 * Network device support
	 */
	#define CONFIG_NETDEVICES 1
	#undef CONFIG_DUMMY
	#undef CONFIG_BONDING
	#undef CONFIG_EQUALIZER
	#undef CONFIG_TUN
	...
	```

	上面的代码用 `#undef` 确保取消一些宏的定义，如果先前没有定义过 `CONFIG_DUMMY`，用 `#undef CONFIG_DUMMY` 取消它的定义没有任何作用，也不算错。

	`include/linux/autoconf.h` 被另一个头文件 `include/linux/config.h` 所包含，通常内核代码包含后一个头文件，例如 `net/core/sock.c`：

	```c
	...
	#include <linux/config.h>
	...
	int sock_setsockopt(struct socket *sock, int level, int optname,
	                    char __user *optval, int optlen)
	{
	...
	#ifdef CONFIG_NETDEVICES
	                case SO_BINDTODEVICE:
	                {
				...
	                }
	#endif
	...
	```
	
	再比如`drivers/isdn/i4l/isdn_common.c`：
	
	```
	...
	#include <linux/config.h>
	...
	static int
	isdn_ioctl(struct inode *inode, struct file *file, uint cmd, ulong arg)
	{
	...
	#ifdef CONFIG_NETDEVICES
	                        case IIOCNETGPN:
	                                /* Get peer phone number of a connected
	                                 * isdn network interface */
	                                if (arg) {
	                                        if (copy_from_user(&phone, argp, sizeof(phone)))
	                                                return -EFAULT;
	                                        return isdn_net_getpeer(&phone, argp);
	                                } else
	                                        return -EINVAL;
	#endif
	...
	#ifdef CONFIG_NETDEVICES
	                        case IIOCNETAIF:
	...
	#endif                          /* CONFIG_NETDEVICES */
	...
	```
	
	这样，在配置菜单中所做的配置通过条件预处理最终决定了哪些代码被编译到内核中。`#ifdef` 或 `#if` 可以嵌套使用，但预处理指示通常都顶头写不缩进，为了区分嵌套的层次，可以像上面的代码中最后一行那样，在 `#endif` 处用注释写清楚它结束的是哪个 `#if` 或 `#ifdef`。
3. 要定义一个宏不一定非得在代码中用 `#define` 定义，早在[第 11 章「排序与查找」第 6 节「折半查找」](1-C-语言入门/ch11-排序与查找#_6-折半查找)我们就见过用 `gcc` 的 `-D` 选项定义一个宏 `NDEBUG`。对于上面的例子，我们需要给 `MACHINE` 定义一个值，可以写成类似这样的命令：`gcc -c -DMACHINE=8086 main.c`。这种办法需要给每个编译命令都加上适当的选项，和第 2 种方法相比似乎也很麻烦，第 2 种方法在头文件中只写一次宏定义就可以在很多源文件中生效，第 3 种方法能不能做到「只写一次到处生效」呢？等以后学习了 Makefile 就有办法了。

最后通过下面的例子说一下  `#if`  后面的表达式：

```c
#define VERSION  2
#if defined x || y || VERSION < 3
```

1. 首先处理 `defined` 运算符，`defined` 运算符一般用作表达式中的一部分，如果单独使用，`#if defined x` 相当于 `#ifdef x`，而 `#if !defined x` 相当于 `#ifndef x`。在这个例子中，如果 `x` 这个宏有定义，则把 `defined x` 替换为 1，否则替换为 0，因此变成 `#if 0 || y || VERSION < 3`。
2. 然后把有定义的宏展开，变成 `#if 0 || y || 2 < 3`。
3. 把没有定义的宏替换成 0，变成 `#if 0 || 0 || 2 < 3`，注意，即使前面定义了一个变量名是 `y`，在这一步也还是替换成 0，因为 `#if` 的表达式必须在编译时求值，其中包含的名字只能是宏定义。
4. 把得到的表达式 `0 || 0 || 2 < 3` 像 C 表达式一样求值，求值的结果是 `#if 1`，因此条件成立。

### 2.8.4. 其它预处理特性

`#pragma` 预处理指示供编译器实现一些非标准的特性，C 标准没有规定 `#pragma` 后面应该写什么以及起什么作用，由编译器自己规定。有的编译器用 `#pragma` 定义一些特殊功能寄存器名，有的编译器用 `#pragma` 定位链接地址，本书不做深入讨论。如果编译器在代码中碰到不认识的 `#pragma` 指示则忽略它，例如 `gcc` 的 `#pragma` 指示都是 `#pragma GCC ...` 这种形式，用别的编译器编译则忽略这些指示。

C 标准规定了几个特殊的宏，在不同的地方使用可以自动展开成不同的值，常用的有 `__FILE__` 和`__LINE__`，`__FILE__` 展开为当前源文件的文件名，是一个字符串，`__LINE__` 展开为当前代码行的行号，是一个整数。这两个宏在源代码中不同的位置使用会自动取不同的值，显然不是用 `#define` 能定义得出来的，它们是编译器内建的特殊的宏。在打印调试信息时打印这两个宏可以给开发者非常有用的提示，例如在[第 11 章「排序与查找」第 6 节「折半查找」](1-C-语言入门/ch11-排序与查找#_6-折半查找)我们看到 `assert` 函数打印的错误信息就有 `__FILE__` 和 `__LINE__` 的值。现在我们自己实现这个 `assert` 函数，以理解它的原理。这个实现出自 *Standard C Library*：

<p id="e21-3">例 21.3. assert.h 的一种实现</p>

```c
/* assert.h standard header */
#undef assert	/* remove existing definition */

#ifdef NDEBUG
	#define assert(test)	((void)0)
#else		/* NDEBUG not defined */
	void _Assert(char *);
	/* macros */
	#define _STR(x) _VAL(x)
	#define _VAL(x) #x
	#define assert(test)	((test) ? (void)0 \
		: _Assert(__FILE__ ":" _STR(__LINE__) " " #test))
#endif
```

通过这个例子可以全面复习本章所讲的知识。C 标准规定 `assert` 应该实现为宏定义而不是一个真正的函数，并且 `assert(test)` 这个表达式的值应该是 `void` 类型的。首先用 `#undef assert` 确保取消前面对 `assert` 的定义，然后分两种情况：如果定义了 `NDEBUG`，那么 `assert(test)` 直接定义成一个 `void` ，什么也不做；如果没有定义 `NDEBUG`，则要判断测试条件 `test` 是否成立，如果条件成立就什么也不做，如果不成立则调用 `_Assert` 函数。假设在 `main.c` 文件的第 33 行调用 `assert(is_sorted())`，那么 `__FILE__` 是字符串 `"main.c"`，`__LINE__` 是整数`33`，`#test` 是字符串 `"is_sorted()"`。注意 `_STR(__LINE__)` 的展开过程：首先展开成 `_VAL(33)`，然后进一步展开成字符串 `"33"`。这样，最后 `_Assert` 调用的形式是 `_Assert("main.c" ":" "33" " " "is_sorted()")`，传给 `_Assert` 函数的字符串是 `"main.c:33 is_sorted()"`。`_Assert` 函数是我们自己定义的，在另一个源文件中：

```c
/* xassert.c _Assert function */
#include <stdio.h>
#include <stdlib.h>

void _Assert(char *mesg)
{		/* print assertion message and abort */
	fputs(mesg, stderr);
	fputs(" -- assertion failed\n", stderr);
	abort();
}
```

注意，在头文件 `assert.h` 中自己定义的内部使用的标识符都以 `_` 线开头，例如 `_STR`，`_VAL`，`_Assert`，因为我们在模拟 C 标准库的实现，在[第 2 章「常量、变量和表达式」第 3 节「变量」](1-C-语言入门/ch02-常量、变量和表达式#_3-变量)讲过，以 `_` 线开头的标识符通常由编译器和 C 语言库使用，在 `/usr/include` 下的头文件中你可以看到大量 `_` 线开头的标识符。另外一个问题，为什么我们不直接在 `assert` 的宏定义中调用 `fputs` 和 `abort` 呢？因为调用这两个函数需要包含 `stdio.h` 和 `stdlib.h`，C 标准库的头文件应该是相互独立的，一个程序只要包含 `assert.h` 就应该能使用 `assert`，而不应该再依赖于别的头文件。`_Assert` 中的 `fputs` 向标准错误输出打印错误信息，`abort` 异常终止当前进程，这些函数以后再详细讨论。

现在测试一下我们的 `assert` 实现，把 `assert.h` 和 `xassert.c` 和测试代码 `main.c` 放在同一个目录下。

```c
/* main.c */
#include "assert.h"

int main(void)
{
	assert(2>3);
	return 0;
}
```

注意 `#include "assert.h"` 要用 `"` 引号而不要用 `<>` 括号，以保证包含的是我们自己写的 `assert.h` 而非 C 标准库的头文件。然后编译运行：

```bash
$ gcc main.c xassert.c
$ ./a.out
main.c:6 2>3 -- assertion failed
Aborted
```

在打印调试信息时除了文件名和行号之外还可以打印出当前函数名，C99 引入一个特殊的标识符 `__func__` 支持这一功能。这个标识符应该是一个变量名而不是宏定义，不属于预处理的范畴，但它的作用和 `__FILE__`、`__LINE__` 类似，所以放在一起讲。例如：

<p id="e21-4">例 21.4. 特殊标识符 __func__</p>

```bash
#include <stdio.h>

void myfunc(void)
{
	printf("%s\n", __func__);
}

int main(void)
{
	myfunc();
	printf("%s\n", __func__);
	return 0;
}
$ gcc main.c
$ ./a.out 
myfunc
main
```

## 2.9. Makefile 基础

## 2.10. 指针

```c
// 指针数组和指向数组的指针

int a[] = {1,2,3,4,5};
// []的优先级比*高
int (*pa)[] = &a;

printf("%d",a == &a[0]);
printf("%d",pa == &a);                // ①

// `&a` 表示数组 `a` 的首地址
// `&a[0]` 表示数组 `a` 的首元素的首地址
// &a[0] 和 &a 数值相同，类型不同
// 同时 *(&a) =->= *(&a[0]) =->= a[0]    ②
//
// 根据① ② 得：
//              *pa =->= a[0]            ③
//
// 取数组a首元素值：a[0]
// pa == &a,则*pa = a
// 则：取元素a首元素：a[0] =->= (*pa)[0] ④
//
// 根据③ ④ 可得：a[0] = pa[0][0]
```

## 2.11. 函数接口

## 2.12. C 标准库

## 2.13. 链表、二叉树和哈希表

# 3. linux系统编程基础

## 3.1. 文件与 I/O

## 3.2. 文件系统

## 3.3. 进程

## 3.4. Shell 脚本

## 3.5. 正则表达式

## 3.6. 信号

## 3.7. 终端、作业控制与守护进程

## 3.8. 线程

## 3.9. TCP/IP 协议基础

## 3.10. socket 编程

# 4. 参考资料

- [ ] **[Linux C编程一站式学习](http://akaedu.github.io/book/)(重要)**
  - [markdown版本](https://github.com/52fhy/linux-c) **[本地](./资料/linux-c/README.md)**
- [ ] [关于C或C++的#include搜索路径，lib库搜索路径](https://blog.csdn.net/yjk13703623757/article/details/83154578)
- [ ] 雨痕C语言学习笔记
- [ ] [MinGW到底是个什么ghost](https://blog.csdn.net/lee_ham/article/details/81778581)
  - [ ] [MinGW中的头文件路径级环境变量设置](https://blog.csdn.net/wdjhzw/article/details/26576847)
  - [ ] [Window下g++搜索机制以及mingw环境配置](https://blog.csdn.net/weixin_34387284/article/details/91980027)
- [x] [C语言菜鸟教程](https://www.runoob.com/cprogramming/c-environment-setup.html)
- [ ] [Neovim C Cpp Lsp Integration Tips](https://ttys3.dev/post/neovim-c-cpp-lsp-integration-tips)
- [x] [理清gcc、libc、libstdc++的关系](https://blog.csdn.net/fuhanghang/article/details/113886318)

